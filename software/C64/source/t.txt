Comparing files Analyze.c and ..\TABLE888SOURCE\Analyze.C
***** Analyze.c
//        __
//   \\__/ o\    (C) 2012-2015  Robert Finch, Stratford
//    \  __ /    All rights reserved.
***** ..\TABLE888SOURCE\Analyze.C
//        __
//   \\__/ o\    (C) 2012-2014  Robert Finch, Stratford
//    \  __ /    All rights reserved.
*****

Comparing files Cglbdef.c and ..\TABLE888SOURCE\Cglbdef.C
***** Cglbdef.c
int             lastst = 0;
char            lastid[63] = "";
char            lastkw[63] = "";
char            laststr[MAX_STRLEN + 1] = "";
***** ..\TABLE888SOURCE\Cglbdef.C
int             lastst = 0;
char            lastid[33] = "";
char            laststr[MAX_STRLEN + 1] = "";
*****

***** Cglbdef.c
int             save_mask = 0;          /* register save mask */
int             fpsave_mask = 0;
TYP             tp_int, tp_econst;
***** ..\TABLE888SOURCE\Cglbdef.C
int             save_mask = 0;          /* register save mask */
TYP             tp_int, tp_econst;
*****

***** Cglbdef.c

int isKernel = FALSE;
int isPascal = FALSE;
***** ..\TABLE888SOURCE\Cglbdef.C

int isPascal = FALSE;
*****

***** Cglbdef.c
int isInterrupt = FALSE;
int isTask = FALSE;
int isNocall = FALSE;
***** ..\TABLE888SOURCE\Cglbdef.C
int isInterrupt = FALSE;
int isNocall = FALSE;
*****

***** Cglbdef.c
int optimize = TRUE;
int opt_noregs = FALSE;
int opt_nopeep = FALSE;
int opt_noexpr = FALSE;
int exceptions = FALSE;
int mixedSource = FALSE;
SYM *currentFn = (SYM *)NULL;
***** ..\TABLE888SOURCE\Cglbdef.C
int optimize = TRUE;
int exceptions = FALSE;
SYM *currentFn = (SYM *)NULL;
*****

Comparing files Cmain.c and ..\TABLE888SOURCE\Cmain.C
***** Cmain.c
//        __
//   \\__/ o\    (C) 2012-2015  Robert Finch, Stratford
//    \  __ /    All rights reserved.
***** ..\TABLE888SOURCE\Cmain.C
//        __
//   \\__/ o\    (C) 2012-2014  Robert Finch, Stratford
//    \  __ /    All rights reserved.
*****

***** Cmain.c

        if (s[1]=='o') {
        for (nn = 2; s[nn]; nn++) {
            switch(s[nn]) {
            case 'r':     opt_noregs = TRUE; break;
            case 'p':     opt_nopeep = TRUE; break;
            case 'x':     opt_noexpr = TRUE; break;
            }
        }
        if (nn==2) {
            opt_noregs = TRUE;
            opt_nopeep = TRUE;
            opt_noexpr = TRUE;
            optimize = FALSE;
        }
    }
        else if (s[1]=='f') {
***** ..\TABLE888SOURCE\Cmain.C

        if (s[1]=='o')
                optimize = 0;
        else if (s[1]=='f') {
*****

***** Cmain.c
                        gCpu = THOR;
                        regBP = 26;
                        regSP = 27;
                        regXLR = 11;    // branch register
***** ..\TABLE888SOURCE\Cmain.C
                        gCpu = THOR;
                        regXLR = 11;    // branch register
*****

***** Cmain.c
             regBP = 27;
             regGP = 26;
             regXLR = 28;
             use_gp = TRUE;
        }
***** ..\TABLE888SOURCE\Cmain.C
             regBP = 27;
             regXLR = 28;
        }
*****

***** Cmain.c
                wcharSupport = 0;
        else if (s[1]=='v') {
         if (s[2]=='0')
             verbose = 0;
         else
             verbose = 1;
    }
    else if (s[1]=='S')
        mixedSource = TRUE;
        return 0;
***** ..\TABLE888SOURCE\Cmain.C
                wcharSupport = 0;
        else if (s[1]=='v')
                verbose = 1;
        return 0;
*****

***** Cmain.c
{
//    if (verbose > 0)
        printf("\n -- %d errors found.",total_errors);
***** ..\TABLE888SOURCE\Cmain.C
{
        printf("\n -- %d errors found.",total_errors);
*****

Comparing files CodeGenerator.c and ..\TABLE888SOURCE\CodeGenerator.C
***** CodeGenerator.c
extern void FISA64_GenLdi(AMODE*,AMODE *);
void GenLoad(AMODE *ap3, AMODE *ap1, int ssize, int size);

***** ..\TABLE888SOURCE\CodeGenerator.C
extern void FISA64_GenLdi(AMODE*,AMODE *);
void GenLoad(AMODE *ap1, AMODE *ap3, int ssize);

*****

***** CodeGenerator.c
extern int throwlab;
static int nest_level = 0;

static void Enter(char *p)
{
/*
     int nn;
     
     for (nn = 0; nn < nest_level; nn++)
         printf(" ");
     printf("%s: %d ", p, lineno);
     nest_level++;
*/
}
static void Leave(char *p, int n)
{
/*
     int nn;
     
     nest_level--;
     for (nn = 0; nn < nest_level; nn++)
         printf(" ");
     printf("%s (%d) ", p, n);
*/
}
***** ..\TABLE888SOURCE\CodeGenerator.C
extern int throwlab;
/*
 *      construct a reference node for an internal label number.
 */
AMODE *make_label(int64_t lab)
{
        ENODE *lnode;
    AMODE *ap;
    lnode = allocEnode();
    lnode->nodetype = en_labcon;
    lnode->i = lab;
    ap = allocAmode();
    ap->mode = am_direct;
    ap->offset = lnode;
        ap->isUnsigned = TRUE;
    return ap;
}
*****

***** CodeGenerator.c


/*
 *      construct a reference node for an internal label number.
 */
AMODE *make_label(int64_t lab)
{
***** ..\TABLE888SOURCE\CodeGenerator.C

AMODE *make_clabel(int64_t lab)
{
*****

***** CodeGenerator.c
    lnode = allocEnode();
    lnode->nodetype = en_labcon;
    lnode->i = lab;
    ap = allocAmode();
***** ..\TABLE888SOURCE\CodeGenerator.C
    lnode = allocEnode();
    lnode->nodetype = en_clabcon;
    lnode->i = lab;
        if (lab==-1)
                printf("-1\r\n");
    ap = allocAmode();
*****

***** CodeGenerator.c

AMODE *make_clabel(int64_t lab)
{
***** ..\TABLE888SOURCE\CodeGenerator.C

AMODE *make_string(char *s)
{
*****

***** CodeGenerator.c
    AMODE *ap;
    lnode = allocEnode();
    lnode->nodetype = en_clabcon;
    lnode->i = lab;
        if (lab==-1)
                printf("-1\r\n");
    ap = allocAmode();
***** ..\TABLE888SOURCE\CodeGenerator.C
    AMODE *ap;

    lnode = allocEnode();
    lnode->nodetype = en_nacon;
    lnode->sp = s;
    ap = allocAmode();
*****

***** CodeGenerator.c
    ap->offset = lnode;
        ap->isUnsigned = TRUE;
    return ap;
***** ..\TABLE888SOURCE\CodeGenerator.C
    ap->offset = lnode;
    return ap;
*****

***** CodeGenerator.c

AMODE *make_string(char *s)
{
        ENODE *lnode;
    AMODE *ap;

    lnode = allocEnode();
    lnode->nodetype = en_nacon;
    lnode->sp = s;
    ap = allocAmode();
    ap->mode = am_direct;
    ap->offset = lnode;
    return ap;
***** ..\TABLE888SOURCE\CodeGenerator.C

/*
 *      make a node to reference an immediate value i.
 */
AMODE *make_immed(int64_t i)
{
        AMODE *ap;
    ENODE *ep;
    ep = allocEnode();
    ep->nodetype = en_icon;
    ep->i = i;
    ap = allocAmode();
    ap->mode = am_immed;
    ap->offset = ep;
    return ap;
*****

***** CodeGenerator.c

/*
 *      make a node to reference an immediate value i.
 */
AMODE *make_immed(int64_t i)
{
***** ..\TABLE888SOURCE\CodeGenerator.C

AMODE *make_indirect(int i)
{
*****

***** CodeGenerator.c
    ep = allocEnode();
    ep->nodetype = en_icon;
    ep->i = i;
    ap = allocAmode();
    ap->mode = am_immed;
    ap->offset = ep;
    return ap;
***** ..\TABLE888SOURCE\CodeGenerator.C
    ep = allocEnode();
    ep->nodetype = en_uw_ref;
    ep->i = 0;
    ap = allocAmode();
        ap->mode = am_ind;
        ap->preg = i;
    ap->offset = 0;//ep;        //=0;
    return ap;
*****

***** CodeGenerator.c

AMODE *make_indirect(int i)
{
***** ..\TABLE888SOURCE\CodeGenerator.C

AMODE *make_indexed(int64_t o, int i)
{
*****

***** CodeGenerator.c
    ep = allocEnode();
    ep->nodetype = en_uw_ref;
    ep->i = 0;
    ap = allocAmode();
        ap->mode = am_ind;
        ap->preg = i;
    ap->offset = 0;//ep;        //=0;
    return ap;
***** ..\TABLE888SOURCE\CodeGenerator.C
    ep = allocEnode();
    ep->nodetype = en_icon;
    ep->i = o;
    ap = allocAmode();
        ap->mode = am_indx;
        ap->preg = i;
    ap->offset = ep;
    return ap;
*****

***** CodeGenerator.c

AMODE *make_indexed(int64_t o, int i)
{
***** ..\TABLE888SOURCE\CodeGenerator.C

/*
 *      make a direct reference to a node.
 */
AMODE *make_offset(ENODE *node)
{
*****

***** CodeGenerator.c
        AMODE *ap;
    ENODE *ep;
    ep = allocEnode();
    ep->nodetype = en_icon;
    ep->i = o;
    ap = allocAmode();
        ap->mode = am_indx;
        ap->preg = i;
    ap->offset = ep;
    return ap;
***** ..\TABLE888SOURCE\CodeGenerator.C
        AMODE *ap;
    ap = allocAmode();
    ap->mode = am_direct;
    ap->offset = node;
    return ap;
*****

***** CodeGenerator.c
}

/*
 *      make a direct reference to a node.
 */
AMODE *make_offset(ENODE *node)
{
***** ..\TABLE888SOURCE\CodeGenerator.C
}
        
AMODE *make_indx(ENODE *node, int reg)
{
*****

***** CodeGenerator.c
    ap = allocAmode();
    ap->mode = am_direct;
    ap->offset = node;
    return ap;
***** ..\TABLE888SOURCE\CodeGenerator.C
    ap = allocAmode();
    ap->mode = am_indx;
    ap->offset = node;
    ap->preg = reg;
    return ap;
*****

***** CodeGenerator.c
}
        
AMODE *make_indx(ENODE *node, int reg)
{
        AMODE *ap;
    ap = allocAmode();
    ap->mode = am_indx;
    ap->offset = node;
    ap->preg = reg;
    return ap;
}
// ----------------------------------------------------------------------------
***** ..\TABLE888SOURCE\CodeGenerator.C
}
// ----------------------------------------------------------------------------
*****

***** CodeGenerator.c

//     Enter("MkLegalAmode");
        if (ap==(AMODE*)NULL) return;
***** ..\TABLE888SOURCE\CodeGenerator.C

        if (ap==(AMODE*)NULL) return;
*****

***** CodeGenerator.c
                                        }
                                        else if (flags & F_IMM6) {
                                                if (i < 64 && i >= 0)
                                                        return;
***** ..\TABLE888SOURCE\CodeGenerator.C
                                        }
                                        else if (flags & F_IMM0) {
                                                if (i==0)
                                                        return;
*****

***** CodeGenerator.c
                                        }
                                        else if (flags & F_IMM0) {
                                                if (i==0)
                                                        return;
                                        }
                    else if( flags & F_IMMED )
***** ..\TABLE888SOURCE\CodeGenerator.C
                                        }
                    else if( flags & F_IMMED )
*****

***** CodeGenerator.c
                    break;
            case am_fpreg:
                    if( flags & F_FPREG )
                        return;
                    break;
                        case am_breg:
***** ..\TABLE888SOURCE\CodeGenerator.C
                    break;
                        case am_breg:
*****

***** CodeGenerator.c
                        if (ap->mode == am_ind || ap->mode==am_indx)
                GenLoad(ap2,ap,size,size);
                        else if (ap->mode==am_immed) {
***** ..\TABLE888SOURCE\CodeGenerator.C
                        if (ap->mode == am_ind || ap->mode==am_indx)
                GenLoad(ap2,ap,size);
                        else if (ap->mode==am_immed) {
*****

***** CodeGenerator.c
                                else
                    GenLoad(ap2,ap,size,size);
                        }
***** ..\TABLE888SOURCE\CodeGenerator.C
                                else
                    GenLoad(ap2,ap,size);
                        }
*****

***** CodeGenerator.c
        }
        if( flags & F_FPREG )
        {
            ReleaseTempReg(ap);      /* maybe we can use it... */
            ap2 = GetTempFPRegister();
                        if (ap->mode == am_ind || ap->mode==am_indx)
                GenLoad(ap2,ap,size,size);
                        else if (ap->mode==am_immed) {
                            if (isFISA64)
                                FISA64_GenLdi(ap2,ap);
                else
                                    GenerateDiadic(op_ldi,0,ap2,ap);
            }
                        else {
***** ..\TABLE888SOURCE\CodeGenerator.C
        }
                if (flags & F_BREG) {
            ReleaseTempRegister(ap);
            ap2 = GetTempBrRegister();
                        if (ap->mode == am_ind || ap->mode==am_indx) {
                                ap3 = GetTempRegister();
                                GenerateDiadic(op_lw,0,ap3,ap);
                                GenerateDiadic(op_mtspr,0,ap2,ap3);
                                ReleaseTempRegister(ap3);
                        }
                        else if (ap->mode==am_immed) {
                                GenerateDiadic(op_ldis,0,ap2,ap);
                        }
                        else {
*****

***** CodeGenerator.c
                                if (ap->mode==am_reg)
                                        GenerateDiadic(op_mov,0,ap2,ap);
                                else
                    GenLoad(ap2,ap,size,size);
                        }
            ap->mode = am_fpreg;
            ap->preg = ap2->preg;
***** ..\TABLE888SOURCE\CodeGenerator.C
                                if (ap->mode==am_reg)
                                        GenerateDiadic(op_mtspr,0,ap2,ap);
                                else {
                                        ap3 = GetTempRegister();
                                        GenerateDiadic(op_lw,0,ap3,ap);
                                        GenerateDiadic(op_mtspr,0,ap2,ap3);
                                        ReleaseTempRegister(ap3);
                                }
                        }
            ap->mode = am_breg;
            ap->preg = ap2->preg;
*****

***** CodeGenerator.c
            return;
        }
                if (flags & F_BREG) {
            ReleaseTempRegister(ap);
            ap2 = GetTempBrRegister();
                        if (ap->mode == am_ind || ap->mode==am_indx) {
                                ap3 = GetTempRegister();
                                GenerateDiadic(op_lw,0,ap3,ap);
                                GenerateDiadic(op_mtspr,0,ap2,ap3);
                                ReleaseTempRegister(ap3);
                        }
                        else if (ap->mode==am_immed) {
                                GenerateDiadic(op_ldis,0,ap2,ap);
                        }
                        else {
                                if (ap->mode==am_reg)
                                        GenerateDiadic(op_mtspr,0,ap2,ap);
                                else {
                                        ap3 = GetTempRegister();
                                        GenerateDiadic(op_lw,0,ap3,ap);
                                        GenerateDiadic(op_mtspr,0,ap2,ap3);
                                        ReleaseTempRegister(ap3);
                                }
                        }
            ap->mode = am_breg;
            ap->preg = ap2->preg;
            ap->deep = ap2->deep;
            ap->tempflag = 1;
            return;
                }
***** ..\TABLE888SOURCE\CodeGenerator.C
            return;
                }
*****

***** CodeGenerator.c
                        else {
                                if (isTable888|isFISA64|isThor)
                                        GenerateDiadic(op_sxb,0,ap2,ap2);
***** ..\TABLE888SOURCE\CodeGenerator.C
                        else {
                                if (isTable888|isFISA64)
                                        GenerateDiadic(op_sxb,0,ap2,ap2);
*****

***** CodeGenerator.c
                case am_indx:
            GenLoad(ap2,ap,size,size);
                        break;
***** ..\TABLE888SOURCE\CodeGenerator.C
                case am_indx:
            GenLoad(ap2,ap,size);
                        break;
*****

***** CodeGenerator.c
                default:
            GenLoad(ap2,ap,size,size);
                }
***** ..\TABLE888SOURCE\CodeGenerator.C
                default:
            GenLoad(ap2,ap,size);
                }
*****

***** CodeGenerator.c
    ap->tempflag = 1;
//     Leave("MkLegalAmode",0);
}
***** ..\TABLE888SOURCE\CodeGenerator.C
    ap->tempflag = 1;
}
*****

***** CodeGenerator.c

void GenLoad(AMODE *ap3, AMODE *ap1, int ssize, int size)
{
    if (ap3->isFloat) {
        GenerateDiadic(op_lfd,0,ap3,ap1);
    }
        else {
        if (ap3->isVolatile && isThor) {
                switch(size) {
                case 1: GenerateDiadic(op_lvb,0,ap3,ap1); break;
                case 2: GenerateDiadic(op_lvc,0,ap3,ap1); break;
                case 4: GenerateDiadic(op_lvh,0,ap3,ap1); break;
                case 8: GenerateDiadic(op_lvw,0,ap3,ap1); break;
                }
            if (ap3->isUnsigned)
                        GenerateZeroExtend(ap3,ssize,size);
                else if (ssize > size)
                        GenerateSignExtend(ap3,ssize,size,F_REG);
        }
***** ..\TABLE888SOURCE\CodeGenerator.C

void GenLoad(AMODE *ap3, AMODE *ap1, int ssize)
{
        if (ap1->isUnsigned) {
                switch(ssize) {
                case 1: GenerateDiadic(op_lbu,0,ap3,ap1); break;
                case 2: GenerateDiadic(op_lcu,0,ap3,ap1); break;
                case 4: GenerateDiadic(op_lhu,0,ap3,ap1); break;
                case 8: GenerateDiadic(op_lw,0,ap3,ap1); break;
                }
        }
*****

***** CodeGenerator.c
        else {
            if (ap3->isUnsigned) {
                        switch(size) {
                        case 1: GenerateDiadic(op_lbu,0,ap3,ap1); break;
                        case 2: GenerateDiadic(op_lcu,0,ap3,ap1); break;
                        case 4: GenerateDiadic(op_lhu,0,ap3,ap1); break;
                        case 8: GenerateDiadic(op_lw,0,ap3,ap1); break;
                        }
                }
                else {
                        switch(size) {
                        case 1: GenerateDiadic(op_lb,0,ap3,ap1); break;
                        case 2: GenerateDiadic(op_lc,0,ap3,ap1); break;
                        case 4: GenerateDiadic(op_lh,0,ap3,ap1); break;
                        case 8: GenerateDiadic(op_lw,0,ap3,ap1); break;
                        case 12:        GenerateDiadic(op_lft,0,ap3,ap1); break;
                        }
                        if (ssize > size)
                        GenerateSignExtend(ap3,ssize,size,F_REG);
                }
***** ..\TABLE888SOURCE\CodeGenerator.C
        else {
                switch(ssize) {
                case 1: GenerateDiadic(op_lb,0,ap3,ap1); break;
                case 2: GenerateDiadic(op_lc,0,ap3,ap1); break;
                case 4: GenerateDiadic(op_lh,0,ap3,ap1); break;
                case 8: GenerateDiadic(op_lw,0,ap3,ap1); break;
                case 12:        GenerateDiadic(op_lft,0,ap3,ap1); break;
                }
*****

***** CodeGenerator.c
        }
    }
}
***** ..\TABLE888SOURCE\CodeGenerator.C
        }
}
*****

***** CodeGenerator.c
{
    if (ap1->isFloat) {
        GenerateDiadic(op_sfd,0,ap1,ap3);
    } 
    else {
        switch(size) {
***** ..\TABLE888SOURCE\CodeGenerator.C
{
        switch(size) {
*****

***** CodeGenerator.c
        }
    }
}
***** ..\TABLE888SOURCE\CodeGenerator.C
        }
}
*****

***** CodeGenerator.c
{    
        AMODE *ap2;

***** ..\TABLE888SOURCE\CodeGenerator.C
{    
        struct amode *ap2;

*****

***** CodeGenerator.c
        else {
                if (isTable888|isFISA64|isThor) {
                        switch( isize )
***** ..\TABLE888SOURCE\CodeGenerator.C
        else {
                if (isTable888|isFISA64) {
                        switch( isize )
*****

***** CodeGenerator.c

void GenerateZeroExtend(AMODE *ap, int isize, int osize)
{    
        AMODE *ap2;

    if(ap->mode != am_reg)
        MakeLegalAmode(ap,F_REG,isize);
    if (isThor) {
        switch( osize )
        {
        case 1: GenerateDiadic(op_zxb,0,ap,ap); break;
        case 2: GenerateDiadic(op_zxc,0,ap,ap); break;
        case 4: GenerateDiadic(op_zxh,0,ap,ap); break;
        }
    }
    else {
        switch( osize )
        {
        case 1: GenerateTriadic(op_andi,0,ap,ap,make_immed(0xFF)); break;
        case 2: GenerateTriadic(op_andi,0,ap,ap,make_immed(0xFFFF)); break;
        case 4: GenerateTriadic(op_andi,0,ap,ap,make_immed(0xFFFFFFFF)); break;
        }
    }
}
***** ..\TABLE888SOURCE\CodeGenerator.C

/*
 *      return true if the node passed can be generated as a short
 *      offset.
 */
int isshort(ENODE *node)
{
        return node->nodetype == en_icon &&
        (node->i >= -32768 && node->i <= 32767);
}
*****

***** CodeGenerator.c
/*
 *      return true if the node passed can be generated as a short
 *      offset.
***** ..\TABLE888SOURCE\CodeGenerator.C
/*
 *      return true if the node passed can be evaluated as a byte
 *      offset.
*****

***** CodeGenerator.c
 */
int isshort(ENODE *node)
{
***** ..\TABLE888SOURCE\CodeGenerator.C
 */
int isbyte(ENODE *node)
{
*****

***** CodeGenerator.c
        return node->nodetype == en_icon &&
        (node->i >= -32768 && node->i <= 32767);
}
***** ..\TABLE888SOURCE\CodeGenerator.C
        return node->nodetype == en_icon &&
       (-128 <= node->i && node->i <= 127);
}
*****

***** CodeGenerator.c

/*
 *      return true if the node passed can be evaluated as a byte
 *      offset.
 */
int isbyte(ENODE *node)
{
***** ..\TABLE888SOURCE\CodeGenerator.C

int ischar(ENODE *node)
{
*****

***** CodeGenerator.c
        return node->nodetype == en_icon &&
       (-128 <= node->i && node->i <= 127);
}
***** ..\TABLE888SOURCE\CodeGenerator.C
        return node->nodetype == en_icon &&
        (node->i >= -32768 && node->i <= 32767);
}
*****

***** CodeGenerator.c

int ischar(ENODE *node)
{
        return node->nodetype == en_icon &&
        (node->i >= -32768 && node->i <= 32767);
}

// ----------------------------------------------------------------------------
***** ..\TABLE888SOURCE\CodeGenerator.C

// ----------------------------------------------------------------------------
*****

***** CodeGenerator.c
        AMODE *ap1, *ap2, *ap3;
        
    if( (node->p[0]->nodetype == en_tempref || node->p[0]->nodetype==en_regvar) && (node->p[1]->nodetype == en_tempref || node-
***** ..\TABLE888SOURCE\CodeGenerator.C
        AMODE *ap1, *ap2, *ap3;

    if( (node->p[0]->nodetype == en_tempref || node->p[0]->nodetype==en_regvar) && (node->p[1]->nodetype == en_tempref || node-
*****

***** CodeGenerator.c
        }
        if (ap2->mode == am_direct && ap1->mode==am_reg) {
        ap2->mode = am_indx;
        ap2->preg = ap1->preg;
        ap2->deep = ap1->deep;
        return ap2;
    }
        // ap1->mode must be F_REG
***** ..\TABLE888SOURCE\CodeGenerator.C
        }
        // ap1->mode must be F_REG
*****

***** CodeGenerator.c
            return 12;
        case en_struct_ref:
            return 8;
//                      return node->esize;
    }
***** ..\TABLE888SOURCE\CodeGenerator.C
            return 12;
        //case en_struct_ref:
        //              return node->esize;
    }
*****

***** CodeGenerator.c
{    
        struct amode    *ap1, *ap2;
    int             siz1;
***** ..\TABLE888SOURCE\CodeGenerator.C
{    
        struct amode    *ap1;
    int             siz1;
*****

***** CodeGenerator.c

    Enter("Genderef");
        siz1 = GetReferenceSize(node);
        // When dereferencing a struct or union return a pointer to the struct or
        // union.
//      if (node->tp->type==bt_struct || node->tp->type==bt_union) {
//        return GenerateExpression(node,F_REG|F_MEM,size);
//    }
    if( node->p[0]->nodetype == en_add )
***** ..\TABLE888SOURCE\CodeGenerator.C

        siz1 = GetReferenceSize(node);
    if( node->p[0]->nodetype == en_add )
*****

***** CodeGenerator.c
    {
//        ap2 = GetTempRegister();
        ap1 = GenerateIndex(node->p[0]);
//        GenerateTriadic(op_add,0,ap2,makereg(ap1->preg),makereg(regGP));
                ap1->isUnsigned = !su;//node->isUnsigned;
***** ..\TABLE888SOURCE\CodeGenerator.C
    {
        ap1 = GenerateIndex(node->p[0]);
                ap1->isUnsigned = !su;//node->isUnsigned;
*****

***** CodeGenerator.c
                ap1->segment = dataseg;
//              ap2->mode = ap1->mode;
//              ap2->segment = dataseg;
//              ap2->offset = ap1->offset;
//              ReleaseTempRegister(ap1);
                if (!node->isUnsigned)
***** ..\TABLE888SOURCE\CodeGenerator.C
                ap1->segment = dataseg;
                if (!node->isUnsigned)
*****

***** CodeGenerator.c
        MakeLegalAmode(ap1,flags,size);
    Leave("Genderef",6);
        return ap1;
***** ..\TABLE888SOURCE\CodeGenerator.C
        MakeLegalAmode(ap1,flags,size);
        return ap1;
*****

***** CodeGenerator.c
        MakeLegalAmode(ap1,flags,size);
    Leave("Genderef",5);
        return ap1;
***** ..\TABLE888SOURCE\CodeGenerator.C
        MakeLegalAmode(ap1,flags,size);
        return ap1;
*****

***** CodeGenerator.c
        ap1->offset = makeinode(en_icon,node->p[0]->i);
                ap1->segment = stackseg;
***** ..\TABLE888SOURCE\CodeGenerator.C
        ap1->offset = makeinode(en_icon,node->p[0]->i);
                ap1->isFloat = TRUE;
                ap1->segment = stackseg;
*****

***** CodeGenerator.c
        MakeLegalAmode(ap1,flags,size);
    Leave("Genderef",4);
        return ap1;
***** ..\TABLE888SOURCE\CodeGenerator.C
        MakeLegalAmode(ap1,flags,size);
        return ap1;
*****

***** CodeGenerator.c
    }
    else if(( node->p[0]->nodetype == en_labcon || node->p[0]->nodetype==en_nacon ) && use_gp)
    {
        ap1 = allocAmode();
        ap1->mode = am_indx;
        ap1->preg = regGP;
                ap1->segment = dataseg;
        ap1->offset = node->p[0];//makeinode(en_icon,node->p[0]->i);
                ap1->isUnsigned = !su;
***** ..\TABLE888SOURCE\CodeGenerator.C
    }
    ap1 = GenerateExpression(node->p[0],F_REG | F_IMMED,8); /* generate address */
    if( ap1->mode == am_reg )
    {
        ap1->mode = am_ind;
                ap1->offset = 0;        // ****
                ap1->isUnsigned = !su;
*****

***** CodeGenerator.c
                    MakeLegalAmode(ap1,flags,siz1);
        ap1->isVolatile = node->isVolatile;
        MakeLegalAmode(ap1,flags,size);
    Leave("Genderef",3);
        return ap1;
***** ..\TABLE888SOURCE\CodeGenerator.C
                    MakeLegalAmode(ap1,flags,siz1);
        MakeLegalAmode(ap1,flags,size);
        return ap1;
*****

***** CodeGenerator.c
    }
    ap1 = GenerateExpression(node->p[0],F_REG | F_FPREG | F_IMMED,8); /* generate address */
    if( ap1->mode == am_reg )
    {
//        ap1->mode = am_ind;
          if (use_gp) {
              ap1->mode = am_indx;
              ap1->sreg = regGP;
          }
          else
             ap1->mode = am_ind;
                ap1->offset = 0;        // ****
                ap1->isUnsigned = !su;
                if (!node->isUnsigned)
                GenerateSignExtend(ap1,siz1,size,flags);
                else
                    MakeLegalAmode(ap1,flags,siz1);
        ap1->isVolatile = node->isVolatile;
        MakeLegalAmode(ap1,flags,size);
    Leave("Genderef",2);
        return ap1;
    }
    if( ap1->mode == am_fpreg )
    {
//        ap1->mode = am_ind;
          if (use_gp) {
              ap1->mode = am_indx;
              ap1->sreg = regGP;
          }
          else
             ap1->mode = am_ind;
                ap1->offset = 0;        // ****
                ap1->isUnsigned = !su;
                if (!node->isUnsigned)
                GenerateSignExtend(ap1,siz1,size,flags);
                else
                    MakeLegalAmode(ap1,flags,siz1);
        MakeLegalAmode(ap1,flags,size);
    Leave("Genderef",1);
        return ap1;
    }
        // See segments notes
***** ..\TABLE888SOURCE\CodeGenerator.C
    }
        // See segments notes
*****

***** CodeGenerator.c
        //      ap1->segment = dataseg;
    if (use_gp) {
        ap1->mode = am_indx;
        ap1->preg = regGP;
        ap1->segment = dataseg;
    }
    else {
        ap1->mode = am_direct;
            ap1->isUnsigned = !su;
    }
//    ap1->offset = makeinode(en_icon,node->p[0]->i);
    ap1->isUnsigned = !su;
        if (!node->isUnsigned)
***** ..\TABLE888SOURCE\CodeGenerator.C
        //      ap1->segment = dataseg;
    ap1->mode = am_direct;
        ap1->isUnsigned = !su;
        if (!node->isUnsigned)
*****

***** CodeGenerator.c
                MakeLegalAmode(ap1,flags,siz1);
    ap1->isVolatile = node->isVolatile;
    MakeLegalAmode(ap1,flags,size);
    Leave("Genderef",0);
    return ap1;
***** ..\TABLE888SOURCE\CodeGenerator.C
                MakeLegalAmode(ap1,flags,siz1);
    MakeLegalAmode(ap1,flags,size);
    return ap1;
*****

***** CodeGenerator.c
{
        AMODE *ap, *ap2;

    if (node->etype==bt_double) {
        ap2 = GetTempFPRegister();
        ap = GenerateExpression(node->p[0],F_FPREG,size);
        if (op==op_neg)
           op=op_fdneg;
    }
    else {
        ap2 = GetTempRegister();
        ap = GenerateExpression(node->p[0],F_REG,size);
    }
    GenerateDiadic(op,0,ap2,ap);
    ReleaseTempReg(ap);
    MakeLegalAmode(ap2,flags,size);
    return ap2;
}
***** ..\TABLE888SOURCE\CodeGenerator.C
{
        AMODE *ap;

    ap = GenerateExpression(node->p[0],F_REG,size);
    GenerateDiadic(op,0,ap,ap);
    MakeLegalAmode(ap,flags,size);
    return ap;
}
*****

***** CodeGenerator.c
        int op2;
        if (op==op_ftadd || op==op_ftsub || op==op_ftmul || op==op_ftdiv ||
***** ..\TABLE888SOURCE\CodeGenerator.C
        int op2;
        ap1 = GenerateExpression(node->p[0],F_REG,size);
        if (op==op_ftadd || op==op_ftsub || op==op_ftmul || op==op_ftdiv ||
*****

***** CodeGenerator.c
        {
        ap3 = GetTempFPRegister();
            ap1 = GenerateExpression(node->p[0],F_FPREG,size);
                ap2 = GenerateExpression(node->p[1],F_FPREG,size);
        }
***** ..\TABLE888SOURCE\CodeGenerator.C
        {
                ap2 = GenerateExpression(node->p[1],F_REG,size);
                ap3->isFloat = TRUE;
        }
*****

***** CodeGenerator.c
        else {
        ap3 = GetTempRegister();
        ap1 = GenerateExpression(node->p[0],F_REG,size);
                ap2 = GenerateExpression(node->p[1],F_REG|F_IMMED,size);
***** ..\TABLE888SOURCE\CodeGenerator.C
        else {
                ap2 = GenerateExpression(node->p[1],F_REG|F_IMMED,size);
*****

***** CodeGenerator.c
       }
       GenerateTriadic(op,0,ap3,ap1,ap2);
    }
    ReleaseTempReg(ap2);
    ReleaseTempReg(ap1);
    MakeLegalAmode(ap3,flags,size);
    return ap3;
}
***** ..\TABLE888SOURCE\CodeGenerator.C
       }
       GenerateTriadic(op,0,ap1,ap1,ap2);
    }
    ReleaseTempRegister(ap2);
    MakeLegalAmode(ap1,flags,size);
    return ap1;
}
*****

***** CodeGenerator.c
         swap_nodes(node);
    if (op==op_fddiv) {
        ap3 = GetTempFPRegister();
        ap1 = GenerateExpression(node->p[0],F_FPREG,8);
        ap2 = GenerateExpression(node->p[1],F_FPREG,8);
    }
    else {
        ap3 = GetTempRegister();
        ap1 = GenerateExpression(node->p[0],F_REG,8);
        ap2 = GenerateExpression(node->p[1],F_REG | F_IMMED,8);
    }
    if (ap2->mode==am_immed) {
***** ..\TABLE888SOURCE\CodeGenerator.C
         swap_nodes(node);
    ap1 = GenerateExpression(node->p[0],F_REG,8);
    ap2 = GenerateExpression(node->p[1],F_REG | F_IMMED,8);
    if (ap2->mode==am_immed) {
*****

***** CodeGenerator.c
    }
    GenerateTriadic(op,0,ap3,ap1,ap2);
//    GenerateDiadic(op_ext,0,ap3,0);
    MakeLegalAmode(ap3,flags,8);
    ReleaseTempReg(ap2);
    ReleaseTempReg(ap1);
    return ap3;
}
***** ..\TABLE888SOURCE\CodeGenerator.C
    }
    GenerateTriadic(op,0,ap1,ap1,ap2);
//    GenerateDiadic(op_ext,0,ap3,0);
    MakeLegalAmode(ap1,flags,8);
    ReleaseTempRegister(ap2);
    return ap1;
}
*****

***** CodeGenerator.c
{       
        AMODE *ap1, *ap2, *ap3;
    Enter("Genmul");
    if( node->p[0]->nodetype == en_icon )
***** ..\TABLE888SOURCE\CodeGenerator.C
{       
        AMODE *ap1, *ap2;
    if( node->p[0]->nodetype == en_icon )
*****

***** CodeGenerator.c
        swap_nodes(node);
    if (op==op_fdmul) {
        ap3 = GetTempFPRegister();
        ap1 = GenerateExpression(node->p[0],F_FPREG,8);
        ap2 = GenerateExpression(node->p[1],F_FPREG,8);
    }
    else {
        ap3 = GetTempRegister();
        ap1 = GenerateExpression(node->p[0],F_REG,8);
        ap2 = GenerateExpression(node->p[1],F_REG | F_IMMED,8);
    }
    if (ap2->mode==am_immed) {
***** ..\TABLE888SOURCE\CodeGenerator.C
        swap_nodes(node);
    ap1 = GenerateExpression(node->p[0],F_REG,8);
    ap2 = GenerateExpression(node->p[1],F_REG | F_IMMED,8);
    if (ap2->mode==am_immed) {
*****

***** CodeGenerator.c
    }
        GenerateTriadic(op,0,ap3,ap1,ap2);
    ReleaseTempReg(ap2);
    ReleaseTempReg(ap1);
    MakeLegalAmode(ap3,flags,8);
    Leave("Genmul",0);
    return ap3;
}
***** ..\TABLE888SOURCE\CodeGenerator.C
    }
        GenerateTriadic(op,0,ap1,ap1,ap2);
    ReleaseTempRegister(ap2);
    MakeLegalAmode(ap1,flags,8);
    return ap1;
}
*****

***** CodeGenerator.c
    ap1 = GenerateExpression(node->p[0],flags,size);
    GenerateDiadic(isThor?op_br:op_bra,0,make_clabel(end_label),0);
    GenerateLabel(false_label);
***** ..\TABLE888SOURCE\CodeGenerator.C
    ap1 = GenerateExpression(node->p[0],flags,size);
    GenerateDiadic(op_bra,0,make_clabel(end_label),0);
    GenerateLabel(false_label);
*****

***** CodeGenerator.c
    }
    ReleaseTempReg(ap2);
    GenerateLabel(end_label);
***** ..\TABLE888SOURCE\CodeGenerator.C
    }
    ReleaseTempRegister(ap2);
    GenerateLabel(end_label);
*****

***** CodeGenerator.c
    }
    if (ap1->isFloat)
        ap3 = GetTempFPRegister();
    else
        ap3 = GetTempRegister();
    GenLoad(ap3,ap1,ssize,ssize);
        GenerateTriadic(op,0,ap3,ap3,ap2);
***** ..\TABLE888SOURCE\CodeGenerator.C
    }
        ap3 = GetTempRegister();
    GenLoad(ap3,ap1,ssize);
        GenerateTriadic(op,0,ap3,ap3,ap2);
*****

***** CodeGenerator.c
        GenStore(ap3,ap1,ssize);
        ReleaseTempReg(ap3);
}
***** ..\TABLE888SOURCE\CodeGenerator.C
        GenStore(ap3,ap1,ssize);
        ReleaseTempRegister(ap3);
}
*****

***** CodeGenerator.c
            size = ssize;
    if (node->etype==bt_double) {
        ap1 = GenerateExpression(node->p[0],F_FPREG|F_MEM,ssize);
        ap2 = GenerateExpression(node->p[1],F_FPREG,size);
        if (op==op_addu || op==op_add)
           op = op_fdadd;
        else if (op==op_subu || op==op_sub)
           op = op_fdsub;
    }
    else {
        ap1 = GenerateExpression(node->p[0],F_ALL,ssize);
        ap2 = GenerateExpression(node->p[1],F_REG | F_IMMED,size);
    }
        if (ap2->mode ==am_immed)
***** ..\TABLE888SOURCE\CodeGenerator.C
            size = ssize;
    ap1 = GenerateExpression(node->p[0],F_ALL,ssize);
    ap2 = GenerateExpression(node->p[1],F_REG | F_IMMED,size);
        if (ap2->mode ==am_immed)
*****

***** CodeGenerator.c
        }
        else if (ap1->mode==am_fpreg) {
            GenerateTriadic(op,0,ap1,ap1,ap2);
        }
        else {
***** ..\TABLE888SOURCE\CodeGenerator.C
        }
        else {
*****

***** CodeGenerator.c
        }
    ReleaseTempReg(ap2);
        if (!ap1->isUnsigned)
***** ..\TABLE888SOURCE\CodeGenerator.C
        }
    ReleaseTempRegister(ap2);
        if (!ap1->isUnsigned)
*****

***** CodeGenerator.c

//
//      generate a *= node.
//
AMODE *GenerateAssignMultiply(ENODE *node,int flags, int size, int op)
***** ..\TABLE888SOURCE\CodeGenerator.C

/*
 *      generate a *= node.
 */
AMODE *GenerateAssignMultiply(ENODE *node,int flags, int size, int op)
*****

***** CodeGenerator.c
            size = ssize;
    if (node->etype==bt_double) {
        ap1 = GenerateExpression(node->p[0],F_FPREG | F_MEM,ssize);
        ap2 = GenerateExpression(node->p[1],F_FPREG,size);
        op = op_fdmul;
    }
    else {
        ap1 = GenerateExpression(node->p[0],F_ALL & ~F_IMMED,ssize);
        ap2 = GenerateExpression(node->p[1],F_REG | F_IMMED,size);
    }
        if (ap2->mode==am_immed)
***** ..\TABLE888SOURCE\CodeGenerator.C
            size = ssize;
    ap1 = GenerateExpression(node->p[0],F_ALL & ~F_IMMED,ssize);
    ap2 = GenerateExpression(node->p[1],F_REG | F_IMMED,size);
        if (ap2->mode==am_immed)
*****

***** CodeGenerator.c
                }
        if (ap1->mode==am_reg || ap1->mode==am_fpreg) {
            GenerateTriadic(op,0,ap1,ap1,ap2);
***** ..\TABLE888SOURCE\CodeGenerator.C
                }
        if (ap1->mode==am_reg) {
            GenerateTriadic(op,0,ap1,ap1,ap2);
*****

***** CodeGenerator.c
        }
    ReleaseTempReg(ap2);
    GenerateSignExtend(ap1,ssize,size,flags);
***** ..\TABLE888SOURCE\CodeGenerator.C
        }
    ReleaseTempRegister(ap2);
    GenerateSignExtend(ap1,ssize,size,flags);
*****

***** CodeGenerator.c
    int             siz1;
    int isFP;
 
    siz1 = GetNaturalSize(node->p[0]);
    isFP = node->etype==bt_double;
    if (isFP) {
        ap1 = GetTempFPRegister();
        ap2 = GenerateExpression(node->p[0],F_FPREG|F_MEM,siz1);
        if (op==op_divs || op==op_divu)
           op = op_fddiv;
//        else if (op==op_mod || op==op_modu)
//           op = op_fdmod;
    }
    else {
        ap1 = GetTempRegister();
        ap2 = GenerateExpression(node->p[0],F_ALL & ~F_IMMED,siz1);
    }
        if (ap2->mode==am_reg && ap2->preg != ap1->preg)
***** ..\TABLE888SOURCE\CodeGenerator.C
    int             siz1;

    siz1 = GetNaturalSize(node->p[0]);
    ap1 = GetTempRegister();
    ap2 = GenerateExpression(node->p[0],F_ALL & ~F_IMMED,siz1);
        if (ap2->mode==am_reg && ap2->preg != ap1->preg)
*****

***** CodeGenerator.c
                GenerateDiadic(op_mov,0,ap1,ap2);
        else if (ap2->mode==am_fpreg && ap2->preg != ap1->preg)
                GenerateDiadic(op_fdmov,0,ap1,ap2);
        else
        GenLoad(ap1,ap2,siz1,siz1);
    //GenerateSignExtend(ap1,siz1,8,flags);
    if (isFP)
        ap3 = GenerateExpression(node->p[1],F_FPREG,8);
    else
        ap3 = GenerateExpression(node->p[1],F_REG|F_IMMED,8);
    if (ap3->mode==am_immed) {
    switch (op) {
    case op_mod:    op = op_modi;
    case op_modu:   op = op_modui;
    case op_divs:    op = op_divi;
    case op_divu:   op = op_divui;
    }
    }
    GenerateTriadic(op,0,ap1,ap1,ap3);
    ReleaseTempReg(ap3);
    //GenerateDiadic(op_ext,0,ap1,0);
***** ..\TABLE888SOURCE\CodeGenerator.C
                GenerateDiadic(op_mov,0,ap1,ap2);
        else
        GenLoad(ap1,ap2,siz1);
    //GenerateSignExtend(ap1,siz1,8,flags);
    ap3 = GenerateExpression(node->p[1],F_REG|F_IMMED,2);
    GenerateTriadic(op,0,ap1,ap1,ap3);
    ReleaseTempRegister(ap3);
    //GenerateDiadic(op_ext,0,ap1,0);
*****

***** CodeGenerator.c
                GenerateDiadic(op_mov,0,ap2,ap1);
        else if (ap2->mode==am_fpreg)
                GenerateDiadic(op_fdmov,0,ap2,ap1);
        else
***** ..\TABLE888SOURCE\CodeGenerator.C
                GenerateDiadic(op_mov,0,ap2,ap1);
        else
*****

***** CodeGenerator.c
            GenStore(ap1,ap2,siz1);
    ReleaseTempReg(ap2);
    MakeLegalAmode(ap1,flags,size);
***** ..\TABLE888SOURCE\CodeGenerator.C
            GenStore(ap1,ap2,siz1);
    ReleaseTempRegister(ap2);
    MakeLegalAmode(ap1,flags,size);
*****

***** CodeGenerator.c
                ENODE *ep;

    Enter("GenAssign");

    if (node->p[0]->nodetype == en_uwfieldref ||
***** ..\TABLE888SOURCE\CodeGenerator.C
                ENODE *ep;
    if (node->p[0]->nodetype == en_uwfieldref ||
*****

***** CodeGenerator.c

      Leave("GenAssign",0);
                return GenerateBitfieldAssign(node, flags, size);
***** ..\TABLE888SOURCE\CodeGenerator.C

                return GenerateBitfieldAssign(node, flags, size);
*****

***** CodeGenerator.c
//                      size = ssize;
/*
    if (node->tp->type==bt_struct || node->tp->type==bt_union) {
                ap1 = GenerateExpression(node->p[0],F_REG,ssize);
                ap2 = GenerateExpression(node->p[1],F_REG,size);
                GenerateMonadic(op_push,0,make_immed(node->tp->size));
                GenerateMonadic(op_push,0,ap2);
                GenerateMonadic(op_push,0,ap1);
                GenerateMonadic(op_bsr,0,make_string("memcpy_"));
                GenerateTriadic(op_addui,0,makereg(regSP),makereg(regSP),make_immed(24));
                ReleaseTempReg(ap2);
                return ap1;
    }
*/
        if (size > 8) {
                ap1 = GenerateExpression(node->p[0],F_MEM,ssize);
                ap2 = GenerateExpression(node->p[1],F_MEM,size);
        }
***** ..\TABLE888SOURCE\CodeGenerator.C
//                      size = ssize;
        if (size > 8) {
                ap2 = GenerateExpression(node->p[1],F_MEM,size);
                ap1 = GenerateExpression(node->p[0],F_MEM,ssize);
        }
*****

***** CodeGenerator.c
        else {
                ap1 = GenerateExpression(node->p[0],F_REG|F_FPREG|F_MEM,ssize);
                if (ap1->mode==am_fpreg || ap1->isFloat) {
                ap2 = GenerateExpression(node->p[1],F_FPREG|F_MEM,size);
        }
                else
                ap2 = GenerateExpression(node->p[1],F_ALL,size);
                if (node->p[0]->isUnsigned && !node->p[1]->isUnsigned)
                    GenerateZeroExtend(ap2,size,ssize);
        }
    if (ap1->mode == am_fpreg) {
                if (ap2->mode==am_reg)
***** ..\TABLE888SOURCE\CodeGenerator.C
        else {
                ap2 = GenerateExpression(node->p[1],F_ALL,size);
                ap1 = GenerateExpression(node->p[0],F_REG|F_MEM,ssize);
        }

        if (ap1->mode == am_reg) {
                if (ap2->mode==am_reg)
*****

***** CodeGenerator.c
                        GenerateDiadic(op_mov,0,ap1,ap2);
                else if (ap2->mode==am_fpreg)
                        GenerateDiadic(op_mov,0,ap1,ap2);
                else if (ap2->mode==am_immed) {
            MakeLegalAmode(ap2,F_FPREG,8);
                        GenerateDiadic(op_mov,0,ap1,ap2);
        }
        else
                        GenerateDiadic(op_lfd,0,ap1,ap2);
    }
        else if (ap1->mode == am_reg) {
                if (ap2->mode==am_reg) {
                        GenerateDiadic(op_mov,0,ap1,ap2);
        }
                else if (ap2->mode==am_fpreg)
                        GenerateDiadic(op_mov,0,ap1,ap2);
                else if (ap2->mode==am_immed) {
***** ..\TABLE888SOURCE\CodeGenerator.C
                        GenerateDiadic(op_mov,0,ap1,ap2);
                else if (ap2->mode==am_immed) {
*****

***** CodeGenerator.c
                FISA64_GenLdi(ap1,ap2);
            else {
                        GenerateDiadic(op_ldi,0,ap1,ap2);
            }
      }
***** ..\TABLE888SOURCE\CodeGenerator.C
                FISA64_GenLdi(ap1,ap2);
            else
                        GenerateDiadic(op_ldi,0,ap1,ap2);
      }
*****

***** CodeGenerator.c
                else {
             GenLoad(ap1,ap2,ssize,size);
/*
                        if (ap1->isUnsigned) {
***** ..\TABLE888SOURCE\CodeGenerator.C
                else {
                        if (ap1->isUnsigned) {
*****

***** CodeGenerator.c
                        }
*/
                }
***** ..\TABLE888SOURCE\CodeGenerator.C
                        }
                }
*****

***** CodeGenerator.c
        else {
                if (ap2->mode == am_reg) {
                    GenStore(ap2,ap1,ssize);
        }
                else if (ap2->mode == am_fpreg) {
                    GenStore(ap2,ap1,ssize);
        }
                else if (ap2->mode == am_immed) {
***** ..\TABLE888SOURCE\CodeGenerator.C
        else {
                if (ap2->mode == am_reg)
                    GenStore(ap2,ap1,ssize);
                else if (ap2->mode == am_immed) {
*****

***** CodeGenerator.c
                GenStore(ap3,ap1,ssize);
                        ReleaseTempReg(ap3);
            }
***** ..\TABLE888SOURCE\CodeGenerator.C
                GenStore(ap3,ap1,ssize);
                        ReleaseTempRegister(ap3);
            }
*****

***** CodeGenerator.c
                                GenerateTriadic(op_push,0,ap3,ap2,ap1);
                                GenerateDiadic(op_jal,0,makereg(LR),make_string("memcpy_"));
                                GenerateTriadic(op_addui,0,makereg(SP),makereg(SP),make_immed(24));
***** ..\TABLE888SOURCE\CodeGenerator.C
                                GenerateTriadic(op_push,0,ap3,ap2,ap1);
                                GenerateDiadic(op_jal,0,makereg(LR),make_string("memcpy"));
                                GenerateTriadic(op_addui,0,makereg(SP),makereg(SP),make_immed(24));
*****

***** CodeGenerator.c
                        else {
                GenLoad(ap3,ap2,ssize,size);
/*                
                                if (ap1->isUnsigned) {
***** ..\TABLE888SOURCE\CodeGenerator.C
                        else {
                                if (ap1->isUnsigned) {
*****

***** CodeGenerator.c
                                }
*/
                                GenStore(ap3,ap1,ssize);
***** ..\TABLE888SOURCE\CodeGenerator.C
                                }
                                GenStore(ap3,ap1,ssize);
*****

***** CodeGenerator.c
*/
        ReleaseTempReg(ap2);
    MakeLegalAmode(ap1,flags,size);
    Leave("GenAssign",1);
        return ap1;
}
***** ..\TABLE888SOURCE\CodeGenerator.C
*/
        ReleaseTempRegister(ap1);
    MakeLegalAmode(ap2,flags,size);
        return ap2;
}
*****

***** CodeGenerator.c
        return ap2;
        GenLoad(ap1,ap2,siz1,siz1);
                GenerateTriadic(op,0,ap1,ap1,make_immed(node->i));
***** ..\TABLE888SOURCE\CodeGenerator.C
        return ap2;
        GenLoad(ap1,ap2,siz1);
                GenerateTriadic(op,0,ap1,ap1,make_immed(node->i));
*****

***** CodeGenerator.c

    Enter("GenExperssion"); 
    if( node == (ENODE *)NULL )
***** ..\TABLE888SOURCE\CodeGenerator.C

    if( node == (ENODE *)NULL )
*****

***** CodeGenerator.c
                        exit(0);
         Leave("GenExperssion",1); 
        return (AMODE *)NULL;
***** ..\TABLE888SOURCE\CodeGenerator.C
                        exit(0);
        return (AMODE *)NULL;
*****

***** CodeGenerator.c
            MakeLegalAmode(ap1,flags,size);
         Leave("GenExperssion",2); 
            return ap1;
***** ..\TABLE888SOURCE\CodeGenerator.C
            MakeLegalAmode(ap1,flags,size);
            return ap1;
*****

***** CodeGenerator.c
            MakeLegalAmode(ap1,flags,size);
         Leave("GenExperssion",3); 
            return ap1;
***** ..\TABLE888SOURCE\CodeGenerator.C
            MakeLegalAmode(ap1,flags,size);
            return ap1;
*****

***** CodeGenerator.c
                MakeLegalAmode(ap1,flags,size);
         Leave("GenExperssion",4); 
                return ap1;             // return reg
***** ..\TABLE888SOURCE\CodeGenerator.C
                MakeLegalAmode(ap1,flags,size);
                return ap1;             // return reg
*****

***** CodeGenerator.c
            MakeLegalAmode(ap1,flags,size);
         Leave("GenExperssion",5); 
            return ap1;
***** ..\TABLE888SOURCE\CodeGenerator.C
            MakeLegalAmode(ap1,flags,size);
            return ap1;
*****

***** CodeGenerator.c
                MakeLegalAmode(ap1,flags,size);
         Leave("GenExperssion",6); 
                return ap1;             // return reg
***** ..\TABLE888SOURCE\CodeGenerator.C
                MakeLegalAmode(ap1,flags,size);
                return ap1;             // return reg
*****

***** CodeGenerator.c
            MakeLegalAmode(ap1,flags,size);
         Leave("GenExperssion",7); 
            return ap1;
***** ..\TABLE888SOURCE\CodeGenerator.C
            MakeLegalAmode(ap1,flags,size);
            return ap1;
*****

***** CodeGenerator.c
            ap2 = allocAmode();
            ap2->mode = am_indx;
***** ..\TABLE888SOURCE\CodeGenerator.C
            ap2 = allocAmode();
                        ap2->isFloat = TRUE;
            ap2->mode = am_indx;
*****

***** CodeGenerator.c
            ap2->offset = node;     /* use as constant node */
            ap2->isFloat = TRUE;
            GenerateDiadic(op_lea,0,ap1,ap2);
***** ..\TABLE888SOURCE\CodeGenerator.C
            ap2->offset = node;     /* use as constant node */
            GenerateDiadic(op_lea,0,ap1,ap2);
*****

***** CodeGenerator.c
        case en_uw_ref:
                        ap1 = GenerateDereference(node,flags,size,0);
***** ..\TABLE888SOURCE\CodeGenerator.C
        case en_uw_ref:
        case en_struct_ref:
                        ap1 = GenerateDereference(node,flags,size,0);
*****

***** CodeGenerator.c
            return ap1;
        case en_struct_ref:
                        ap1 = GenerateDereference(node,flags,size,0);
                        ap1->isUnsigned = TRUE;
            return ap1;
    case en_b_ref:
***** ..\TABLE888SOURCE\CodeGenerator.C
            return ap1;
    case en_b_ref:
*****

***** CodeGenerator.c
    case en_w_ref:
                        ap1 = GenerateDereference(node,flags,size,1);
            return ap1;
        case en_flt_ref:
***** ..\TABLE888SOURCE\CodeGenerator.C
    case en_w_ref:
        case en_flt_ref:
*****

***** CodeGenerator.c
                        ap1 = GenerateDereference(node,flags,size,1);
                        ap1->isFloat = TRUE;
            return ap1;
***** ..\TABLE888SOURCE\CodeGenerator.C
                        ap1 = GenerateDereference(node,flags,size,1);
            return ap1;
*****

***** CodeGenerator.c
            return ap1;
    case en_tempfpref:
            ap1 = allocAmode();
            ap1->mode = am_fpreg;
            ap1->preg = node->i;
            ap1->tempflag = 0;      /* not a temporary */
            MakeLegalAmode(ap1,flags,size);
            return ap1;
        case en_fpregvar:
//    case en_fptempref:
            ap1 = allocAmode();
            ap1->mode = am_fpreg;
            ap1->preg = node->i;
            ap1->tempflag = 0;      /* not a temporary */
            MakeLegalAmode(ap1,flags,size);
            return ap1;
    case en_uminus: return GenerateUnary(node,flags,size,op_neg);
***** ..\TABLE888SOURCE\CodeGenerator.C
            return ap1;
    case en_uminus: return GenerateUnary(node,flags,size,op_neg);
*****

***** CodeGenerator.c
    case en_sub:    return GenerateBinary(node,flags,size,op_subu);
    case en_i2d:
         ap1 = GetTempFPRegister();     
         ap2=GenerateExpression(node->p[0],F_REG,8);
         GenerateDiadic(op_mv2flt,0,ap1,ap2);
         ReleaseTempReg(ap2);
         return ap1;
    case en_d2i:
         ap1 = GetTempRegister();       
         ap2 = GenerateExpression(node->p[0],F_FPREG,8);
         GenerateDiadic(op_mv2fix,0,ap1,ap2);
         ReleaseTempReg(ap2);
         return ap1;
    case en_i2t:        return GenerateUnary(node,flags,size,op_i2t);
***** ..\TABLE888SOURCE\CodeGenerator.C
    case en_sub:    return GenerateBinary(node,flags,size,op_subu);
    case en_i2d:        return GenerateUnary(node,flags,size,op_i2d);
    case en_i2t:        return GenerateUnary(node,flags,size,op_i2t);
*****

***** CodeGenerator.c
        return ap1;
    case en_chk:
        return GenExprFISA64(node);
         
    case en_eq:     case en_ne:
***** ..\TABLE888SOURCE\CodeGenerator.C
        return ap1;

    case en_eq:     case en_ne:
*****

***** CodeGenerator.c
    case en_ugt:    case en_uge:
                case en_feq:    case en_fne:
                case en_flt:    case en_fle:
                case en_fgt:    case en_fge:
        if (isFISA64)
***** ..\TABLE888SOURCE\CodeGenerator.C
    case en_ugt:    case en_uge:
        if (isFISA64)
*****

***** CodeGenerator.c
                case en_regvar:
        case en_fpregvar:
                case en_cbw: case en_cubw:
***** ..\TABLE888SOURCE\CodeGenerator.C
                case en_regvar:
                case en_cbw: case en_cubw:
*****

***** CodeGenerator.c
                case en_asr:    case en_asrshu:
                case en_feq:    case en_fne:
                case en_flt:    case en_fle:
                case en_fgt:    case en_fge:
        case en_eq:     case en_ne:
***** ..\TABLE888SOURCE\CodeGenerator.C
                case en_asr:    case en_asrshu:
        case en_eq:     case en_ne:
*****

***** CodeGenerator.c
                return GetNaturalSize(node->p[1]);
        case en_chk:
             return 8;
        default:
***** ..\TABLE888SOURCE\CodeGenerator.C
                return GetNaturalSize(node->p[1]);
        default:
*****

***** CodeGenerator.c
{
     Enter("GenCmp");
    if (isFISA64)
***** ..\TABLE888SOURCE\CodeGenerator.C
{
    if (isFISA64)
*****

***** CodeGenerator.c
                GenerateThorCmp(node, op, label, predreg);
     Leave("GenCmp",0);
}
***** ..\TABLE888SOURCE\CodeGenerator.C
                GenerateThorCmp(node, op, label, predreg);
}
*****

***** CodeGenerator.c
                                                        GenerateDiadic(op_tst,0,makepred(predreg),ap1);
                                                        GeneratePredicatedMonadic(predreg,PredOp(op_ne),op_br,0,make_clabel(lab
el));
                                                }
***** ..\TABLE888SOURCE\CodeGenerator.C
                                                        GenerateDiadic(op_tst,0,makepred(predreg),ap1);
                                                        GeneratePredicatedMonadic(predreg,PredOp(op_ne),op_bra,0,make_clabel(la
bel));
                                                }
*****

***** CodeGenerator.c
                case en_uge: GenerateCmp(node, op_ltu, label, predreg); break;
                case en_feq:    GenerateCmp(node, op_fne, label, predreg); break;
                case en_fne: GenerateCmp(node, op_feq, label, predreg); break;
                case en_flt: GenerateCmp(node, op_fge, label, predreg); break;
                case en_fle: GenerateCmp(node, op_fgt, label, predreg); break;
                case en_fgt: GenerateCmp(node, op_fle, label, predreg); break;
                case en_fge: GenerateCmp(node, op_flt, label, predreg); break;
                case en_land:
***** ..\TABLE888SOURCE\CodeGenerator.C
                case en_uge: GenerateCmp(node, op_ltu, label, predreg); break;
                case en_land:
*****

***** CodeGenerator.c
                                                        GenerateDiadic(op_tst,0,makepred(predreg),ap);
                                                        GeneratePredicatedMonadic(predreg,PredOp(op_eq),op_br,0,make_clabel(lab
el));
                                                }
***** ..\TABLE888SOURCE\CodeGenerator.C
                                                        GenerateDiadic(op_tst,0,makepred(predreg),ap);
                                                        GeneratePredicatedMonadic(predreg,PredOp(op_eq),op_bra,0,make_clabel(la
bel));
                                                }
*****

Comparing files ctype.c and ..\TABLE888SOURCE\ctype.C
FC: no differences encountered

Comparing files DoubleDouble.c and ..\TABLE888SOURCE\DoubleDouble.C
Comparing files err.c and ..\TABLE888SOURCE\err.C
FC: no differences encountered

Comparing files FISA64.c and ..\TABLE888SOURCE\FISA64.C
***** FISA64.c
    ap1 = GetTempRegister();
    GenerateDiadic(op_ldi,0,ap1,make_immed(1));
    GenerateMonadic(op_bra,0,make_label(lab1));
***** ..\TABLE888SOURCE\FISA64.C
    ap1 = GetTempRegister();
    GenerateDiadic(op_lc0i,0,ap1,make_immed(1));
    GenerateMonadic(op_bra,0,make_label(lab1));
*****

***** FISA64.c
    GenerateLabel(lab0);
    GenerateDiadic(op_ldi,0,ap1,make_immed(0));
    GenerateLabel(lab1);
***** ..\TABLE888SOURCE\FISA64.C
    GenerateLabel(lab0);
    GenerateDiadic(op_lc0i,0,ap1,make_immed(0));
    GenerateLabel(lab1);
*****

***** FISA64.c
        ap2 = GenerateExpression(node->p[1],F_REG|F_IMMED,size);
        ap3 = GetTempRegister();
        // Optimize CMP to zero and branch into plain branch, this works only for
***** ..\TABLE888SOURCE\FISA64.C
        ap2 = GenerateExpression(node->p[1],F_REG|F_IMMED,size);
        // Optimize CMP to zero and branch into plain branch, this works only for
*****

***** FISA64.c
        }
        ReleaseTempRegister(ap3);
                ReleaseTempRegister(ap2);
***** ..\TABLE888SOURCE\FISA64.C
        }
                ReleaseTempRegister(ap2);
*****

***** FISA64.c
        if (op==op_ltu || op==op_leu || op==op_gtu || op==op_geu)
            GenerateTriadic(op_cmpu,0,ap3,ap1,ap2);
        else
            GenerateTriadic(op_cmp,0,ap3,ap1,ap2);
        switch(op)
***** ..\TABLE888SOURCE\FISA64.C
        if (op==op_ltu || op==op_leu || op==op_gtu || op==op_geu)
            GenerateTriadic(op_cmpu,0,ap1,ap1,ap2);
        else
            GenerateTriadic(op_cmp,0,ap1,ap1,ap2);
        switch(op)
*****

***** FISA64.c
        }
        GenerateDiadic(op,0,ap3,make_clabel(label));
        ReleaseTempRegister(ap3);
        ReleaseTempRegister(ap2);
***** ..\TABLE888SOURCE\FISA64.C
        }
        GenerateDiadic(op,0,ap1,make_clabel(label));
        ReleaseTempRegister(ap2);
*****

***** FISA64.c
        if (sym->IsInterrupt) {
       if (sym->stkname)
           GenerateDiadic(op_lea,0,makereg(SP),make_string(sym->stkname));
       GenerateMonadic(op_push,0,makereg(1));
       GenerateMonadic(op_push,0,makereg(2));
       GenerateMonadic(op_push,0,makereg(3));
       GenerateMonadic(op_push,0,makereg(4));
       GenerateMonadic(op_push,0,makereg(5));
       GenerateMonadic(op_push,0,makereg(6));
       GenerateMonadic(op_push,0,makereg(7));
       GenerateMonadic(op_push,0,makereg(8));
       GenerateMonadic(op_push,0,makereg(9));
       GenerateMonadic(op_push,0,makereg(10));
       GenerateMonadic(op_push,0,makereg(11));
       GenerateMonadic(op_push,0,makereg(12));
       GenerateMonadic(op_push,0,makereg(13));
       GenerateMonadic(op_push,0,makereg(14));
       GenerateMonadic(op_push,0,makereg(15));
       GenerateMonadic(op_push,0,makereg(16));
       GenerateMonadic(op_push,0,makereg(17));
       GenerateMonadic(op_push,0,makereg(18));
       GenerateMonadic(op_push,0,makereg(19));
       GenerateMonadic(op_push,0,makereg(20));
       GenerateMonadic(op_push,0,makereg(21));
       GenerateMonadic(op_push,0,makereg(22));
       GenerateMonadic(op_push,0,makereg(23));
       GenerateMonadic(op_push,0,makereg(25));
       GenerateMonadic(op_push,0,makereg(26));
       GenerateMonadic(op_push,0,makereg(27));
       GenerateMonadic(op_push,0,makereg(28));
       GenerateMonadic(op_push,0,makereg(29));
       GenerateMonadic(op_push,0,makereg(31));
        }
        if (sym->prolog) {
       if (optimize)
           opt1(sym->prolog);
           GenerateStatement(sym->prolog);
    }
        if (!sym->IsNocall) {
***** ..\TABLE888SOURCE\FISA64.C
        if (sym->IsInterrupt) {
        }
        if (!sym->IsNocall) {
*****

***** FISA64.c
        int toAdd;
        Statement *s;

***** ..\TABLE888SOURCE\FISA64.C
        int toAdd;

*****

***** FISA64.c
                        GenerateDiadic(op_sb,0,makereg(0),make_string(semaphores[nn]));
                
        if (sym->IsNocall) {    // nothing to do for nocall convention
                        return;
        }
                // Restore registers used as register variables.
***** ..\TABLE888SOURCE\FISA64.C
                        GenerateDiadic(op_sb,0,makereg(0),make_string(semaphores[nn]));
                if (sym->IsNocall)      // nothing to do for nocall convention
                        return;
                // Restore registers used as register variables.
*****

***** FISA64.c
                }
                    if (sym->epilog) {
               if (optimize)
                  opt1(sym->epilog);
                       GenerateStatement(sym->epilog);
                       return;
           }
        
                // Generate the return instruction. For the Pascal calling convention pop the parameters
***** ..\TABLE888SOURCE\FISA64.C
                }
                // Generate the return instruction. For the Pascal calling convention pop the parameters
*****

***** FISA64.c
                if (sym->IsInterrupt) {
            GenerateMonadic(op_pop,0,makereg(31));
            GenerateMonadic(op_pop,0,makereg(29));
            GenerateMonadic(op_pop,0,makereg(28));
            GenerateMonadic(op_pop,0,makereg(27));
            GenerateMonadic(op_pop,0,makereg(26));
            GenerateMonadic(op_pop,0,makereg(25));
            GenerateMonadic(op_pop,0,makereg(23));
            GenerateMonadic(op_pop,0,makereg(22));
            GenerateMonadic(op_pop,0,makereg(21));
            GenerateMonadic(op_pop,0,makereg(20));
            GenerateMonadic(op_pop,0,makereg(19));
            GenerateMonadic(op_pop,0,makereg(18));
            GenerateMonadic(op_pop,0,makereg(17));
            GenerateMonadic(op_pop,0,makereg(16));
            GenerateMonadic(op_pop,0,makereg(15));
            GenerateMonadic(op_pop,0,makereg(14));
            GenerateMonadic(op_pop,0,makereg(13));
            GenerateMonadic(op_pop,0,makereg(12));
            GenerateMonadic(op_pop,0,makereg(11));
            GenerateMonadic(op_pop,0,makereg(10));
            GenerateMonadic(op_pop,0,makereg(9));
            GenerateMonadic(op_pop,0,makereg(8));
            GenerateMonadic(op_pop,0,makereg(7));
            GenerateMonadic(op_pop,0,makereg(6));
            GenerateMonadic(op_pop,0,makereg(5));
            GenerateMonadic(op_pop,0,makereg(4));
            GenerateMonadic(op_pop,0,makereg(3));
            GenerateMonadic(op_pop,0,makereg(2));
            GenerateMonadic(op_pop,0,makereg(1));
                        GenerateMonadic(op_rti,0,NULL);
***** ..\TABLE888SOURCE\FISA64.C
                if (sym->IsInterrupt) {
                        GenerateMonadic(op_rti,0,NULL);
*****

***** FISA64.c
                if (sym->IsPascal)
            GenerateMonadic(op_rtl,0,make_immed(toAdd+sym->NumParms * 8));
                else
            GenerateMonadic(op_rtl,0,make_immed(toAdd));
    }
***** ..\TABLE888SOURCE\FISA64.C
                if (sym->IsPascal)
            GenerateMonadic(op_rts,0,make_immed(toAdd+sym->NumParms * 8));
                else
            GenerateMonadic(op_rts,0,make_immed(toAdd));
    }
*****

Comparing files FloatTriple.c and ..\TABLE888SOURCE\FloatTriple.C
Comparing files GenerateBitfield.c and ..\TABLE888SOURCE\GenerateBitfield.C
FC: no differences encountered

Comparing files GenerateFunction.c and ..\TABLE888SOURCE\GenerateFunction.C
***** GenerateFunction.c
//        __
//   \\__/ o\    (C) 2012-2014  Robert Finch, Stratford
//    \  __ /    All rights reserved.
***** ..\TABLE888SOURCE\GenerateFunction.C
//        __
//   \\__/ o\    (C) 2012,2013  Robert Finch, Stratford
//    \  __ /    All rights reserved.
*****

***** GenerateFunction.c

    if (sym->IsKernel) {
       regSP = 31;
    }
        throwlab = retlab = contlab = breaklab = -1;
***** ..\TABLE888SOURCE\GenerateFunction.C

        throwlab = retlab = contlab = breaklab = -1;
*****

***** GenerateFunction.c
        }
        if (sym->prolog) {
       if (optimize)
           opt1(sym->prolog);
           GenerateStatement(sym->prolog);
    }
        if (!sym->IsNocall) {
                GenerateTriadic(op_addui,0,makereg(regSP),makereg(regSP),make_immed(-32));
                if (lc_auto || sym->NumParms > 0) {
                        GenerateDiadic(op_sw,0,makereg(regBP),make_indirect(SP));
                }
***** ..\TABLE888SOURCE\GenerateFunction.C
        }
        if (!sym->IsNocall) {
                GenerateTriadic(op_subui,0,makereg(SP),makereg(SP),make_immed(32));
                if (lc_auto || sym->NumParms > 0) {
                        GenerateDiadic(op_ss|op_sw,0,makereg(regBP),make_indirect(SP));
                }
*****

***** GenerateFunction.c
//              if (sym->UsesPredicate)
                        GenerateDiadic(op_sws, 0, make_string("pregs"), make_indexed(24,SP));
                // For a leaf routine don't bother to store the link register or exception link register.
***** ..\TABLE888SOURCE\GenerateFunction.C
//              if (sym->UsesPredicate)
                        GenerateDiadic(op_ss|op_sws, 0, make_string("pregs"), make_indexed(24,SP));
                // For a leaf routine don't bother to store the link register or exception link register.
*****

***** GenerateFunction.c
                        if (exceptions) {
                                GenerateDiadic(op_sws, 0, makebreg(11), make_indexed(8,SP));
                        }
                        GenerateDiadic(op_sws, 0, makebreg(1), make_indexed(16,SP));
                        if (exceptions) {
***** ..\TABLE888SOURCE\GenerateFunction.C
                        if (exceptions) {
                                GenerateDiadic(op_ss|op_sws, 0, makebreg(CLR), make_indexed(8,SP));
                        }
                        GenerateDiadic(op_ss|op_sws, 0, makebreg(LR), make_indexed(16,SP));
                        if (exceptions) {
*****

***** GenerateFunction.c
                                ap = GetTempRegister();
                                GenerateDiadic(op_mfspr,0,ap,makebreg(11));
                                GenerateDiadic(op_mtspr,0,makebreg(1),ap);
                                ReleaseTempRegister(ap);
                                GenerateMonadic(op_br,0,make_clabel(retlab));                           // goto regular return 
cleanup code
***** ..\TABLE888SOURCE\GenerateFunction.C
                                ap = GetTempRegister();
                                GenerateDiadic(op_mfspr,0,ap,makebreg(CLR));
                                GenerateDiadic(op_mtspr,0,makebreg(LR),ap);
                                ReleaseTempRegister(ap);
                                GenerateMonadic(op_bra,0,make_clabel(retlab));                          // goto regular return 
cleanup code
*****

***** GenerateFunction.c
                        GenerateLabel(throwlab);
                        GenerateDiadic(op_lws,0,makebreg(1),make_indexed(8,regBP));             // load throw return address fr
om stack into LR
                        GenerateDiadic(op_sws,0,makebreg(1),make_indexed(16,regBP));            // and store it back (so it can
 be loaded with the lm)
                        GenerateMonadic(op_br,0,make_clabel(retlab));                           // goto regular return cleanup 
code
***** ..\TABLE888SOURCE\GenerateFunction.C
                        GenerateLabel(throwlab);
                        GenerateDiadic(op_lws,0,makebreg(regLR),make_indexed(8,regBP));         // load throw return address fr
om stack into LR
                        GenerateDiadic(op_sws,0,makebreg(regLR),make_indexed(16,regBP));                // and store it back (s
o it can be loaded with the lm)
                        GenerateMonadic(op_bra,0,make_clabel(retlab));                          // goto regular return cleanup 
code
*****

***** GenerateFunction.c
        }
        regSP = 27;
}
***** ..\TABLE888SOURCE\GenerateFunction.C
        }
}
*****

***** GenerateFunction.c

    if (sym->IsKernel)
       regSP = 31;
        // Generate code to evaluate the return expression.
***** ..\TABLE888SOURCE\GenerateFunction.C

        // Generate code to evaluate the return expression.
*****

***** GenerateFunction.c
                                if (bsave_mask & (1 << nn)) {
                                        GenerateDiadic(op_lws,0,makebreg(nn),make_indexed(cnt,SP));
                                        cnt -= 8;
***** ..\TABLE888SOURCE\GenerateFunction.C
                                if (bsave_mask & (1 << nn)) {
                                        GenerateDiadic(op_ss|op_lws,0,makebreg(nn),make_indexed(cnt,SP));
                                        cnt -= 8;
*****

***** GenerateFunction.c
                                if (save_mask & (1 << nn)) {
                                        GenerateDiadic(op_lw,0,makereg(nn),make_indexed(cnt,SP));
                                        cnt -= 8;
***** ..\TABLE888SOURCE\GenerateFunction.C
                                if (save_mask & (1 << nn)) {
                                        GenerateDiadic(op_ss|op_lw,0,makereg(nn),make_indexed(cnt,SP));
                                        cnt -= 8;
*****

***** GenerateFunction.c
                        GenerateDiadic(op_mov,0,makereg(SP),makereg(regBP));
                        GenerateDiadic(op_lw,0,makereg(regBP),make_indirect(regSP));
                }
***** ..\TABLE888SOURCE\GenerateFunction.C
                        GenerateDiadic(op_mov,0,makereg(SP),makereg(regBP));
                        GenerateDiadic(op_ss|op_lw,0,makereg(regBP),make_indirect(regSP));
                }
*****

***** GenerateFunction.c
                        if (exceptions)
                                GenerateDiadic(op_lws,0,makebreg(11),make_indexed(8,regSP));        // 11=CLR
                        GenerateDiadic(op_lws,0,makebreg(1),make_indexed(16,regSP));            // 1 = LR
//                      if (sym->UsesPredicate)
***** ..\TABLE888SOURCE\GenerateFunction.C
                        if (exceptions)
                                GenerateDiadic(op_ss|op_lws,0,makebreg(CLR),make_indexed(8,regSP));
                        GenerateDiadic(op_ss|op_lws,0,makebreg(LR),make_indexed(16,regSP));
//                      if (sym->UsesPredicate)
*****

***** GenerateFunction.c
                }
                GenerateDiadic(op_lws,0,make_string("pregs"),make_indexed(24,regSP));
                    if (sym->epilog) {
               if (optimize)
                  opt1(sym->epilog);
                       GenerateStatement(sym->epilog);
                       return;
           }
                //if (isOscall) {
***** ..\TABLE888SOURCE\GenerateFunction.C
                }
                GenerateDiadic(op_ss|op_lws,0,make_string("pregs"),make_indexed(24,regSP));
                //if (isOscall) {
*****

***** GenerateFunction.c
        else {
                GenerateMonadic(op_br,0,make_clabel(retlab));
        }
        regSP = 27;
}
***** ..\TABLE888SOURCE\GenerateFunction.C
        else {
                GenerateMonadic(op_bra,0,make_clabel(retlab));
        }
}
*****

***** GenerateFunction.c
                return;
        ap = GenerateExpression(ep,F_REG,8);
        if (ap==NULL)
***** ..\TABLE888SOURCE\GenerateFunction.C
                return;
        ap = GenerateExpression(ep,F_REG|F_IMM8,8);
        if (ap==NULL)
*****

***** GenerateFunction.c
        if (ap->mode==am_immed)
                GenerateDiadic(op_sti,0,ap,make_indexed((n-i)*8-8,regSP));
        else
                GenerateDiadic(op_sw,0,ap,make_indexed((n-i)*8-8,regSP));
        ReleaseTempRegister(ap);
***** ..\TABLE888SOURCE\GenerateFunction.C
        if (ap->mode==am_immed)
                GenerateDiadic(op_ss|op_sti,0,ap,make_indexed((n-i)*8-8,SP));
        else
                GenerateDiadic(op_ss|op_sw,0,ap,make_indexed((n-i)*8-8,SP));
        ReleaseTempRegister(ap);
*****

***** GenerateFunction.c
        if (st)
                GenerateTriadic(op_addui,0,makereg(regSP),makereg(regSP),make_immed(-n*8));
        plist = st;
***** ..\TABLE888SOURCE\GenerateFunction.C
        if (st)
                GenerateTriadic(op_subui,0,makereg(regSP),makereg(regSP),make_immed(n*8));
        plist = st;
*****

***** GenerateFunction.c
                ap->mode = am_brind;
                GenerateDiadic(op_jsr,0,makebreg(1),ap);
                ReleaseTempRegister(ap);
***** ..\TABLE888SOURCE\GenerateFunction.C
                ap->mode = am_brind;
                GenerateDiadic(op_jsr,0,makebreg(LR),ap);
                ReleaseTempRegister(ap);
*****

Comparing files GenerateShift.c and ..\TABLE888SOURCE\GenerateShift.C
***** GenerateShift.c
        case op_shr:
                if (isTable888|isFISA64|isThor) {
                        if (ap1->isUnsigned)
***** ..\TABLE888SOURCE\GenerateShift.C
        case op_shr:
                if (isTable888|isFISA64) {
                        if (ap1->isUnsigned)
*****

***** GenerateShift.c
{
        AMODE *ap1, *ap2, *ap3;

    ap3 = GetTempRegister();
    ap1 = GenerateExpression(node->p[0],F_REG,size);
***** ..\TABLE888SOURCE\GenerateShift.C
{
        AMODE *ap1, *ap2;

    ap1 = GenerateExpression(node->p[0],F_REG,size);
*****

***** GenerateShift.c
                case op_shlu:   op = op_shlui; break;
                case op_asr:    op = isThor?op_shri:op_asri; break;
                case op_sra:    op = op_srai; break;
***** ..\TABLE888SOURCE\GenerateShift.C
                case op_shlu:   op = op_shlui; break;
                case op_asr:    op = op_asri; break;
                case op_sra:    op = op_srai; break;
*****

***** GenerateShift.c
                }
                GenerateTriadic(op,0,ap3,ap1,make_immed(ap2->offset->i));
        }
***** ..\TABLE888SOURCE\GenerateShift.C
                }
                GenerateTriadic(op,0,ap1,ap1,make_immed(ap2->offset->i));
        }
*****

***** GenerateShift.c
        else
                GenerateTriadic(op,0,ap3,ap1,ap2);

***** ..\TABLE888SOURCE\GenerateShift.C
        else
                GenerateTriadic(op,0,ap1,ap1,ap2);

*****

***** GenerateShift.c
        ReleaseTempRegister(ap2);
        ReleaseTempRegister(ap1);
    MakeLegalAmode(ap3,flags,size);
    return ap3;
}
***** ..\TABLE888SOURCE\GenerateShift.C
        ReleaseTempRegister(ap2);
    MakeLegalAmode(ap1,flags,size);
    return ap1;
}
*****

Comparing files GenerateStatement.c and ..\TABLE888SOURCE\GenerateStatement.C
***** GenerateStatement.c

extern char *rtrim(char *);

/*
***** ..\TABLE888SOURCE\GenerateStatement.C

/*
*****

***** GenerateStatement.c
char *semaphores[20];
char last_rem[132];

***** ..\TABLE888SOURCE\GenerateStatement.C
char *semaphores[20];

*****

***** GenerateStatement.c

AMODE *makefpreg(int r)
{
***** ..\TABLE888SOURCE\GenerateStatement.C

AMODE *makesreg(int r)
{
*****

***** GenerateStatement.c
    ap = allocAmode();
    ap->mode = am_fpreg;
    ap->preg = r;
    ap->isFloat = TRUE;
    return ap;
***** ..\TABLE888SOURCE\GenerateStatement.C
    ap = allocAmode();
    ap->mode = am_sreg;
    ap->preg = r;
    return ap;
*****

***** GenerateStatement.c

AMODE *makesreg(int r)
{
***** ..\TABLE888SOURCE\GenerateStatement.C

AMODE *makebreg(int r)
{
*****

***** GenerateStatement.c
    ap = allocAmode();
    ap->mode = am_sreg;
    ap->preg = r;
***** ..\TABLE888SOURCE\GenerateStatement.C
    ap = allocAmode();
    ap->mode = am_breg;
    ap->preg = r;
*****

***** GenerateStatement.c

AMODE *makebreg(int r)
{
***** ..\TABLE888SOURCE\GenerateStatement.C

AMODE *makepred(int r)
{
*****

***** GenerateStatement.c
    ap = allocAmode();
    ap->mode = am_breg;
    ap->preg = r;
***** ..\TABLE888SOURCE\GenerateStatement.C
    ap = allocAmode();
    ap->mode = am_predreg;
    ap->preg = r;
*****

***** GenerateStatement.c

AMODE *makepred(int r)
{
***** ..\TABLE888SOURCE\GenerateStatement.C

/*
 *      generate the mask address structure.
 */
AMODE *make_mask(int mask)
{
*****

***** GenerateStatement.c
    ap = allocAmode();
    ap->mode = am_predreg;
    ap->preg = r;
    return ap;
***** ..\TABLE888SOURCE\GenerateStatement.C
    ap = allocAmode();
    ap->mode = am_mask;
    ap->offset = (ENODE *)mask;
    return ap;
*****

***** GenerateStatement.c
/*
 *      generate the mask address structure.
 */
AMODE *make_mask(int mask)
{
        AMODE *ap;
    ap = allocAmode();
    ap->mode = am_mask;
    ap->offset = (ENODE *)mask;
    return ap;
}
***** ..\TABLE888SOURCE\GenerateStatement.C
/*
 *      make a direct reference to an immediate value.
 */
AMODE *make_direct(int64_t i)
{
        return make_offset(makeinode(en_icon,i));
}
*****

***** GenerateStatement.c
/*
 *      make a direct reference to an immediate value.
 */
AMODE *make_direct(int64_t i)
{
        return make_offset(makeinode(en_icon,i));
}

/*
 *      generate a direct reference to a string label.
***** ..\TABLE888SOURCE\GenerateStatement.C
/*
 *      generate a direct reference to a string label.
*****

***** GenerateStatement.c

void GenMixedSource(Statement *stmt)
{
    if (mixedSource) {
        rtrim(stmt->lptr);
        if (strcmp(stmt->lptr,last_rem)!=0) {
                GenerateMonadic(op_rem,0,make_string(stmt->lptr));
                strncpy(last_rem,stmt->lptr,131);
                last_rem[131] = '\0';
        }
    }
}

/*
***** ..\TABLE888SOURCE\GenerateStatement.C

/*
*****

***** GenerateStatement.c
                GenerateStatement(stmt->s1);
                GenerateMonadic(isThor ? op_br:op_bra,0,make_clabel(contlab));
                GenerateLabel(breaklab);
***** ..\TABLE888SOURCE\GenerateStatement.C
                GenerateStatement(stmt->s1);
                GenerateMonadic(op_bra,0,make_clabel(contlab));
                GenerateLabel(breaklab);
*****

***** GenerateStatement.c
            GenerateStatement(stmt->s1);
            GenerateMonadic(isThor ? op_br:op_bra,0,make_clabel(contlab));
            GenerateLabel(breaklab);
***** ..\TABLE888SOURCE\GenerateStatement.C
            GenerateStatement(stmt->s1);
            GenerateMonadic(op_bra,0,make_clabel(contlab));
            GenerateLabel(breaklab);
*****

***** GenerateStatement.c
            ReleaseTempRegister(GenerateExpression(stmt->incrExpr,F_ALL | F_NOVALUE,GetNaturalSize(stmt->incrExpr)));
    GenerateMonadic(isThor ? op_br:op_bra,0,make_clabel(loop_label));
    breaklab = old_break;
***** ..\TABLE888SOURCE\GenerateStatement.C
            ReleaseTempRegister(GenerateExpression(stmt->incrExpr,F_ALL | F_NOVALUE,GetNaturalSize(stmt->incrExpr)));
    GenerateMonadic(op_bra,0,make_clabel(loop_label));
    breaklab = old_break;
*****

***** GenerateStatement.c
        }
    GenerateMonadic(isThor ? op_br:op_bra,0,make_clabel(loop_label));
    breaklab = old_break;
***** ..\TABLE888SOURCE\GenerateStatement.C
        }
    GenerateMonadic(op_bra,0,make_clabel(loop_label));
    breaklab = old_break;
*****

***** GenerateStatement.c
    {
        GenerateDiadic(isThor ? op_br:op_bra,0,make_clabel(lab2),0);
        if (mixedSource)
                GenerateMonadic(op_rem,0,make_string("; else"));
        GenerateLabel(lab1);
***** ..\TABLE888SOURCE\GenerateStatement.C
    {
        GenerateDiadic(op_bra,0,make_clabel(lab2),0);
        GenerateLabel(lab1);
*****

***** GenerateStatement.c
                }
        ap = GenerateExpression(stmt->exp,F_REG,GetNaturalSize(stmt->exp));
//        if( ap->preg != 0 )
***** ..\TABLE888SOURCE\GenerateStatement.C
                }
        ap = GenerateExpression(stmt->exp,F_REG,4);
//        if( ap->preg != 0 )
*****

***** GenerateStatement.c
                                                GenerateTriadic(op_cmp,0,makepred(predreg),ap,make_immed(bf[nn]));
                                                GeneratePredicatedMonadic(predreg,PredOp(op_eq),op_br,0,make_clabel(curlab));
                                        }
***** ..\TABLE888SOURCE\GenerateStatement.C
                                                GenerateTriadic(op_cmp,0,makepred(predreg),ap,make_immed(bf[nn]));
                                                GeneratePredicatedMonadic(predreg,PredOp(op_eq),op_bra,0,make_clabel(curlab));
                                        }
*****

***** GenerateStatement.c
        if( defcase == NULL )
            GenerateMonadic(isThor ? op_br : op_bra,0,make_clabel(breaklab));
        else
                        GenerateMonadic(isThor ? op_br : op_bra,0,make_clabel((int64_t)defcase->label));
    ReleaseTempRegister(ap);
***** ..\TABLE888SOURCE\GenerateStatement.C
        if( defcase == NULL )
            GenerateMonadic(op_bra,0,make_clabel(breaklab));
        else
                        GenerateMonadic(op_bra,0,make_clabel((int64_t)defcase->label));
    ReleaseTempRegister(ap);
*****

***** GenerateStatement.c
        char buf[20];
        AMODE *ap, *a, *ap2;
        ENODE *node;
        SYM *sym;
***** ..\TABLE888SOURCE\GenerateStatement.C
        char buf[20];
        AMODE *ap, *a;
        SYM *sym;
*****

***** GenerateStatement.c
    else
                GenerateDiadic(op_ldi,0,makebreg(CLR),make_clabel(throwlab));
        GenerateStatement(stmt->s1);
    GenerateMonadic(isThor?op_br:op_bra,0,make_clabel(lab1));
        GenerateLabel(throwlab);
***** ..\TABLE888SOURCE\GenerateStatement.C
    else
                GenerateDiadic(op_lea,0,makebreg(CLR),make_clabel(throwlab));
        GenerateStatement(stmt->s1);
    GenerateMonadic(op_bra,0,make_clabel(lab1));
        GenerateLabel(throwlab);
*****

***** GenerateStatement.c
        stmt = stmt->s2;
        // Generate catch statements
        // r1 holds the value to be assigned to the catch variable
        // r2 holds the type number
        while (stmt) {
        GenMixedSource(stmt);
                throwlab = oldthrow;
***** ..\TABLE888SOURCE\GenerateStatement.C
        stmt = stmt->s2;
        while (stmt) {
                throwlab = oldthrow;
*****

***** GenerateStatement.c
                                // ToDo: fix Thor
                                GenerateTriadic(op_cmpi, 0, make_string("p0"), makereg(2), make_immed((int64_t)stmt->s2));
                GeneratePredicatedMonadic(0,PredOp(op_ne),op_br,0,make_clabel(nextlabel));
                        }
***** ..\TABLE888SOURCE\GenerateStatement.C
                                // ToDo: fix Thor
                                GenerateTriadic(op_cmp, 0, make_string("p0"), makereg(2), make_immed((int64_t)stmt->s2));
                                GenerateDiadic(op_bne, 0, make_string("p0"), make_clabel(nextlabel));
                        }
*****

***** GenerateStatement.c
                // move the throw expression result in 'r1' into the catch variable.
                node = (ENODE *)stmt->label;
        {
            ap2 = GenerateExpression(node,F_REG|F_MEM,GetNaturalSize(node));
            if (ap2->mode==am_reg)
               GenerateDiadic(op_mov,0,ap2,makereg(1));
            else
               GenStore(makereg(1),ap2,GetNaturalSize(node));
            ReleaseTempRegister(ap2);
        }
//            GenStore(makereg(1),make_indexed(sym->value.i,regBP),sym->tp->size);
                GenerateStatement(stmt->s1);
***** ..\TABLE888SOURCE\GenerateStatement.C
                // move the throw expression result in 'r1' into the catch variable.
                sym = (SYM *)stmt->label;
                if (sym)
            GenStore(makereg(1),make_indexed(sym->value.i,regBP),sym->tp->size);
                GenerateStatement(stmt->s1);
*****

***** GenerateStatement.c
        else
                GenerateDiadic(op_ldi,0,makebreg(CLR),make_clabel(oldthrow));
}
***** ..\TABLE888SOURCE\GenerateStatement.C
        else
                GenerateDiadic(op_lea,0,makebreg(CLR),make_clabel(oldthrow));
}
*****

***** GenerateStatement.c
        }
        GenerateMonadic(isThor?op_br:op_bra,0,make_clabel(throwlab));
}

void GenerateCheck(Statement * stmt)
{
     AMODE *ap1, *ap2, *ap3, *ap4;
     ENODE *node, *ep;
     int size;

    initstack();
    ep = node = stmt->exp;
        if (ep->p[0]->nodetype==en_lt && ep->p[1]->nodetype==en_ge && equalnode(ep->p[0]->p[0],ep->p[1]->p[0])) {
        ep->nodetype = en_chk;
        if (ep->p[0])
            ep->p[2] = ep->p[0]->p[1];
        else
            ep->p[2] = NULL;
        ep->p[1] = ep->p[1]->p[1];
        ep->p[0] = ep->p[0]->p[0];
    }
        else if (ep->p[0]->nodetype==en_ge && ep->p[1]->nodetype==en_lt && equalnode(ep->p[0]->p[0],ep->p[1]->p[0])) {
       ep->nodetype = en_chk;
        if (ep->p[1])
            ep->p[2] = ep->p[1]->p[1];
        else
            ep->p[2] = NULL;
        ep->p[1] = ep->p[0]->p[1];
        ep->p[0] = ep->p[0]->p[0];
    }
    if (ep->nodetype != en_chk) {
         error(ERR_CHECK);
         return;
    }
        size = GetNaturalSize(node);
        ap1 = GenerateExpression(node->p[0],F_REG,size);
        ap2 = GenerateExpression(node->p[1],F_REG|F_IMM0,size);
    ap3 = GenerateExpression(node->p[2],F_REG|F_IMMED,size);
        if (ap2->mode == am_immed) {
           ap2->mode = am_reg;
           ap2->preg = 0;
    }
        GenerateTriadic(op_chk,0,ap1,ap2,ap3);
    ReleaseTempRegister(ap3);
    ReleaseTempRegister(ap2);
    ReleaseTempRegister(ap1);
}

***** ..\TABLE888SOURCE\GenerateStatement.C
        }
        GenerateMonadic(op_bra,0,make_clabel(throwlab));
}
/*
void GenerateCritical(struct snode *stmt)
{
        int lab1;

        lab1 = nextlabel++;
        semaphores[lastsph] = stmt->label;
        lastsph++;
    GenerateLabel(lab1);
        GenerateDiadic(op_tas,0,make_string(stmt->label),NULL);
        GenerateDiadic(op_bmi,0,make_label(lab1),NULL);
        GenerateStatement(stmt->s1);
        --lastsph;
        semaphores[lastsph] = NULL;
        GenerateDiadic(op_move,0,make_immed(0),make_string(stmt->label));
}
*/

*****

***** GenerateStatement.c
        AMODE *ap;
        int sp = 0;

***** ..\TABLE888SOURCE\GenerateStatement.C
        AMODE *ap;

*****

***** GenerateStatement.c
                ap = GenerateExpression(stmt->exp,F_REG,8);
                GenerateDiadic(op_mov,0,makereg(1),ap);
                if (stmt->initExpr) {
***** ..\TABLE888SOURCE\GenerateStatement.C
                ap = GenerateExpression(stmt->exp,F_REG,8);
                if (stmt->initExpr) {
*****

***** GenerateStatement.c
            if (isFISA64)
                FISA64_GenLdi(makereg(2),make_immed((int64_t)stmt->initExpr));
            else
                            GenerateTriadic(op_ori, 0, makereg(2),makereg(0),make_immed((int64_t)stmt->initExpr));
        }
        else {
            GenerateDiadic(op_ldi,0,makereg(2),make_immed(-1));
        }
        GenerateMonadic(op_bsr,0,make_string("_LockSema"));
        if (stmt->initExpr)
            GenerateDiadic(op_beq,0,makereg(1),make_clabel(lab2));
                ReleaseTempRegister(ap);
                ReleaseTempRegister(ap2);
                ReleaseTempRegister(ap1);
        // We treat this statement generation like a function call and save
        // the used temporary beforehand.  The statement might reinitialize
        // the expression vars. There aren't any other cases where temporaries
        // are needed after statements are generated.
        GenerateMonadic(op_push,0,ap);
                GenerateStatement(stmt->s1);
        GenerateMonadic(op_pop,0,ap);
                // unlock
***** ..\TABLE888SOURCE\GenerateStatement.C
            if (isFISA64)
                FISA64_GenLdi(ap1,make_immed((int64_t)stmt->initExpr));
            else
                            GenerateTriadic(op_ori, 0, ap1,makereg(0),make_immed((int64_t)stmt->initExpr));
        }
                GenerateLabel(lab1);
                if (stmt->initExpr) {
                        // Decrement timeout
                        GenerateTriadic(op_sub, 0, ap1, ap1, make_immed(1));
                        if (isFISA64)
                                GenerateDiadic(op_beq, 0, ap1, make_label(lab2));
                        else if (isTable888)
                                GenerateDiadic(op_brz, 0, ap1, make_label(lab2));
                        else if (isRaptor64)
                                GenerateTriadic(op_beq, 0, ap1, makereg(0), make_label(lab2));
                        // ToDo: finish for Thor
                        else
                                ;
                }
                if (isRaptor64) {
                        GenerateDiadic(op_inbu, 0, ap2, make_indexed((int64_t)stmt->incrExpr,ap->preg));
                        GenerateTriadic(op_beq, 0, ap2, makereg(0), make_label(lab1));
                }
                else if (isFISA64) {
                        GenerateDiadic(op_lbu, 0, ap2, make_indexed((int64_t)stmt->incrExpr,ap->preg));
                        GenerateDiadic(op_beq, 0, ap2, make_label(lab1));
                }
                else if (isTable888) {
                        GenerateDiadic(op_lbu, 0, ap2, make_indexed((int64_t)stmt->incrExpr,ap->preg));
                        GenerateDiadic(op_brz, 0, ap2, make_label(lab1));
                }
                // ToDo: finish for Thor
                else {
                        GenerateDiadic(op_lbu, 0, ap2, make_indexed((int64_t)stmt->incrExpr,ap->preg));
                }
                GenerateStatement(stmt->s1);
                // unlock
*****

***** GenerateStatement.c
                        GenerateDiadic(op_outb, 0, makereg(0), make_indexed((int64_t)stmt->incrExpr,ap->preg));
                else if (isFISA64) {
            GenerateDiadic(op_mov, 0, makereg(1), makereg(ap->preg));
            GenerateMonadic(op_bsr, 0, make_string("_UnlockSema"));
        }
                else
                        GenerateDiadic(op_sw, 0, makereg(0), make_indexed((int64_t)stmt->incrExpr,ap->preg));
                if (stmt->initExpr) {
                        GenerateMonadic(isThor?op_br:op_bra,0,make_clabel(lab3));
                        GenerateLabel(lab2);
***** ..\TABLE888SOURCE\GenerateStatement.C
                        GenerateDiadic(op_outb, 0, makereg(0), make_indexed((int64_t)stmt->incrExpr,ap->preg));
                else
                        GenerateDiadic(op_sb, 0, makereg(0), make_indexed((int64_t)stmt->incrExpr,ap->preg));
                if (stmt->initExpr) {
                        GenerateMonadic(op_bra,0,make_clabel(lab3));
                        GenerateLabel(lab2);
*****

***** GenerateStatement.c
                }
        }
***** ..\TABLE888SOURCE\GenerateStatement.C
                }
                ReleaseTempRegister(ap);
                ReleaseTempRegister(ap2);
                ReleaseTempRegister(ap1);
        }
*****

***** GenerateStatement.c
                                GenerateDiadic(op_outb, 0, makereg(0),make_indexed((int64_t)stmt->incrExpr,1));
                else if (isFISA64) {
                GenerateMonadic(op_bsr, 0, make_string("_UnlockSema"));
            }
                        else
***** ..\TABLE888SOURCE\GenerateStatement.C
                                GenerateDiadic(op_outb, 0, makereg(0),make_indexed((int64_t)stmt->incrExpr,1));
                        else
*****

***** GenerateStatement.c

//    if (stmt->prolog)
//        GenerateStatement(stmt->prolog);
        sp = stmt->ssyms.head;
***** ..\TABLE888SOURCE\GenerateStatement.C

        sp = stmt->ssyms.head;
*****

***** GenerateStatement.c
        while (sp) {
                if (sp->initexp) {
                initstack();
                        ReleaseTempRegister(GenerateExpression(sp->initexp,F_ALL,8));
        }
                sp = sp->next;
***** ..\TABLE888SOURCE\GenerateStatement.C
        while (sp) {
                if (sp->initexp)
                        ReleaseTempRegister(GenerateExpression(sp->initexp,F_ALL,8));
                sp = sp->next;
*****

***** GenerateStatement.c
        GenerateStatement(stmt->s1);
//    if (stmt->epilog)
//        GenerateStatement(stmt->epilog);
}
***** ..\TABLE888SOURCE\GenerateStatement.C
        GenerateStatement(stmt->s1);
}
*****

***** GenerateStatement.c

// The same as generating a compound statement but leaves out the generation of
// the prolog and epilog clauses.
void GenerateFuncbody(Statement *stmt)
{
        Statement *st;
        SYM *sp;

        sp = stmt->ssyms.head;
        while (sp) {
                if (sp->initexp) {
                initstack();
                        ReleaseTempRegister(GenerateExpression(sp->initexp,F_ALL,8));
        }
                sp = sp->next;
        }
        // Generate statement will process the entire list of statements in
        // the block.
        GenerateStatement(stmt->s1);
}

/*
***** ..\TABLE888SOURCE\GenerateStatement.C

/*
*****

***** GenerateStatement.c
        AMODE *ap;
 
        while( stmt != NULL )
***** ..\TABLE888SOURCE\GenerateStatement.C
        AMODE *ap;

        while( stmt != NULL )
*****

***** GenerateStatement.c
    {
        GenMixedSource(stmt);
        switch( stmt->stype )
***** ..\TABLE888SOURCE\GenerateStatement.C
    {
        switch( stmt->stype )
*****

***** GenerateStatement.c
                                //              break;
                    case st_funcbody:
                        GenerateFuncbody(stmt);
                        break;
                                case st_compound:
***** ..\TABLE888SOURCE\GenerateStatement.C
                                //              break;
                                case st_compound:
*****

***** GenerateStatement.c
                case st_goto:
                        GenerateMonadic(isThor?op_br:op_bra,0,make_clabel((int64_t)stmt->label));
                        break;
***** ..\TABLE888SOURCE\GenerateStatement.C
                case st_goto:
                        GenerateMonadic(op_bra,0,make_clabel((int64_t)stmt->label));
                        break;
*****

***** GenerateStatement.c
                                                break;
                                case st_check:
                        GenerateCheck(stmt);
                        break;
                case st_expr:
***** ..\TABLE888SOURCE\GenerateStatement.C
                                                break;
                case st_expr:
*****

***** GenerateStatement.c
                                                ReleaseTempRegister(ap);
                                                tmpFreeAll();
                        break;
***** ..\TABLE888SOURCE\GenerateStatement.C
                                                ReleaseTempRegister(ap);
                        break;
*****

***** GenerateStatement.c
                                                        error(ERR_NOT_IN_LOOP);
                        GenerateDiadic(isThor?op_br:op_bra,0,make_clabel(contlab),0);
                        break;
***** ..\TABLE888SOURCE\GenerateStatement.C
                                                        error(ERR_NOT_IN_LOOP);
                        GenerateDiadic(op_bra,0,make_clabel(contlab),0);
                        break;
*****

***** GenerateStatement.c
                                                        error(ERR_NOT_IN_LOOP);
                        GenerateDiadic(isThor?op_br:op_bra,0,make_clabel(breaklab),0);
                        break;
***** ..\TABLE888SOURCE\GenerateStatement.C
                                                        error(ERR_NOT_IN_LOOP);
                        GenerateDiadic(op_bra,0,make_clabel(breaklab),0);
                        break;
*****

***** GenerateStatement.c
{
        int     lab1, lab2;
        char buf[20];
***** ..\TABLE888SOURCE\GenerateStatement.C
{
        int     lab1, lab2, lab3,lab4,lab5,lab6,lab7;
        char buf[20];
*****

***** GenerateStatement.c
    contlab = nextlabel++;  /* new continue label */
    if( stmt->s1 != NULL )      /* has block */
***** ..\TABLE888SOURCE\GenerateStatement.C
    contlab = nextlabel++;  /* new continue label */
        lab3 = nextlabel++;
        lab4 = nextlabel++;
        lab5 = nextlabel++;
        lab6 = nextlabel++;
        lab7 = nextlabel++;
    if( stmt->s1 != NULL )      /* has block */
*****

***** GenerateStatement.c
        breaklab = nextlabel++;
                ap1 = GetTempRegister();
                GenerateDiadic(op_lb,0,ap1,make_string(stmt->fcname));
                if (isThor) {
            GenerateDiadic(op_tst,0,make_string("p0"), ap1);
                GeneratePredicatedMonadic(0,PredOp(op_eq),op_br,0,make_clabel(breaklab));
        }
        else
                GenerateDiadic(op_beq,0,ap1,make_clabel(breaklab));
                ReleaseTempRegister(ap1);
                GenerateDiadic(op_sb,0,makereg(0),make_string(stmt->fcname));
                GenerateStatement(stmt->s1);
***** ..\TABLE888SOURCE\GenerateStatement.C
        breaklab = nextlabel++;
        GenerateLabel(lab3);    // marks address of brf
        GenerateMonadic(op_bra,0,make_clabel(lab7));    // branch to the firstcall statement
        GenerateLabel(lab6);    // prevent optimizer from optimizing move away
                GenerateMonadic(op_bra,0,make_clabel(breaklab));        // then branch around it
        GenerateLabel(lab7);    // prevent optimizer from optimizing move away
                ap1 = GetTempRegister();
                ap2 = GetTempRegister();
                GenerateDiadic(op_lea,0,ap2,make_label(lab3));
                GenerateTriadic(op_andi,0,ap2,ap2,make_immed(0x0c));
                GenerateTriadic(op_beqi,0,ap2,make_immed(0x08L),make_label(lab4));
                GenerateTriadic(op_beqi,0,ap2,make_immed(0x04L),make_label(lab5));
                GenerateDiadic(op_lea,0,ap2,make_label(lab3));
                GenerateDiadic(op_lw,0,ap1,make_indirect(ap2->preg));
                GenerateTriadic(op_andi,0,ap1,ap1,make_immed(0xFFFFFC0000000000L));
                GenerateTriadic(op_ori,0,ap1,ap1,make_immed(0x000037800000000L));       // nop instruction
                GenerateDiadic(op_sw,0,ap1,make_indirect(ap2->preg));
                GenerateDiadic(op_cache,0,make_string("invil"),make_indirect(ap2->preg));
                GenerateMonadic(op_bra,0,make_label(lab6));
                GenerateLabel(lab4);
                GenerateDiadic(op_lea,0,ap2,make_label(lab3));
                GenerateDiadic(op_lw,0,ap1,make_indirect(ap2->preg));
                GenerateTriadic(op_andi,0,ap1,ap1,make_immed(0x00000000000FFFFFL));
                GenerateTriadic(op_ori,0,ap1,ap1,make_immed(0x3780000000000000L));      // nop instruction
                GenerateDiadic(op_sw,0,ap1,make_indirect(ap2->preg));
                GenerateDiadic(op_cache,0,make_string("invil"),make_indirect(ap2->preg));
                GenerateMonadic(op_bra,0,make_label(lab6));
                GenerateLabel(lab5);
                GenerateDiadic(op_lea,0,ap2,make_label(lab3));
                GenerateDiadic(op_lw,0,ap1,make_indexed(4,ap2->preg));
                GenerateTriadic(op_andi,0,ap1,ap1,make_immed(0xFFFFFFFFFFF00000L));
                GenerateTriadic(op_ori,0,ap1,ap1,make_immed(0x00000000000DE000L));      // nop instruction
                GenerateDiadic(op_sw,0,ap1,make_indexed(4,ap2->preg));
                GenerateDiadic(op_cache,0,make_string("invil"),make_indexed(4,ap2->preg));
                GenerateLabel(lab6);
                GenerateStatement(stmt->s1);
*****

Comparing files GenerateTable888Function.c and ..\TABLE888SOURCE\GenerateTable888Function.C
Comparing files IdentifyKeyword.c and ..\TABLE888SOURCE\IdentifyKeyword.C
***** IdentifyKeyword.c
{
        char *p = lastkw;

        if (p[0]=='i') { // if,int,inton,intoff,interrupt,icache,inline,inout
                if (p[1]=='f' && p[2]=='\0')
***** ..\TABLE888SOURCE\IdentifyKeyword.C
{
        char *p = lastid;

        if (p[0]=='i') { // if,int,inton,intoff,interrupt,icache
                if (p[1]=='f' && p[2]=='\0')
*****

***** IdentifyKeyword.c
                        return lastst = kw_icache;
                if (p[1]=='n' && p[2]=='l' && p[3]=='i' && p[4]=='n' && p[5]=='e' && p[6]=='\0')
                        return lastst = kw_inline;
                if (p[1]=='n' && p[2]=='o' && p[3]=='u' && p[4]=='t' && p[5]=='\0')
                        return lastst = kw_inout;
        }
***** ..\TABLE888SOURCE\IdentifyKeyword.C
                        return lastst = kw_icache;
        }
*****

***** IdentifyKeyword.c

        if (p[0]=='e') {        // else,enum,extern,epilog
                if (p[1]=='l' && p[2]=='s' && p[3]=='e' && p[4]=='\0')
***** ..\TABLE888SOURCE\IdentifyKeyword.C

        if (p[0]=='e') {        // else,enum,extern
                if (p[1]=='l' && p[2]=='s' && p[3]=='e' && p[4]=='\0')
*****

***** IdentifyKeyword.c
                        return lastst = kw_extern;
                if (p[1]=='p' && p[2]=='i' && p[3]=='l' && p[4]=='o' && p[5]=='g' && p[6]=='\0')
                        return lastst = kw_epilog;
        }
        if (p[0]=='a') {        // and,asm,align
                if (p[1]=='n' && p[2]=='d' && p[3]=='\0')
***** ..\TABLE888SOURCE\IdentifyKeyword.C
                        return lastst = kw_extern;
        }
        if (p[0]=='a') {        // and,asm
                if (p[1]=='n' && p[2]=='d' && p[3]=='\0')
*****

***** IdentifyKeyword.c
                        return lastst = kw_asm;
                if (p[1]=='l' && p[2]=='i' && p[3]=='g' && p[4]=='n' && p[5]=='\0')
                        return lastst = kw_align;
        }
***** ..\TABLE888SOURCE\IdentifyKeyword.C
                        return lastst = kw_asm;
        }
*****

***** IdentifyKeyword.c

        if (p[0]=='p') {        // private,public,pascal,prolog
                if (p[1]=='r' && p[2]=='i' && p[3]=='v' && p[4]=='a' && p[5]=='t' && p[6]=='e' && p[7]=='\0')
***** ..\TABLE888SOURCE\IdentifyKeyword.C

        if (p[0]=='p') {        // private,public,pascal
                if (p[1]=='r' && p[2]=='i' && p[3]=='v' && p[4]=='a' && p[5]=='t' && p[6]=='e' && p[7]=='\0')
*****

***** IdentifyKeyword.c
                        return lastst = kw_pascal;
                if (p[1]=='r' && p[2]=='o' && p[3]=='l' && p[4]=='o' && p[5]=='g' && p[6]=='\0')
                        return lastst = kw_prolog;
        }
***** ..\TABLE888SOURCE\IdentifyKeyword.C
                        return lastst = kw_pascal;
        }
*****

***** IdentifyKeyword.c
        }
        // kernel
        if (p[0]=='k') {
        if (p[1]=='e' && p[2]=='r' && p[3]=='n' && p[4]=='e' && p[5]=='l' && p[6]=='\0')
            return lastst = kw_kernel;
    }
        // spinlock,spinunlock
***** ..\TABLE888SOURCE\IdentifyKeyword.C
        }
        // spinlock,spinunlock
*****

***** IdentifyKeyword.c

        // triple true
        if (p[0]=='t' && p[1]=='r' && p[2]=='u' && p[3]=='e' && p[4]=='\0') {
***** ..\TABLE888SOURCE\IdentifyKeyword.C

        // true
        if (p[0]=='t' && p[1]=='r' && p[2]=='u' && p[3]=='e' && p[4]=='\0') {
*****

***** IdentifyKeyword.c
        }
        if (p[0]=='t' && p[1]=='r' && p[2]=='i' && p[3]=='p' && p[4]=='l' && p[5]=='e' && p[6]=='\0') {
                return lastst = kw_triple;
        }


        // __cdecl,__asm,__int64,__int32,__int16,__int8,__check,__exception,__task,__unordered
        if (p[0]=='_' && p[1]=='_') {
***** ..\TABLE888SOURCE\IdentifyKeyword.C
        }

        // __cdecl,__asm,__int64,__int32,__int16,__int8
        if (p[0]=='_' && p[1]=='_') {
*****

***** IdentifyKeyword.c
                }
                if (p[2]=='c' && p[3]=='h' && p[4]=='e' && p[5]=='c' && p[6]=='k' && p[7]=='\0')
                        return lastst = kw_check;
                if (p[2]=='e' && p[3]=='x' && p[4]=='c' && p[5]=='e' && p[6]=='p' && p[7]=='t' && p[8]=='i' && p[9]=='o' && p[1
0]=='n' && p[11]=='\0')
                        return lastst = kw_exception;
                if (p[2]=='t' && p[3]=='a' && p[4]=='s' && p[5]=='k' && p[6]=='\0')
                        return lastst = kw_task;
                if (p[2]=='u' && p[3]=='n' && p[4]=='o' && p[5]=='r' && p[6]=='d' && p[7]=='e' && p[8]=='r' && p[9]=='e' && p[1
0]=='d' && p[11]=='\0')
                        return lastst = kw_unordered;
        }
***** ..\TABLE888SOURCE\IdentifyKeyword.C
                }
        }
*****

Comparing files Initializers.c and ..\TABLE888SOURCE\Initializers.C
***** Initializers.c
//        __
//   \\__/ o\    (C) 2012-2015  Robert Finch, Stratford
//    \  __ /    All rights reserved.
***** ..\TABLE888SOURCE\Initializers.C
//        __
//   \\__/ o\    (C) 2012,2013  Robert Finch, Stratford
//    \  __ /    All rights reserved.
*****

***** Initializers.c
#include "cglbdec.h"

extern int catchdecl;

/*
***** ..\TABLE888SOURCE\Initializers.C
#include "cglbdec.h"
/*
*****

***** Initializers.c
        char lbl[200];
    int algn;
    enum e_sg oseg;
 
    oseg = noseg;
        lbl[0] = 0;
        // Initialize constants into read-only data segment. Constants may be placed
        // in ROM along with code.
        if (sp->isConst) {
        oseg = rodataseg;
    }
        if (sp->storage_class == sc_thread) {
        if (sp->tp->type==bt_struct || sp->tp->type==bt_union)
           algn = imax(sp->tp->alignment,8);
        else if (sp->tp->type==bt_pointer && sp->tp->val_flag)
           algn = imax(sp->tp->btp->alignment,8);
        else
            algn = 8;
                seg(oseg==noseg ? tlsseg : oseg,algn);
                nl();
***** ..\TABLE888SOURCE\Initializers.C
        char lbl[200];

        lbl[0] = 0;
        if (sp->storage_class == sc_thread) {
                seg(tlsseg);
                nl();
*****

***** Initializers.c
        else if (sp->storage_class == sc_static || lastst==assign) {
        if (sp->tp->type==bt_struct || sp->tp->type==bt_union)
           algn = imax(sp->tp->alignment,8);
        else if (sp->tp->type==bt_pointer && sp->tp->val_flag)
           algn = imax(sp->tp->btp->alignment,8);
        else
            algn = 8;
                seg(oseg==noseg ? dataseg : oseg,algn);          /* initialize into data segment */
                nl();                   /* start a new line in object */
***** ..\TABLE888SOURCE\Initializers.C
        else if (sp->storage_class == sc_static || lastst==assign) {
                seg(dataseg);          /* initialize into data segment */
                nl();                   /* start a new line in object */
*****

***** Initializers.c
        else {
        if (sp->tp->type==bt_struct || sp->tp->type==bt_union)
           algn = imax(sp->tp->alignment,8);
        else if (sp->tp->type==bt_pointer && sp->tp->val_flag)
           algn = imax(sp->tp->btp->alignment,8);
        else
            algn = 8;
                seg(oseg==noseg ? bssseg : oseg,algn);            /* initialize into data segment */
                nl();                   /* start a new line in object */
***** ..\TABLE888SOURCE\Initializers.C
        else {
                seg(bssseg);            /* initialize into data segment */
                nl();                   /* start a new line in object */
*****

***** Initializers.c
        if(sp->storage_class == sc_static || sp->storage_class == sc_thread) {
                sp->realname = litlate(put_label(sp->value.i, sp->name, GetNamespace(), 'D'));
        }
***** ..\TABLE888SOURCE\Initializers.C
        if(sp->storage_class == sc_static || sp->storage_class == sc_thread) {
                put_label(sp->value.i, sp->name, GetNamespace(), 'D');
        }
*****

***** Initializers.c
                strcat(lbl, sp->name);
                gen_strlab(lbl);
        }
        if (lastst == kw_firstcall) {
        GenerateByte(1);
        return;
    }
        else if( lastst != assign) {
                genstorage(sp->tp->size);
***** ..\TABLE888SOURCE\Initializers.C
                strcat(lbl, sp->name);
                //gen_strlab(lbl);
        }
        if( lastst != assign) {
                genstorage(sp->tp->size);
*****

***** Initializers.c
            break;
    case bt_exception:
        case bt_ulong:
***** ..\TABLE888SOURCE\Initializers.C
            break;
        case bt_ulong:
*****

***** Initializers.c
                lng = GetIntegerExpression(&n);
                if (n && n->nodetype == en_cnacon) {
                        if (n->sp) {
***** ..\TABLE888SOURCE\Initializers.C
                lng = GetIntegerExpression(&n);
                if (n->nodetype == en_cnacon) {
                        if (n->sp) {
*****

***** Initializers.c
                }
                else {
                        GenerateLong(lng);
***** ..\TABLE888SOURCE\Initializers.C
                }
                else
                        GenerateLong(lng);
*****

***** Initializers.c
        }
        }
    endinit();
***** ..\TABLE888SOURCE\Initializers.C
        }
    endinit();
*****

***** Initializers.c
{    
    if (catchdecl) {
        if (lastst!=closepa)
                        error(ERR_PUNCT);
    }
    else if( lastst != comma && lastst != semicolon && lastst != end) {
                error(ERR_PUNCT);
***** ..\TABLE888SOURCE\Initializers.C
{    
        if( lastst != comma && lastst != semicolon && lastst != end) {
                error(ERR_PUNCT);
*****

Comparing files Intexpr.c and ..\TABLE888SOURCE\Intexpr.C
***** Intexpr.c
//        __
//   \\__/ o\    (C) 2012-2015  Robert Finch, Stratford
//    \  __ /    All rights reserved.
***** ..\TABLE888SOURCE\Intexpr.C
//        __
//   \\__/ o\    (C) 2012-2014  Robert Finch, Stratford
//    \  __ /    All rights reserved.
*****

***** Intexpr.c
//
#include "stdafx.h"

__int64 clsParser::GetIntegerExpression(clsEnode **pnode)       // simple integer value
{ 
        clsType *tp;
        clsEnode *node;

        tp = parser.NonCommaExpression(&node);
        if (node==NULL) {
***** ..\TABLE888SOURCE\Intexpr.C
//
#include <stdio.h>
#include "c.h"
#include "expr.h"
#include "gen.h"
#include "cglbdec.h"

int64_t GetIntegerExpression(ENODE **pnode)       /* simple integer value */
{ 
        TYP *tp;
        ENODE *node;

        tp = NonCommaExpression(&node);
        if (node==NULL) {
*****

***** Intexpr.c
        if (node==NULL) {
                err.fatal("Compiler Error: GetIntegerExpression: node is NULL");
                return 0;
***** ..\TABLE888SOURCE\Intexpr.C
        if (node==NULL) {
                fatal("Compiler Error: GetIntegerExpression: node is NULL");
                return 0;
*****

***** Intexpr.c
        if (node->nodetype != en_icon && node->nodetype != en_cnacon) {
                err.error(ERR_INT_CONST);
                return 0;
***** ..\TABLE888SOURCE\Intexpr.C
        if (node->nodetype != en_icon && node->nodetype != en_cnacon) {
                error(ERR_INT_CONST);
                return 0;
*****

Comparing files List.c and ..\TABLE888SOURCE\List.C
***** List.c
//        __
//   \\__/ o\    (C) 2012-2015  Robert Finch, Stratford
//    \  __ /    All rights reserved.
***** ..\TABLE888SOURCE\List.C
//        __
//   \\__/ o\    (C) 2012-2014  Robert Finch, Stratford
//    \  __ /    All rights reserved.
*****

Comparing files LTRIM.C and ..\TABLE888SOURCE\LTRIM.C
Comparing files MemoryManagement.c and ..\TABLE888SOURCE\MemoryManagement.C
***** MemoryManagement.c
//
#include "stdafx.h"
#include        <stdio.h>
***** ..\TABLE888SOURCE\MemoryManagement.C
//
#include        <stdio.h>
*****

***** MemoryManagement.c

clsSYM *allocSYM() { return (clsSYM *)xalloc(sizeof(SYM)); };
clsType *allocTYP() { return (clsType *)xalloc(sizeof(TYP)); };
struct snode *allocSnode() { return (struct snode *)xalloc(sizeof(struct snode)); };
***** ..\TABLE888SOURCE\MemoryManagement.C

SYM *allocSYM() { return (SYM *)xalloc(sizeof(SYM)); };
TYP *allocTYP() { return (TYP *)xalloc(sizeof(TYP)); };
struct snode *allocSnode() { return (struct snode *)xalloc(sizeof(struct snode)); };
*****

Comparing files NextToken.c and ..\TABLE888SOURCE\NextToken.C
***** NextToken.c
//        __
//   \\__/ o\    (C) 2012-2015  Robert Finch, Stratford
//    \  __ /    All rights reserved.
***** ..\TABLE888SOURCE\NextToken.C
//        __
//   \\__/ o\    (C) 2012-2014  Robert Finch, Stratford
//    \  __ /    All rights reserved.
*****

***** NextToken.c
int             lstackptr = 0;  /* substitution stack pointer */
static char numstr[100];
static char *numstrptr;
static char backup_token = 0;

***** ..\TABLE888SOURCE\NextToken.C
int             lstackptr = 0;  /* substitution stack pointer */

*****

***** NextToken.c
            lastch = chstack[lstackptr];
            goto j1;
        }
***** ..\TABLE888SOURCE\NextToken.C
            lastch = chstack[lstackptr];
            return lastch;
        }
*****

***** NextToken.c
    }
 j1:
    if (numstrptr >= &numstr[0] && numstrptr < &numstr[98]) {
       *numstrptr = lastch;
       numstrptr++;
    }
    return lastch;
***** ..\TABLE888SOURCE\NextToken.C
    }
    return lastch;
*****

***** NextToken.c
    while(isidch(lastch)) {
                if(i < 62) {
                        lastkw[i] = lastch;
                        lastid[i++] = lastch;
        }
                getch();
***** ..\TABLE888SOURCE\NextToken.C
    while(isidch(lastch)) {
                if(i < 32)
                        lastid[i++] = lastch;
                getch();
*****

***** NextToken.c
    }
    lastkw[i] = '\0';
    lastid[i] = '_';
    lastid[i+1] = '\0';
    lastst = id;
***** ..\TABLE888SOURCE\NextToken.C
    }
    lastid[i] = '\0';
    lastst = id;
*****

***** NextToken.c
 */
void getbase(int64_t b)
{       
        register int64_t i0, i1, i2;
        register int64_t i, j;
        int k;

        i = 0;
        i0 = 0;
        i1 = 0;
        while(isalnum(lastch)) {
***** ..\TABLE888SOURCE\NextToken.C
 */
void getbase(int b)
{       register int64_t i, j;
        i = 0;
        while(isalnum(lastch)) {
*****

***** NextToken.c
                        i = i * b + j;
                        i2 = i0;
                        for (k = 0; k < b; k++) {
                            i0 = i0 + i2;
                            if (i0 & 0x100000000L) {
                               i0 = i0 - 0x100000000L;
                               i1 = i1 + 1;
                            }
                        }
                        i0 = i0 + j;
                        if (i0 & 0x100000000L) {
                            i0 = i0 - 0x100000000L;
                            i1 = i1 + 1;
                        }
                        getch();
***** ..\TABLE888SOURCE\NextToken.C
                        i = i * b + j;
                        getch();
*****

***** NextToken.c
        ival = i;
/*
        rval.exp = 0x804E;
        rval.man1 = (i1 >> 32) & 0xffffL;
        rval.man2 = (i1 >> 16) & 0xffffL;
        rval.man3 = i1 & 0xffffL;
        rval.man4 = (i0 >> 16) & 0ffffL;
        rval.man5 = i0 & 0xffffL;
        // normalize the number
        while (!(rval.man1 & 0x8000)) {
             rval.exp--;
             rval.man1 = (rval.man1 << 1) | (rval.man2 & 0x8000) ? 1 : 0;
             rval.man2 = (rval.man2 << 1) | (rval.man3 & 0x8000) ? 1 : 0;
             rval.man3 = (rval.man3 << 1) | (rval.man4 & 0x8000) ? 1 : 0;
             rval.man4 = (rval.man4 << 1) | (rval.man5 & 0x8000) ? 1 : 0;
             rval.man5 = (rval.man5 << 1);
        }
*/
        lastst = iconst;
***** ..\TABLE888SOURCE\NextToken.C
        ival = i;
        lastst = iconst;
*****

***** NextToken.c
void getfrac()
{
        __float128  frmul;
        printf("Get fract\r\n");
    frmul = 0.1;
***** ..\TABLE888SOURCE\NextToken.C
void getfrac()
{       
        double  frmul;
    frmul = 0.1;
*****

***** NextToken.c
    }
        printf("leave Get fract\r\n");
}
***** ..\TABLE888SOURCE\NextToken.C
    }
}
*****

***** NextToken.c
void getexp()
{       __float128  expo, exmul;
        expo = 1.0;
***** ..\TABLE888SOURCE\NextToken.C
void getexp()
{       double  expo, exmul;
        expo = 1.0;
*****

***** NextToken.c
        getbase(10);
        if(ival > 32767)
                error(ERR_FPCON);
***** ..\TABLE888SOURCE\NextToken.C
        getbase(10);
        if(ival > 255)
                error(ERR_FPCON);
*****

***** NextToken.c
        i = 0;

        numstrptr = &numstr[0];
         *numstrptr = lastch;
         numstrptr++; 
        if(lastch == '0') {
***** ..\TABLE888SOURCE\NextToken.C
        i = 0;
        if(lastch == '0') {
*****

***** NextToken.c
                getch();
                if (lastch=='.')
                     goto j1;
                if(lastch == 'x' || lastch == 'X') {
***** ..\TABLE888SOURCE\NextToken.C
                getch();
                if(lastch == 'x' || lastch == 'X') {
*****

***** NextToken.c
                getbase(10);
j1:
                if(lastch == '.') {
***** ..\TABLE888SOURCE\NextToken.C
                getbase(10);
                if(lastch == '.') {
*****

***** NextToken.c
                                }
    numstrptr[-1]='\0';
    numstrptr = NULL;
//    dd_real::read(numstr,rval);
//    printf("leave getnum=%s\r\n", numstr);
                                
***** ..\TABLE888SOURCE\NextToken.C
                                }
                                
*****

***** NextToken.c
restart:        /* we come back here after comments */
        if (backup_token) {
           backup_token = 0;
           lastch = '(';
           lastst = openpa;
           return;
        }
                SkipSpaces();
***** ..\TABLE888SOURCE\NextToken.C
restart:        /* we come back here after comments */
                SkipSpaces();
*****

***** NextToken.c
                        break;
                case '\\':
                        getch();
                        goto restart;
                default:
***** ..\TABLE888SOURCE\NextToken.C
                        break;
                default:
*****

***** NextToken.c

void backup() {
    backup_token = 1;
}
***** ..\TABLE888SOURCE\NextToken.C
*****

Comparing files Optimize.c and ..\TABLE888SOURCE\Optimize.C
FC: no differences encountered

Comparing files Outcode.c and ..\TABLE888SOURCE\Outcode.C
***** Outcode.c
//        __
//   \\__/ o\    (C) 2012-2015  Robert Finch, Stratford
//    \  __ /    All rights reserved.
***** ..\TABLE888SOURCE\Outcode.C
//        __
//   \\__/ o\    (C) 2012-2014  Robert Finch, Stratford
//    \  __ /    All rights reserved.
*****

***** Outcode.c
                {"sxb",op_sxb}, {"sxc", op_sxc}, {"sxh", op_sxh},
                {"zxb",op_zxb}, {"zxc", op_zxc}, {"zxh", op_zxh},
                {"subui",op_subui}, {"shru", op_shru}, {"divsi", op_divsi}, {"not", op_not},
***** ..\TABLE888SOURCE\Outcode.C
                {"sxb",op_sxb}, {"sxc", op_sxc}, {"sxh", op_sxh},
                {"subui",op_subui}, {"shru", op_shru}, {"divsi", op_divsi}, {"not", op_not},
*****

***** Outcode.c
                {"sw", op_sw}, {"lw", op_lw}, {"lh", op_lh}, {"lc", op_lc}, {"lb", op_lb},
                {"lvb", op_lvb}, {"lvc", op_lvc}, {"lvh", op_lvh}, {"lvw", op_lvw},
                {"lbu", op_lbu}, {"lcu", op_lcu}, {"lhu", op_lhu}, {"sti", op_sti},
***** ..\TABLE888SOURCE\Outcode.C
                {"sw", op_sw}, {"lw", op_lw}, {"lh", op_lh}, {"lc", op_lc}, {"lb", op_lb},
                {"lbu", op_lbu}, {"lcu", op_lcu}, {"lhu", op_lhu}, {"sti", op_sti},
*****

***** Outcode.c
                {"xor",op_xor}, {"xori", op_xori}, {"mul",op_mul}, {"muli", op_muli}, {"mului", op_mului}, 
                
                {"fmul", op_fdmul}, {"fdiv", op_fddiv}, {"fadd", op_fdadd}, {"fsub", op_fdsub}, {"fcmp", op_fdcmp},
                {"fmul.s", op_fsmul}, {"fdiv.s", op_fsdiv}, {"fadd.s", op_fsadd}, {"fsub.s", op_fssub},
                {"fs2d", op_fs2d}, {"fi2d", op_i2d}, {"fneg", op_fdneg}, 

                {"divs",op_divs}, {"swap",op_swap}, {"mod", op_mod}, {"modu", op_modu},
***** ..\TABLE888SOURCE\Outcode.C
                {"xor",op_xor}, {"xori", op_xori}, {"mul",op_mul}, {"muli", op_muli}, {"mului", op_mului}, 
                {"fdmul", op_fdmul}, {"fddiv", op_fddiv}, {"fdadd", op_fdadd}, {"fdsub", op_fdsub},
                {"fsmul", op_fsmul}, {"fsdiv", op_fsdiv}, {"fsadd", op_fsadd}, {"fssub", op_fssub},
                {"fs2d", op_fs2d}, {"fi2d", op_i2d},
                {"divs",op_divs}, {"swap",op_swap}, {"mod", op_mod}, {"modu", op_modu},
*****

***** Outcode.c
                {"ltu", op_ltu}, {"leu",op_leu}, {"gtu",op_gtu}, {"geu", op_geu},
                {"bhi",op_bhi}, {"bhs",op_bhs}, {"blo",op_blo}, {"bun", op_bun},
                {"bls",op_bls}, {"mulu",op_mulu}, {"divu",op_divu},
***** ..\TABLE888SOURCE\Outcode.C
                {"ltu", op_ltu}, {"leu",op_leu}, {"gtu",op_gtu}, {"geu", op_geu},
                {"bhi",op_bhi}, {"bhs",op_bhs}, {"blo",op_blo},
                {"bls",op_bls}, {"mulu",op_mulu}, {"divu",op_divu},
*****

***** Outcode.c
                {"ne",op_ne}, {"lt",op_lt}, {"le",op_le},
                {"gt",op_gt}, {"ge",op_ge}, {"neg",op_neg}, {"nr", op_nr},
                {"not",op_not}, {"com", op_com}, {"cmp",op_cmp}, {"ext",op_ext}, 
***** ..\TABLE888SOURCE\Outcode.C
                {"ne",op_ne}, {"lt",op_lt}, {"le",op_le},
                {"gt",op_gt}, {"ge",op_ge}, {"neg",op_neg}, {"fdneg", op_fdneg}, {"nr", op_nr},
                {"not",op_not}, {"com", op_com}, {"cmp",op_cmp}, {"ext",op_ext}, 
*****

***** Outcode.c
                {"clr",op_clr}, {"link",op_link}, {"unlink",op_unlk},
                {"br",op_br}, {"bra",op_bra}, {"pea",op_pea},
                                {"cmpi",op_cmpi}, {"tst",op_tst},
                {"stop", op_stop}, {"movs", op_movs},
***** ..\TABLE888SOURCE\Outcode.C
                {"clr",op_clr}, {"link",op_link}, {"unlink",op_unlk},
                {"bra",op_bra}, {"pea",op_pea},
                                {"cmp",op_cmpi}, {"tst",op_tst},
                {"stop", op_stop}, {"movs", op_movs},
*****

***** Outcode.c
                {"sll", op_sll}, {"slli", op_slli}, {"srl", op_srl}, {"srli", op_srli}, {"sra", op_sra}, {"srai", op_srai},
                {"asl", op_asl}, {"asli", op_asli}, {"lsr", op_lsr}, {"lsri", op_lsri}, {"chk", op_chk }, {";", op_rem},
                {"sfd", op_sfd}, {"lfd", op_lfd}, {"fmov.d", op_fdmov},
                {"fix2flt", op_fix2flt}, {"mtfp", op_mtfp}, {"flt2fix",op_flt2fix}, {"mffp",op_mffp},
                {"mv2fix",op_mv2fix}, {"mv2flt", op_mv2flt},
                {0,0} };
***** ..\TABLE888SOURCE\Outcode.C
                {"sll", op_sll}, {"slli", op_slli}, {"srl", op_srl}, {"srli", op_srli}, {"sra", op_sra}, {"srai", op_srai},
                {"asl", op_asl}, {"asli", op_asli}, {"lsr", op_lsr}, {"lsri", op_lsri},
                {0,0} };
*****

***** Outcode.c
        case en_autofcon:
                        fprintf(output,"%lld",offset->i);
                        break;
***** ..\TABLE888SOURCE\Outcode.C
        case en_autofcon:
                        fprintf(output,"%ld",offset->i);
                        break;
*****

***** Outcode.c
        case en_fcon:
                        fprintf(output,"0x%llx",offset->f);
                        break;
***** ..\TABLE888SOURCE\Outcode.C
        case en_fcon:
                        fprintf(output,"0x%lx",offset->f);
                        break;
*****

***** Outcode.c
            if (lowhigh==2)
                    fprintf(output,"%lld",offset->i & 0xffff);
            else if (lowhigh==3)
                    fprintf(output,"%lld",(offset->i >> 16) & 0xffff);
            else
                fprintf(output,"%lld",offset->i);
                if (rshift > 0)
***** ..\TABLE888SOURCE\Outcode.C
            if (lowhigh==2)
                    fprintf(output,"%ld",offset->i & 0xffff);
            else if (lowhigh==3)
                    fprintf(output,"%ld",(offset->i >> 16) & 0xffff);
            else
                fprintf(output,"%ld",offset->i);
                if (rshift > 0)
*****

***** Outcode.c
        case en_labcon:
                        sprintf(buf, "%s_%lld",GetNamespace(),offset->i);
                        fprintf(output,buf);
***** ..\TABLE888SOURCE\Outcode.C
        case en_labcon:
                        sprintf(buf, "%s_%ld",GetNamespace(),offset->i);
                        fprintf(output,buf);
*****

***** Outcode.c
        case en_clabcon:
                        sprintf(buf,"%s_%lld",GetNamespace(),offset->i);
                        fprintf(output,buf);
***** ..\TABLE888SOURCE\Outcode.C
        case en_clabcon:
                        sprintf(buf,"%s_%ld",GetNamespace(),offset->i);
                        fprintf(output,buf);
*****

***** Outcode.c
                    sprintf(&buf[n][0], "bp");
        else if (regno==regGP)
                    sprintf(&buf[n][0], "gp");
            else if (regno==regXLR)
***** ..\TABLE888SOURCE\Outcode.C
                    sprintf(&buf[n][0], "bp");
            else if (regno==regXLR)
*****

***** Outcode.c
                switch(regno) {
                case 26:        sprintf(&buf[n][0], "bp"); break;
                //case 251:     sprintf(&buf[n], "xlr"); break;
***** ..\TABLE888SOURCE\Outcode.C
                switch(regno) {
                case 253:       sprintf(&buf[n][0], "bp"); break;
                //case 251:     sprintf(&buf[n], "xlr"); break;
*****

***** Outcode.c
                //case 254:     sprintf(&buf[n], "pc"); break;
                case 27:        sprintf(&buf[n][0], "sp"); break;
                default:        sprintf(&buf[n][0], "r%d", regno); break;
***** ..\TABLE888SOURCE\Outcode.C
                //case 254:     sprintf(&buf[n], "pc"); break;
                case 255:       sprintf(&buf[n][0], "sp"); break;
                default:        sprintf(&buf[n][0], "r%d", regno); break;
*****

***** Outcode.c
        switch(regno) {
        case  1:        sprintf(&buf[n][0], "c1"); break;
        case 11:        sprintf(&buf[n][0], "c11"); break;
        case 15:        sprintf(&buf[n][0], "c15"); break;
        default:        sprintf(&buf[n][0], "c%d", regno); break;
        }
***** ..\TABLE888SOURCE\Outcode.C
        switch(regno) {
        case  1:        sprintf(&buf[n][0], "lr"); break;
        case 11:        sprintf(&buf[n][0], "xlr"); break;
        case 15:        sprintf(&buf[n][0], "pc"); break;
        default:        sprintf(&buf[n][0], "br%d", regno); break;
        }
*****

***** Outcode.c
            break;
    case am_fpreg:
            fprintf(output, "fp%d", ap->preg);
            break;
    case am_predreg:
***** ..\TABLE888SOURCE\Outcode.C
            break;
    case am_predreg:
*****

***** Outcode.c
                        if (ap->offset != NULL && !is816) {
//                if (ap->offset->i)
                        PutConstant(ap->offset,0,0);
***** ..\TABLE888SOURCE\Outcode.C
                        if (ap->offset != NULL && !is816) {
                if (ap->offset->i)
                        PutConstant(ap->offset,0,0);
*****

***** Outcode.c
    case am_indx2:
//                      if (ap->offset != 0)
//                              PutConstant(ap->offset,0,0);
                        if (ap->scale==1 || ap->scale==0)
***** ..\TABLE888SOURCE\Outcode.C
    case am_indx2:
                        if (ap->offset != 0)
                                PutConstant(ap->offset,0,0);
                        if (ap->scale==1 || ap->scale==0)
*****

***** Outcode.c
    case am_indx3:
//                      if (ap->offset->i != 0)
//                  PutConstant(ap->offset,0,0);
            fprintf(output,"[%s+%s]",RegMoniker(ap->sreg),RegMoniker(ap->preg));
***** ..\TABLE888SOURCE\Outcode.C
    case am_indx3:
                        if (ap->offset->i != 0)
                    PutConstant(ap->offset,0,0);
            fprintf(output,"[%s+%s]",RegMoniker(ap->sreg),RegMoniker(ap->preg));
*****

***** Outcode.c
 */
char *put_label(int lab, char *nm, char *ns, char d)
{
    static char buf[300];

    sprintf(buf, "%s_%d", ns, lab);
        if (nm==NULL)
                fprintf(output,"%s:\n",buf);
        else if (strlen(nm)==0)
                fprintf(output,"%s:\n",buf);
        else
                fprintf(output,"%s:     ; %s\n",buf,nm);
        return buf;
}
***** ..\TABLE888SOURCE\Outcode.C
 */
void put_label(int lab, char *nm, char *ns, char d)
{
        if (nm==NULL)
                fprintf(output,"%s_%d:\n",ns,lab);
        else if (strlen(nm)==0)
                fprintf(output,"%s_%d:\n",ns,lab);
        else
                fprintf(output,"%s_%d:  ; %s\n",ns,lab,nm);
}
*****

***** Outcode.c


void GenerateByte(int val)
***** ..\TABLE888SOURCE\Outcode.C

void GenerateByte(int val)
*****

***** Outcode.c
{       nl();
        fprintf(output,"\tfill.b\t%d,0x00\n",nbytes);
}
***** ..\TABLE888SOURCE\Outcode.C
{       nl();
        fprintf(output,"\tdcb.b\t%d,0x00\n",nbytes);
}
*****

***** Outcode.c

char *strip_crlf(char *p)
{
     static char buf[2000];
     int nn;

     for (nn = 0; *p && nn < 1998; p++) {
         if (*p != '\r' && *p!='\n') {
            buf[nn] = *p;
            nn++;
         }
     }
     buf[nn] = '\0';
}

/*
***** ..\TABLE888SOURCE\Outcode.C

/*
*****

***** Outcode.c
            nl();
        put_label(strtab->label,strip_crlf(strtab->str),strtab->nmspace,'D');
        cp = strtab->str;
***** ..\TABLE888SOURCE\Outcode.C
            nl();
        put_label(strtab->label,strtab->str,strtab->nmspace,'D');
        cp = strtab->str;
*****

***** Outcode.c

void seg(int sg, int algn)
{    
***** ..\TABLE888SOURCE\Outcode.C

void seg(int sg)
{    
*****

***** Outcode.c
                        fprintf(output,"\tbss\n");
                        break;
***** ..\TABLE888SOURCE\Outcode.C
                        fprintf(output,"\tbss\n");
                        fprintf(output,"\talign\t8\n");
                        break;
*****

***** Outcode.c
                        fprintf(output,"\tdata\n");
                        break;
***** ..\TABLE888SOURCE\Outcode.C
                        fprintf(output,"\tdata\n");
                        fprintf(output,"\talign\t8\n");
                        break;
*****

***** Outcode.c
                        fprintf(output,"\ttls\n");
                        break;
***** ..\TABLE888SOURCE\Outcode.C
                        fprintf(output,"\ttls\n");
                        fprintf(output,"\talign\t8\n");
                        break;
*****

***** Outcode.c
                        fprintf(output,"\tidata\n");
                        break;
***** ..\TABLE888SOURCE\Outcode.C
                        fprintf(output,"\tidata\n");
                        fprintf(output,"\talign\t8\n");
                        break;
*****

***** Outcode.c
                        fprintf(output,"\tcode\n");
                        break;
***** ..\TABLE888SOURCE\Outcode.C
                        fprintf(output,"\tcode\n");
                        fprintf(output,"\talign\t16\n");
                        break;
*****

***** Outcode.c
                        fprintf(output,"\trodata\n");
                        break;
***** ..\TABLE888SOURCE\Outcode.C
                        fprintf(output,"\trodata\n");
                        fprintf(output,"\talign\t16\n");
                        break;
*****

***** Outcode.c
    }
        fprintf(output,"\talign\t%d\n", algn);
}
***** ..\TABLE888SOURCE\Outcode.C
    }
        fprintf(output,"\talign\t8\n");
}
*****

Comparing files ParseDeclarations.c and ..\TABLE888SOURCE\ParseDeclarations.C
***** ParseDeclarations.c
//        __
//   \\__/ o\    (C) 2012-2015  Robert Finch, Stratford
//    \  __ /    All rights reserved.
***** ..\TABLE888SOURCE\ParseDeclarations.C
//        __
//   \\__/ o\    (C) 2012-2014  Robert Finch, Stratford
//    \  __ /    All rights reserved.
*****

***** ParseDeclarations.c
TABLE           tagtable = {(SYM *)0,(SYM *)0};
TYP             stdconst = { bt_long, bt_long, 1, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0, 0, 8, {0, 0}, 0, "stdcons
t"};
char *names[20];
***** ..\TABLE888SOURCE\ParseDeclarations.C
TABLE           tagtable = {(SYM *)0,(SYM *)0};
TYP             stdconst = { bt_long, bt_long, 1, FALSE, FALSE, FALSE, FALSE, 0, 0, 8, {0, 0}, 0, "stdconst"};
char *names[20];
*****

***** ParseDeclarations.c
int funcdecl = 0;               //0,1, or 2
int nfc = 0;
int isFirstCall = 0;
int catchdecl = FALSE;
***** ..\TABLE888SOURCE\ParseDeclarations.C
int funcdecl = 0;               //0,1, or 2
int catchdecl = FALSE;
*****

***** ParseDeclarations.c
int isVolatile = FALSE;
int isIO = FALSE;
int isConst = FALSE;
***** ..\TABLE888SOURCE\ParseDeclarations.C
int isVolatile = FALSE;
int isConst = FALSE;
*****

***** ParseDeclarations.c
int worstAlignment = 0;
char *stkname = 0;

***** ..\TABLE888SOURCE\ParseDeclarations.C
int worstAlignment = 0;

*****

***** ParseDeclarations.c
    tp->val_flag = 0;
    tp->isArray = FALSE;
    tp->size = siz;
***** ..\TABLE888SOURCE\ParseDeclarations.C
    tp->val_flag = 0;
    tp->size = siz;
*****

***** ParseDeclarations.c
        tp->isVolatile = FALSE;
        tp->isIO = FALSE;
        tp->isConst = FALSE;
***** ..\TABLE888SOURCE\ParseDeclarations.C
        tp->isVolatile = FALSE;
        tp->isConst = FALSE;
*****

***** ParseDeclarations.c
        isVolatile = FALSE;
        isIO = FALSE;
        isConst = FALSE;
***** ..\TABLE888SOURCE\ParseDeclarations.C
        isVolatile = FALSE;
        isConst = FALSE;
*****

***** ParseDeclarations.c
                                NextToken();
                                if (lastst==openpa) {
                    NextToken();
                    if (lastst!=id) 
                       error(ERR_IDEXPECT);
                    needpunc(closepa);
                    stkname = litlate(lastid);
                }
                                goto lxit;
***** ..\TABLE888SOURCE\ParseDeclarations.C
                                NextToken();
                                goto lxit;
*****

***** ParseDeclarations.c

                        case kw_kernel:
                                isKernel = TRUE;
                                head = tail = maketype(bt_kernel,8);
                                NextToken();
                                goto lxit;

                        case kw_pascal:
***** ..\TABLE888SOURCE\ParseDeclarations.C

                        case kw_pascal:
*****

***** ParseDeclarations.c
                                head->isVolatile = isVolatile;
                                head->isIO = isIO;
                                head->isConst = isConst;
                                bit_max = 8;
***** ..\TABLE888SOURCE\ParseDeclarations.C
                                head->isVolatile = isVolatile;
                                bit_max = 8;
*****

***** ParseDeclarations.c
                                head->isVolatile = isVolatile;
                                head->isIO = isIO;
                                head->isConst = isConst;
                                bit_max = 16;
***** ..\TABLE888SOURCE\ParseDeclarations.C
                                head->isVolatile = isVolatile;
                                bit_max = 16;
*****

***** ParseDeclarations.c
                                head->isVolatile = isVolatile;
                                head->isIO = isIO;
                                head->isConst = isConst;
                                bit_max = 16;
***** ..\TABLE888SOURCE\ParseDeclarations.C
                                head->isVolatile = isVolatile;
                                bit_max = 16;
*****

***** ParseDeclarations.c
                                head->isVolatile = isVolatile;
                                head->isIO = isIO;
                                head->isConst = isConst;
                                head->isShort = TRUE;
***** ..\TABLE888SOURCE\ParseDeclarations.C
                                head->isVolatile = isVolatile;
                                head->isShort = TRUE;
*****

***** ParseDeclarations.c
                                //NextToken();
                                if (lastst==kw_task) {
                                    isTask = TRUE;
                                    NextToken();
                }
                                if (lastst==kw_oscall) {
***** ..\TABLE888SOURCE\ParseDeclarations.C
                                //NextToken();
                                if (lastst==kw_oscall) {
*****

***** ParseDeclarations.c
                                head->isVolatile = isVolatile;
                                head->isIO = isIO;
                                head->isConst = isConst;
                                bit_max = 64;
***** ..\TABLE888SOURCE\ParseDeclarations.C
                                head->isVolatile = isVolatile;
                                bit_max = 64;
*****

***** ParseDeclarations.c
                                head->isVolatile = isVolatile;
                                head->isIO = isIO;
                                head->isConst = isConst;
                                NextToken();
                                if (lastst==kw_task) {
                                    isTask = TRUE;
                                    NextToken();
                }
                                if (lastst==kw_oscall) {
***** ..\TABLE888SOURCE\ParseDeclarations.C
                                head->isVolatile = isVolatile;
                                NextToken();
                                if (lastst==kw_oscall) {
*****

***** ParseDeclarations.c
                                }
                                else if (lastst==kw_nocall || lastst==kw_naked) {
                                        isNocall = TRUE;
***** ..\TABLE888SOURCE\ParseDeclarations.C
                                }
                                if (lastst==kw_nocall || lastst==kw_naked) {
                                        isNocall = TRUE;
*****

***** ParseDeclarations.c

            case kw_task:
                isTask = TRUE;
                NextToken();
                                break;

                        case kw_int8:
***** ..\TABLE888SOURCE\ParseDeclarations.C

                        case kw_int8:
*****

***** ParseDeclarations.c
                                head->isVolatile = isVolatile;
                                head->isIO = isIO;
                                head->isConst = isConst;
                                NextToken();
***** ..\TABLE888SOURCE\ParseDeclarations.C
                                head->isVolatile = isVolatile;
                                NextToken();
*****

***** ParseDeclarations.c
                                NextToken();
                                if (lastst==kw_inout) {
                    NextToken();
                    isIO = TRUE;
                }
                                isVolatile = TRUE;
***** ..\TABLE888SOURCE\ParseDeclarations.C
                                NextToken();
                                isVolatile = TRUE;
*****

***** ParseDeclarations.c
                                head->isVolatile = isVolatile;
                                head->isIO = isIO;
                                head->isConst = isConst;
                                NextToken();
***** ..\TABLE888SOURCE\ParseDeclarations.C
                                head->isVolatile = isVolatile;
                                NextToken();
*****

***** ParseDeclarations.c
                                head->isVolatile = isVolatile;
                                head->isIO = isIO;
                                head->isConst = isConst;
                                NextToken();
***** ..\TABLE888SOURCE\ParseDeclarations.C
                                head->isVolatile = isVolatile;
                                NextToken();
*****

***** ParseDeclarations.c

                        case kw_triple:
                                head = tail = maketype(bt_triple,12);
                                head->isVolatile = isVolatile;
                                head->isIO = isIO;
                                head->isConst = isConst;
                                NextToken();
                                bit_max = 96;
                                goto lxit;

                        case kw_void:
***** ..\TABLE888SOURCE\ParseDeclarations.C

                        case kw_void:
*****

***** ParseDeclarations.c
                                head->isVolatile = isVolatile;
                                head->isIO = isIO;
                                head->isConst = isConst;
                                NextToken();
***** ..\TABLE888SOURCE\ParseDeclarations.C
                                head->isVolatile = isVolatile;
                                NextToken();
*****

***** ParseDeclarations.c

            case kw_exception:
                                head = tail = maketype(bt_exception,8);
                                head->isVolatile = isVolatile;
                                head->isIO = isIO;
                                head->isConst = isConst;
                                NextToken();
                                bit_max = 64;
                                goto lxit;
                                
            case kw_inline:
                NextToken();
                break;

                        default:
***** ..\TABLE888SOURCE\ParseDeclarations.C

                        default:
*****

***** ParseDeclarations.c
        TYP *tempHead, *tempTail;
        long sz2;

***** ..\TABLE888SOURCE\ParseDeclarations.C
        TYP *tempHead, *tempTail;

*****

***** ParseDeclarations.c
    case openbr:

        NextToken();
***** ..\TABLE888SOURCE\ParseDeclarations.C
    case openbr:
        NextToken();
*****

***** ParseDeclarations.c
        temp1->val_flag = 1;
        temp1->isArray = TRUE;
        temp1->btp = head;
***** ..\TABLE888SOURCE\ParseDeclarations.C
        temp1->val_flag = 1;
        temp1->btp = head;
*****

***** ParseDeclarations.c
        else if(head != NULL) {
            sz2 = GetIntegerExpression((ENODE **)NULL);
                        temp1->size = sz2 * head->size;
                        temp1->alignment = head->alignment;
                        needpunc(closebr);
***** ..\TABLE888SOURCE\ParseDeclarations.C
        else if(head != NULL) {
                        temp1->size = GetIntegerExpression((ENODE **)NULL) * head->size;
                        needpunc(closebr);
*****

***** ParseDeclarations.c
        else {
            sz2 = GetIntegerExpression((ENODE **)NULL);
                        temp1->size = sz2;
                        needpunc(closebr);
***** ..\TABLE888SOURCE\ParseDeclarations.C
        else {
                        temp1->size = GetIntegerExpression((ENODE **)NULL);
                        needpunc(closebr);
*****

***** ParseDeclarations.c
        break;

    case openpa:
***** ..\TABLE888SOURCE\ParseDeclarations.C
        break;
    case openpa:
*****

***** ParseDeclarations.c
    case bt_double:         return AL_DOUBLE;
    case bt_triple:         return AL_TRIPLE;
    case bt_struct:
    case bt_union:          
         return (tp->alignment) ?  tp->alignment : AL_STRUCT;
    default:                return AL_CHAR;
***** ..\TABLE888SOURCE\ParseDeclarations.C
    case bt_double:         return AL_DOUBLE;
    case bt_struct:
    case bt_union:          return AL_STRUCT;
    default:                return AL_CHAR;
*****

***** ParseDeclarations.c
    case bt_double:         return imax(AL_DOUBLE,worstAlignment);
    case bt_triple:         return imax(AL_TRIPLE,worstAlignment);
    case bt_struct:
***** ..\TABLE888SOURCE\ParseDeclarations.C
    case bt_double:         return imax(AL_DOUBLE,worstAlignment);
    case bt_struct:
*****

***** ParseDeclarations.c
                sp = tp->lst.head;
        worstAlignment = tp->alignment;
                while(sp != NULL) {
            if (sp->tp && sp->tp->alignment) {
                worstAlignment = imax(worstAlignment,sp->tp->alignment);
            }
            else
                        worstAlignment = imax(worstAlignment,walignment(sp->tp));
***** ..\TABLE888SOURCE\ParseDeclarations.C
                sp = tp->lst.head;
                while(sp != NULL) {
                        worstAlignment = imax(worstAlignment,walignment(sp->tp));
*****

***** ParseDeclarations.c
        int fn_doneinit = 0;
        int bcnt;

***** ..\TABLE888SOURCE\ParseDeclarations.C
        int fn_doneinit = 0;

*****

***** ParseDeclarations.c
            sp->storage_class = al;
            sp->isConst = isConst;
                        if (bit_width > 0 && bit_offset > 0) {
***** ..\TABLE888SOURCE\ParseDeclarations.C
            sp->storage_class = al;
                        if (bit_width > 0 && bit_offset > 0) {
*****

***** ParseDeclarations.c
                        }
                        if ((ilc + nbytes) % roundAlignment(head)) {
                                if (al==sc_thread)
                                        tseg();
                                else
                                        dseg();
            }
            bcnt = 0;
            while( (ilc + nbytes) % roundAlignment(head)) {
                ++nbytes;
                bcnt++;
            }
            if( al != sc_member && al != sc_external && al != sc_auto) {
                if (bcnt > 0)
                    genstorage(bcnt);
            }
***** ..\TABLE888SOURCE\ParseDeclarations.C
                        }
            while( (ilc + nbytes) % roundAlignment(head)) {
                if( al != sc_member && al != sc_external && al != sc_auto) {
                                        if (al==sc_thread)
                                                tseg();
                                        else
                                                dseg();
                                        GenerateByte(0);
                }
                ++nbytes;
            }
*****

***** ParseDeclarations.c
            if(ztype == bt_union)
                nbytes = imax(nbytes,roundSize(sp->tp));
                        else if(al != sc_external) {
***** ..\TABLE888SOURCE\ParseDeclarations.C
            if(ztype == bt_union)
                nbytes = imax(nbytes,sp->tp->size);
                        else if(al != sc_external) {
*****

***** ParseDeclarations.c
                case id:
        case kw_kernel:
                case kw_interrupt:
        case kw_task:
                case kw_cdecl:
***** ..\TABLE888SOURCE\ParseDeclarations.C
                case id:
                case kw_interrupt:
                case kw_cdecl:
*****

***** ParseDeclarations.c
                case kw_volatile: case kw_const:
        case kw_exception:
                case kw_int8: case kw_int16: case kw_int32: case kw_int64:
***** ..\TABLE888SOURCE\ParseDeclarations.C
                case kw_volatile: case kw_const:
                case kw_int8: case kw_int16: case kw_int32: case kw_int64:
*****

***** ParseDeclarations.c
                                }
                                if (lastst==kw_kernel) {
                                        isKernel = TRUE;
                                        NextToken();
                                }
                                else if (lastst==kw_oscall || lastst==kw_interrupt || lastst==kw_nocall || lastst==kw_naked)
***** ..\TABLE888SOURCE\ParseDeclarations.C
                                }
                                else if (lastst==kw_oscall || lastst==kw_interrupt || lastst==kw_nocall || lastst==kw_naked)
*****

***** ParseDeclarations.c
                break;
        case kw_inline:
                NextToken();
                break;
        default:
***** ..\TABLE888SOURCE\ParseDeclarations.C
                break;
        default:
*****

***** ParseDeclarations.c
                case kw_cdecl:
        case kw_kernel:
                case kw_interrupt:
***** ..\TABLE888SOURCE\ParseDeclarations.C
                case kw_cdecl:
                case kw_interrupt:
*****

***** ParseDeclarations.c
                case kw_volatile: case kw_const:
        case kw_exception:
                case kw_int8: case kw_int16: case kw_int32: case kw_int64:
***** ..\TABLE888SOURCE\ParseDeclarations.C
                case kw_volatile: case kw_const:
                case kw_int8: case kw_int16: case kw_int32: case kw_int64:
*****

***** ParseDeclarations.c
                error(ERR_ILLCLASS);
                                if (lastst==kw_oscall || lastst==kw_interrupt || lastst == kw_nocall || lastst==kw_naked || las
tst==kw_kernel)
                                        NextToken();
***** ..\TABLE888SOURCE\ParseDeclarations.C
                error(ERR_ILLCLASS);
                                if (lastst==kw_oscall || lastst==kw_interrupt || lastst == kw_nocall || lastst==kw_naked)
                                        NextToken();
*****

***** ParseDeclarations.c
                case kw_cdecl:
        case kw_kernel:
                case kw_interrupt:
***** ..\TABLE888SOURCE\ParseDeclarations.C
                case kw_cdecl:
                case kw_interrupt:
*****

***** ParseDeclarations.c
                NextToken();
        case kw_exception:
                case kw_volatile: case kw_const:
***** ..\TABLE888SOURCE\ParseDeclarations.C
                NextToken();
                case kw_volatile: case kw_const:
*****

***** ParseDeclarations.c
                NextToken();
                                if (lastst==kw_oscall || lastst==kw_interrupt || lastst == kw_nocall || lastst==kw_naked || las
tst==kw_kernel)
                                        NextToken();
***** ..\TABLE888SOURCE\ParseDeclarations.C
                NextToken();
                                if (lastst==kw_oscall || lastst==kw_interrupt || lastst == kw_nocall || lastst==kw_naked)
                                        NextToken();
*****

Comparing files ParseEnumDeclaration.c and ..\TABLE888SOURCE\ParseEnumDeclaration.C
FC: no differences encountered

Comparing files ParseExpressions.c and ..\TABLE888SOURCE\ParseExpressions.C
***** ParseExpressions.c
//        __
//   \\__/ o\    (C) 2012-2015  Robert Finch, Stratford
//    \  __ /    All rights reserved.
***** ..\TABLE888SOURCE\ParseExpressions.C
//        __
//   \\__/ o\    (C) 2012-2014  Robert Finch, Stratford
//    \  __ /    All rights reserved.
*****

***** ParseExpressions.c
TYP *forcefit(ENODE **node1,TYP *tp1,ENODE **node2,TYP *tp2);
extern void backup();
extern char *inpline;
extern int parsingParameterList;

***** ..\TABLE888SOURCE\ParseExpressions.C
TYP *forcefit(ENODE **node1,TYP *tp1,ENODE **node2,TYP *tp2);

*****

***** ParseExpressions.c
// Tells subsequent levels that ParseCastExpression already fetched a token.
//static unsigned char expr_flag = 0;

***** ..\TABLE888SOURCE\ParseExpressions.C
// Tells subsequent levels that ParseCastExpression already fetched a token.
static unsigned char expr_flag = 0;

*****

***** ParseExpressions.c

TYP             stdint = { bt_long, bt_long, 0, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,0,8, {0, 0}, 0, 0 };
TYP             stduint = { bt_long, bt_long, 0, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,0,8, {0, 0}, 0, 0 };
TYP             stdlong = { bt_long, bt_long, 0, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,0,8, {0, 0}, 0, 0 };
TYP             stdulong = { bt_long, bt_long, 0, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,0,8, {0, 0}, 0, 0 };
TYP             stdshort = { bt_short, bt_short, 0, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,0,4, {0, 0}, 0, 0 };
TYP             stdushort = { bt_short, bt_short, 0, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,0,4, {0, 0}, 0, 0 };
TYP             stdchar = {bt_char, bt_char, 0, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,0,2, {0, 0}, 0, 0 };
TYP             stduchar = {bt_char, bt_char, 0, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,0,2, {0, 0}, 0, 0 };
TYP             stdbyte = {bt_byte, bt_byte, 0, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,0,1, {0, 0}, 0, 0 };
TYP             stdubyte = {bt_byte, bt_byte, 0, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,0,1, {0, 0}, 0, 0 };
TYP             stdstring = {bt_pointer, bt_pointer, 1, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,0,4, {0, 0}, &stdcha
r, 0};
TYP                             stddbl = {bt_double, bt_double, 0, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,0,8, {0, 
0}, 0, 0};
TYP                             stdtriple = {bt_triple, bt_triple, 0, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,0,12, 
{0, 0}, 0, 0};
TYP                             stdflt = {bt_float, bt_float, 0, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,0,4, {0, 0}
, 0, 0};
TYP                             stddouble = {bt_double, bt_double, 0, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,0,8, {
0, 0}, 0, 0};
TYP             stdfunc = {bt_func, bt_func, 1, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,0,0, {0, 0}, &stdint, 0};
TYP             stdexception = { bt_exception, bt_exception, 0, FALSE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, 0,0,8, {0, 0}, 
0, 0 };
extern TYP      *head;          /* shared with ParseSpecifier */
***** ..\TABLE888SOURCE\ParseExpressions.C

TYP             stdint = { bt_long, bt_long, 0, FALSE, FALSE, FALSE, FALSE, 0,0,8, {0, 0}, 0, 0 };
TYP             stduint = { bt_long, bt_long, 0, TRUE, FALSE, FALSE, FALSE, 0,0,8, {0, 0}, 0, 0 };
TYP             stdlong = { bt_long, bt_long, 0, FALSE, FALSE, FALSE, FALSE, 0,0,8, {0, 0}, 0, 0 };
TYP             stdulong = { bt_long, bt_long, 0, TRUE, FALSE, FALSE, FALSE, 0,0,8, {0, 0}, 0, 0 };
TYP             stdshort = { bt_short, bt_short, 0, FALSE, FALSE, FALSE, FALSE, 0,0,4, {0, 0}, 0, 0 };
TYP             stdushort = { bt_short, bt_short, 0, TRUE, FALSE, FALSE, FALSE, 0,0,4, {0, 0}, 0, 0 };
TYP             stdchar = {bt_char, bt_char, 0, FALSE, FALSE, FALSE, FALSE, 0,0,2, {0, 0}, 0, 0 };
TYP             stduchar = {bt_char, bt_char, 0, TRUE, FALSE, FALSE, FALSE, 0,0,2, {0, 0}, 0, 0 };
TYP             stdbyte = {bt_byte, bt_byte, 0, FALSE, FALSE, FALSE, FALSE, 0,0,1, {0, 0}, 0, 0 };
TYP             stdubyte = {bt_byte, bt_byte, 0, TRUE, FALSE, FALSE, FALSE, 0,0,1, {0, 0}, 0, 0 };
TYP             stdstring = {bt_pointer, bt_pointer, 1, FALSE, FALSE, FALSE, FALSE, 0,0,4, {0, 0}, &stdchar, 0};
TYP                             stddbl = {bt_double, bt_double, 0, FALSE, FALSE, FALSE, FALSE, 0,0,8, {0, 0}, 0, 0};
TYP                             stdflt = {bt_float, bt_float, 0, FALSE, FALSE, FALSE, FALSE, 0,0,4, {0, 0}, 0, 0};
TYP             stdfunc = {bt_func, bt_func, 1, FALSE, FALSE, FALSE, FALSE, 0,0,0, {0, 0}, &stdint, 0};
extern TYP      *head;          /* shared with ParseSpecifier */
*****

***** ParseExpressions.c

int nest_level = 0;

void Enter(char *p)
{
/*
     int nn;
     
     for (nn = 0; nn < nest_level; nn++)
         printf("   ");
     printf("%s: %d\r\n", p, lineno);
     nest_level++;
*/
}
void Leave(char *p, int n)
{
/*
     int nn;
     
     nest_level--;
     for (nn = 0; nn < nest_level; nn++)
         printf("   ");
     printf("%s (%d)\r\n", p, n);
*/
}
***** ..\TABLE888SOURCE\ParseExpressions.C

/*
 *      build an expression node with a node type of nt and values
 *      v1 and v2.
 */
ENODE *makenode(int nt, ENODE *v1, ENODE *v2)
{
        ENODE *ep;
    ep = (ENODE *)xalloc(sizeof(ENODE));
    ep->nodetype = (enum e_node)nt;
    ep->constflag = FALSE;
        ep->isUnsigned = FALSE;
        ep->etype = bt_void;
        ep->esize = -1;
        ep->p[0] = v1;
        ep->p[1] = v2;
    return ep;
}
*****

***** ParseExpressions.c

/*
 *      build an expression node with a node type of nt and values
 *      v1 and v2.
 */
ENODE *makenode(int nt, ENODE *v1, ENODE *v2)
{
***** ..\TABLE888SOURCE\ParseExpressions.C

ENODE *makesnode(int nt, char *v1, int64_t i)
{
*****

***** ParseExpressions.c
        ep->esize = -1;
        ep->p[0] = v1;
        ep->p[1] = v2;
    return ep;
***** ..\TABLE888SOURCE\ParseExpressions.C
        ep->esize = -1;
        ep->sp = v1;
        ep->i = i;
    return ep;
*****

***** ParseExpressions.c

ENODE *makesnode(int nt, char *v1, int64_t i)
{
***** ..\TABLE888SOURCE\ParseExpressions.C

ENODE *makenodei(int nt, ENODE *v1, int64_t i)
{
*****

***** ParseExpressions.c
        ep->esize = -1;
        ep->sp = v1;
        ep->i = i;
    return ep;
***** ..\TABLE888SOURCE\ParseExpressions.C
        ep->esize = -1;
        ep->i = i;
        ep->p[0] = v1;
        ep->p[1] = (ENODE *)NULL;
    return ep;
*****

***** ParseExpressions.c

ENODE *makenodei(int nt, ENODE *v1, int64_t i)
{
***** ..\TABLE888SOURCE\ParseExpressions.C

ENODE *makeinode(int nt, int64_t v1)
{
*****

***** ParseExpressions.c
    ep->nodetype = (enum e_node)nt;
    ep->constflag = FALSE;
        ep->isUnsigned = FALSE;
***** ..\TABLE888SOURCE\ParseExpressions.C
    ep->nodetype = (enum e_node)nt;
    ep->constflag = TRUE;
        ep->isUnsigned = FALSE;
*****

***** ParseExpressions.c
        ep->esize = -1;
        ep->i = i;
        ep->p[0] = v1;
        ep->p[1] = (ENODE *)NULL;
    return ep;
***** ..\TABLE888SOURCE\ParseExpressions.C
        ep->esize = -1;
    ep->i = v1;
    return ep;
*****

***** ParseExpressions.c

ENODE *makeinode(int nt, int64_t v1)
{
***** ..\TABLE888SOURCE\ParseExpressions.C

ENODE *makefnode(int nt, double v1)
{
*****

***** ParseExpressions.c
        ep->esize = -1;
    ep->i = v1;
    return ep;
***** ..\TABLE888SOURCE\ParseExpressions.C
        ep->esize = -1;
    ep->f = v1;
    return ep;
*****

***** ParseExpressions.c

ENODE *makefnode(int nt, double v1)
{
        ENODE *ep;
    ep = (ENODE *)xalloc(sizeof(ENODE));
    ep->nodetype = (enum e_node)nt;
    ep->constflag = TRUE;
        ep->isUnsigned = FALSE;
        ep->etype = bt_void;
        ep->esize = -1;
        ep->f = v1;
    ep->f1 = v1;
//    ep->f2 = v2;
    return ep;
}
***** ..\TABLE888SOURCE\ParseExpressions.C

void PromoteConstFlag(ENODE *ep)
{
        ep->constflag = ep->p[0]->constflag && ep->p[1]->constflag;
}
*****

***** ParseExpressions.c

void PromoteConstFlag(ENODE *ep)
{
        ep->constflag = ep->p[0]->constflag && ep->p[1]->constflag;
}

/*
***** ..\TABLE888SOURCE\ParseExpressions.C

/*
*****

***** ParseExpressions.c
                case bt_byte:
                        if (tp->isUnsigned) {
***** ..\TABLE888SOURCE\ParseExpressions.C
                case bt_byte:
                case bt_ubyte:
                        if (tp->isUnsigned) {
*****

***** ParseExpressions.c
                        if (tp->isUnsigned)
                    tp = &stdubyte;//&stduint;
                        else
                    tp = &stdbyte;//&stdint;
            break;
                case bt_ubyte:
                        *node = makenode(en_ub_ref,*node,(ENODE *)NULL);
                        (*node)->isUnsigned = TRUE;
                        (*node)->esize = tp->size;
                        (*node)->etype = (enum e_bt)tp->type;
            tp = &stdubyte;//&stduint;
            break;
***** ..\TABLE888SOURCE\ParseExpressions.C
                        if (tp->isUnsigned)
                    tp = &stduint;
                        else
                    tp = &stdint;
            break;
*****

***** ParseExpressions.c
            break;
                case bt_exception:
                        (*node)->esize = tp->size;
***** ..\TABLE888SOURCE\ParseExpressions.C
            break;
                case bt_ulong:
                case bt_long:
                        (*node)->esize = tp->size;
*****

***** ParseExpressions.c
                        (*node)->etype = (enum e_bt)tp->type;
                        (*node)->isUnsigned = TRUE;
                        *node = makenode(en_uw_ref,*node,(ENODE *)NULL);
            break;
                case bt_ulong:
                case bt_long:
                        (*node)->esize = tp->size;
                        (*node)->etype = (enum e_bt)tp->type;
                        if (tp->isUnsigned) {
***** ..\TABLE888SOURCE\ParseExpressions.C
                        (*node)->etype = (enum e_bt)tp->type;
                        if (tp->isUnsigned) {
*****

***** ParseExpressions.c
                case bt_pointer:
                        (*node)->esize = tp->size;
***** ..\TABLE888SOURCE\ParseExpressions.C
                case bt_pointer:
                case bt_unsigned:
                        (*node)->esize = tp->size;
*****

***** ParseExpressions.c
            break;
                case bt_unsigned:
                        (*node)->esize = tp->size;
***** ..\TABLE888SOURCE\ParseExpressions.C
            break;
        case bt_double:
            *node = makenode(en_dbl_ref,*node,(ENODE *)NULL);
                        (*node)->esize = tp->size;
*****

***** ParseExpressions.c
                        (*node)->etype = (enum e_bt)tp->type;
            *node = makenode(en_uw_ref,*node,(ENODE *)NULL);
                        (*node)->isUnsigned = TRUE;
            break;
        case bt_triple:
            *node = makenode(en_triple_ref,*node,(ENODE *)NULL);
                        (*node)->esize = tp->size;
***** ..\TABLE888SOURCE\ParseExpressions.C
                        (*node)->etype = (enum e_bt)tp->type;
            tp = &stddbl;
            break;
        case bt_float:
            *node = makenode(en_flt_ref,*node,(ENODE *)NULL);
                        (*node)->esize = tp->size;
*****

***** ParseExpressions.c
                        (*node)->etype = (enum e_bt)tp->type;
            tp = &stdtriple;
            break;
        case bt_double:
            *node = makenode(en_dbl_ref,*node,(ENODE *)NULL);
                        (*node)->esize = tp->size;
                        (*node)->etype = (enum e_bt)tp->type;
                        (*node)->isDouble = TRUE;
            tp = &stddbl;
            break;
        case bt_float:
            *node = makenode(en_flt_ref,*node,(ENODE *)NULL);
                        (*node)->esize = tp->size;
                        (*node)->etype = (enum e_bt)tp->type;
            tp = &stdflt;
***** ..\TABLE888SOURCE\ParseExpressions.C
                        (*node)->etype = (enum e_bt)tp->type;
            tp = &stdflt;
*****

***** ParseExpressions.c
  //          break;
                case bt_struct:
                case bt_union:
                        (*node)->esize = tp->size;
                        (*node)->etype = tp->type;
            *node = makenode(en_struct_ref,*node,NULL);
                        (*node)->isUnsigned = TRUE;
            break;
                default:
***** ..\TABLE888SOURCE\ParseExpressions.C
  //          break;
                //case bt_struct:
                //case bt_union:
                //      (*node)->esize = tp->size;
                //      (*node)->etype = tp->type;
  //          *node = makenode(en_struct_ref,*node,NULL);
                //      (*node)->isUnsigned = TRUE;
  //          break;
                default:
*****

***** ParseExpressions.c
                return deref(node, tp);
    if (tp->type == bt_pointer && (sizeof_flag == 0)) {
                tp1 = tp->btp;
                if (tp1==NULL)
                    printf("DIAG: CondDeref: tp1 is NULL\r\n");
                tp = maketype(bt_pointer, 8);
***** ..\TABLE888SOURCE\ParseExpressions.C
                return deref(node, tp);
    if (tp->type == bt_pointer && sizeof_flag == 0) {
                tp1 = tp->btp;
                tp = maketype(bt_pointer, 8);
*****

***** ParseExpressions.c
    }
    else if (tp->type==bt_pointer)
        return tp;
//    else if (tp->type==bt_struct || tp->type==bt_union)
//       return deref(node, tp);
    return tp;
***** ..\TABLE888SOURCE\ParseExpressions.C
    }
    return tp;
*****

***** ParseExpressions.c
                                                        }
                                                        (*node)->etype = bt_pointer;//sp->tp->type;
                                                        (*node)->isDouble = sp->tp->type==bt_double;
                            break;
***** ..\TABLE888SOURCE\ParseExpressions.C
                                                        }
                            break;
*****

***** ParseExpressions.c
                                                        (*node)->esize = sp->tp->size;
                                                        (*node)->etype = bt_pointer;//sp->tp->type;
                                                        if (sp->tp->isUnsigned)
***** ..\TABLE888SOURCE\ParseExpressions.C
                                                        (*node)->esize = sp->tp->size;
                                                        if (sp->tp->isUnsigned)
*****

***** ParseExpressions.c
                                                                (*node)->isUnsigned = TRUE;
                                                        (*node)->isDouble = sp->tp->type==bt_double;
                                                        break;
***** ..\TABLE888SOURCE\ParseExpressions.C
                                                                (*node)->isUnsigned = TRUE;
                                                        break;
*****

***** ParseExpressions.c
                                                        (*node)->esize = sp->tp->size;
                                                        (*node)->etype = bt_pointer;//sp->tp->type;
                                                        (*node)->isUnsigned = sp->tp->isUnsigned;
                                                        (*node)->isDouble = sp->tp->type==bt_double;
                            break;
***** ..\TABLE888SOURCE\ParseExpressions.C
                                                        (*node)->esize = sp->tp->size;
                                                        (*node)->isUnsigned = sp->tp->isUnsigned;
                            break;
*****

***** ParseExpressions.c
                    case sc_const:
                                                        if (sp->tp->type==bt_float || sp->tp->type==bt_double || sp->tp->type==
bt_triple)
                                                                *node = makefnode(en_fcon,sp->value.f);
***** ..\TABLE888SOURCE\ParseExpressions.C
                    case sc_const:
                                                        if (sp->tp->type==bt_float || sp->tp->type==bt_double)
                                                                *node = makefnode(en_fcon,sp->value.f);
*****

***** ParseExpressions.c
                                                        (*node)->esize = sp->tp->size;
                                                        (*node)->isDouble = sp->tp->type==bt_double;
                            break;
***** ..\TABLE888SOURCE\ParseExpressions.C
                                                        (*node)->esize = sp->tp->size;
                            break;
*****

***** ParseExpressions.c
                                    error(ERR_ILLCLASS);
                                                        if (sp->tp->type==bt_float || sp->tp->type==bt_double || sp->tp->type==
bt_triple)
                                                                *node = makeinode(en_autofcon,sp->value.i);
***** ..\TABLE888SOURCE\ParseExpressions.C
                                    error(ERR_ILLCLASS);
                                                        if (sp->tp->type==bt_float || sp->tp->type==bt_double)
                                                                *node = makeinode(en_autofcon,sp->value.i);
*****

***** ParseExpressions.c
                                                        (*node)->esize = sp->tp->size;
                                                        (*node)->etype = bt_pointer;//sp->tp->type;
                                                        (*node)->isDouble = sp->tp->type==bt_double;
                            break;
***** ..\TABLE888SOURCE\ParseExpressions.C
                                                        (*node)->esize = sp->tp->size;
                            break;
*****

***** ParseExpressions.c
                    }
                    (*node)->tp = sp->tp;
                    tp = CondDeref(node,tp);
***** ..\TABLE888SOURCE\ParseExpressions.C
                    }
                    tp = CondDeref(node,tp);
*****

***** ParseExpressions.c
                                st == kw_int16 || st == kw_int8 || st == kw_int32 || st == kw_int16 ||
                st == kw_long || st == kw_float || st == kw_double || st == kw_triple || 
                st == kw_enum || st == kw_struct || st == kw_union ||
                st== kw_unsigned || st==kw_signed || st==kw_exception ||
                                st == kw_const;
***** ..\TABLE888SOURCE\ParseExpressions.C
                                st == kw_int16 || st == kw_int8 || st == kw_int32 || st == kw_int16 ||
                st == kw_long || st == kw_float || st == kw_double || st==kw_enum ||
                st == kw_struct || st == kw_union || st== kw_unsigned || st==kw_signed ||
                                st == kw_const;
*****

***** ParseExpressions.c
        else
                return IsIntrinsicType(st) || st==kw_volatile;
}
***** ..\TABLE888SOURCE\ParseExpressions.C
        else
                return IsIntrinsicType(st);
}
*****

***** ParseExpressions.c
// ----------------------------------------------------------------------------
TYP *ParsePrimaryExpression(ENODE **node, int got_pa)
{
***** ..\TABLE888SOURCE\ParseExpressions.C
// ----------------------------------------------------------------------------
TYP *ParsePrimaryExpression(ENODE **node)
{
*****

***** ParseExpressions.c
        qnode2 = (ENODE *)NULL;
        pnode = (ENODE *)NULL;
    *node = (ENODE *)NULL;
    Enter("ParsePrimary ");
    if (got_pa) {
        tptr = expression(&pnode);
        needpunc(closepa);
        *node = pnode;
        if (pnode==NULL)
           printf("pnode is NULL\r\n");
        else
           (*node)->tp = tptr;
        if (tptr)
        Leave("ParsePrimary", tptr->type);
        else
        Leave("ParsePrimary", 0);
        return tptr;
    }
    switch( lastst ) {
***** ..\TABLE888SOURCE\ParseExpressions.C
        qnode2 = (ENODE *)NULL;
        if (expr_flag)
                goto processExpression;
    switch( lastst ) {
*****

***** ParseExpressions.c
        tptr = &stdint;
        tptr->isConst = TRUE;
        pnode = makeinode(en_icon,ival);
***** ..\TABLE888SOURCE\ParseExpressions.C
        tptr = &stdint;
        pnode = makeinode(en_icon,ival);
*****

***** ParseExpressions.c
                        pnode->esize = 8;
        pnode->tp = tptr;
        NextToken();
***** ..\TABLE888SOURCE\ParseExpressions.C
                        pnode->esize = 8;
        NextToken();
*****

***** ParseExpressions.c
    case rconst:
        tptr = &stddouble;
        tptr->isConst = TRUE;
        pnode = makefnode(en_fcon,rval);
***** ..\TABLE888SOURCE\ParseExpressions.C
    case rconst:
        tptr = &stddbl;
        pnode = makefnode(en_fcon,rval);
*****

***** ParseExpressions.c
        pnode->constflag = TRUE;
        pnode->isDouble = TRUE;
        pnode->tp = tptr;
        NextToken();
***** ..\TABLE888SOURCE\ParseExpressions.C
        pnode->constflag = TRUE;
        NextToken();
*****

***** ParseExpressions.c
                        tptr->size = strlen(laststr) + 1;
                        tptr->size2 = tptr->size;
                        tptr->btp = &stdchar;
            tptr->btp->isConst = TRUE;
                        tptr->val_flag = 1;
***** ..\TABLE888SOURCE\ParseExpressions.C
                        tptr->size = strlen(laststr) + 1;
                        tptr->btp = &stdchar;
                        tptr->val_flag = 1;
*****

***** ParseExpressions.c
        pnode->constflag = TRUE;
        pnode->tp = tptr;
        tptr->isConst = TRUE;
        NextToken();
***** ..\TABLE888SOURCE\ParseExpressions.C
        pnode->constflag = TRUE;
        NextToken();
*****

***** ParseExpressions.c
        NextToken();
j1:
//        if( !IsBeginningOfTypecast(lastst) ) {
//              expr_flag = 0;
        tptr = expression(&pnode);
        pnode->tp = tptr;
        needpunc(closepa);
***** ..\TABLE888SOURCE\ParseExpressions.C
        NextToken();
processExpression:
//        if( !IsBeginningOfTypecast(lastst) ) {
                expr_flag = 0;
        tptr = expression(&pnode);
        needpunc(closepa);
*****

***** ParseExpressions.c
    default:
        Leave("ParsePrimary", 0);
        return (TYP *)NULL;
***** ..\TABLE888SOURCE\ParseExpressions.C
    default:
        return (TYP *)NULL;
*****

***** ParseExpressions.c
fini:   *node = pnode;
    if (*node)
       (*node)->tp = tptr;
    if (tptr)
    Leave("ParsePrimary", tptr->type);
    else
    Leave("ParsePrimary", 0);
    return tptr;
***** ..\TABLE888SOURCE\ParseExpressions.C
fini:   *node = pnode;
    return tptr;
*****

***** ParseExpressions.c
        case en_uhfieldref:
    case en_triple_ref:
        case en_dbl_ref:
***** ..\TABLE888SOURCE\ParseExpressions.C
        case en_uhfieldref:
        case en_dbl_ref:
*****

***** ParseExpressions.c
        case en_flt_ref:
        case en_struct_ref:
            return TRUE;
***** ..\TABLE888SOURCE\ParseExpressions.C
        case en_flt_ref:
        //case en_struct_ref:
            return TRUE;
*****

***** ParseExpressions.c
        *node = ep1;
        if (*node)
        (*node)->tp = tp;
        return tp;
***** ..\TABLE888SOURCE\ParseExpressions.C
        *node = ep1;
        return tp;
*****

***** ParseExpressions.c

TYP *ParsePostfixExpression(ENODE **node, int got_pa)
{
        TYP *tp1, *tp2;
        ENODE *ep1, *ep2, *ep3;
        ENODE *rnode[4],*cnode[4],*qnode[4],*rnode1,*rnode2,*q1node;
        SYM *sp;
***** ..\TABLE888SOURCE\ParseExpressions.C

TYP *ParsePostfixExpression(ENODE **node)
{
        TYP *tp1;
        ENODE *ep1;
        ENODE *rnode,*qnode;
        SYM *sp;
*****

***** ParseExpressions.c
        int iu;
        int size;
        TYP *p, *q;
        int sof;
        int na,ii;
        int sz[4],fact[4];

    ep1 = (ENODE *)NULL;
    Enter("ParsePostfix ");
    *node = (ENODE *)NULL;
    sof = sizeof_flag;
//    sizeof_flag = 1;
        tp1 = ParsePrimaryExpression(&ep1, got_pa);
//      sizeof_flag = sof;
//      if (ep1==NULL)
//         printf("DIAG: ParsePostFix: ep1 is NULL\r\n");
        if (tp1 == NULL) {
        Leave("ParsePostfix",0);
                return (TYP *)NULL;
    }
        while(1) {
***** ..\TABLE888SOURCE\ParseExpressions.C
        int iu;

        tp1 = ParsePrimaryExpression(&ep1);
        if (tp1 == NULL)
                return (TYP *)NULL;
        while(1) {
*****

***** ParseExpressions.c
                        }
                        
            if( tp1->type != bt_pointer )
***** ..\TABLE888SOURCE\ParseExpressions.C
                        }
            if( tp1->type != bt_pointer )
*****

***** ParseExpressions.c
                error(ERR_NOPOINTER);
            else {
                 size = tp1->size;
                 tp1 = tp1->btp;
            }
            NextToken();
/*
                        if ((tp1->val_flag && (tp1->size==1 || tp1->size==2 || tp1->size==4 || tp1->size==8))) {
                                expression(&rnode[0]);
//                              ep1 = makenode(en_add,rnode,ep1);
                                ep1 = makenode(en_add,ep1,rnode[0]);
                        ep1->constflag = rnode[0]->constflag && ep1->p[1]->constflag;
                                ep1->isUnsigned = rnode[0]->isUnsigned && ep1->p[1]->isUnsigned;
                                ep1->scale = tp1->size;
                                ep1->esize = 8;             // was 8
                        }
                        else
*/
            {
                                p = tp1;
//                              qnode = makeinode(en_icon,size);
                for (na = 0; na < 4 && p; na++) {
                    sz[na] = p->size;
                                    expression(&rnode[na]);
                    needpunc(closebr);
                    if (lastst != openbr)
                        break;
***** ..\TABLE888SOURCE\ParseExpressions.C
                error(ERR_NOPOINTER);
            else
                tp1 = tp1->btp;
            NextToken();
                        if (tp1->val_flag && (tp1->size==1 || tp1->size==2 || tp1->size==4 || tp1->size==8)) {
                                expression(&rnode);
                                ep1 = makenode(en_add,rnode,ep1);
                                ep1->constflag = rnode->constflag && ep1->p[1]->constflag;
                                ep1->isUnsigned = rnode->isUnsigned && ep1->p[1]->isUnsigned;
                                ep1->scale = tp1->size;
                                ep1->esize = 8;
                        }
                        else {
                                qnode = makeinode(en_icon,tp1->size);
                                qnode->constflag = TRUE;
                                qnode->isUnsigned = tp1->isUnsigned;
                                expression(&rnode);
/*
 *      we could check the type of the expression here...
                                                                        
 */
                                if (rnode==NULL) {
                                        error(ERR_EXPREXPECT);
                                        break;
                                }
                                qnode = makenode(en_mulu,rnode,qnode);
                                qnode->constflag = rnode->constflag && qnode->p[0]->constflag;
                                ep1 = makenode(en_add,qnode,ep1);
                                ep1->constflag = qnode->constflag && ep1->p[1]->constflag;
                                ep1->isUnsigned = qnode->isUnsigned && ep1->p[1]->isUnsigned;
                                ep1->scale = 1;
                                ep1->esize = 8;
                        }
            tp1 = CondDeref(&ep1,tp1);
            needpunc(closebr);
            break;

                case openpa:
            NextToken();
            if( tp1->type != bt_func && tp1->type != bt_ifunc )
                error(ERR_NOFUNC);
            else
                tp1 = tp1->btp;
                        if (currentFn==NULL)
                                error(ERR_SYNTAX);
                        else
                                currentFn->IsLeaf = FALSE;
                        if (lastst==closepa) {
                                NextToken();
                                ep1 = makenode(en_fcall,ep1,(ENODE *)NULL);
                        }
                        else {
                                ep1 = makenode(en_fcall,ep1,ArgumentList());
                                needpunc(closepa);
                        }
                        ep1->esize = 8;
            break;

                case pointsto:
                        if (tp1==NULL) {
                                error(ERR_UNDEFINED);
                                goto j1;
                        }
            if( tp1->type != bt_pointer )
                error(ERR_NOPOINTER);
            else
                tp1 = tp1->btp;
            if( tp1->val_flag == FALSE )
                ep1 = makenode(en_w_ref,ep1,(ENODE *)NULL);
                 // fall through to dot operation
                case dot:
                        if (tp1==NULL) {
                                error(ERR_UNDEFINED);
                                goto j1;
                        }
            NextToken();       /* past -> or . */
            if( lastst != id )
                error(ERR_IDEXPECT);
            else {
                sp = search(lastid,&tp1->lst);
                if( sp == NULL )
                    error(ERR_NOMEMBER);
                else {
                    tp1 = sp->tp;
                    qnode = makeinode(en_icon,sp->value.i);
                    qnode->constflag = TRUE;
                                        iu = ep1->isUnsigned;
                    ep1 = makenode(en_add,ep1,qnode);
                    ep1->constflag = ep1->p[0]->constflag;
                                        ep1->isUnsigned = iu;
                                        ep1->esize = 8;
                    tp1 = CondDeref(&ep1,tp1);
                }
                NextToken();       /* past id */
            }
            break;
                case autodec:
                        NextToken();
                        Autoincdec(tp1,&ep1,1);
                        break;
*****

Resync Failed.  Files are too different.
***** ParseExpressions.c
                        break;
                    NextToken();
                    p = p->btp;
                }
                if (na>2) {
                   printf("Too many array indexes.\r\n");
                   break;
                }
                switch(na) {
                case 0: 
                        fact[0] = sz[0];
                        cnode[0] = makeinode(en_icon,fact[0]);
                        cnode[0]->constflag = TRUE;
                        cnode[0]->isUnsigned = tp1->isUnsigned;
                        qnode[0] = makenode(en_mulu,rnode[0],cnode[0]);
                        qnode[0]->constflag = rnode[0]->constflag;
                                        ep1 = makenode(en_add,qnode[0],ep1);
                                        ep1->constflag = qnode[0]->constflag && ep1->p[1]->constflag;
                                        ep1->isUnsigned = qnode[0]->isUnsigned && ep1->p[1]->isUnsigned;
                                        ep1->scale = 1;
                                        ep1->esize = 8;
                        tp1 = CondDeref(&ep1,tp1);
                        break;
                case 1: 
                        fact[0] = sz[na];
                        fact[1] = sz[na-1]/sz[na];
                        fact[2] = size/sz[0];
                        cnode[0] = makeinode(en_icon,size/fact[1]);
                        cnode[0]->constflag = TRUE;
                        cnode[0]->isUnsigned = tp1->isUnsigned;
                        qnode[0] = makenode(en_mulu,rnode[0],cnode[0]);
                        qnode[0]->constflag = rnode[0]->constflag;
                        cnode[1] = makeinode(en_icon,fact[0]);
                        cnode[1]->constflag = TRUE;
                        cnode[1]->isUnsigned = tp1->isUnsigned;
                        qnode[1] = makenode(en_mulu,rnode[1],cnode[1]);
                        qnode[1]->constflag = rnode[1]->constflag;
                        ep2 = makenode(en_add,qnode[0],qnode[1]);
                        ep2->constflag = qnode[0]->constflag && qnode[1]->constflag;
                                        ep2->isUnsigned = qnode[0]->isUnsigned && qnode[1]->isUnsigned;
                        ep1 = makenode(en_add,ep1,ep2);
                        ep1->constflag = ep1->p[0]->constflag && ep2->p[0]->constflag;
                                        ep1->isUnsigned = ep1->p[0]->isUnsigned && ep2->p[0]->isUnsigned;
                                        ep1->scale = 1;
                                        ep1->esize = 8;
                        tp1 = CondDeref(&ep1,tp1);
                        break;
                case 2: 
                        fact[0] = sz[na];
                        fact[1] = sz[na-1]/sz[na];
                        fact[2] = sz[na-2]/sz[na-1];
                        fact[3] = size/sz[0];
                        cnode[0] = makeinode(en_icon,size/fact[1]);
                        cnode[0]->constflag = TRUE;
                        cnode[0]->isUnsigned = tp1->isUnsigned;
                        qnode[0] = makenode(en_mulu,rnode[0],cnode[0]);
                        qnode[0]->constflag = rnode[0]->constflag;
                        cnode[1] = makeinode(en_icon,size/(fact[1]*fact[2]));
                        cnode[1]->constflag = TRUE;
                        cnode[1]->isUnsigned = tp1->isUnsigned;
                        qnode[1] = makenode(en_mulu,rnode[1],cnode[1]);
                        qnode[1]->constflag = rnode[1]->constflag;
                        cnode[2] = makeinode(en_icon,size/(fact[1]*fact[2]*fact[3]));
                        cnode[2]->constflag = TRUE;
                        cnode[2]->isUnsigned = tp1->isUnsigned;
                        qnode[2] = makenode(en_mulu,rnode[2],cnode[2]);
                        qnode[2]->constflag = rnode[2]->constflag;
                        ep2 = makenode(en_add,qnode[0],qnode[1]);
                        ep2->constflag = qnode[0]->constflag && qnode[1]->constflag;
                                        ep2->isUnsigned = qnode[0]->isUnsigned && qnode[1]->isUnsigned;
                        ep1 = makenode(en_add,ep1,ep2);
                        ep1->constflag = ep1->p[0]->constflag && ep2->p[0]->constflag;
                                        ep1->isUnsigned = ep1->p[0]->isUnsigned && ep2->p[0]->isUnsigned;
                        ep1 = makenode(en_add,ep1,qnode[2]);
                        ep1->constflag = qnode[2]->constflag && ep1->p[0]->constflag;
                                        ep1->isUnsigned = qnode[2]->isUnsigned && ep1->p[0]->isUnsigned;
                                        ep1->scale = 1;
                                        ep1->esize = 8;
                        tp1 = CondDeref(&ep1,tp1);
                        break;
                }
            }
            break;
/*
                if (lastst==openbr) {
                    na = 2;
                    qnode = makeinode(en_icon,size/(tp1->size/tp1->btp->size));
                                qnode->constflag = TRUE;
                                qnode->isUnsigned = tp1->isUnsigned;
                    q1node = makeinode(en_icon,tp1->btp->size);
                    printf("sz:%d\r\n", tp1->size/tp1->btp->size);
                    NextToken();
                    expression(&rnode1);
                                if (rnode1==NULL) {
                                        error(ERR_EXPREXPECT);
                                        break;
                                }
                    needpunc(closebr);
                    qnode = makenode(en_mulu,rnode,qnode);
                    qnode->constflag = rnode->constflag && qnode->p[0]->constflag;
***** ..\TABLE888SOURCE\ParseExpressions.C
                        break;
                case autoinc:
                        NextToken();
                        Autoincdec(tp1,&ep1,0);
                        break;
                default:        goto j1;
                }
        }
j1:
        *node = ep1;
        return tp1;
}

/*
 *      ParseUnaryExpression evaluates unary expressions and returns the type of the
 *      expression evaluated. unary expressions are any of:
 *
 *                      postfix expression
 *                      ++unary
 *                      --unary
 *                      !cast_expression
 *                      ~cast_expression
 *                      -cast_expression
 *                      +cast_expression
 *                      *cast_expression
 *                      &cast_expression
 *                      sizeof(typecast)
 *                      sizeof unary
 *                      typenum(typecast)
 *
 */
TYP *ParseUnaryExpression(ENODE **node)
{
        TYP *tp, *tp1;
    ENODE *ep1, *ep2;
    int flag2;
        SYM *sp;

        flag2 = FALSE;
        if (expr_flag) {
        tp = ParsePostfixExpression(&ep1);
                *node = ep1;
                return tp;
        }
    switch( lastst ) {
    case autodec:
                NextToken();
                tp = ParseUnaryExpression(&ep1);
                Autoincdec(tp,&ep1,1);
                break;
    case autoinc:
                NextToken();
                tp = ParseUnaryExpression(&ep1);
                Autoincdec(tp,&ep1,0);
                break;
        case plus:
        NextToken();
        tp = ParseCastExpression(&ep1);
        if( tp == NULL ) {
            error(ERR_IDEXPECT);
            return (TYP *)NULL;
        }
        break;
    case minus:
        NextToken();
        tp = ParseCastExpression(&ep1);
        if( tp == NULL ) {
            error(ERR_IDEXPECT);
            return (TYP *)NULL;
        }
        ep1 = makenode(en_uminus,ep1,(ENODE *)NULL);
        ep1->constflag = ep1->p[0]->constflag;
                ep1->isUnsigned = ep1->p[0]->isUnsigned;
                ep1->esize = tp->size;
        break;
    case nott:
        NextToken();
        tp = ParseCastExpression(&ep1);
        if( tp == NULL ) {
            error(ERR_IDEXPECT);
            return (TYP *)NULL;
        }
        ep1 = makenode(en_not,ep1,(ENODE *)NULL);
        ep1->constflag = ep1->p[0]->constflag;
                ep1->isUnsigned = ep1->p[0]->isUnsigned;
                ep1->esize = tp->size;
        break;
    case cmpl:
        NextToken();
        tp = ParseCastExpression(&ep1);
        if( tp == NULL ) {
            error(ERR_IDEXPECT);
            return 0;
        }
        ep1 = makenode(en_compl,ep1,(ENODE *)NULL);
        ep1->constflag = ep1->p[0]->constflag;
                ep1->isUnsigned = ep1->p[0]->isUnsigned;
                ep1->esize = tp->size;
        break;
    case star:
*****

Comparing files ParseFunction.c and ..\TABLE888SOURCE\ParseFunction.C
***** ParseFunction.c
extern int nparms;
extern char *stkname;

***** ..\TABLE888SOURCE\ParseFunction.C
extern int nparms;

*****

***** ParseFunction.c

static int round8(int n)
{
    while (n & 7) n++;
    return n;
}


***** ..\TABLE888SOURCE\ParseFunction.C


*****

***** ParseFunction.c
        }
        sp->stkname = stkname;
        if (verbose) printf("Parsing function: %s\r\n", sp->name);
***** ..\TABLE888SOURCE\ParseFunction.C
        }
        if (verbose) printf("Parsing function: %s\r\n", sp->name);
*****

***** ParseFunction.c
        global_flag = 0;
        poffset = 24;            /* size of return block */
        nparms = 0;
***** ..\TABLE888SOURCE\ParseFunction.C
        global_flag = 0;
        poffset = 40;            /* size of return block */
        nparms = 0;
*****

***** ParseFunction.c
                                                sp1->value.i = poffset;
                                                // Check for aggregate types passed as parameters. Structs
                                                // and unions use the type size. 
                                        //      if (sp1->tp->type==bt_struct || sp1->tp->type==bt_union) {
                                                poffset += round8(sp1->tp->size);
                                                if (round8(sp1->tp->size) > 8)
                                                   sp->IsLeaf = FALSE;
                    //     }
                    //     else
                    //         poffset += 8;
                                                //sp1->value.i = poffset;
                                                //poffset += 8;
                        sp1->storage_class = sc_auto;
***** ..\TABLE888SOURCE\ParseFunction.C
                                                sp1->value.i = poffset;
                                                poffset += 8;
                        sp1->storage_class = sc_auto;
*****

***** ParseFunction.c
                                        }
                                        // Process extra hidden parameter
                                        if (sp->tp->btp->type==bt_struct || sp->tp->btp->type==bt_union) {
                         sp1 = makeint(litlate("_pHiddenStructPtr"));
                         sp1->value.i = poffset;
                         poffset += 8;
                         sp1->storage_class = sc_auto;
                                                 sp1->nextparm = (SYM *)NULL;
                                                // record parameter list
                                                if (sp->parms == (SYM *)NULL) {
                                                        sp->parms = sp1;
                                                }
                                                else {
                                                        sp1->nextparm = sp->parms;
                                                        sp->parms = sp1;
                                                }
                                                nparms++;
                    }
                }
***** ..\TABLE888SOURCE\ParseFunction.C
                                        }
                }
*****

***** ParseFunction.c
                        sp->IsPascal = isPascal;
                        sp->IsKernel = isKernel;
                        sp->IsInterrupt = isInterrupt;
                        sp->IsTask = isTask;
                        sp->NumParms = nparms;
***** ..\TABLE888SOURCE\ParseFunction.C
                        sp->IsPascal = isPascal;
                        sp->IsInterrupt = isInterrupt;
                        sp->NumParms = nparms;
*****

***** ParseFunction.c
                        isPascal = FALSE;
                        isKernel = FALSE;
                        isOscall = FALSE;
***** ..\TABLE888SOURCE\ParseFunction.C
                        isPascal = FALSE;
                        isOscall = FALSE;
*****

***** ParseFunction.c
                        isInterrupt = FALSE;
                        isTask = FALSE;
                        isNocall = FALSE;
***** ..\TABLE888SOURCE\ParseFunction.C
                        isInterrupt = FALSE;
                        isNocall = FALSE;
*****

***** ParseFunction.c
                        sp->IsPascal = isPascal;
                        sp->IsKernel = isKernel;
                        sp->IsInterrupt = isInterrupt;
                        sp->IsTask = isTask;
                        sp->NumParms = nparms;
***** ..\TABLE888SOURCE\ParseFunction.C
                        sp->IsPascal = isPascal;
                        sp->IsInterrupt = isInterrupt;
                        sp->NumParms = nparms;
*****

***** ParseFunction.c
                        isPascal = FALSE;
                        isKernel = FALSE;
                        isOscall = FALSE;
***** ..\TABLE888SOURCE\ParseFunction.C
                        isPascal = FALSE;
                        isOscall = FALSE;
*****

***** ParseFunction.c
                        isInterrupt = FALSE;
                        isTask = FALSE;
                        isNocall = FALSE;
***** ..\TABLE888SOURCE\ParseFunction.C
                        isInterrupt = FALSE;
                        isNocall = FALSE;
*****

***** ParseFunction.c
                                sp->IsPascal = isPascal;
                        sp->IsKernel = isKernel;
                                sp->IsInterrupt = isInterrupt;
                        sp->IsTask = isTask;
                                sp->NumParms = nparms;
***** ..\TABLE888SOURCE\ParseFunction.C
                                sp->IsPascal = isPascal;
                                sp->IsInterrupt = isInterrupt;
                                sp->NumParms = nparms;
*****

***** ParseFunction.c
                                isPascal = FALSE;
                        isKernel = FALSE;
                                isOscall = FALSE;
***** ..\TABLE888SOURCE\ParseFunction.C
                                isPascal = FALSE;
                                isOscall = FALSE;
*****

***** ParseFunction.c
                                isInterrupt = FALSE;
                        isTask = FALSE;
                                isNocall = FALSE;
***** ..\TABLE888SOURCE\ParseFunction.C
                                isInterrupt = FALSE;
                                isNocall = FALSE;
*****

***** ParseFunction.c
                                sp->IsPascal = isPascal;
                        sp->IsKernel = isKernel;
                                sp->IsInterrupt = isInterrupt;
                        sp->IsTask = isTask;
                                isPascal = FALSE;
                        isKernel = FALSE;
                                isOscall = FALSE;
                                isInterrupt = FALSE;
                        isTask = FALSE;
                                isNocall = FALSE;
                                sp->NumParms = nparms;
***** ..\TABLE888SOURCE\ParseFunction.C
                                sp->IsPascal = isPascal;
                                sp->IsInterrupt = isInterrupt;
                                sp->NumParms = nparms;
*****

***** ParseFunction.c
                        sp->IsPascal = isPascal;
                        sp->IsKernel = isKernel;
                        sp->IsInterrupt = isInterrupt;
                        sp->IsTask = isTask;
                        isPascal = FALSE;
                        isKernel = FALSE;
                        isOscall = FALSE;
                        isInterrupt = FALSE;
                        isTask = FALSE;
                        isNocall = FALSE;
                        sp->NumParms = nparms;
***** ..\TABLE888SOURCE\ParseFunction.C
                        sp->IsPascal = isPascal;
                        sp->IsInterrupt = isInterrupt;
                        sp->NumParms = nparms;
*****

***** ParseFunction.c
        isPascal = FALSE;
        isKernel = FALSE;
        isOscall = FALSE;
***** ..\TABLE888SOURCE\ParseFunction.C
        isPascal = FALSE;
        isOscall = FALSE;
*****

***** ParseFunction.c
        Statement *stmt;
        Statement *plg;
        Statement *eplg;

***** ..\TABLE888SOURCE\ParseFunction.C
        Statement *stmt;

*****

***** ParseFunction.c
        needpunc(begin);
     
    tmpReset();
        TRACE( printf("Parse function body: %s\r\n", sp->name); )
***** ..\TABLE888SOURCE\ParseFunction.C
        needpunc(begin);

        TRACE( printf("Parse function body: %s\r\n", sp->name); )
*****

***** ParseFunction.c
        stmt = ParseCompoundStatement();
//      stmt->stype = st_funcbody;
        if (isThor)
***** ..\TABLE888SOURCE\ParseFunction.C
        stmt = ParseCompoundStatement();
        if (isThor)
*****

***** ParseFunction.c

        flush_peep();
        if (sp->storage_class == sc_global) {
***** ..\TABLE888SOURCE\ParseFunction.C

//      if (optimize)
                flush_peep();
        if (sp->storage_class == sc_global) {
*****

***** ParseFunction.c
        }
        fprintf(output,"%sSTKSIZE_ EQU %d\r\n", sp->name, tmpVarSpace() + lc_auto);
        return stmt;
***** ..\TABLE888SOURCE\ParseFunction.C
        }
        return stmt;
*****

Comparing files ParseStatements.c and ..\TABLE888SOURCE\ParseStatements.C
***** ParseStatements.c
//      NextToken();
//      if (lastst==comma) {
//              NextToken();
//              snp->incrExpr = (ENODE *)GetIntegerExpression((ENODE **)NULL);
//              if ((int64_t)snp->incrExpr < 1 || (int64_t)snp->incrExpr > 15)
//                      error(ERR_SEMA_INCR);
//              snp->incrExpr = (ENODE *)((int64_t)snp->incrExpr);
//      }
        if (lastst==comma) {
***** ..\TABLE888SOURCE\ParseStatements.C
//      NextToken();
        if (lastst==comma) {
*****

***** ParseStatements.c
                NextToken();
                snp->initExpr = (ENODE *)GetIntegerExpression((ENODE **)NULL);
***** ..\TABLE888SOURCE\ParseStatements.C
                NextToken();
                snp->incrExpr = (ENODE *)GetIntegerExpression((ENODE **)NULL);
                if ((int64_t)snp->incrExpr < 1 || (int64_t)snp->incrExpr > 15)
                        error(ERR_SEMA_INCR);
                snp->incrExpr = (ENODE *)((int64_t)snp->incrExpr & 15);
        }
        if (lastst==comma) {
                NextToken();
                snp->initExpr = (ENODE *)GetIntegerExpression((ENODE **)NULL);
*****

***** ParseStatements.c
        currentStmt = snp;
        head = 0;
        if (lastst==colon) {
***** ..\TABLE888SOURCE\ParseStatements.C
        currentStmt = snp;
        head = 0; 
        if (lastst==colon) {
*****

***** ParseStatements.c
                        printf("clockbug\r\n");
                NextToken();
        }
***** ..\TABLE888SOURCE\ParseStatements.C
                        printf("clockbug\r\n");
        }
*****

***** ParseStatements.c
        // Add remaining statements onto the tail of the list.
        while( lastst != end) {
                tail->next = ParseStatement(); 
***** ..\TABLE888SOURCE\ParseStatements.C
        // Add remaining statements onto the tail of the list.
        while( lastst != end ) {
                tail->next = ParseStatement(); 
*****

***** ParseStatements.c
        return snp; 
    case kw_prolog:
         snp = NewStatement(st_empty,1);
         currentFn->prolog = ParseStatement(); break;
    case kw_epilog:
         snp = NewStatement(st_empty,1);
         currentFn->epilog = ParseStatement(); break;
    case kw_if: snp = ParseIfStatement(); break; 
***** ..\TABLE888SOURCE\ParseStatements.C
        return snp; 
    case kw_if: snp = ParseIfStatement(); break; 
*****

Comparing files ParseStructDeclaration.c and ..\TABLE888SOURCE\ParseStructDeclaration.C
***** ParseStructDeclaration.c
        int psd;
        ENODE nd;
        ENODE *pnd = &nd;

***** ..\TABLE888SOURCE\ParseStructDeclaration.C
        int psd;

*****

***** ParseStructDeclaration.c
            sp->tp->sname = sp->name;
            sp->tp->alignment = 0;
            NextToken();
***** ..\TABLE888SOURCE\ParseStructDeclaration.C
            sp->tp->sname = sp->name;
            NextToken();
*****

***** ParseStructDeclaration.c

                        if (lastst == kw_align) {
                NextToken();
                sp->tp->alignment = GetIntegerExpression(&pnd);
            }

                        // Could be a forward structure declaration like:
***** ..\TABLE888SOURCE\ParseStructDeclaration.C

                        // Could be a forward structure declaration like:
*****

***** ParseStructDeclaration.c
            NextToken();
            if (lastst==kw_align) {
                    NextToken();
                sp->tp->alignment = GetIntegerExpression(&pnd);
            }
                        if (lastst==begin) {
***** ..\TABLE888SOURCE\ParseStructDeclaration.C
            NextToken();
                        if (lastst==begin) {
*****

***** ParseStructDeclaration.c
        tp->lst.head = 0;

        if (lastst==kw_align) {
            NextToken();
            tp->alignment = GetIntegerExpression(&pnd);
        }

        if( lastst != begin)
***** ..\TABLE888SOURCE\ParseStructDeclaration.C
        tp->lst.head = 0;
        if( lastst != begin)
*****

***** ParseStructDeclaration.c
        bit_width = -1;
    tp->size = tp->alignment ? tp->alignment : slc;
    NextToken();
***** ..\TABLE888SOURCE\ParseStructDeclaration.C
        bit_width = -1;
    tp->size = slc;
    NextToken();
*****

Comparing files Peepgen.c and ..\TABLE888SOURCE\Peepgen.C
***** Peepgen.c
       return;
    if (ip->oper2->mode != am_ind && ip->oper2->mode != am_indx)
       return;     
    ip->opcode = op_push;
***** ..\TABLE888SOURCE\Peepgen.C
       return;
         
    ip->opcode = op_push;
*****

***** Peepgen.c
       return;
    if (ip2->oper1->mode != am_reg)
       return;
    if (ip2->oper1->preg != ip->oper1->preg)
***** ..\TABLE888SOURCE\Peepgen.C
       return;
    if (ip2->oper1->preg != ip->oper1->preg)
*****

***** Peepgen.c
 
// Optimize away duplicate sign extensions that the compiler sometimes
// generates. This handles sxb, sxcm and sxh.

void PeepoptSxb(struct ocode *ip)
{
     if (!ip->fwd)
         return;
     if (ip->fwd->opcode != ip->opcode)
         return;
     if (ip->fwd->oper1->preg != ip->oper1->preg)
         return;
     if (ip->fwd->oper2->preg != ip->oper2->preg)
         return;
     // Now we must have the same instruction twice in a row. ELiminate the
     // duplicate.
     ip->fwd = ip->fwd->fwd;
     if (ip->fwd->fwd)
          ip->fwd->fwd->back = ip;
}

/*
***** ..\TABLE888SOURCE\Peepgen.C
 
/*
*****

***** Peepgen.c
                    break;
            case op_sxb:
            case op_sxc:
            case op_sxh:
                    PeepoptSxb(ip);
                    break;
            case op_bra:
***** ..\TABLE888SOURCE\Peepgen.C
                    break;
            case op_bra:
*****

***** Peepgen.c
                        case op_rtd:
            case op_rtl:
                                        if (ip->predop==1 || isTable888)
***** ..\TABLE888SOURCE\Peepgen.C
                        case op_rtd:
                                        if (ip->predop==1 || isTable888)
*****

Comparing files Preprocessor.c and ..\TABLE888SOURCE\Preprocessor.C
***** Preprocessor.c
            }
    if( strcmp(lastkw,"include") == 0 )
            return doinclude();
    else if( strcmp(lastkw,"define") == 0 )
            return dodefine();
    else if (strcmp(lastkw,"ifdef")==0)
                        return doifdef();
    else if (strcmp(lastkw,"ifndef")==0)
                        return doifndef();
    else if (strcmp(lastkw,"endif")==0)
                        return doendif();
***** ..\TABLE888SOURCE\Preprocessor.C
            }
    if( strcmp(lastid,"include") == 0 )
            return doinclude();
    else if( strcmp(lastid,"define") == 0 )
            return dodefine();
    else if (strcmp(lastid,"ifdef")==0)
                        return doifdef();
    else if (strcmp(lastid,"ifndef")==0)
                        return doifndef();
    else if (strcmp(lastid,"endif")==0)
                        return doendif();
*****

***** Preprocessor.c
    input = fopen(pathname,"r");
    printf("%s\r\n", pathname);
    if( input == 0 ) {
***** ..\TABLE888SOURCE\Preprocessor.C
    input = fopen(pathname,"r");
    if( input == 0 ) {
*****

Comparing files Raptor64.c and ..\TABLE888SOURCE\Raptor64.C
FC: no differences encountered

Comparing files Register.c and ..\TABLE888SOURCE\Register.C
***** Register.c
//        __
//   \\__/ o\    (C) 2012-2015  Robert Finch, Stratford
//    \  __ /    All rights reserved.
***** ..\TABLE888SOURCE\Register.C
//        __
//   \\__/ o\    (C) 2012-2014  Robert Finch, Stratford
//    \  __ /    All rights reserved.
*****

***** Register.c
        initRegStack();
        initFPRegStack();
}
***** ..\TABLE888SOURCE\Register.C
        initRegStack();
}
*****

***** Register.c
*/
void ReleaseTempReg(AMODE *ap)
{
     if (ap->mode==am_fpreg)
         ReleaseTempFPRegister(ap);
     else
         ReleaseTempRegister(ap);
}

***** ..\TABLE888SOURCE\Register.C
*/

*****

Comparing files rtrim.c and ..\TABLE888SOURCE\rtrim.C
Comparing files searchenv.c and ..\TABLE888SOURCE\searchenv.C
FC: no differences encountered

Comparing files Strmat.c and ..\TABLE888SOURCE\Strmat.C
FC: no differences encountered

Comparing files Symbol.c and ..\TABLE888SOURCE\Symbol.C
FC: no differences encountered

Comparing files Table888.c and ..\TABLE888SOURCE\Table888.C
***** Table888.c
        int brreg, brmask, brrmask;
        int fpreg, fpmask;
    AMODE *ap, *ap2;
***** ..\TABLE888SOURCE\Table888.C
        int brreg, brmask, brrmask;
    AMODE *ap, *ap2;
*****

***** Table888.c
        brreg = 19;
        fpreg = 256+11;
    mask = 0;
***** ..\TABLE888SOURCE\Table888.C
        brreg = 19;
    mask = 0;
*****

***** Table888.c
        brmask = 0;
        fpmask = 0;
        brrmask = 0;
***** ..\TABLE888SOURCE\Table888.C
        brmask = 0;
        brrmask = 0;
*****

***** Table888.c
                        }
                        else if (csp->exp->etype==bt_triple)
                        {
                                if( csp->duses > csp->uses / 4 && reg < 256+18 )
//                              if( reg < 18 )  // was / 4
***** ..\TABLE888SOURCE\Table888.C
                        }
                        else
                        {
                                if( csp->duses > csp->uses / 4 && reg < 18 )
//                              if( reg < 18 )  // was / 4
*****

***** Table888.c
                        }
                        else
                        {
                                if( csp->duses > csp->uses / 4 && reg < 18 )
//                              if( reg < 18 )  // was / 4
                                        csp->reg = reg++;
                                else
                                        csp->reg = -1;
                        }
                }
        if( csp->reg != -1 && csp->reg < 256)
                {
***** ..\TABLE888SOURCE\Table888.C
                        }
                }
        if( csp->reg != -1 )
                {
*****

Comparing files temp.c and ..\TABLE888SOURCE\temp.C
Comparing files Thor.c and ..\TABLE888SOURCE\Thor.C
***** Thor.c
                cnt = 0;
                GenerateTriadic(op_subui,0,makereg(SP),makereg(SP),make_immed(bitsset(rmask)*8));
                for (nn = 0; nn < 32; nn++) {
***** ..\TABLE888SOURCE\Thor.C
                cnt = 0;
                //GenerateTriadic(op_subui,0,makereg(SP),makereg(SP),make_immed(bitsset(rmask)*8));
                for (nn = 0; nn < 32; nn++) {
*****

***** Thor.c
                        if (rmask & (0x80000000 >> nn)) {
                GenerateDiadic(op_sw,0,makereg(nn&31),make_indexed(cnt,SP));
//                              GenerateMonadic(op_push,0,makereg(nn&31));//,make_indexed(cnt,SP),NULL);
                                cnt+=8;
***** ..\TABLE888SOURCE\Thor.C
                        if (rmask & (0x80000000 >> nn)) {
                                GenerateMonadic(op_push,0,makereg(nn&31));//,make_indexed(cnt,SP),NULL);
                                cnt+=8;
*****

***** Thor.c
                        if (brrmask & (0x8000 >> nn)) {
                                GenerateTriadic(op_sws,0,makebreg(nn&15),make_indexed(cnt,SP),NULL);
                                cnt+=8;
***** ..\TABLE888SOURCE\Thor.C
                        if (brrmask & (0x8000 >> nn)) {
                                GenerateTriadic(op_ss|op_sws,0,makebreg(nn&15),make_indexed(cnt,SP),NULL);
                                cnt+=8;
*****

***** Thor.c
        sprintf(buf[ndx], "p%d", predreg);
        if (ap2->mode==am_immed)
            GenerateTriadic(op_cmpi,0,make_string(buf[ndx]),ap1,ap2);
        else
            GenerateTriadic(op_cmp,0,make_string(buf[ndx]),ap1,ap2);
        GeneratePredicatedMonadic(predreg,PredOp(op),op_br,0,make_clabel(label));
}
***** ..\TABLE888SOURCE\Thor.C
        sprintf(buf[ndx], "p%d", predreg);
        GenerateTriadic(op_cmp,0,make_string(buf[ndx]),ap1,ap2);
        GeneratePredicatedMonadic(predreg,PredOp(op),op_bra,0,make_clabel(label));
}
*****

Comparing files TRIM.C and ..\TABLE888SOURCE\TRIM.C
Comparing files W65C816.c and ..\TABLE888SOURCE\W65C816.C
FC: no differences encountered

Comparing files xstoul.c and ..\TABLE888SOURCE\xstoul.C
FC: no differences encountered

Comparing files xtolower.c and ..\TABLE888SOURCE\xtolower.C
FC: no differences encountered

