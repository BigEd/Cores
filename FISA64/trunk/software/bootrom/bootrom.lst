                	; ============================================================================
                	; bootrom.s
                	;        __
                	;   \\__/ o\    (C) 2014  Robert Finch, Stratford
                	;    \  __ /    All rights reserved.
                	;     \/_//     robfinch<remove>@finitron.ca
                	;       ||
                	;  
                	;
                	; This source file is free software: you can redistribute it and/or modify 
                	; it under the terms of the GNU Lesser General Public License as published 
                	; by the Free Software Foundation, either version 3 of the License, or     
                	; (at your option) any later version.                                      
                	;                                                                          
                	; This source file is distributed in the hope that it will be useful,      
                	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                	; GNU General Public License for more details.                             
                	;                                                                          
                	; You should have received a copy of the GNU General Public License        
                	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                	;                                                                          
                	; ============================================================================
                	;
                	TXTCOLS		EQU		84
                	TXTROWS		EQU		31
                	
                	CR	EQU	0x0D		;ASCII equates
                	LF	EQU	0x0A
                	TAB	EQU	0x09
                	CTRLC	EQU	0x03
                	CTRLH	EQU	0x08
                	CTRLI	EQU	0x09
                	CTRLJ	EQU	0x0A
                	CTRLK	EQU	0x0B
                	CTRLM   EQU 0x0D
                	CTRLS	EQU	0x13
                	CTRLX	EQU	0x18
                	XON		EQU	0x11
                	XOFF	EQU	0x13
                	
                	SC_LSHIFT	EQU		$12
                	SC_RSHIFT	EQU		$59
                	SC_KEYUP	EQU		$F0
                	SC_EXTEND	EQU		$E0
                	SC_CTRL		EQU		$14
                	SC_ALT		EQU		$11
                	SC_DEL		EQU		$71		; extend
                	SC_LCTRL	EQU		$58
                	SC_NUMLOCK	EQU		$77
                	SC_SCROLLLOCK	EQU	$7E
                	SC_CAPSLOCK	EQU		$58
                	
                	; Boot sector info (62 byte structure) */
                	BSI_JMP		= 0x00
                	BSI_OEMName	= 0x03
                	BSI_bps		= 0x0B
                	BSI_SecPerCluster	= 0x0D
                	BSI_ResSectors	= 0x0E
                	BSI_FATS	= 0x10
                	BSI_RootDirEnts	= 0x11
                	BSI_Sectors	= 0x13
                	BSI_Media	= 0x15
                	BSI_SecPerFAT	= 0x16
                	BSI_SecPerTrack	= 0x18
                	BSI_Heads	= 0x1A
                	BSI_HiddenSecs	= 0x1C
                	BSI_HugeSecs	= 0x1E
                	
                	BSI_DriveNum	= 0x24
                	BSI_Rsvd1		= 0x25
                	BSI_BootSig		= 0x26
                	BSI_VolID		= 0x27
                	BSI_VolLabel	= 0x2B
                	BSI_FileSysType = 0x36
                	
                	IRQ_STACK   EQU     $8000
                	DBG_STACK   EQU     $7000
                	CPU0_BIOS_STACK  EQU     $6800
                	MON_STACK   EQU     $6000
                	; CPU1 Ram allocations must be to the dram area.
                	CPU1_IRQ_STACK  EQU     $20800
                	CPU1_SYS_STACK      EQU  $21000
                	CPU1_BIOS_STACK     EQU  $21800
                	CPU0_SYS_STACK      EQU  $5000
                	
                	LEDS	equ		$FFDC0600
                	
                	BIOS_FREE      EQU       0
                	BIOS_DONE      EQU       1
                	BIOS_INSERVICE EQU       2
                	
                	MAX_BIOS_CALL  EQU       100
                	E_BadFuncno    EQU       1
                	
                	; The following offsets in the I/O segment
                	TEXTSCR	equ		$00000
                	TEXTREG		EQU		$A0000
                	TEXT_COLS	EQU		0x00
                	TEXT_ROWS	EQU		0x04
                	TEXT_CURPOS	EQU		0x2C
                	TEXT_CURCTL	EQU		0x20
                	
                	BMP_CLUT	EQU		$C5800
                	
                	PIC			EQU		0xFFDC0FC0
                	PIC_IE		EQU		0xFFDC0FC4
                	PIC_ES		EQU		0xFFDC0FD0
                	PIC_RSTE	EQU		0xFFDC0FD4
                	
                	KEYBD		EQU		0xFFDC0000
                	KEYBDCLR	EQU		0xFFDC0004
                	
                	SPIMASTER	EQU		0xFFDC0500
                	SPI_MASTER_VERSION_REG	EQU	0x00
                	SPI_MASTER_CONTROL_REG	EQU	0x04
                	SPI_TRANS_TYPE_REG	EQU		0x08
                	SPI_TRANS_CTRL_REG	EQU		0x0C
                	SPI_TRANS_STATUS_REG	EQU	0x10
                	SPI_TRANS_ERROR_REG		EQU	0x14
                	SPI_DIRECT_ACCESS_DATA_REG		EQU	0x18
                	SPI_SD_SECT_7_0_REG		EQU	0x1C
                	SPI_SD_SECT_15_8_REG	EQU	0x20
                	SPI_SD_SECT_23_16_REG	EQU	0x24
                	SPI_SD_SECT_31_24_REG	EQU	0x28
                	SPI_RX_FIFO_DATA_REG	EQU	0x40
                	SPI_RX_FIFO_DATA_COUNT_MSB	EQU	0x48
                	SPI_RX_FIFO_DATA_COUNT_LSB  EQU 0x4C
                	SPI_RX_FIFO_CTRL_REG		EQU	0x50
                	SPI_TX_FIFO_DATA_REG	EQU	0x80
                	SPI_TX_FIFO_CTRL_REG	EQU	0x90
                	SPI_RESP_BYTE1			EQU	0xC0
                	SPI_RESP_BYTE2			EQU	0xC4
                	SPI_RESP_BYTE3			EQU	0xC8
                	SPI_RESP_BYTE4			EQU	0xCC
                	
                	SPI_INIT_SD			EQU		0x01
                	SPI_TRANS_START		EQU		0x01
                	SPI_TRANS_BUSY		EQU		0x01
                	SPI_INIT_NO_ERROR	EQU		0x00
                	SPI_READ_NO_ERROR	EQU		0x00
                	SPI_WRITE_NO_ERROR	EQU		0x00
                	RW_READ_SD_BLOCK	EQU		0x02
                	RW_WRITE_SD_BLOCK	EQU		0x03
                	
                	I2C_MASTER		EQU		0xFFDC0E00
                	I2C_PRESCALE_LO	EQU		0x00
                	I2C_PRESCALE_HI	EQU		0x01
                	I2C_CONTROL		EQU		0x02
                	I2C_TX			EQU		0x03
                	I2C_RX			EQU		0x03
                	I2C_CMD			EQU		0x04
                	I2C_STAT		EQU		0x04
                	
                	SD_MASTER		EQU		0xFFDC0B00
                	
                	RANDOM_NUM      EQU     0xFFDC0C00
                	
                	UART            EQU     0xFFDC0A00
                	UART_TX         EQU     0
                	UART_RX         EQU     0
                	UART_LS         EQU     1
                	UART_MS         EQU     2
                	UART_IS         EQU     3
                	UART_IE         EQU     4
                	UART_FF         EQU     5
                	UART_MC         EQU     6
                	UART_CTRL       EQU     7
                	UART_CM0        EQU     8
                	UART_CM1        EQU     9
                	UART_CM2        EQU     10
                	UART_CM3        EQU     11
                	UART_SPR        EQU     15
                	
                	TCB_BASE       EQU     $0C00000
                	TCB_TOP        EQU     $1C00000
                	
                	; BIOS request structure
                	BIOS_op        EQU     $00
                	BIOS_arg1      EQU     $08
                	BIOS_arg2      EQU     $10
                	BIOS_arg3      EQU     $18
                	BIOS_arg4      EQU     $20
                	BIOS_arg5      EQU     $28
                	BIOS_resp      EQU     $30
                	BIOS_stat      EQU     $38
                	
                	;include "FMTK_Equates.inc"
                	
                		code
                		org		$00010000
010000 3A 10 00 00 		bra     start
                	BIOS_FuncTable:
010004 00 00 00 00 		align   
                	
010008 74 06 01 00 		dw		ClearScreen		; $8000
01000C 00 00 00 00 
010010 60 06 01 00 		dw		HomeCursor		; $8008
010014 00 00 00 00 
010018 54 07 01 00 		dw		DisplayString	; $8010
01001C 00 00 00 00 
010020 B0 17 01 00 		dw		KeybdGetCharNoWait; $8018
010024 00 00 00 00 
010028 90 00 00 00 		dw		ClearBmpScreen	; $8020
01002C 00 00 00 80 
010030 F0 0B 01 00 		dw		DisplayChar		; $8028
010034 00 00 00 00 
010038 92 00 00 00 		dw		SDInit			; $8030
01003C 00 00 00 80 
010040 93 00 00 00 		dw		SDReadMultiple	; $8038
010044 00 00 00 80 
010048 94 00 00 00 		dw		SDWriteMultiple	; $8040
01004C 00 00 00 80 
010050 95 00 00 00 		dw		SDReadPart		; $8048
010054 00 00 00 80 
010058 96 00 00 00 		dw		SDDiskSize		; $8050
01005C 00 00 00 80 
010060 D4 06 01 00 		dw		DisplayWord		; $8058
010064 00 00 00 00 
010068 E8 06 01 00 		dw		DisplayHalf		; $8060
01006C 00 00 00 00 
010070 FC 06 01 00 		dw		DisplayCharHex	; $8068
010074 00 00 00 00 
010078 10 07 01 00 		dw		DisplayByte		; $8070
01007C 00 00 00 00 
                	message "start"
                	start:
010080 02 00 02 6E 	    sei     ; interrupts off
010084 02 10 00 6C 	    cpuid   r1,r0,#0
010088 BD 00 14 00 	    beq     r1,.0002
01008C 7C C1 00 00 	    ldi     tr,#$C10000          ; IDLE task for CPU #1
010090 0A 80 01 00 
                	.0003:
010094 7C 02 00 00 	    inc     $20000
010098 64 10 00 00 
01009C 46 10 30 07 	    lw      r1,StartCPU1Flag
0100A0 7C 34 12 00 	    cmp     r1,r1,#$12345678
0100A4 86 10 F0 AC 
0100A8 BD 10 F6 FF 	    bne     r1,.0003
0100AC 3E 00 40 07 	    jmp     (StartCPU1Addr)
                	.0002:
0100B0 7C 00 00 00 	    ldi     sp,#MON_STACK        ; set stack pointer to top of 32k Area
0100B4 0A E0 01 C0 
0100B8 7C C0 00 00 		ldi     tr,#$C00000          ; load task register with IDLE task
0100BC 0A 80 01 00 
0100C0 0A 50 00 00 	    ldi     r5,#$0000
0100C4 0A 10 28 00 	    ldi     r1,#20
                	.0001:
0100C8 7C DC FF 00 	    sc      r5,LEDS
0100CC 61 50 00 0C 
0100D0 94 52 02 00 	    addui   r5,r5,#1
0100D4 63 00 10 02 		sw		r0,Milliseconds
0100D8 0A 10 FE FF 		ldi     r1,#-1
0100DC 63 10 10 07 		sw      r1,API_sema
0100E0 63 00 20 07 		sw      r0,BIOS_sema
0100E4 FC 26 00 00 		ldi		r1,#%000000100_110101110_0000000000
0100E8 0A 10 00 70 
0100EC 60 10 78 02 		sb		r1,KeybdEcho
0100F0 60 00 7A 02 		sb		r0,KeybdBad
0100F4 62 10 60 02 		sh		r1,NormAttr
0100F8 60 00 70 02 		sb		r0,CursorRow
0100FC 60 00 72 02 		sb		r0,CursorCol
010100 7C 01 00 00 		ldi		r1,#DisplayChar
010104 0A 10 E0 17 
010108 63 10 20 02 		sw		r1,OutputVec
01010C 39 AD 00 00 		bsr		ClearScreen
010110 39 AA 00 00 		bsr		HomeCursor
010114 7C 01 00 00 		ldi     r1,#msgStart
010118 0A 10 B2 1D 
01011C 39 CD 00 00 		bsr     DisplayStringCRLF
010120 0A 10 10 00 		ldi     r1,#8
010124 7C DC FF 00 		sb      r1,LEDS
010128 60 10 00 0C 
01012C 39 0C 00 00 		bsr		SetupIntVectors
                	;	bsr		KeybdInit
010130 B9 DD 07 00 	    bsr     FMTKInitialize
010134 7C 01 00 00 	    ldi     r1,#UserTickRout     ; set user tick vector
010138 0A 10 30 15 
01013C 7C C0 00 00 	    sw      r1,$C00000
010140 63 10 00 00 
010144 B9 22 00 00 		bsr		InitPIC
010148 B9 25 00 00 		bsr     InitUart
01014C B9 AE 03 00 		bsr     RTCCReadbuf          ; read the real-time clock
010150 39 8D 04 00 		bsr     set_time_serial      ; set the system time serial
010154 3A B4 01 00 		bra		Monitor
010158 B9 D8 07 00 		bsr		FMTKInitialize
01015C 02 00 00 6E 		cli
                	
                	SerialStartMsg:
010160 E7 EF 01 00 	    push    lr
010164 7C 01 00 00 		ldi     r1,#SerialPutChar
010168 0A 10 18 06 
01016C 63 10 20 02 		sw      r1,OutputVec
010170 7C 01 00 00 		ldi     r1,#msgStart
010174 0A 10 B2 1D 
010178 B9 C1 00 00 		bsr     DisplayStringCRLF
01017C 7C 01 00 00 		ldi		r1,#DisplayChar
010180 0A 10 E0 17 
010184 63 10 20 02 		sw		r1,OutputVec
010188 3B FF 11 00 	    rts
 
                	SetupIntVectors:
01018C 0A 10 4E 01 		ldi     r1,#$00A7
010190 7C DC FF 00 		sc      r1,LEDS
010194 61 10 00 0C 
010198 02 00 14 3C 		mtspr   vbr,r0               ; place vector table at $0000
01019C 3F 00 00 00 		nop
0101A0 3F 00 00 00 		nop
0101A4 02 20 14 3E 		mfspr   r2,vbr
0101A8 7C 01 00 00 		ldi		r1,#Tick1024Rout
0101AC 0A 10 90 15 
0101B0 63 11 20 1C 		sw		r1,450*8[r2]
0101B4 7C 01 00 00 		ldi		r1,#TickRout         ; This vector will be taken over by FMTK
0101B8 0A 10 40 12 
0101BC 63 11 30 1C 		sw		r1,451*8[r2]
0101C0 7C 01 00 00 		ldi     r1,#SerialIRQ
0101C4 0A 10 E8 09 
0101C8 63 11 80 1C 		sw      r1,456*8[r2]
0101CC 7C 00 00 00 		ldi     r1,#ServiceRequestIRQ
0101D0 7C 00 00 00 
0101D4 0A 10 70 01 
0101D8 63 11 90 1C 		sw      r1,457*8[r2]
0101DC 7C 01 00 00 		ldi		r1,#KeybdIRQ
0101E0 0A 10 B0 0F 
0101E4 63 11 F0 1C 		sw		r1,463*8[r2]
0101E8 7C 01 00 00 	    ldi     r1,#SSM_ISR          ; set ISR vector for single step routine
0101EC 0A 10 00 46 
0101F0 63 11 F0 1E 	    sw      r1,495*8[r2]
0101F4 7C 01 00 00 	    ldi     r1,#IBPT_ISR         ; set ISR vector for instruction breakpoint routine
0101F8 0A 10 08 46 
0101FC 63 11 00 1F 	    sw      r1,496*8[r2]
010200 7C 01 00 00 		ldi		r1,#exf_rout
010204 0A 10 E8 43 
010208 63 11 10 1F 		sw		r1,497*8[r2]
01020C 7C 01 00 00 		ldi		r1,#dwf_rout
010210 0A 10 58 44 
010214 63 11 20 1F 		sw		r1,498*8[r2]
010218 7C 01 00 00 		ldi		r1,#drf_rout
01021C 0A 10 20 44 
010220 63 11 30 1F 		sw		r1,499*8[r2]
010224 7C 01 00 00 		ldi		r1,#priv_rout
010228 0A 10 90 44 
01022C 63 11 50 1F 		sw		r1,501*8[r2]
010230 7C 01 00 00 		ldi		r1,#berr_rout
010234 0A 10 3E 45 
010238 63 11 C0 1F 		sw		r1,508*8[r2]
01023C 7C 01 00 00 		ldi		r1,#berr_rout
010240 0A 10 3E 45 
010244 63 11 D0 1F 		sw		r1,509*8[r2]
010248 0A 10 54 01 		ldi     r1,#$00AA
01024C 7C DC FF 00 		sc      r1,LEDS
010250 61 10 00 0C 
010254 37 FF 01 00 	    rtl
 
                	;------------------------------------------------------------------------------
                	; Initialize the interrupt controller.
                	;------------------------------------------------------------------------------
                	
                	InitPIC:
010258 0A 10 18 04 		ldi		r1,#$020C		; timer interrupt(s) are edge sensitive
01025C 7C DC FF 00 		sh		r1,PIC_ES
010260 62 10 A0 1F 
010264 0A 10 1E 04 		ldi		r1,#$020F		; enable keyboard reset, timer interrupts
010268 7C DC FF 00 		sh		r1,PIC_IE
01026C 62 10 88 1F 
010270 37 FF 01 00 		rtl

                	
                	;==============================================================================
                	; Serial port
                	;==============================================================================
                		code
                	;------------------------------------------------------------------------------
                	; Initialize UART
                	;------------------------------------------------------------------------------
                	
                	InitUart:
010274 7C DC FF 00 	    ldi     r2,#UART
010278 0A 20 00 14 
                	;    ldi     r1,#$025BF7BA   ; constant for clock multiplier with 16.667MHz clock for 9600 baud
01027C FC 27 0E 00 	    ldi     r1,#$0E27CE61   ; constant for clock multiplier with 16.667MHz clock for 57600 baud
010280 0A 10 C2 9C 
010284 82 10 10 72 	    lsr     r1,r1,#8          ; drop the LSB (not used)
010288 60 11 12 00 	    sb      r1,UART_CM1[r2]
01028C 82 10 10 72 	    lsr     r1,r1,#8
010290 60 11 14 00 	    sb      r1,UART_CM2[r2]
010294 82 10 10 72 	    lsr     r1,r1,#8
010298 60 11 16 00 	    sb      r1,UART_CM3[r2]
01029C 60 01 0E 00 	    sb      r0,UART_CTRL[r2]           ; no hardware flow control
0102A0 61 00 DC 02 		sc		r0,Uart_rxhead			; reset buffer indexes
0102A4 61 00 E0 02 		sc		r0,Uart_rxtail
0102A8 0A 10 E0 03 		ldi		r1,#0x1f0
0102AC 61 10 EC 02 		sc		r1,Uart_foff		; set threshold for XOFF
0102B0 0A 10 20 00 		ldi		r1,#0x010
0102B4 61 10 F0 02 		sc		r1,Uart_fon			; set threshold for XON
0102B8 0A 10 02 00 		ldi		r1,#1
0102BC 60 11 08 00 		sb		r1,UART_IE[r2]		; enable receive interrupt only
0102C0 60 00 E6 02 		sb		r0,Uart_rxrts		; no RTS/CTS signals available
0102C4 60 00 F4 02 		sb		r0,Uart_txrts		; no RTS/CTS signals available
0102C8 60 00 F6 02 		sb		r0,Uart_txdtr		; no DTR signals available
0102CC 60 00 E8 02 		sb		r0,Uart_rxdtr		; no DTR signals available
0102D0 0A 10 02 00 		ldi		r1,#1
0102D4 60 10 F8 02 		sb		r1,Uart_txxon		; for now
0102D8 0A 10 02 00 		ldi		r1,#1
                	;	sb		r1,SERIAL_SEMA
0102DC 37 FF 01 00 	    rtl

                	;---------------------------------------------------------------------------------
                	; Get character directly from serial port. Blocks until a character is available.
                	;---------------------------------------------------------------------------------
                	;
                	SerialGetCharDirect:
                	sgc1:
0102E0 7C DC FF 00 		lb		r1,UART+UART_LS	; uart status
0102E4 40 10 02 14 
0102E8 8C 10 02 00 		and		r1,r1,#1		; is there a char available ?
0102EC BD 00 FA FF 		beq		r1,sgc1
0102F0 7C DC FF 00 		lb		r1,UART+UART_RX
0102F4 40 10 00 14 
0102F8 37 FF 01 00 		rtl

                	;------------------------------------------------
                	; Check for a character at the serial port
                	; returns r1 = 1 if char available, 0 otherwise
                	;------------------------------------------------
                	;
                	SerialCheckForCharDirect:
0102FC 7C DC FF 00 		lb		r1,UART+UART_LS			; uart status
010300 40 10 02 14 
010304 8C 10 02 00 		and		r1,r1,#rxfull			; is there a char available ?
010308 37 FF 01 00 		rtl

                	;-----------------------------------------
                	; Put character to serial port
                	; r1 = char to put
                	;-----------------------------------------
                	;
                	SerialPutChar:
01030C 67 E1 01 00 	    push    r2
010310 E7 E1 01 00 	    push    r3
010314 67 E2 01 00 		push	r4
010318 E7 E2 01 00 		push	r5
01031C 67 E3 01 00 	    push    r6
010320 7C DC FF 00 	    ldi     r6,#UART
010324 0A 60 00 14 
010328 40 23 0C 00 		lb		r2,UART_MC[r6]
01032C 0D 21 06 00 		or		r2,r2,#3		; assert DTR / RTS
010330 60 23 0C 00 		sb		r2,UART_MC[r6]
010334 40 20 F4 02 		lb		r2,Uart_txrts
010338 3D 01 1A 00 		beq		r2,spcb1
01033C 46 40 10 02 		lw		r4,Milliseconds
010340 0A 30 00 08 		ldi		r3,#1024		; delay count (1 s)
                	spcb3:
010344 40 23 04 00 		lb		r2,UART_MS[r6]
010348 0C 21 20 00 		and		r2,r2,#$10		; is CTS asserted ?
01034C 3D 11 10 00 		bne		r2,spcb1
010350 46 50 10 02 		lw		r5,Milliseconds
010354 02 22 0A 0C 		cmp		r2,r4,r5
010358 3D 01 F6 FF 		beq		r2,spcb3
01035C 82 42 00 1A 		mov		r4,r5
010360 95 31 02 00 		subui   r3,r3,#1
010364 BD 11 F0 FF 		bne		r3,spcb3
010368 BA 11 00 00 		bra		spcabort
                	spcb1:
01036C 40 20 F6 02 		lb		r2,Uart_txdtr
010370 3D 01 1A 00 		beq		r2,spcb2
010374 46 40 10 02 		lw		r4,Milliseconds
010378 0A 30 00 08 		ldi		r3,#1024		; delay count
                	spcb4:
01037C 40 23 04 00 		lb		r2,UART_MS[r6]
010380 0C 21 40 00 		and		r2,r2,#$20		; is DSR asserted ?
010384 3D 11 10 00 		bne		r2,spcb2
010388 46 50 10 02 		lw		r5,Milliseconds
01038C 02 22 0A 0C 		cmp		r2,r4,r5
010390 3D 01 F6 FF 		beq		r2,spcb4
010394 82 42 00 1A 		mov		r4,r5
010398 95 31 02 00 		subui   r3,r3,#1
01039C BD 11 F0 FF 		bne		r3,spcb4
0103A0 BA 0A 00 00 		bra		spcabort
                	spcb2:	
0103A4 40 20 F8 02 		lb		r2,Uart_txxon
0103A8 3D 01 0C 00 		beq		r2,spcb5
                	spcb6:
0103AC 40 20 DA 02 		lb		r2,Uart_txxonoff
0103B0 3D 01 08 00 		beq		r2,spcb5
0103B4 40 43 04 00 		lb		r4,UART_MS[r6]
0103B8 0C 42 00 01 		and		r4,r4,#0x80			; DCD ?
0103BC 3D 12 F8 FF 		bne		r4,spcb6
                	spcb5:
0103C0 46 40 10 02 		lw		r4,Milliseconds
0103C4 0A 30 00 08 		ldi		r3,#1024			; wait up to 1s
                	spcb8:
0103C8 40 23 02 00 		lb		r2,UART_LS[r6]
0103CC 0C 21 40 00 		and		r2,r2,#0x20			; tx not full ?
0103D0 3D 11 10 00 		bne		r2,spcb7
0103D4 46 50 10 02 		lw		r5,Milliseconds
0103D8 02 22 0A 0C 		cmp		r2,r4,r5
0103DC 3D 01 F6 FF 		beq		r2,spcb8
0103E0 82 42 00 1A 		mov		r4,r5
0103E4 95 31 02 00 		subui   r3,r3,#1
0103E8 BD 11 F0 FF 		bne		r3,spcb8
0103EC 3A 01 00 00 		bra		spcabort
                	spcb7:
0103F0 60 13 00 00 		sb		r1,UART_TX[r6]
                	spcabort:
0103F4 57 6F 10 00 	    pop     r6
0103F8 57 5F 10 00 		pop		r5
0103FC 57 4F 10 00 		pop		r4
010400 57 3F 10 00 		pop     r3
010404 57 2F 10 00 		pop     r2
010408 37 FF 01 00 		rtl

                	
                	;-------------------------------------------------
                	; Compute number of characters in recieve buffer.
                	; r4 = number of chars
                	;-------------------------------------------------
                	CharsInRxBuf:
01040C 43 40 DC 02 		lcu		r4,Uart_rxhead
010410 43 30 E0 02 		lcu		r3,Uart_rxtail
010414 02 42 06 2A 		subu	r4,r4,r3
010418 3D 22 0A 00 		bgt		r4,cirxb1
01041C 0A 40 00 04 		ldi		r4,#0x200
010420 02 42 06 28 		addu	r4,r4,r3
010424 43 30 DC 02 		lcu		r3,Uart_rxhead
010428 02 42 06 2A 		subu	r4,r4,r3
                	cirxb1:
01042C 37 FF 01 00 		rtl

                	;----------------------------------------------
                	; Get character from rx fifo
                	; If the fifo is empty enough then send an XON
                	;----------------------------------------------
                	;
                	SerialGetChar:
010430 67 E1 01 00 	    push    r2
010434 E7 E1 01 00 	    push    r3
010438 67 E2 01 00 		push	r4
01043C E7 E2 01 00 	    push    r5
010440 7C DC FF 00 	    ldi     r5,#UART
010444 0A 50 00 14 
010448 43 30 DC 02 		lcu		r3,Uart_rxhead
01044C 43 20 E0 02 		lcu		r2,Uart_rxtail
010450 02 31 06 0C 		cmp		r3,r2,r3
010454 BD 01 44 00 		beq		r3,sgcfifo1		    ; is there a char available ?
010458 41 11 FA 02 		lbu		r1,Uart_rxfifo[r2]	; get the char from the fifo into r1
01045C 14 21 02 00 		addui   r2,r2,#1    		; increment the fifo pointer
010460 0C 21 FE 03 		and		r2,r2,#$1ff
010464 61 20 E0 02 		sc		r2,Uart_rxtail
010468 40 20 E4 02 		lb		r2,Uart_rxflow		; using flow control ?
01046C 3D 01 2E 00 		beq		r2,sgcfifo2
010470 43 30 F0 02 		lcu		r3,Uart_fon		; enough space in Rx buffer ?
010474 E7 EF 01 00 		push    lr
010478 B9 F2 FF FF 		bsr		CharsInRxBuf
01047C 57 FF 11 00 		pop     lr
010480 02 42 06 0C 		cmp		r4,r4,r3
010484 3D 22 22 00 		bgt		r4,sgcfifo2
010488 60 00 E4 02 		sb		r0,Uart_rxflow		; flow off
01048C 40 40 E6 02 		lb		r4,Uart_rxrts
010490 3D 02 08 00 		beq		r4,sgcfifo3
010494 C0 42 0C 00 		lb		r4,UART_MC[r5]		; set rts bit in MC
010498 0D 42 04 00 		or		r4,r4,#2
01049C E0 42 0C 00 		sb		r4,UART_MC[r5]
                	sgcfifo3:
0104A0 40 40 E8 02 		lb		r4,Uart_rxdtr
0104A4 3D 02 08 00 		beq		r4,sgcfifo4
0104A8 C0 42 0C 00 		lb		r4,UART_MC[r5]		; set DTR
0104AC 0D 42 02 00 		or		r4,r4,#1
0104B0 E0 42 0C 00 		sb		r4,UART_MC[r5]
                	sgcfifo4:
0104B4 40 40 EA 02 		lb		r4,Uart_rxxon
0104B8 3D 02 08 00 		beq		r4,sgcfifo5
0104BC 0A 40 22 00 		ldi		r4,#XON
0104C0 7C DC FF 00 		sb		r4,UART[r5]
0104C4 E0 42 00 14 
                	sgcfifo5:
                	sgcfifo2:					; return with char in r1
0104C8 57 5F 10 00 	    pop     r5
0104CC 57 4F 10 00 		pop		r4
0104D0 57 3F 10 00 		pop     r3
0104D4 57 2F 10 00 		pop     r2
0104D8 37 FF 01 00 		rtl
sgcfifo1:
0104DC 0A 10 FE FF 		ldi		r1,#-1				; no char available
0104E0 57 5F 10 00 		pop     r5
0104E4 57 4F 10 00 		pop		r4
0104E8 57 3F 10 00 		pop     r3
0104EC 57 2F 10 00 		pop     r2
0104F0 3B FF 11 00 		rts

                	
                	;-----------------------------------------
                	; Serial port IRQ
                	;-----------------------------------------
                	;
                	SerialIRQ:
0104F4 FC 00 00 00 	    ldi     sp,#$8000
0104F8 0A E0 01 00 
0104FC E7 E0 01 00 		push    r1
010500 67 E1 01 00 		push    r2
010504 E7 E1 01 00 		push    r3
010508 67 E2 01 00 		push	r4
                	
01050C 7C DC FF 00 	    ldi     r2,#UART
010510 0A 20 00 14 
010514 40 11 06 00 	    lb      r1,UART_IS[r2]  ; get interrupt status
010518 BD 20 10 00 		bgt		r1,sirq1		; no interrupt
01051C 8C 10 FE 00 		and		r1,r1,#0x7f  	; switch on interrupt type
010520 86 30 08 00 		cmp		r3,r1,#4
010524 BD 01 1C 00 		beq		r3,srxirq
010528 86 30 18 00 		cmp		r3,r1,#$0C
01052C BD 01 16 00 		beq		r3,stxirq
010530 86 30 20 00 		cmp		r3,r1,#$10
010534 BD 01 0C 00 		beq		r3,smsirq
                		; unknown IRQ type
                	sirq1:
010538 57 4F 10 00 		pop		r4
01053C 57 3F 10 00 		pop     r3
010540 57 2F 10 00 		pop     r2
010544 57 1F 10 00 		pop     r1
010548 02 E0 3F 6E 		rti
                	
                	; Get the modem status and record it
                	smsirq:
01054C 41 11 04 00 	    lbu     r1,UART_MS[r2]
010550 60 10 D8 02 		sb      r1,Uart_ms
010554 BA FC FF FF 		bra		sirq1
                	
                	stxirq:
010558 3A FC FF FF 		bra		sirq1
                	
                	; Get a character from the uart and store it in the rx fifo
                	srxirq:
                	srxirq1:
01055C 41 11 00 00 	    lbu     r1,UART_RX[r2]      ; get the char (clears interrupt)
010560 41 30 F8 02 	    lbu     r3,Uart_txxon
010564 BD 01 14 00 		beq		r3,srxirq3
010568 86 40 26 00 		cmp		r4,r1,#XOFF
01056C 3D 12 08 00 		bne		r4,srxirq2
010570 0A 10 02 00 		ldi     r1,#1
010574 60 10 DA 02 		sb		r1,Uart_txxonoff
010578 BA 05 00 00 		bra		srxirq5
                	srxirq2:
01057C 86 40 22 00 		cmp		r4,r1,#XON
010580 3D 12 06 00 		bne		r4,srxirq3
010584 60 00 DA 02 		sb		r0,Uart_txxonoff
010588 BA 03 00 00 		bra		srxirq5
                	srxirq3:
01058C 60 00 DA 02 		sb		r0,Uart_txxonoff
010590 43 40 DC 02 		lcu		r4,Uart_rxhead
010594 60 12 FA 02 		sb		r1,Uart_rxfifo[r4]  ; store in buffer
010598 14 42 02 00 		addui   r4,r4,#1
01059C 0C 42 FE 03 		and		r4,r4,#$1ff
0105A0 61 40 DC 02 		sc		r4,Uart_rxhead
                	srxirq5:
0105A4 40 11 02 00 	    lb      r1,UART_LS[r2]      ; check for another ready character
0105A8 8C 10 02 00 		and		r1,r1,#1            ; check rxfull bit
0105AC BD 10 D8 FF 		bne		r1,srxirq1          ; loop back for another character
0105B0 40 10 E4 02 		lb		r1,Uart_rxflow		; are we using flow controls?
0105B4 BD 10 2E 00 		bne		r1,srxirq8
0105B8 E7 EF 01 00 		push    lr
0105BC 39 CA FF FF 		bsr		CharsInRxBuf
0105C0 57 FF 11 00 		pop     lr
0105C4 40 10 EC 02 		lb		r1,Uart_foff
0105C8 02 12 02 0C 		cmp		r1,r4,r1
0105CC BD 40 22 00 		blt		r1,srxirq8
0105D0 0A 10 02 00 		ldi		r1,#1
0105D4 60 10 E4 02 		sb		r1,Uart_rxflow
0105D8 40 10 E6 02 		lb		r1,Uart_rxrts
0105DC BD 00 08 00 		beq		r1,srxirq6
0105E0 40 11 0C 00 		lb		r1,UART_MC[r2]
0105E4 8C 10 FA 01 		and		r1,r1,#$FD		; turn off RTS
0105E8 60 11 0C 00 		sb		r1,UART_MC[r2]
                	srxirq6:
0105EC 40 10 E8 02 		lb		r1,Uart_rxdtr
0105F0 BD 00 08 00 		beq		r1,srxirq7
0105F4 40 11 0C 00 		lb		r1,UART_MC[r2]
0105F8 8C 10 FC 01 		and		r1,r1,#$FE		; turn off DTR
0105FC 60 11 0C 00 		sb		r1,UART_MC[r2]
                	srxirq7:
010600 40 10 EA 02 		lb		r1,Uart_rxxon
010604 BD 00 06 00 		beq		r1,srxirq8
010608 0A 10 26 00 		ldi		r1,#XOFF
01060C 60 11 00 00 		sb		r1,UART_TX[r2]
                	srxirq8:
010610 3A E5 FF FF 		bra		sirq1
                	
                	
                	
                	;------------------------------------------------------------------------------
                	; Convert ASCII character to screen display character.
                	;------------------------------------------------------------------------------
                	
                	AsciiToScreen:
010614 67 E1 01 00 	    push    r2
010618 8C 10 FE 01 		and		r1,r1,#$FF
01061C 8D 10 00 02 		or		r1,r1,#$100
010620 8C 20 40 00 		and		r2,r1,#%00100000	; if bit 5 or 6 isn't set
010624 3D 01 08 00 		beq		r2,.00001
010628 8C 20 80 00 		and		r2,r1,#%01000000
01062C 3D 01 04 00 		beq		r2,.00001
010630 8C 10 3E 03 		and		r1,r1,#%110011111
                	.00001:
010634 57 2F 10 00 	    pop     r2
010638 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; Convert screen display character to ascii.
                	;------------------------------------------------------------------------------
                	
                	ScreenToAscii:
01063C 67 E1 01 00 	    push    r2
010640 8C 10 FE 01 		and		r1,r1,#$FF
010644 96 20 36 00 		cmpu	r2,r1,#26+1
010648 3D 31 04 00 		bge		r2,.stasc1
01064C 84 10 C0 00 		add		r1,r1,#$60
                	.stasc1:
010650 57 2F 10 00 	    pop     r2
010654 37 FF 01 00 		rtl

                	CursorOff:
010658 37 FF 01 00 		rtl
CursorOn:
01065C 37 FF 01 00 		rtl
HomeCursor:
010660 60 00 70 02 		sb		r0,CursorRow
010664 60 00 72 02 		sb		r0,CursorCol
010668 7C DA FF 00 		sc	    r0,TEXTREG+TEXT_CURPOS+$FFD00000
01066C 61 00 58 00 
010670 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	                                                                               
                	ClearScreen:
010674 E7 EF 01 00 	    push    lr
010678 E7 E0 01 00 	    push	r1
01067C 67 E1 01 00 	    push    r2
010680 E7 E1 01 00 	    push    r3
010684 67 E2 01 00 	    push    r4
010688 7C DA FF 00 		lbu	    r1,TEXTREG+TEXT_COLS+$FFD00000
01068C 41 10 00 00 
010690 7C DA FF 00 		lbu	    r2,TEXTREG+TEXT_ROWS+$FFD00000
010694 41 20 08 00 
010698 02 41 02 2E 		mulu	r4,r2,r1
01069C 7C D0 FF 00 		ldi		r3,#TEXTSCR+$FFD00000
0106A0 0A 30 00 00 
0106A4 0A 10 40 00 		ldi		r1,#' '
0106A8 B9 ED FF FF 		bsr		AsciiToScreen
0106AC 45 20 60 02 		lhu		r2,NormAttr
0106B0 82 10 04 1A 		or		r1,r1,r2
                	.cs1:
0106B4 EA 11 88 00 	    sh	    r1,[r3+r4*4]
0106B8 15 42 02 00 	    subui   r4,r4,#1
0106BC 3D 12 FC FF 		bne	    r4,.cs1
0106C0 57 4F 10 00 		pop     r4
0106C4 57 3F 10 00 		pop     r3
0106C8 57 2F 10 00 		pop     r2
0106CC 57 1F 10 00 		pop     r1
0106D0 3B FF 11 00 	    rts

                	;------------------------------------------------------------------------------
                	; Display the word in r1
                	;------------------------------------------------------------------------------
                	
                	DisplayWord:
0106D4 E7 EF 01 00 	    push    lr
0106D8 82 10 40 74 		rol	    r1,r1,#32
0106DC B9 01 00 00 		bsr		DisplayHalf
0106E0 82 10 40 74 		rol	    r1,r1,#32
0106E4 57 FF 11 00 	    pop     lr
                	
                	;------------------------------------------------------------------------------
                	; Display the half-word in r1
                	;------------------------------------------------------------------------------
                	
                	DisplayHalf:
0106E8 E7 EF 01 00 	    push    lr
0106EC 82 10 20 76 		ror		r1,r1,#16
0106F0 B9 01 00 00 		bsr		DisplayCharHex
0106F4 82 10 20 74 		rol		r1,r1,#16
0106F8 57 FF 11 00 	    pop     lr
                	
                	;------------------------------------------------------------------------------
                	; Display the char in r1
                	;------------------------------------------------------------------------------
                	
                	DisplayCharHex:
0106FC E7 EF 01 00 	    push    lr
010700 82 10 10 76 		ror		r1,r1,#8
010704 B9 01 00 00 		bsr		DisplayByte
010708 82 10 10 74 		rol		r1,r1,#8
01070C 57 FF 11 00 	    pop     lr
                	
                	;------------------------------------------------------------------------------
                	; Display the byte in r1
                	;------------------------------------------------------------------------------
                	
                	DisplayByte:
010710 E7 EF 01 00 	    push    lr
010714 82 10 08 76 		ror		r1,r1,#4
010718 B9 01 00 00 		bsr		DisplayNybble
01071C 82 10 08 74 		rol		r1,r1,#4
010720 57 FF 11 00 		pop     lr
                	 
                	;------------------------------------------------------------------------------
                	; Display nybble in r1
                	;------------------------------------------------------------------------------
                	
                	DisplayNybble:
010724 E7 EF 01 00 	    push    lr
010728 E7 E0 01 00 		push	r1
01072C 67 E1 01 00 		push    r2
010730 8C 10 1E 00 		and		r1,r1,#$0F
010734 94 10 60 00 		addui	r1,r1,#'0'
010738 96 20 74 00 		cmpu	r2,r1,#'9'+1
01073C 3D 41 04 00 		blt		r2,.0001
010740 94 10 0E 00 		addui	r1,r1,#7
                	.0001:
010744 B9 3A 01 00 		bsr		OutChar
010748 57 2F 10 00 		pop     r2
01074C 57 1F 10 00 		pop		r1
010750 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; Display a string pointer to string in r1.
                	;------------------------------------------------------------------------------
                	
                	DisplayString:
010754 E7 EF 01 00 	    push    lr
010758 E7 E0 01 00 		push	r1
01075C 67 E1 01 00 		push    r2
010760 82 20 00 1A 		mov		r2,r1
                	.dm2:
010764 41 11 00 00 		lbu		r1,[r2]
010768 14 21 02 00 		addui   r2,r2,#1	; increment text pointer
01076C BD 00 06 00 		beq		r1,.dm1
010770 39 35 01 00 		bsr		OutChar
010774 3A FE FF FF 		bra		.dm2
                	.dm1:
010778 57 2F 10 00 		pop		r2
01077C 57 1F 10 00 	    pop     r1
010780 3B FF 11 00 		rts

                	DisplayStringCRLF:
010784 E7 EF 01 00 	    push    lr
010788 B9 F9 FF FF 		bsr		DisplayString
01078C 3A 01 00 00 		bra     CRLF1
                	OutCRLF:
                	CRLF:
010790 E7 EF 01 00 	    push    lr
                	CRLF1:
010794 E7 E0 01 00 		push	r1
010798 0A 10 1A 00 		ldi		r1,#CR
01079C B9 2F 01 00 		bsr		OutChar
0107A0 0A 10 14 00 		ldi		r1,#LF
0107A4 B9 2E 01 00 		bsr		OutChar
0107A8 57 1F 10 00 		pop		r1
0107AC 3B FF 11 00 		rts

                	
                	DispCharQ:
0107B0 E7 EF 01 00 	    push    lr
0107B4 39 CC FF FF 		bsr		AsciiToScreen
0107B8 E1 11 00 00 		sc		r1,[r3]
0107BC 84 31 08 00 		add		r3,r3,#4
0107C0 3B FF 11 00 	    rts

                	DispStartMsg:
0107C4 E7 EF 01 00 	    push    lr
0107C8 7C 01 00 00 		ldi		r1,#msgStart
0107CC 0A 10 B2 1D 
0107D0 B9 F0 FF FF 		bsr		DisplayString
0107D4 3B FF 11 00 	    rts

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	KeybdIRQ:
0107D8 7C DC FF 00 		sb		r0,KEYBD+1
0107DC 60 00 02 00 
0107E0 02 E0 3F 6E 		rti
                	
                	BranchToSelf2:
0107E4 3A 00 00 00 	    bra      BranchToSelf2
                	
                	;------------------------------------------------------------------------------
                	; Display a space on the output device.
                	;------------------------------------------------------------------------------
                	
                	DisplaySpace:
0107E8 E7 EF 01 00 	    push     lr
0107EC E7 E0 01 00 	    push     r1
0107F0 0A 10 40 00 	    ldi      r1,#' '
0107F4 B9 24 01 00 	    bsr      OutChar
0107F8 57 1F 10 00 	    pop      r1
0107FC 3B FF 11 00 	    rts

                	;------------------------------------------------------------------------------
                	; 'PRTNUM' prints the 64 bit number in r1, leading blanks are added if
                	; needed to pad the number of spaces to the number in r2.
                	; However, if the number of digits is larger than the no. in
                	; r2, all digits are printed anyway. Negative sign is also
                	; printed and counted in, positive sign is not.
                	;
                	; r1 = number to print
                	; r2 = number of digits
                	; Register Usage
                	;	r5 = number of padding spaces
                	;------------------------------------------------------------------------------
                	PRTNUM:
010800 E7 EF 01 00 	    push    lr
010804 E7 E1 01 00 		push	r3
010808 E7 E2 01 00 		push	r5
01080C 67 E3 01 00 		push	r6
010810 E7 E3 01 00 		push	r7
010814 0A 70 88 02 		ldi		r7,#NUMWKA	; r7 = pointer to numeric work area
010818 82 60 00 1A 		mov		r6,r1		; save number for later
01081C 02 51 00 1A 		mov		r5,r2		; r5 = min number of chars
010820 BD 30 06 00 		bge		r1,PN2			; is it negative? if not
010824 02 10 02 2A 		subu	r1,r0,r1	; else make it positive
010828 95 52 02 00 		subui   r5,r5,#1	; one less for width count
                	PN2:
                	;	ldi		r3,#10
                	PN1:
01082C 89 20 14 00 		mod		r2,r1,#10	; r2 = r1 mod 10
010830 88 10 14 00 		div		r1,r1,#10	; r1 /= 10 divide by 10
010834 04 21 60 00 		add		r2,r2,#'0'	; convert remainder to ascii
010838 E0 23 00 00 		sb		r2,[r7]		; and store in buffer
01083C 94 73 02 00 		addui   r7,r7,#1
010840 95 52 02 00 		subui   r5,r5,#1	; decrement width
010844 BD 10 F4 FF 		bne		r1,PN1
                	PN6:
010848 BD 52 08 00 		ble		r5,PN4		; test pad count, skip padding if not needed
                	PN3:
01084C B9 F3 FF FF 		bsr     DisplaySpace	; display the required leading spaces
010850 95 52 02 00 		subui   r5,r5,#1
010854 BD 12 FC FF 		bne		r5,PN3
                	PN4:
010858 3D 33 06 00 		bge		r6,PN5		; is number negative?
01085C 0A 10 5A 00 		ldi		r1,#'-'		; if so, display the sign
010860 39 17 01 00 		bsr		OutChar
                	PN5:
010864 95 73 02 00 	    subui   r7,r7,#1
010868 C0 13 00 00 		lb		r1,[r7]		; now unstack the digits and display
01086C B9 15 01 00 		bsr		OutChar
010870 86 13 88 02 		cmp		r1,r7,#NUMWKA
010874 BD 20 F8 FF 		bgt		r1,PN5
                	PNRET:
010878 57 7F 10 00 		pop		r7
01087C 57 6F 10 00 		pop		r6
010880 57 5F 10 00 		pop		r5
010884 57 3F 10 00 		pop		r3
010888 3B FF 11 00 		rts

                	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	BIOSCall:
01088C 02 E0 01 6C 	    cpuid   sp,r0,#0
010890 3D 0F 18 00 	    beq     sp,.0005
010894 7C 02 00 00 	    ldi     sp,#CPU1_BIOS_STACK
010898 0A E0 01 30 
01089C 67 E5 01 00 	    push    r10
0108A0 E7 E5 01 00 	    push    r11
0108A4 67 E6 01 00 	    push    r12
0108A8 0A C0 02 00 	    ldi     r12,#1             ; remember the original affinity
                	.0002:
0108AC 61 0C 00 05 	    sc      r0,TCB_Affinity[tr]
                	    ; Now wait for an interrupt. After the task switch interrupt, CPU#0 is
                	    ; the one that would be returning here because of the affinity setting.
                	    ; The BIOS call can be completed then.
0108B0 02 00 06 6E 	    wai
                	
                	    ; Some other interrupt besides a task switch might have happened, so
                	    ; we check if the CPU switched.
0108B4 02 A0 00 6C 	    cpuid   r10,r0,#0
0108B8 3D 15 FA FF 	    bne     r10,.0002
0108BC BA 03 00 00 	    bra     .0006
                	.0005:
0108C0 7C 00 00 00 	    ldi     sp,#CPU0_BIOS_STACK
0108C4 0A E0 01 D0 
0108C8 67 E5 01 00 	    push    r10
0108CC E7 E5 01 00 	    push    r11
0108D0 67 E6 01 00 	    push    r12
0108D4 0A C0 00 00 	    ldi     r12,#0
                	.0006:
0108D8 02 A0 12 3E 	    mfspr   r10,epc             ;
0108DC 44 B5 08 00 	    lh      r11,4[r10]           ; get the function #
0108E0 14 A5 10 00 	    addui   r10,r10,#8
0108E4 02 05 12 3C 	    mtspr   epc,r10
0108E8 86 A5 C8 00 	    cmp     r10,r11,#MAX_BIOS_CALL
0108EC 3D 25 12 7C 	    bgt     r10,.0003
0108F0 82 B5 06 70 	    asl     r11,r11,#3
0108F4 E7 EF 01 00 	    push    lr
0108F8 7C 01 00 00 	    jsr     (BIOS_FuncTable[r11])
0108FC 3E F0 09 00 
010900 57 FF 11 00 	    pop     lr
                	.0004:
010904 61 CC 00 05 	    sc      r12,TCB_Affinity[tr]
010908 57 CF 10 00 	    pop     r12
01090C 57 BF 10 00 	    pop     r11
010910 57 AF 10 00 	    pop     r10
010914 02 E0 3D 6E 	    rte
                	.0003:
010918 0A 10 02 00 	    ldi     r1,#E_BadFuncno
01091C 3A FD FF FF 	    bra     .0004
                	
                	
                	;------------------------------------------------------------------------------
                	; 60 Hz interrupt routine.
                	; Both cpu's will execute this interrupt (necessary for multi-tasking).
                	; Only cpu#0 needs to reset the I/O hardware.
                	;------------------------------------------------------------------------------
                	
                	TickRout:
010920 02 E0 01 6C 	    cpuid   sp,r0,#0
010924 3D 0F 98 00 	    beq     sp,.acknowledgeInterrupt
                	    ; The stacks for the CPUs' must not overlap
010928 7C 02 00 00 	    ldi     sp,#CPU1_IRQ_STACK
01092C 0A E0 01 10 
                	.SaveContext:
                	    ; Do something here that takes a few cycles in order to allow cpu#0 to
                	    ; reset the PIC. Otherwise the IRQ line going high will cause a bounce back
                	    ; to here.
010930 63 1C 10 00 	    sw      r1,TCB_r1[tr]
010934 63 2C 20 00 	    sw      r2,TCB_r2[tr]
010938 63 3C 30 00 	    sw      r3,TCB_r3[tr]
01093C 63 4C 40 00 	    sw      r4,TCB_r4[tr]
010940 63 5C 50 00 	    sw      r5,TCB_r5[tr]
010944 63 6C 60 00 	    sw      r6,TCB_r6[tr]
010948 63 7C 70 00 	    sw      r7,TCB_r7[tr]
01094C 63 8C 80 00 	    sw      r8,TCB_r8[tr]
010950 63 9C 90 00 	    sw      r9,TCB_r9[tr]
010954 63 AC A0 00 	    sw      r10,TCB_r10[tr]
010958 63 BC B0 00 	    sw      r11,TCB_r11[tr]
01095C 63 CC C0 00 	    sw      r12,TCB_r12[tr]
010960 63 DC D0 00 	    sw      r13,TCB_r13[tr]
010964 63 EC E0 00 	    sw      r14,TCB_r14[tr]
010968 63 FC F0 00 	    sw      r15,TCB_r15[tr]
01096C 63 0C 01 01 	    sw      r16,TCB_r16[tr]
010970 63 1C 11 01 	    sw      r17,TCB_r17[tr]
010974 63 2C 21 01 	    sw      r18,TCB_r18[tr]
010978 63 3C 31 01 	    sw      r19,TCB_r19[tr]
01097C 63 4C 41 01 	    sw      r20,TCB_r20[tr]
010980 63 5C 51 01 	    sw      r21,TCB_r21[tr]
010984 63 6C 61 01 	    sw      r22,TCB_r22[tr]
010988 63 7C 71 01 	    sw      r23,TCB_r23[tr]
01098C 63 8C 81 01 	    sw      r24,TCB_r24[tr]
010990 63 9C 91 01 	    sw      r25,TCB_r25[tr]
010994 63 AC A1 01 	    sw      r26,TCB_r26[tr]
010998 63 BC B1 01 	    sw      r27,TCB_r27[tr]
01099C 63 CC C1 01 	    sw      r28,TCB_r28[tr]
0109A0 63 DC D1 01 	    sw      r29,TCB_r29[tr]
0109A4 02 10 1E 3E 	    mfspr   r1,isp
0109A8 63 1C E0 01 	    sw      r1,TCB_r30[tr]
0109AC 63 FC F1 01 	    sw      r31,TCB_r31[tr]
0109B0 02 10 10 3E 	    mfspr   r1,ipc
0109B4 63 1C 00 03 	    sw      r1,TCB_IPC[tr]
0109B8 46 1C 10 00 	    lw      r1,TCB_r1[tr]
                	
0109BC B9 27 00 00 	    bsr     SelectTaskToRun2
0109C0 82 80 01 1A 	    mov     tr,r1
                	
                	    ; Restore the context of the selected task
0109C4 46 1C 00 03 	    lw      r1,TCB_IPC[tr]
0109C8 82 00 10 3C 	    mtspr   ipc,r1
0109CC 46 FC F1 01 	    lw      r31,TCB_r31[tr]
0109D0 46 1C E0 01 	    lw      r1,TCB_r30[tr]
0109D4 82 00 1E 3C 	    mtspr   isp,r1
0109D8 46 DC D1 01 	    lw      r29,TCB_r29[tr]
0109DC 46 CC C1 01 	    lw      r28,TCB_r28[tr]
0109E0 46 BC B1 01 	    lw      r27,TCB_r27[tr]
0109E4 46 AC A1 01 	    lw      r26,TCB_r26[tr]
0109E8 46 9C 91 01 	    lw      r25,TCB_r25[tr]
                	;   lw      r24,TCB_r24[tr]    ; r24 is the task register - no need to load
0109EC 46 7C 71 01 	    lw      r23,TCB_r23[tr]
0109F0 46 6C 61 01 	    lw      r22,TCB_r22[tr]
0109F4 46 5C 51 01 	    lw      r21,TCB_r21[tr]
0109F8 46 4C 41 01 	    lw      r20,TCB_r20[tr]
0109FC 46 3C 31 01 	    lw      r19,TCB_r19[tr]
010A00 46 2C 21 01 	    lw      r18,TCB_r18[tr]
010A04 46 1C 11 01 	    lw      r17,TCB_r17[tr]
010A08 46 0C 01 01 	    lw      r16,TCB_r16[tr]
010A0C 46 FC F0 00 	    lw      r15,TCB_r15[tr]
010A10 46 EC E0 00 	    lw      r14,TCB_r14[tr]
010A14 46 DC D0 00 	    lw      r13,TCB_r13[tr]
010A18 46 CC C0 00 	    lw      r12,TCB_r12[tr]
010A1C 46 BC B0 00 	    lw      r11,TCB_r11[tr]
010A20 46 AC A0 00 	    lw      r10,TCB_r10[tr]
010A24 46 9C 90 00 	    lw      r9,TCB_r9[tr]
010A28 46 8C 80 00 	    lw      r8,TCB_r8[tr]
010A2C 46 7C 70 00 	    lw      r7,TCB_r7[tr]
010A30 46 6C 60 00 	    lw      r6,TCB_r6[tr]
010A34 46 5C 50 00 	    lw      r5,TCB_r5[tr]
010A38 46 4C 40 00 	    lw      r4,TCB_r4[tr]
010A3C 46 3C 30 00 	    lw      r3,TCB_r3[tr]
010A40 46 2C 20 00 	    lw      r2,TCB_r2[tr]
010A44 46 1C 10 00 	    lw      r1,TCB_r1[tr]
010A48 02 E0 3F 6E 	    rti
010A4C 3F 00 00 00 	    nop
010A50 3F 00 00 00 	    nop
                	    
                	.acknowledgeInterrupt:
010A54 FC 00 00 00 	    ldi     sp,#IRQ_STACK       ; set stack pointer to interrupt processing stack
010A58 0A E0 01 00 
010A5C E7 E0 01 00 	    push    r1
010A60 0A 10 06 00 		ldi		r1,#3				; reset the edge sense circuit
010A64 7C DC FF 00 		sh		r1,PIC_RSTE
010A68 62 10 A8 1F 
010A6C 7C D0 FF 00 		lh	    r1,TEXTSCR+220+$FFD00000
010A70 44 10 B8 01 
010A74 94 10 02 00 		addui	r1,r1,#1
010A78 7C D0 FF 00 		sh	    r1,TEXTSCR+220+$FFD00000
010A7C 62 10 B8 01 
010A80 7C 02 00 00 		lw      r1,$20000
010A84 46 10 00 00 
010A88 7C D0 FF 00 		sh      r1,TEXTSCR+224+$FFD00000
010A8C 62 10 C0 01 
010A90 57 1F 10 00 		pop     r1
010A94 BA D3 FF FF 		bra     .SaveContext
                	
                	UserTickRout:
010A98 E7 E0 01 00 	    push    r1
010A9C 7C D0 FF 00 		lh	    r1,TEXTSCR+220+$FFD00000
010AA0 44 10 B8 01 
010AA4 94 10 02 00 		addui	r1,r1,#1
010AA8 7C D0 FF 00 		sh	    r1,TEXTSCR+220+$FFD00000
010AAC 62 10 B8 01 
010AB0 7C 02 00 00 		lw      r1,$20000
010AB4 46 10 00 00 
010AB8 7C D0 FF 00 		sh      r1,TEXTSCR+224+$FFD00000
010ABC 62 10 C0 01 
010AC0 57 1F 10 00 		pop     r1
010AC4 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	; 1024Hz interupt routine. This must be fast. Allows the system time to be
                	; gotten by right shifting by 10 bits.
                	;------------------------------------------------------------------------------
                	
                	Tick1024Rout:
010AC8 02 E0 01 6C 	    cpuid   sp,r0,#0
010ACC 3D 0F 04 00 	    beq     sp,.0001
010AD0 02 E0 3F 6E 	    rti                         ; nothing for cpu >0 to do here
                	.0001:
010AD4 FC 00 00 00 	    ldi     sp,#$8000           ; set stack pointer to interrupt processing stack
010AD8 0A E0 01 00 
010ADC E7 E0 01 00 		push	r1
010AE0 0A 10 04 00 		ldi		r1,#2				; reset the edge sense circuit
010AE4 7C DC FF 00 		sh		r1,PIC_RSTE
010AE8 62 10 A8 1F 
010AEC 64 10 10 02 		inc     Milliseconds
010AF0 57 1F 10 00 		pop		r1
010AF4 02 E0 3F 6E 		rti                         ; restore stack pointer and return
                	
                	;------------------------------------------------------------------------------
                	; For now, just pick one at random.
                	;------------------------------------------------------------------------------
                	SelectTaskToRun2:
010AF8 02 1C 00 1A 	    mov     r1,tr             ; stay in the same task for now
010AFC 37 FF 01 00 	    rtl
    lw      r1,RANDOM_NUM
010B00 7C DC FF 00 
010B04 46 10 00 18 
010B08 02 20 00 6C 	    cpuid   r2,r0,#0
010B0C 3D 01 0E 00 	    beq     r2,.0001
010B10 8C 10 3E 00 	    and     r1,r1,#$1F
010B14 8D 10 02 00 	    or      r1,r1,#1         ; make sure it's an odd task for CPU1
010B18 82 10 20 70 	    asl     r1,r1,#16
010B1C 7C C0 00 00 	    addui   r1,r1,#$C00000
010B20 94 10 00 00 
010B24 37 FF 01 00 	    rtl    
.0001:
010B28 8C 10 3C 00 	    and     r1,r1,#$1E       ; make sure it's an even task for CPU0
010B2C 82 10 20 70 	    asl     r1,r1,#16
010B30 7C C0 00 00 	    addui   r1,r1,#$C00000
010B34 94 10 00 00 
010B38 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	; GetSystemTime
                	;
                	; Returns 
                	;    r1 = the system time in seconds.
                	;------------------------------------------------------------------------------
                	
                	GetSystemTime:
010B3C 46 10 10 02 	    lw      r1,Milliseconds
010B40 82 10 14 72 	    lsr     r1,r1,#10
010B44 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	GetScreenLocation:
010B48 7C D0 FF 00 		ldi		r1,#TEXTSCR+$FFD00000
010B4C 0A 10 00 00 
010B50 37 FF 01 00 		rtl
GetCurrAttr:
010B54 45 10 60 02 		lhu		r1,NormAttr
010B58 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	UpdateCursorPos:
010B5C E7 EF 01 00 	    push    lr
010B60 E7 E0 01 00 		push	r1
010B64 67 E1 01 00 		push    r2
010B68 67 E2 01 00 		push    r4
010B6C 41 10 70 02 		lbu		r1,CursorRow
010B70 8C 10 7E 00 		and		r1,r1,#$3f
010B74 7C DA FF 00 		lbu	    r2,TEXTREG+TEXT_COLS+$FFD00000
010B78 41 20 00 00 
010B7C 02 21 02 2E 		mulu	r2,r2,r1
010B80 41 10 72 02 		lbu		r1,CursorCol
010B84 8C 10 FE 00 		and		r1,r1,#$7f
010B88 02 21 02 28 		addu	r2,r2,r1
010B8C 7C DA FF 00 		sc	    r2,TEXTREG+TEXT_CURPOS+$FFD00000
010B90 61 20 58 00 
010B94 57 4F 10 00 		pop		r4
010B98 57 2F 10 00 	    pop     r2
010B9C 57 1F 10 00 	    pop     r1
010BA0 3B FF 11 00 	    rts
	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	CalcScreenLoc:
010BA4 E7 EF 01 00 	    push    lr
010BA8 67 E1 01 00 		push	r2
010BAC 67 E2 01 00 		push    r4
010BB0 41 10 70 02 		lbu		r1,CursorRow
010BB4 8C 10 7E 00 		and		r1,r1,#$3f
010BB8 7C DA FF 00 		lbu	    r2,TEXTREG+TEXT_COLS+$FFD00000
010BBC 41 20 00 00 
010BC0 02 21 02 2E 		mulu	r2,r2,r1
010BC4 41 10 72 02 		lbu		r1,CursorCol
010BC8 8C 10 FE 00 		and		r1,r1,#$7f
010BCC 02 21 02 28 		addu	r2,r2,r1
010BD0 7C DA FF 00 		sc	    r2,TEXTREG+TEXT_CURPOS+$FFD00000
010BD4 61 20 58 00 
010BD8 39 EE FF FF 		bsr		GetScreenLocation
010BDC 02 21 04 70 		shl		r2,r2,#2
010BE0 82 10 04 28 		addu	r1,r1,r2
010BE4 57 4F 10 00 		pop		r4
010BE8 57 2F 10 00 	    pop     r2
010BEC 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	DisplayChar:
010BF0 E7 EF 01 00 	    push    lr
010BF4 E7 E0 01 00 		push	r1
010BF8 67 E1 01 00 	    push    r2
010BFC E7 E1 01 00 	    push    r3
010C00 67 E2 01 00 	    push    r4
010C04 8C 10 FE 01 		and		r1,r1,#$FF
010C08 86 20 1A 00 		cmp		r2,r1,#'\r'
010C0C 3D 01 42 00 		beq		r2,.docr
010C10 86 20 22 01 		cmp		r2,r1,#$91		; cursor right ?
010C14 3D 01 44 00 		beq		r2,.doCursorRight
010C18 86 20 20 01 		cmp		r2,r1,#$90		; cursor up ?
010C1C 3D 01 4E 00 		beq		r2,.doCursorUp
010C20 86 20 26 01 		cmp		r2,r1,#$93		; cursor left ?
010C24 3D 01 54 00 		beq		r2,.doCursorLeft
010C28 86 20 24 01 		cmp		r2,r1,#$92		; cursor down ?
010C2C 3D 01 5A 00 		beq		r2,.doCursorDown
010C30 86 20 28 01 		cmp		r2,r1,#$94		; cursor home ?
010C34 3D 01 62 00 		beq		r2,.doCursorHome
010C38 86 20 32 01 		cmp		r2,r1,#$99		; delete ?
010C3C 3D 01 6A 00 		beq		r2,.doDelete
010C40 86 20 10 00 		cmp		r2,r1,#CTRLH	; backspace ?
010C44 3D 01 6E 00 		beq		r2,.doBackspace
010C48 86 20 14 00 		cmp		r2,r1,#'\n'	; line feed ?
010C4C 3D 01 92 00 		beq		r2,.doLinefeed
010C50 82 20 00 1A 		mov		r2,r1
010C54 39 EA FF FF 		bsr		CalcScreenLoc
010C58 82 30 00 1A 		mov		r3,r1
010C5C 02 11 00 1A 		mov		r1,r2
010C60 B9 36 FF FF 		bsr		AsciiToScreen
010C64 82 20 00 1A 		mov		r2,r1
010C68 B9 DD FF FF 		bsr		GetCurrAttr
010C6C 82 10 04 1A 		or		r1,r1,r2
010C70 E2 11 00 00 		sh	    r1,[r3]
010C74 B9 20 00 00 		bsr		IncCursorPos
                	.dcx4:
010C78 57 4F 10 00 		pop		r4
010C7C 57 3F 10 00 	    pop     r3
010C80 57 2F 10 00 	    pop     r2
010C84 57 1F 10 00 	    pop     r1
010C88 57 FF 11 00 	    pop     lr
010C8C 37 FF 01 00 		rtl
.docr:
010C90 60 00 72 02 		sb		r0,CursorCol
010C94 39 D9 FF FF 		bsr		UpdateCursorPos
010C98 3A FC FF FF 		bra     .dcx4
                	.doCursorRight:
010C9C 41 10 72 02 		lbu		r1,CursorCol
010CA0 84 10 02 00 		add		r1,r1,#1
010CA4 96 20 A8 00 		cmpu	r2,r1,#TXTCOLS
010CA8 3D 31 04 00 		bge		r2,.dcx7
010CAC 60 10 72 02 		sb		r1,CursorCol
                	.dcx7:
010CB0 B9 D5 FF FF 		bsr		UpdateCursorPos
010CB4 BA F8 FF FF 		bra     .dcx4
                	.doCursorUp:
010CB8 41 10 70 02 		lbu		r1,CursorRow
010CBC BD 00 FA FF 		beq		r1,.dcx7
010CC0 85 10 02 00 		sub		r1,r1,#1
010CC4 60 10 70 02 		sb		r1,CursorRow
010CC8 3A FD FF FF 		bra		.dcx7
                	.doCursorLeft:
010CCC 41 10 72 02 		lbu		r1,CursorCol
010CD0 BD 00 F0 FF 		beq		r1,.dcx7
010CD4 85 10 02 00 		sub		r1,r1,#1
010CD8 60 10 72 02 		sb		r1,CursorCol
010CDC BA FA FF FF 		bra		.dcx7
                	.doCursorDown:
010CE0 41 10 70 02 		lbu		r1,CursorRow
010CE4 84 10 02 00 		add		r1,r1,#1
010CE8 96 20 3E 00 		cmpu	r2,r1,#TXTROWS
010CEC 3D 31 E2 FF 		bge		r2,.dcx7
010CF0 60 10 70 02 		sb		r1,CursorRow
010CF4 BA F7 FF FF 		bra		.dcx7
                	.doCursorHome:
010CF8 41 10 72 02 		lbu		r1,CursorCol
010CFC BD 00 06 00 		beq		r1,.dcx12
010D00 60 00 72 02 		sb		r0,CursorCol
010D04 BA F5 FF FF 		bra		.dcx7
                	.dcx12:
010D08 60 00 70 02 		sb		r0,CursorRow
010D0C BA F4 FF FF 		bra		.dcx7
                	.doDelete:
010D10 B9 D2 FF FF 		bsr		CalcScreenLoc
010D14 82 30 00 1A 		mov		r3,r1
010D18 41 10 72 02 		lbu		r1,CursorCol
010D1C 3A 04 00 00 		bra		.dcx5
                	.doBackspace:
010D20 41 10 72 02 		lbu		r1,CursorCol
010D24 BD 00 AA FF 		beq		r1,.dcx4
010D28 85 10 02 00 		sub		r1,r1,#1
010D2C 60 10 72 02 		sb		r1,CursorCol
010D30 B9 CE FF FF 		bsr		CalcScreenLoc
010D34 82 30 00 1A 		mov		r3,r1
010D38 41 10 72 02 		lbu		r1,CursorCol
                	.dcx5:
010D3C C5 21 08 00 		lhu	    r2,4[r3]
010D40 E2 21 00 00 		sh	    r2,[r3]
010D44 84 31 08 00 		add		r3,r3,#4
010D48 84 10 02 00 		add		r1,r1,#1
010D4C 96 20 A8 00 		cmpu	r2,r1,#TXTCOLS
010D50 3D 41 F6 FF 		blt		r2,.dcx5
010D54 0A 10 40 00 		ldi		r1,#' '
010D58 B9 17 FF FF 		bsr		AsciiToScreen
010D5C 45 20 60 02 		lhu		r2,NormAttr
010D60 82 10 04 1A 		or		r1,r1,r2
010D64 85 31 08 00 		sub		r3,r3,#4
010D68 E2 11 00 00 		sh	    r1,[r3]
010D6C BA E1 FF FF 		bra		.dcx4
                	.doLinefeed:
010D70 B9 06 00 00 		bsr		IncCursorRow
010D74 BA E0 FF FF 		bra		.dcx4
                	
                	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	IncCursorPos:
010D78 E7 EF 01 00 	    push    lr
010D7C E7 E0 01 00 		push	r1
010D80 67 E1 01 00 	    push    r2
010D84 67 E2 01 00 	    push    r4
010D88 41 10 72 02 		lbu		r1,CursorCol
010D8C 94 10 02 00 		addui	r1,r1,#1
010D90 60 10 72 02 		sb		r1,CursorCol
010D94 96 20 A8 00 		cmpu	r2,r1,#TXTCOLS
010D98 3D 41 1E 00 		blt		r2,icc1
010D9C 60 00 72 02 		sb		r0,CursorCol
010DA0 BA 02 00 00 		bra		icr1
                	IncCursorRow:
010DA4 E7 EF 01 00 	    push    lr
010DA8 E7 E0 01 00 		push	r1
010DAC 67 E1 01 00 	    push    r2
010DB0 67 E2 01 00 	    push    r4
                	icr1:
010DB4 41 10 70 02 		lbu		r1,CursorRow
010DB8 94 10 02 00 		addui	r1,r1,#1
010DBC 60 10 70 02 		sb		r1,CursorRow
010DC0 96 20 3E 00 		cmpu	r2,r1,#TXTROWS
010DC4 3D 41 08 00 		blt		r2,icc1
010DC8 0A 20 3C 00 		ldi		r2,#TXTROWS-1
010DCC 60 20 70 02 		sb		r2,CursorRow
010DD0 B9 04 00 00 		bsr		ScrollUp
                	icc1:
010DD4 3F 00 00 00 	    nop
010DD8 3F 00 00 00 	    nop
010DDC 39 B0 FF FF 		bsr		UpdateCursorPos
010DE0 57 4F 10 00 		pop		r4
010DE4 57 2F 10 00 	    pop     r2
010DE8 57 1F 10 00 	    pop     r1
010DEC 57 FF 11 00 		pop     lr
010DF0 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	ScrollUp:
010DF4 E7 EF 01 00 	    push    lr
010DF8 E7 E0 01 00 		push	r1
010DFC 67 E1 01 00 	    push    r2
010E00 E7 E1 01 00 	    push    r3
010E04 E7 E2 01 00 	    push    r5
010E08 67 E3 01 00 		push	r6
010E0C 7C DA FF 00 		lbu	    r1,TEXTREG+TEXT_COLS+$FFD00000
010E10 41 10 00 00 
010E14 7C DA FF 00 		lbu	    r2,TEXTREG+TEXT_ROWS+$FFD00000
010E18 41 20 08 00 
010E1C 15 21 02 00 		subui	r2,r2,#1
010E20 82 60 04 2E 		mulu	r6,r1,r2
010E24 7C D0 FF 00 		ldi		r1,#TEXTSCR+$FFD00000
010E28 0A 10 00 00 
010E2C 7C D0 FF 00 		ldi		r2,#TEXTSCR+TXTCOLS*4+$FFD00000
010E30 0A 20 A0 02 
010E34 0A 30 00 00 		ldi		r3,#0
                	.0001:
010E38 4C 51 86 00 		lh	    r5,[r2+r3*4]
010E3C EA 50 86 00 		sh	    r5,[r1+r3*4]
010E40 94 31 02 00 		addui	r3,r3,#1
010E44 15 63 02 00 		subui   r6,r6,#1
010E48 3D 13 F8 FF 		bne	    r6,.0001
010E4C 7C DA FF 00 		lbu	    r1,TEXTREG+TEXT_ROWS+$FFD00000
010E50 41 10 08 00 
010E54 95 10 02 00 		subui	r1,r1,#1
010E58 39 04 00 00 		bsr		BlankLine
010E5C 57 6F 10 00 		pop		r6
010E60 57 5F 10 00 		pop		r5
010E64 57 3F 10 00 	    pop     r3
010E68 57 2F 10 00 	    pop     r2
010E6C 57 1F 10 00 	    pop     r1
010E70 57 FF 11 00 		pop     lr
010E74 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; Blank out a line on the screen.
                	;
                	; Parameters:
                	;	r1 = line number to blank out
                	;------------------------------------------------------------------------------
                	
                	BlankLine:
010E78 E7 EF 01 00 	    push    lr
010E7C E7 E0 01 00 		push	r1
010E80 67 E1 01 00 	    push    r2
010E84 E7 E1 01 00 	    push    r3
010E88 67 E2 01 00 	    push    r4
010E8C 7C DA FF 00 	    lbu     r2,TEXTREG+TEXT_COLS+$FFD00000
010E90 41 20 00 00 
010E94 02 31 02 2E 		mulu	r3,r2,r1
                	;	subui	r2,r2,#1		; r2 = #chars to blank - 1
010E98 82 31 04 70 		shl		r3,r3,#2
010E9C 7C D0 FF 00 		addui	r3,r3,#TEXTSCR+$FFD00000
010EA0 94 31 00 00 
010EA4 0A 10 40 00 		ldi		r1,#' '
010EA8 B9 ED FE FF 		bsr		AsciiToScreen
010EAC 45 40 60 02 		lhu		r4,NormAttr
010EB0 82 10 08 1A 		or		r1,r1,r4
                	.0001:
010EB4 EA 11 84 00 		sh	    r1,[r3+r2*4]
010EB8 15 21 02 00 		subui   r2,r2,#1
010EBC 3D 11 FC FF 		bne	    r2,.0001
010EC0 57 4F 10 00 		pop		r4
010EC4 57 3F 10 00 	    pop     r3
010EC8 57 2F 10 00 	    pop     r2
010ECC 57 1F 10 00 	    pop     r1
010ED0 57 FF 11 00 		pop     lr
010ED4 37 FF 01 00 		rtl

010ED8 00          		db	0
                	msgStart:
010ED9 46 49 53 41 		db	"FISA64 test system starting.",0
010EDD 36 34 20 74 
010EE1 65 73 74 20 
010EE5 73 79 73 74 
010EE9 65 6D 20 73 
010EED 74 61 72 74 
010EF1 69 6E 67 2E 
010EF5 00          
                	
                	
                	; ============================================================================
                	; Monitor Task
                	; ============================================================================
                	
                	Monitor:
010EF6 00 00 0A 10 		ldi		r1,#49
010EFA 62 00       
010EFC 7C DC FF 00 		sc		r1,LEDS
010F00 61 10 00 0C 
                	;	bsr		ClearScreen
                	;	bsr		HomeCursor
010F04 7C 01 00 00 		ldi		r1,#msgMonitorStarted
010F08 0A 10 7A 2A 
010F0C 39 0F FF FF 		bsr		DisplayStringCRLF
010F10 60 00 78 02 		sb		r0,KeybdEcho
                		;ldi		r1,#7
                		;ldi		r2,#0
                		;ldi		r3,#IdleTask
                		;ldi		r4,#0
                		;ldi		r5,#0
                		;bsr		StartTask
                	mon1:
010F14 0A 10 64 00 		ldi		r1,#50
010F18 7C DC FF 00 		sc		r1,LEDS
010F1C 61 10 00 0C 
                	;	ldi		sp,#TCBs+TCB_Size-8		; reload the stack pointer, it may have been trashed
010F20 7C 00 00 00 		ldi		sp,#MON_STACK
010F24 0A E0 01 C0 
010F28 02 00 00 6E 		cli
                	.PromptLn:
010F2C B9 0C FF FF 		bsr		CRLF
010F30 0A 10 48 00 		ldi		r1,#'$'
010F34 B9 3C 00 00 		bsr		OutChar
                	.Prompt3:
010F38 39 0F 01 00 		bsr		KeybdGetCharNoWait		; KeybdGetCharDirectNB
010F3C BD 40 FE FF 		blt	    r1,.Prompt3
010F40 86 20 1A 00 		cmp		r2,r1,#CR
010F44 3D 01 06 00 		beq		r2,.Prompt1
010F48 39 3A 00 00 		bsr		OutChar
010F4C BA FD FF FF 		bra		.Prompt3
                	.Prompt1:
010F50 60 00 72 02 		sb		r0,CursorCol
010F54 39 8A FF FF 		bsr		CalcScreenLoc
010F58 82 30 00 1A 		mov		r3,r1
010F5C B9 0F 00 00 		bsr		MonGetch
010F60 86 20 48 00 		cmp		r2,r1,#'$'
010F64 3D 11 04 00 		bne		r2,.Prompt2
010F68 39 0E 00 00 		bsr		MonGetch
                	.Prompt2:
010F6C 86 20 7E 00 		cmp		r2,r1,#'?'
010F70 3D 01 2C 00 		beq		r2,.doHelp
010F74 86 20 86 00 		cmp		r2,r1,#'C'
010F78 3D 01 EA 02 		beq		r2,doCLS
010F7C 86 20 C6 00 		cmp     r2,r1,#'c'
010F80 3D 01 EE 78 		beq     r2,doCS
010F84 86 20 9A 00 		cmp		r2,r1,#'M'
010F88 3D 01 64 00 		beq		r2,doDumpmem
010F8C 86 20 8C 00 		cmp		r2,r1,#'F'
010F90 3D 01 70 00 		beq		r2,doFillmem
010F94 86 20 DA 00 		cmp		r2,r1,#'m'
010F98 3D 01 E2 78 		beq		r2,MRTest
010F9C 86 20 A6 00 		cmp		r2,r1,#'S'
010FA0 3D 01 AA 00 		beq		r2,doSDBoot
010FA4 86 20 CE 00 		cmp		r2,r1,#'g'
010FA8 3D 01 DC 78 		beq		r2,doRand
010FAC 86 20 CA 00 		cmp		r2,r1,#'e'
010FB0 3D 01 D8 78 		beq		r2,eval
010FB4 86 20 94 00 		cmp		r2,r1,#'J'
010FB8 3D 01 B2 00 		beq		r2,doJump
010FBC 86 20 88 00 		cmp		r2,r1,#'D'
010FC0 3D 01 34 01 		beq		r2,doDate
010FC4 3A EA FF FF 		bra     mon1
                	
                	.doHelp:
010FC8 7C 01 00 00 		ldi		r1,#msgHelp
010FCC 0A 10 68 29 
010FD0 B9 F0 FE FF 		bsr		DisplayString
010FD4 3A E8 FF FF 		bra     mon1
                	
                	MonGetch:
010FD8 E7 EF 01 00 	    push    lr
010FDC C5 11 00 00 		lhu	    r1,[r3]
010FE0 8C 10 FE 03 		andi	r1,r1,#$1FF
010FE4 84 31 08 00 		add		r3,r3,#4
010FE8 B9 CA FE FF 		bsr		ScreenToAscii
010FEC 57 FF 11 00 		pop     lr
010FF0 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; Ignore blanks in the input
                	; r3 = text pointer
                	; r1 destroyed
                	;------------------------------------------------------------------------------
                	
                	ignBlanks:
010FF4 E7 EF 01 00 	    push    lr
010FF8 67 E1 01 00 	    push    r2
                	ignBlanks1:
010FFC B9 FB FF FF 		bsr		MonGetch
011000 86 20 40 00 		cmp		r2,r1,#' '
011004 3D 01 FC FF 		beq		r2,ignBlanks1
011008 85 31 08 00 		sub		r3,r3,#4
01100C 57 2F 10 00 		pop     r2
011010 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	GetTwoParams:
011014 E7 EF 01 00 	    push    lr
011018 B9 FB FF FF 		bsr		ignBlanks
01101C B9 7A 00 00 		bsr		GetHexNumber	; get start address of dump
011020 82 20 00 1A 		mov		r2,r1
011024 39 FA FF FF 		bsr		ignBlanks
011028 39 79 00 00 		bsr		GetHexNumber	; get end address of dump
01102C 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; Get a range, the end must be greater or equal to the start.
                	;------------------------------------------------------------------------------
                	
                	GetRange:
011030 E7 EF 01 00 	    push    lr
011034 67 E2 01 00 	    push    r4
011038 B9 FB FF FF 		bsr		GetTwoParams
01103C 02 41 02 2C 		cmpu	r4,r2,r1
011040 3D 22 2E 02 		bgt		r4,DisplayErr
011044 57 4F 10 00 		pop     r4
011048 57 FF 11 00 		pop     lr
01104C 37 FF 01 00 		rtl

                	doDumpmem:
011050 39 C1 FE FF 		bsr		CursorOff
011054 B9 FB FF FF 		bsr		GetRange
011058 39 E7 FE FF 		bsr		CRLF
                	;	bra     mon1
                	.001:
01105C 39 64 00 00 		bsr		CheckKeys
011060 B9 4B 00 00 		bsr		DisplayMemBytes
011064 02 41 02 2C 		cmpu	r4,r2,r1
011068 3D 52 FA FF 		ble		r4,.001
01106C 3A D5 FF FF 		bra     mon1
                	
                	;------------------------------------------------------------------------------
                	; Fill memory
                	;
                	; FB FFD80000 FFD8FFFF r	; fill sprite memory with random bytes
                	;------------------------------------------------------------------------------
                	
                	doFillmem:
011070 39 BD FE FF 		bsr		CursorOff
011074 B9 EC FF FF 		bsr		MonGetch		; skip over 'B' of "FB"
011078 86 20 84 00 		cmp		r2,r1,#'B'
01107C 3D 01 04 00 		beq		r2,.0004
011080 95 31 08 00 		subui	r3,r3,#4		; backup text pointer
                	.0004:
011084 B9 F5 FF FF 		bsr		GetRange
011088 E7 E0 01 00 		push	r1
01108C 67 E1 01 00 	    push    r2
011090 B9 EC FF FF 		bsr		ignBlanks
011094 B9 E8 FF FF 		bsr		MonGetch		; check for random fill
011098 86 20 E4 00 		cmp		r2,r1,#'r'
01109C 3D 01 18 00 		beq		r2,.0001
0110A0 95 31 08 00 		subui   r3,r3,#4
0110A4 B9 69 00 00 		bsr		GetHexNumber
0110A8 82 30 00 1A 		mov		r3,r1
0110AC 57 2F 10 00 		pop		r2
0110B0 57 1F 10 00 	    pop     r1
                	.0002:
0110B4 39 59 00 00 		bsr		CheckKeys
0110B8 60 31 00 00 		sb		r3,[r2]
0110BC 14 21 02 00 		addui	r2,r2,#1
0110C0 02 51 02 2C 		cmpu	r5,r2,r1
0110C4 BD 42 F8 FF 		blt		r5,.0002
0110C8 BA C9 FF FF 		bra		mon1
                	.0001:
0110CC 57 2F 10 00 		pop		r2
0110D0 57 1F 10 00 	    pop     r1
                	.0003:
0110D4 39 55 00 00 		bsr		CheckKeys
0110D8 7C DC FF 00 		lw	    r3,RANDOM_NUM
0110DC 46 30 00 18 
0110E0 60 31 00 00 		sb		r3,[r2]
0110E4 14 21 02 00 		addui	r2,r2,#1
0110E8 02 51 02 2C 		cmpu	r5,r2,r1
0110EC BD 42 F4 FF 		blt		r5,.0003
0110F0 BA C4 FF FF 		bra		mon1
                	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	doSDBoot:
                	;	sub		r3,r3,#4
0110F4 B9 F3 DD FF 		bsr		SDInit
0110F8 BD 10 0E FF 		bne	    r1,mon1
0110FC 39 F3 DD FF 		bsr		SDReadPart
011100 BD 10 0A FF 		bne	    r1,mon1
011104 B9 0D DE FF 		bsr		SDReadBoot
011108 BD 10 06 FF 		bne	    r1,mon1
01110C 39 0D DE FF 		bsr		loadBootFile
011110 7C 00 00 00 		jmp		mon1
011114 3C 00 8A 87 
                	
                	OutChar:
011118 3E 00 20 02 	    jmp     (OutputVec)
                	
                	;------------------------------------------------------------------------------
                	; Jump to subroutine
                	;
                	; J 10000     ; restart system
                	;------------------------------------------------------------------------------
                	
                	doJump:
01111C B9 D7 FF FF 		bsr		MonGetch		; skip over 'S'
011120 B9 DA FF FF 		bsr		ignBlanks
011124 B9 59 00 00 		bsr		GetHexNumber
011128 63 10 40 02 		sw      r1,jmp_vector
01112C 46 F0 01 02 	    lw      r31,MON_r31
011130 46 E0 F1 01 	    lw      r30,MON_r30
011134 46 D0 E1 01 	    lw      r29,MON_r29
011138 46 C0 D1 01 	    lw      r28,MON_r28
01113C 46 B0 C1 01 	    lw      r27,MON_r27
011140 46 A0 B1 01 	    lw      r26,MON_r26
011144 46 90 A1 01 	    lw      r25,MON_r25
                	;   lw      r24,MON_r24    ; r24 is the task register - no need to load
011148 46 70 81 01 	    lw      r23,MON_r23
01114C 46 60 71 01 	    lw      r22,MON_r22
011150 46 50 61 01 	    lw      r21,MON_r21
011154 46 40 51 01 	    lw      r20,MON_r20
011158 46 30 41 01 	    lw      r19,MON_r19
01115C 46 20 31 01 	    lw      r18,MON_r18
011160 46 10 21 01 	    lw      r17,MON_r17
011164 46 00 11 01 	    lw      r16,MON_r16
011168 46 F0 00 01 	    lw      r15,MON_r15
01116C 46 E0 F0 00 	    lw      r14,MON_r14
011170 46 D0 E0 00 	    lw      r13,MON_r13
011174 46 C0 D0 00 	    lw      r12,MON_r12
011178 46 B0 C0 00 	    lw      r11,MON_r11
01117C 46 A0 B0 00 	    lw      r10,MON_r10
011180 46 90 A0 00 	    lw      r9,MON_r9
011184 46 80 90 00 	    lw      r8,MON_r8
011188 46 70 80 00 	    lw      r7,MON_r7
01118C 46 60 70 00 	    lw      r6,MON_r6
011190 46 50 60 00 	    lw      r5,MON_r5
011194 46 40 50 00 	    lw      r4,MON_r4
011198 46 30 40 00 	    lw      r3,MON_r3
01119C 46 20 30 00 	    lw      r2,MON_r2
0111A0 46 10 20 00 	    lw      r1,MON_r1
0111A4 3E F0 41 02 	    jsr		(jmp_vector)
0111A8 63 10 20 00 	    sw      r1,MON_r1
0111AC 63 20 30 00 	    sw      r2,MON_r2
0111B0 63 30 40 00 	    sw      r3,MON_r3
0111B4 63 40 50 00 	    sw      r4,MON_r4
0111B8 63 50 60 00 	    sw      r5,MON_r5
0111BC 63 60 70 00 	    sw      r6,MON_r6
0111C0 63 70 80 00 	    sw      r7,MON_r7
0111C4 63 80 90 00 	    sw      r8,MON_r8
0111C8 63 90 A0 00 	    sw      r9,MON_r9
0111CC 63 A0 B0 00 	    sw      r10,MON_r10
0111D0 63 B0 C0 00 	    sw      r11,MON_r11
0111D4 63 C0 D0 00 	    sw      r12,MON_r12
0111D8 63 D0 E0 00 	    sw      r13,MON_r13
0111DC 63 E0 F0 00 	    sw      r14,MON_r14
0111E0 63 F0 00 01 	    sw      r15,MON_r15
0111E4 63 00 11 01 	    sw      r16,MON_r16
0111E8 63 10 21 01 	    sw      r17,MON_r17
0111EC 63 20 31 01 	    sw      r18,MON_r18
0111F0 63 30 41 01 	    sw      r19,MON_r19
0111F4 63 40 51 01 	    sw      r20,MON_r20
0111F8 63 50 61 01 	    sw      r21,MON_r21
0111FC 63 60 71 01 	    sw      r22,MON_r22
011200 63 70 81 01 	    sw      r23,MON_r23
011204 63 80 91 01 	    sw      r24,MON_r24
011208 63 90 A1 01 	    sw      r25,MON_r25
01120C 63 A0 B1 01 	    sw      r26,MON_r26
011210 63 B0 C1 01 	    sw      r27,MON_r27
011214 63 C0 D1 01 	    sw      r28,MON_r28
011218 63 D0 E1 01 	    sw      r29,MON_r29
01121C 63 E0 F1 01 	    sw      r30,MON_r30
011220 63 F0 01 02 	    sw      r31,MON_r31
011224 3A 9E FF FF 		bra		mon1
                	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	doDate:
011228 39 B6 FF FF 		bsr		MonGetch		; skip over 'T'
01122C 86 50 82 00 		cmp		r5,r1,#'A'		; look for DAY
011230 BD 02 38 00 		beq		r5,doDay
011234 39 B8 FF FF 		bsr		ignBlanks
011238 39 B4 FF FF 		bsr		MonGetch
01123C 86 50 7E 00 		cmp		r5,r1,#'?'
011240 BD 02 14 00 		beq		r5,.0001
011244 95 31 08 00 		subui	r3,r3,#4
011248 39 35 00 00 		bsr		GetHexNumber
01124C 60 10 AA 07 		sb		r1,RTCC_BUF+5	; update month
011250 39 34 00 00 		bsr		GetHexNumber
011254 60 10 A8 07 		sb		r1,RTCC_BUF+4	; update day
011258 39 33 00 00 		bsr		GetHexNumber
01125C 60 10 AC 07 		sb		r1,RTCC_BUF+6	; update year
011260 39 91 01 00 		bsr		RTCCWritebuf
011264 3A 96 FF FF 		bra		mon1
                	.0001:
011268 39 8B 01 00 		bsr		RTCCReadbuf
01126C B9 A4 FE FF 		bsr		CRLF
011270 41 10 AA 07 		lbu		r1,RTCC_BUF+5
011274 B9 93 FE FF 		bsr		DisplayByte
011278 0A 10 5E 00 		ldi		r1,#'/'
01127C B9 D3 FF FF 		bsr		OutChar
011280 41 10 A8 07 		lbu		r1,RTCC_BUF+4
011284 B9 91 FE FF 		bsr		DisplayByte
011288 0A 10 5E 00 		ldi		r1,#'/'
01128C B9 D1 FF FF 		bsr		OutChar
011290 41 10 AC 07 		lbu		r1,RTCC_BUF+6
011294 B9 8F FE FF 		bsr		DisplayByte
011298 39 9F FE FF 		bsr		CRLF
01129C 3A 8F FF FF 		bra		mon1
                	
                	doDay:
0112A0 B9 AA FF FF 		bsr		ignBlanks
0112A4 B9 29 00 00 		bsr		GetHexNumber
0112A8 82 30 00 1A 		mov		r3,r1			; value to write
0112AC 0A 10 DE 00 		ldi		r1,#$6F			; device $6F
0112B0 0A 20 06 00 		ldi		r2,#$03			; register 3
0112B4 B9 6F 01 00 		bsr		I2C_WRITE
0112B8 BA 8B FF FF 		bra		mon1
                	
                	;------------------------------------------------------------------------------
                	; Display memory pointed to by r2.
                	; destroys r1,r3
                	;------------------------------------------------------------------------------
                	;
                	DisplayMemBytes:
0112BC E7 EF 01 00 	    push    lr
0112C0 E7 E0 01 00 		push	r1
0112C4 E7 E1 01 00 	    push    r3
0112C8 67 E2 01 00 	    push    r4
0112CC 0A 10 7C 00 		ldi		r1,#'>'
0112D0 39 C9 FF FF 		bsr		OutChar
0112D4 0A 10 84 00 		ldi		r1,#'B'
0112D8 39 C8 FF FF 		bsr		OutChar
0112DC 0A 10 40 00 		ldi		r1,#' '
0112E0 39 C7 FF FF 		bsr		OutChar
0112E4 02 11 00 1A 		mov		r1,r2
0112E8 39 80 FE FF 		bsr		DisplayHalf
0112EC 0A 30 10 00 		ldi		r3,#8
                	.001:
0112F0 0A 10 40 00 		ldi		r1,#' '
0112F4 B9 C4 FF FF 		bsr		OutChar
0112F8 41 11 00 00 		lbu		r1,[r2]
0112FC B9 82 FE FF 		bsr		DisplayByte
011300 14 21 02 00 		addui	r2,r2,#1
011304 95 31 02 00 		subui   r3,r3,#1
011308 BD 11 F4 FF 		bne	    r3,.001
01130C 0A 10 74 00 		ldi		r1,#':'
011310 39 C1 FF FF 		bsr		OutChar
011314 7C 70 0D 00 		ldi		r1,#%110101110_000000100_0000000000	; reverse video
011318 0A 10 00 20 
01131C 62 10 60 02 		sh		r1,NormAttr
011320 0A 30 10 00 		ldi		r3,#8
011324 15 21 10 00 		subui	r2,r2,#8
                	.002
011328 41 11 00 00 		lbu		r1,[r2]
01132C 96 40 34 00 		cmpu	r4,r1,#26				; convert control characters to '.'
011330 3D 32 06 00 		bge		r4,.004
011334 0A 10 5C 00 		ldi		r1,#'.'
011338 3A 02 00 00 		bra     .003
                	.004:
01133C 96 40 00 01 		cmpu	r4,r1,#$80				; convert other non-ascii to '.'
011340 3D 42 04 00 		blt		r4,.003
011344 0A 10 5C 00 		ldi		r1,#'.'
                	.003:
011348 39 BA FF FF 		bsr		OutChar
01134C 14 21 02 00 		addui	r2,r2,#1
011350 95 31 02 00 		subui   r3,r3,#1
011354 BD 11 EA FF 		bne	    r3,.002
011358 FC 26 00 00 		ldi		r1,#%000000100_110101110_0000000000	; normal video
01135C 0A 10 00 70 
011360 62 10 60 02 		sh		r1,NormAttr
011364 B9 85 FE FF 		bsr		CRLF
011368 57 4F 10 00 		pop     r4
01136C 57 3F 10 00 		pop		r3
011370 57 1F 10 00 	    pop     r1
011374 57 FF 11 00 	    pop     lr
011378 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; CheckKeys:
                	;	Checks for a CTRLC or a scroll lock during long running dumps.
                	;------------------------------------------------------------------------------
                	
                	CheckKeys:
01137C E7 EF 01 00 	    push    lr
011380 39 02 00 00 		bsr	    CTRLCCheck
011384 B9 07 00 00 		bsr     CheckScrollLock
011388 57 FF 11 00 		pop     lr
01138C 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; CTRLCCheck
                	;	Checks to see if CTRL-C is pressed. If so then the current routine is
                	; aborted and control is returned to the monitor.
                	;------------------------------------------------------------------------------
                	
                	CTRLCCheck:
011390 E7 EF 01 00 	    push    lr
011394 E7 E0 01 00 		push	r1
011398 67 E1 01 00 		push    r2
01139C B9 82 00 00 		bsr		KeybdGetCharNoWait
0113A0 86 20 06 00 		cmp		r2,r1,#CTRLC
0113A4 3D 01 0A 00 		beq		r2,.0001
0113A8 57 2F 10 00 		pop     r2
0113AC 57 1F 10 00 		pop		r1
0113B0 57 FF 11 00 		pop     lr
0113B4 37 FF 01 00 		rtl
.0001:
0113B8 14 EF 31 00 		addui	sp,sp,#24
0113BC 3A 6B FF FF 		bra     mon1
                	
                	;------------------------------------------------------------------------------
                	; CheckScrollLock:
                	;	Check for a scroll lock by the user. If scroll lock is active then tasks
                	; are rescheduled while the scroll lock state is tested in a loop.
                	;------------------------------------------------------------------------------
                	
                	CheckScrollLock:
0113C0 E7 EF 01 00 	    push    lr
0113C4 E7 E0 01 00 		push	r1
0113C8 67 E1 01 00 		push    r2
                	.0002:
0113CC 43 10 7C 02 		lcu		r1,KeybdLocks
0113D0 7C 00 00 00 		and		r2,r1,#$4000		; is scroll lock active ?
0113D4 8C 20 00 80 
0113D8 3D 01 04 00 		beq		r2,.0001
                	;	brk		#2*16				; reschedule tasks
0113DC 3A FE FF FF 		bra     .0002
                	.0001:
0113E0 57 2F 10 00 	    pop     r2
0113E4 57 1F 10 00 		pop		r1
0113E8 57 FF 11 00 		pop     lr
0113EC 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; Get a hexidecimal number. Maximum of eight digits.
                	; R3 = text pointer (updated)
                	; R1 = hex number
                	;------------------------------------------------------------------------------
                	;
                	GetHexNumber:
0113F0 E7 EF 01 00 	    push    lr
0113F4 67 E1 01 00 		push	r2
0113F8 67 E2 01 00 	    push    r4
0113FC 0A 20 00 00 		ldi		r2,#0
011400 0A 40 20 00 		ldi		r4,#16
                	.gthxn2:
011404 B9 7A FF FF 		bsr		MonGetch
011408 39 05 00 00 		bsr		AsciiToHexNybble
01140C BD 40 0A 00 		bmi		r1,.gthxn1
011410 02 21 08 70 		asl		r2,r2,#4
011414 02 21 02 1A 		or		r2,r2,r1
011418 15 42 02 00 		subui   r4,r4,#1
01141C 3D 12 F4 FF 	    bne	    r4,.gthxn2
                	.gthxn1:
011420 02 11 00 1A 		mov		r1,r2
011424 57 4F 10 00 		pop		r4
011428 57 2F 10 00 	    pop     r2
01142C 3B FF 11 00 	    rts

                	;------------------------------------------------------------------------------
                	; Convert ASCII character in the range '0' to '9', 'a' to 'f' or 'A' to 'F'
                	; to a hex nybble.
                	;------------------------------------------------------------------------------
                	;
                	AsciiToHexNybble:
011430 67 E1 01 00 	    push    r2
011434 96 20 60 00 		cmpu	r2,r1,#'0'
011438 3D 41 2C 00 		blt		r2,.gthx3
01143C 96 20 74 00 		cmpu	r2,r1,#'9'+1
011440 3D 31 08 00 		bge		r2,.gthx5
011444 95 10 60 00 		subui	r1,r1,#'0'
011448 57 2F 10 00 		pop     r2
01144C 37 FF 01 00 		rtl
.gthx5:
011450 96 20 82 00 		cmpu	r2,r1,#'A'
011454 3D 41 1E 00 		blt		r2,.gthx3
011458 96 20 8E 00 		cmpu	r2,r1,#'F'+1
01145C 3D 31 0A 00 		bge		r2,.gthx6
011460 95 10 82 00 		subui	r1,r1,#'A'
011464 94 10 14 00 		addui	r1,r1,#10
011468 57 2F 10 00 		pop     r2
01146C 37 FF 01 00 		rtl
.gthx6:
011470 96 20 C2 00 		cmpu	r2,r1,#'a'
011474 3D 41 0E 00 		blt		r2,.gthx3
011478 96 20 F6 00 		cmpu	r2,r1,#'z'+1
01147C 3D 31 0A 00 		bge		r2,.gthx3
011480 95 10 C2 00 		subui	r1,r1,#'a'
011484 94 10 14 00 		addui	r1,r1,#10
011488 57 2F 10 00 		pop     r2
01148C 37 FF 01 00 		rtl
.gthx3:
011490 57 2F 10 00 	    pop     r2
011494 0A 10 FE FF 		ldi		r1,#-1		; not a hex number
011498 37 FF 01 00 		rtl

                	DisplayErr:
01149C 7C 01 00 00 		ldi		r1,#msgErr
0114A0 0A 10 58 29 
0114A4 39 56 FE FF 		bsr		DisplayString
0114A8 BA 4D FF FF 		bra mon1
                	
                	msgErr:
0114AC 2A 2A 45 72 		db	"**Err",CR,LF,0
0114B0 72 0D 0A 00 
                	
                	msgHelp:
0114B4 3F 20 3D 20 		db		"? = Display Help",CR,LF
0114B8 44 69 73 70 
0114BC 6C 61 79 20 
0114C0 48 65 6C 70 
0114C4 0D 0A       
0114C6 43 4C 53 20 		db		"CLS = clear screen",CR,LF
0114CA 3D 20 63 6C 
0114CE 65 61 72 20 
0114D2 73 63 72 65 
0114D6 65 6E 0D 0A 
0114DA 44 54 20 3D 		db		"DT = set/read date",CR,LF
0114DE 20 73 65 74 
0114E2 2F 72 65 61 
0114E6 64 20 64 61 
0114EA 74 65 0D 0A 
0114EE 46 42 20 3D 		db		"FB = fill memory",CR,LF
0114F2 20 66 69 6C 
0114F6 6C 20 6D 65 
0114FA 6D 6F 72 79 
0114FE 0D 0A       
011500 4D 42 20 3D 		db		"MB = dump memory",CR,LF
011504 20 64 75 6D 
011508 70 20 6D 65 
01150C 6D 6F 72 79 
011510 0D 0A       
011512 4A 53 20 3D 		db		"JS = jump to code",CR,LF
011516 20 6A 75 6D 
01151A 70 20 74 6F 
01151E 20 63 6F 64 
011522 65 0D 0A    
011525 53 20 3D 20 		db		"S = boot from SD card",CR,LF
011529 62 6F 6F 74 
01152D 20 66 72 6F 
011531 6D 20 53 44 
011535 20 63 61 72 
011539 64 0D 0A    
01153C 00          		db		0
                	
                	msgMonitorStarted
01153D 4D 6F 6E 69 		db		"Monitor started.",0
011541 74 6F 72 20 
011545 73 74 61 72 
011549 74 65 64 2E 
01154D 00          
                	
                	doCLS:
01154E 00 00 B9 24 		bsr		ClearScreen
011552 FE FF       
011554 B9 21 FE FF 		bsr		HomeCursor
011558 BA 37 FF FF 		bra     mon1
                	
                	;------------------------------------------------------------------------------
                	; Get a random number from peripheral device.
                	;------------------------------------------------------------------------------
                	
                	GetRandomNumber:
01155C 7C DC FF 00 	    lw      r1,$FFDC0C00
011560 46 10 00 18 
011564 37 FF 01 00 	    rtl
                
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	; Keyboard processing routines follow.
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	KEYBD_DELAY		EQU		1000
                	
                	KeybdGetCharDirectNB:
011568 E7 EF 01 00 	    push    lr
01156C 67 E1 01 00 		push	r2
011570 02 00 02 6E 		sei
011574 7C DC FF 00 		lcu		r1,KEYBD
011578 43 10 00 00 
01157C FC 00 00 00 		and		r2,r1,#$8000
011580 8C 20 00 00 
011584 3D 01 22 00 		beq		r2,.0001
011588 7C DC FF 00 		lbu		r0,KEYBD+4		; clear keyboard strobe
01158C 41 00 08 00 
011590 02 00 00 6E 		cli
011594 8C 20 00 10 		and		r2,r1,#$800	; is it keydown ?
011598 3D 11 18 00 		bne	    r2,.0001
01159C 8C 10 FE 01 		and		r1,r1,#$FF
0115A0 41 20 78 02 		lbu		r2,KeybdEcho
0115A4 3D 01 0C 00 		beq		r2,.0002
0115A8 86 20 1A 00 		cmp		r2,r1,#CR
0115AC 3D 11 06 00 		bne		r2,.0003
0115B0 39 3C FE FF 		bsr		CRLF
0115B4 3A 01 00 00 		bra     .0002
                	.0003:
0115B8 3E F0 21 02 		jsr		(OutputVec)
                	.0002:
0115BC 57 2F 10 00 		pop		r2
0115C0 57 FF 11 00 		pop     lr
0115C4 37 FF 01 00 		rtl
.0001:
0115C8 02 00 00 6E 		cli
0115CC 0A 10 FE FF 		ldi		r1,#-1
0115D0 57 2F 10 00 		pop		r2
0115D4 57 FF 11 00 		pop     lr
0115D8 37 FF 01 00 		rtl

                	KeybdGetCharDirect:
0115DC E7 EF 01 00 	    push    lr
0115E0 67 E1 01 00 		push	r2
                	.0001:
0115E4 7C DC FF 00 		lc		r1,KEYBD
0115E8 42 10 00 00 
0115EC FC 00 00 00 		and		r2,r1,#$8000
0115F0 8C 20 00 00 
0115F4 3D 01 F8 FF 		beq		r2,.0001
0115F8 7C DC FF 00 		lbu		r0,KEYBD+4		; clear keyboard strobe
0115FC 41 00 08 00 
011600 8C 20 00 10 		and		r2,r1,#$800	; is it keydown ?
011604 3D 11 F0 FF 		bne	    r2,.0001
011608 8C 10 FE 01 		and		r1,r1,#$FF
01160C 41 20 78 02 		lbu		r2,KeybdEcho
011610 3D 01 0C 00 		beq		r2,.gk1
011614 86 20 1A 00 		cmp		r2,r1,#CR
011618 3D 11 06 00 		bne		r2,.gk2
01161C B9 2E FE FF 		bsr		CRLF
011620 3A 01 00 00 		bra     .gk1
                	.gk2:
011624 3E F0 21 02 		jsr		(OutputVec)
                	.gk1:
011628 57 2F 10 00 		pop		r2
01162C 57 FF 11 00 		pop     lr
011630 37 FF 01 00 		rtl

                	;KeybdInit:
                	;	mfspr	r1,cr0		; turn off tmr mode
                	;	push	r1
                	;	mtspr	cr0,r0
                	;	ldi		r1,#33
                	;	sb		r1,LEDS
                	;	bsr		WaitForKeybdAck	; grab a byte from the keyboard
                	;	cmp		flg0,r1,#$AA	; did it send a ack ?
                	;	
                	;	ldi		r1,#$ff			; issue keyboard reset
                	;	bsr		SendByteToKeybd
                	;	ldi		r1,#38
                	;	sb		r1,LEDS
                	;	ldi		r1,#4
                	;	jsr		Sleep
                	;	ldi		r1,#KEYBD_DELAY	; delay a bit
                	kbdi5:
                	;	sub		r1,r1,#1
                	;	brnz	r1,kbdi5
                	;	ldi		r1,#34
                	;	sb		r1,LEDS
                	;	ldi		r1,#0xf0		; send scan code select
                	;	bsr		SendByteToKeybd
                	;	ldi		r1,#35
                	;	sb		r1,LEDS
                	;	ldi		r2,#0xFA
                	;	bsr		WaitForKeybdAck
                	;	cmp		fl0,r1,#$FA
                	;	bne		fl0,kbdi2
                	;	ldi		r1,#36
                	;	sb		r1,LEDS
                	;	ldi		r1,#2			; select scan code set#2
                	;	bsr		SendByteToKeybd
                	;	ldi		r1,#39
                	;	sb		r1,LEDS
                	;kbdi2:
                	;	ldi		r1,#45
                	;	sb		r1,LEDS
                	;	pop		r1				; turn back on tmr mode
                	;	mtspr	cr0,r1
                	;	rtl
                	
                	msgBadKeybd:
011634 4B 65 79 62 		db		"Keyboard not responding.",0
011638 6F 61 72 64 
01163C 20 6E 6F 74 
011640 20 72 65 73 
011644 70 6F 6E 64 
011648 69 6E 67 2E 
01164C 00          
                	
                	;SendByteToKeybd:
                	;	push	r2
                	;	sb		r1,KEYBD
                	;	ldi		r1,#40
                	;	sb		r1,LEDS
                	;	mfspr	r3,tick
                	;kbdi4:						; wait for transmit complete
                	;	mfspr	r4,tick
                	;	sub		r4,r4,r3
                	;	cmp		fl0,r4,#KEYBD_DELAY
                	;	bhi		fl0,kbdbad
                	;	ldi		r1,#41
                	;	sb		r1,LEDS
                	;	lbu		r1,KEYBD+1
                	;	and		fl0,r1,#64
                	;	brz		fl0,kbdi4
                	;	bra 	sbtk1
                	;kbdbad:
                	;	ldi		r1,#42
                	;	sb		r1,LEDS
                	;	lbu		r1,KeybdBad
                	;	brnz	r1,sbtk2
                	;	ldi		r1,#1
                	;	sb		r1,KeybdBad
                	;	ldi		r1,#43
                	;	sb		r1,LEDS
                	;	ldi		r1,#msgBadKeybd
                	;	bsr		DisplayStringCRLF
                	;sbtk1:
                	;	ldi		r1,#44
                	;	sb		r1,LEDS
                	;	pop		r2
                	;	rtl
                	;sbtk2:
                	;	bra sbtk1
                	
                	; Wait for keyboard to respond with an ACK (FA)
                	;
                	;WaitForKeybdAck:
                	;	ldi		r1,#64
                	;	sb		r1,LEDS
                	;	mfspr	r3,tick
                	;wkbdack1:
                	;	mfspr	r4,tick
                	;	sub		r4,r4,r3
                	;	cmp		fl0,r4,#KEYBD_DELAY
                	;	bhi		fl0,wkbdbad
                	;	ldi		r1,#65
                	;	sb		r1,LEDS
                	;	lb		r1,KEYBD+1				; check keyboard status for key
                	;	brpl	r1,wkbdack1				; no key available, go back
                	;	lbu		r1,KEYBD				; get the scan code
                	;	sb		r0,KEYBD+1				; clear recieve register
                	;wkbdbad:
                	;	rtl
                	
                	KeybdInit:
01164D 00 00 00 E7 	    push    lr
011651 EF 01 00    
011654 0A 30 0A 00 		ldi		r3,#5
                	.0001:
011658 39 19 00 00 		bsr		KeybdRecvByte	; Look for $AA
01165C BD 40 06 00 		bmi		r1,.0002
011660 86 20 54 01 		cmp		r2,r1,#$AA		;
011664 3D 01 20 00 		beq		r2,.config
                	.0002:
011668 B9 75 00 00 		bsr		Wait10ms
01166C 0A 10 FE FF 		ldi		r1,#-1			; send reset code to keyboard
011670 7C DC FF 00 		sb		r1,KEYBD+1		; write to status reg to clear TX state
011674 60 10 02 00 
011678 B9 73 00 00 		bsr		Wait10ms
01167C 0A 10 FE 01 		ldi		r1,#$FF
011680 39 71 00 00 		bsr		KeybdSendByte	; now write to transmit register
011684 B9 1B 00 00 		bsr		KeybdWaitTx		; wait until no longer busy
011688 39 13 00 00 		bsr		KeybdRecvByte	; look for an ACK ($FA)
01168C 86 20 F4 01 		cmp		r2,r1,#$FA
011690 39 12 00 00 		bsr		KeybdRecvByte
011694 86 20 F8 01 		cmp		r2,r1,#$FC		; reset error ?
011698 3D 01 1A 00 		beq		r2,.tryAgain
01169C 86 20 54 01 		cmp		r2,r1,#$AA		; reset complete okay ?
0116A0 3D 11 16 00 		bne		r2,.tryAgain
                	.config:
0116A4 0A 10 E0 01 		ldi		r1,#$F0			; send scan code select
0116A8 7C DC FF 00 		sc		r1,LEDS
0116AC 61 10 00 0C 
0116B0 39 6B 00 00 		bsr		KeybdSendByte
0116B4 B9 15 00 00 		bsr		KeybdWaitTx
0116B8 BD 40 0A 00 		bmi		r1,.tryAgain
0116BC B9 0C 00 00 		bsr		KeybdRecvByte	; wait for response from keyboard
0116C0 BD 40 06 00 		bmi		r1,.tryAgain
0116C4 86 20 F4 01 		cmp		r2,r1,#$FA
0116C8 3D 01 10 00 		beq		r2,.0004
                	.tryAgain:
0116CC 95 31 02 00 	    subui   r3,r3,#1
0116D0 BD 11 C4 FF 		bne	    r3,.0001
                	.keybdErr:
0116D4 7C 01 00 00 		ldi		r1,#msgBadKeybd
0116D8 0A 10 68 2C 
0116DC 39 0F FE FF 		bsr		DisplayString
0116E0 57 FF 11 00 		pop     lr
0116E4 37 FF 01 00 		rtl
.0004:
0116E8 0A 10 04 00 		ldi		r1,#2			; select scan code set #2
0116EC B9 63 00 00 		bsr		KeybdSendByte
0116F0 39 0E 00 00 		bsr		KeybdWaitTx
0116F4 BD 40 EC FF 		bmi		r1,.tryAgain
0116F8 57 FF 11 00 		pop     lr
0116FC 37 FF 01 00 		rtl

                	; Get the keyboard status
                	;
                	KeybdGetStatus:
011700 7C DC FF 00 		lb		r1,KEYBD+1
011704 40 10 02 00 
011708 37 FF 01 00 		rtl

                	; Get the scancode from the keyboard port
                	;
                	KeybdGetScancode:
01170C 7C DC FF 00 		lbu		r1,KEYBD				; get the scan code
011710 41 10 00 00 
011714 7C DC FF 00 		sb		r0,KEYBD+1				; clear receive register
011718 60 00 02 00 
01171C 37 FF 01 00 		rtl

                	; Recieve a byte from the keyboard, used after a command is sent to the
                	; keyboard in order to wait for a response.
                	;
                	KeybdRecvByte:
011720 E7 EF 01 00 	    push    lr
011724 E7 E1 01 00 		push	r3
011728 0A 30 C8 00 		ldi		r3,#100			; wait up to 1s
                	.0003:
01172C B9 FA FF FF 		bsr		KeybdGetStatus	; wait for response from keyboard
011730 BD 40 10 00 		bmi		r1,.0004		; is input buffer full ? yes, branch
011734 39 5C 00 00 		bsr		Wait10ms		; wait a bit
011738 95 31 02 00 		subui   r3,r3,#1
01173C BD 11 F8 FF 		bne     r3,.0003		; go back and try again
011740 57 3F 10 00 		pop		r3				; timeout
011744 0A 10 FE FF 		ldi		r1,#-1			; return -1
011748 57 FF 11 00 		pop     lr
01174C 37 FF 01 00 		rtl
.0004:
011750 B9 F7 FF FF 		bsr		KeybdGetScancode
011754 57 3F 10 00 		pop		r3
011758 57 FF 11 00 		pop     lr
01175C 37 FF 01 00 		rtl

                	
                	; Wait until the keyboard transmit is complete
                	; Returns .CF = 1 if successful, .CF=0 timeout
                	;
                	KeybdWaitTx:
011760 E7 EF 01 00 	    push    lr
011764 67 E1 01 00 		push	r2
011768 E7 E1 01 00 	    push    r3
01176C 0A 30 C8 00 		ldi		r3,#100			; wait a max of 1s
                	.0001:
011770 39 F2 FF FF 		bsr		KeybdGetStatus
011774 8C 10 80 00 		and		r1,r1,#$40		; check for transmit complete bit
011778 BD 10 12 00 		bne	    r1,.0002		; branch if bit set
01177C 39 53 00 00 		bsr		Wait10ms		; delay a little bit
011780 95 31 02 00 		subui   r3,r3,#1
011784 BD 11 F6 FF 		bne	    r3,.0001		; go back and try again
011788 57 3F 10 00 		pop		r3
01178C 57 2F 10 00 	    pop     r2			    ; timed out
011790 0A 10 FE FF 		ldi		r1,#-1			; return -1
011794 57 FF 11 00 		pop     lr
011798 37 FF 01 00 		rtl
.0002:
01179C 57 3F 10 00 		pop		r3
0117A0 57 2F 10 00 	    pop     r2			    ; wait complete, return 
0117A4 0A 10 00 00 		ldi		r1,#0			; return 0
0117A8 57 FF 11 00 		pop     lr
0117AC 37 FF 01 00 		rtl

                	KeybdGetCharNoWait:
0117B0 60 00 84 02 		sb		r0,KeybdWaitFlag
0117B4 BA 01 00 00 		bra		KeybdGetChar
                	
                	KeybdGetCharWait:
0117B8 0A 10 FE FF 		ldi		r1,#-1
0117BC 60 10 84 02 		sb		r1,KeybdWaitFlag
                		
                	KeybdGetChar:
0117C0 E7 EF 01 00 	    push    lr
0117C4 67 E1 01 00 		push	r2
0117C8 E7 E1 01 00 	    push    r3
                	.0003:
0117CC B9 E6 FF FF 		bsr		KeybdGetStatus			; check keyboard status for key available
0117D0 BD 40 10 00 		bmi		r1,.0006				; yes, go process
0117D4 40 10 84 02 		lb		r1,KeybdWaitFlag		; are we willing to wait for a key ?
0117D8 BD 40 FA FF 		bmi		r1,.0003				; yes, branch back
0117DC 0A 10 FE FF 		ldi		r1,#-1					; flag no char available
0117E0 57 3F 10 00 		pop		r3
0117E4 57 2F 10 00 	    pop     r2
0117E8 57 FF 11 00 	    pop     lr
0117EC 37 FF 01 00 		rtl
.0006:
0117F0 B9 E3 FF FF 		bsr		KeybdGetScancode
                	.0001:
0117F4 0A 20 02 00 		ldi		r2,#1
0117F8 7C DC FF 00 		sb		r2,LEDS
0117FC 60 20 00 0C 
011800 86 20 E0 01 		cmp		r2,r1,#SC_KEYUP
011804 3D 01 68 00 		beq		r2,.doKeyup
011808 86 20 C0 01 		cmp		r2,r1,#SC_EXTEND
01180C 3D 01 6A 00 		beq		r2,.doExtend
011810 86 20 28 00 		cmp		r2,r1,#$14				; code for CTRL
011814 3D 01 6E 00 		beq		r2,.doCtrl
011818 86 20 24 00 		cmp		r2,r1,#$12				; code for left shift
01181C 3D 01 80 00 		beq		r2,.doShift
011820 86 20 B2 00 		cmp		r2,r1,#$59				; code for right-shift
011824 3D 01 7C 00 		beq		r2,.doShift
011828 86 20 EE 00 		cmp		r2,r1,#SC_NUMLOCK
01182C 3D 01 8E 00 		beq		r2,.doNumLock
011830 86 20 B0 00 		cmp		r2,r1,#SC_CAPSLOCK
011834 3D 01 94 00 		beq		r2,.doCapsLock
011838 86 20 FC 00 		cmp		r2,r1,#SC_SCROLLLOCK
01183C 3D 01 9A 00 		beq		r2,.doScrollLock
011840 40 20 80 02 		lb		r2,KeyState1			; check key up/down
011844 60 00 80 02 		sb		r0,KeyState1			; clear keyup status
011848 3D 11 C2 FF 		bne	    r2,.0003				; ignore key up
01184C 40 20 82 02 		lb		r2,KeyState2
011850 0C 31 00 01 		and		r3,r2,#$80				; is it extended code ?
011854 BD 01 0E 00 		beq		r3,.0010
011858 0C 31 FE 00 		and		r3,r2,#$7f				; clear extended bit
01185C 60 30 82 02 		sb		r3,KeyState2
011860 60 00 80 02 		sb		r0,KeyState1			; clear keyup
011864 7C 01 00 00 		lbu		r1,keybdExtendedCodes[r1]
011868 C1 10 A0 39 
01186C BA 09 00 00 		bra		.0008
                	.0010:
011870 40 20 82 02 		lb		r2,KeyState2
011874 0C 31 08 00 		and		r3,r2,#$04				; is it CTRL code ?
011878 BD 01 0A 00 		beq		r3,.0009
01187C 8C 10 FE 00 		and		r1,r1,#$7F
011880 7C 01 00 00 		lbu		r1,keybdControlCodes[r1]
011884 C1 10 A0 38 
011888 3A 06 00 00 		bra		.0008
                	.0009:
01188C 40 20 82 02 		lb		r2,KeyState2
011890 0C 31 02 00 		and		r3,r2,#$01				; is it shift down ?
011894 BD 01 08 00 		beq  	r3,.0007
011898 7C 01 00 00 		lbu		r1,shiftedScanCodes[r1]
01189C C1 10 A0 36 
0118A0 3A 03 00 00 		bra		.0008
                	.0007:
0118A4 7C 01 00 00 		lbu		r1,unshiftedScanCodes[r1]
0118A8 C1 10 A0 34 
0118AC 0A 20 04 00 		ldi		r2,#2
0118B0 7C DC FF 00 		sb		r2,LEDS
0118B4 60 20 00 0C 
                	.0008:
0118B8 0A 20 06 00 		ldi		r2,#3
0118BC 7C DC FF 00 		sb		r2,LEDS
0118C0 60 20 00 0C 
0118C4 57 3F 10 00 		pop		r3
0118C8 57 2F 10 00 	    pop     r2
0118CC 57 FF 11 00 	    pop     lr
0118D0 37 FF 01 00 		rtl
.doKeyup:
0118D4 0A 10 FE FF 		ldi		r1,#-1
0118D8 60 10 80 02 		sb		r1,KeyState1
0118DC 3A DE FF FF 		bra		.0003
                	.doExtend:
0118E0 41 10 82 02 		lbu		r1,KeyState2
0118E4 8D 10 00 01 		or		r1,r1,#$80
0118E8 60 10 82 02 		sb		r1,KeyState2
0118EC 3A DC FF FF 		bra		.0003
                	.doCtrl:
0118F0 40 10 80 02 		lb		r1,KeyState1
0118F4 60 00 80 02 		sb		r0,KeyState1
0118F8 BD 30 0A 00 		bpl		r1,.0004
0118FC 40 10 82 02 		lb		r1,KeyState2
011900 8C 10 F6 FF 		and		r1,r1,#-5
011904 60 10 82 02 		sb		r1,KeyState2
011908 BA D8 FF FF 		bra		.0003
                	.0004:
01190C 40 10 82 02 		lb		r1,KeyState2
011910 8D 10 08 00 		or		r1,r1,#4
011914 60 10 82 02 		sb		r1,KeyState2
011918 BA D6 FF FF 		bra		.0003
                	.doShift:
01191C 40 10 80 02 		lb		r1,KeyState1
011920 60 00 80 02 		sb		r0,KeyState1
011924 BD 30 0A 00 		bpl		r1,.0005
011928 40 10 82 02 		lb		r1,KeyState2
01192C 8C 10 FC FF 		and		r1,r1,#-2
011930 60 10 82 02 		sb		r1,KeyState2
011934 3A D3 FF FF 		bra		.0003
                	.0005:
011938 40 10 82 02 		lb		r1,KeyState2
01193C 8D 10 02 00 		or		r1,r1,#1
011940 60 10 82 02 		sb		r1,KeyState2
011944 3A D1 FF FF 		bra		.0003
                	.doNumLock:
011948 40 10 82 02 		lb		r1,KeyState2
01194C 8E 10 20 00 		eor		r1,r1,#16
011950 60 10 82 02 		sb		r1,KeyState2
011954 39 06 00 00 		bsr		KeybdSetLEDStatus
011958 BA CE FF FF 		bra		.0003
                	.doCapsLock:
01195C 40 10 82 02 		lb		r1,KeyState2
011960 8E 10 40 00 		eor		r1,r1,#32
011964 60 10 82 02 		sb		r1,KeyState2
011968 B9 03 00 00 		bsr		KeybdSetLEDStatus
01196C 3A CC FF FF 		bra		.0003
                	.doScrollLock:
011970 40 10 82 02 		lb		r1,KeyState2
011974 8E 10 80 00 		eor		r1,r1,#64
011978 60 10 82 02 		sb		r1,KeyState2
01197C 39 01 00 00 		bsr		KeybdSetLEDStatus
011980 BA C9 FF FF 		bra		.0003
                	
                	KeybdSetLEDStatus:
011984 E7 EF 01 00 	    push    lr
011988 67 E1 01 00 		push	r2
01198C E7 E1 01 00 	    push    r3
011990 60 00 86 02 		sb		r0,KeybdLEDs
011994 40 10 82 02 		lb		r1,KeyState2
011998 8C 20 20 00 		and		r2,r1,#16
01199C 3D 01 06 00 		beq		r2,.0002
0119A0 0A 30 04 00 		ldi		r3,#2
0119A4 60 30 86 02 		sb		r3,KeybdLEDs
                	.0002:
0119A8 8C 20 40 00 		and		r2,r1,#32
0119AC 3D 01 08 00 		beq		r2,.0003
0119B0 40 30 86 02 		lb		r3,KeybdLEDs
0119B4 8D 31 08 00 		or		r3,r3,#4
0119B8 60 30 86 02 		sb		r3,KeybdLEDs
                	.0003:
0119BC 8C 20 80 00 		and		r2,r1,#64
0119C0 3D 01 08 00 		beq		r2,.0004
0119C4 40 30 86 02 		lb		r3,KeybdLEDs
0119C8 8D 31 02 00 		or		r3,r3,#1
0119CC 60 30 86 02 		sb		r3,KeybdLEDs
                	.0004:
0119D0 0A 10 DA 01 		ldi		r1,#$ED
0119D4 B9 06 00 00 		bsr		KeybdSendByte
0119D8 39 B1 FF FF 		bsr		KeybdWaitTx
0119DC B9 A8 FF FF 		bsr		KeybdRecvByte
0119E0 BD 40 0C 00 		bmi		r1,.0001
0119E4 86 20 F4 01 		cmp		r2,r1,#$FA
0119E8 40 10 86 02 		lb		r1,KeybdLEDs
0119EC B9 03 00 00 		bsr		KeybdSendByte
0119F0 39 AE FF FF 		bsr		KeybdWaitTx
0119F4 B9 A5 FF FF 		bsr		KeybdRecvByte
                	.0001:
0119F8 57 3F 10 00 		pop		r3
0119FC 57 2F 10 00 	    pop     r2
011A00 57 FF 11 00 	    pop     lr
011A04 37 FF 01 00 		rtl

                	KeybdSendByte:
011A08 7C DC FF 00 		sb		r1,KEYBD
011A0C 60 10 00 00 
011A10 37 FF 01 00 		rtl
	
                	Wait10ms:
011A14 E7 E1 01 00 		push	r3
011A18 67 E2 01 00 	    push    r4
011A1C 02 30 08 3E 		mfspr	r3,tick					; get orginal count
                	.0001:
011A20 02 40 08 3E 		mfspr	r4,tick
011A24 02 42 06 0A 		sub		r4,r4,r3
011A28 3D 42 08 00 		blt  	r4,.0002				; shouldn't be -ve unless counter overflowed
011A2C FC 03 00 00 		cmpu	r4,r4,#250000			; about 10ms at 25 MHz
011A30 16 42 20 A1 
011A34 3D 42 F6 FF 		blt		r4,.0001
                	.0002:
011A38 57 4F 10 00 		pop		r4
011A3C 57 3F 10 00 	    pop     r3
011A40 37 FF 01 00 		rtl

                		;--------------------------------------------------------------------------
                		; PS2 scan codes to ascii conversion tables.
                		;--------------------------------------------------------------------------
                		;
011A44 00 00 00 00 		align	1
011A48 00 00 00 00 
011A4C 00 00 00 00 
                	
                	unshiftedScanCodes:
011A50 2E A9 2E A5 		.byte	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
011A54 A3 A1 A2 AC 
011A58 2E AA A8 A6 		.byte	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
011A5C A4 09 60 2E 
011A60 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
011A64 2E 71 31 2E 
011A68 2E 2E 7A 73 		.byte	$2e,$2e,$7a,$73,$61,$77,$32,$2e
011A6C 61 77 32 2E 
011A70 2E 63 78 64 		.byte	$2e,$63,$78,$64,$65,$34,$33,$2e
011A74 65 34 33 2E 
011A78 2E 20 76 66 		.byte	$2e,$20,$76,$66,$74,$72,$35,$2e
011A7C 74 72 35 2E 
011A80 2E 6E 62 68 		.byte	$2e,$6e,$62,$68,$67,$79,$36,$2e
011A84 67 79 36 2E 
011A88 2E 2E 6D 6A 		.byte	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
011A8C 75 37 38 2E 
011A90 2E 2C 6B 69 		.byte	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
011A94 6F 30 39 2E 
011A98 2E 2E 2F 6C 		.byte	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
011A9C 3B 70 2D 2E 
011AA0 2E 2E 27 2E 		.byte	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
011AA4 5B 3D 2E 2E 
011AA8 AD 2E 0D 5D 		.byte	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
011AAC 2E 5C 2E 2E 
011AB0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
011AB4 2E 2E 08 2E 
011AB8 2E 95 2E 93 		.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
011ABC 94 2E 2E 2E 
011AC0 98 7F 92 2E 		.byte	$98,$7f,$92,$2e,$91,$90,$1b,$af
011AC4 91 90 1B AF 
011AC8 AB 2E 97 2E 		.byte	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
011ACC 2E 96 AE 2E 
                	
011AD0 2E 2E 2E A7 		.byte	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
011AD4 2E 2E 2E 2E 
011AD8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011ADC 2E 2E 2E 2E 
011AE0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011AE4 2E 2E 2E 2E 
011AE8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011AEC 2E 2E 2E 2E 
011AF0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011AF4 2E 2E 2E 2E 
011AF8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011AFC 2E 2E 2E 2E 
011B00 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B04 2E 2E 2E 2E 
011B08 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B0C 2E 2E 2E 2E 
011B10 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B14 2E 2E 2E 2E 
011B18 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B1C 2E 2E 2E 2E 
011B20 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B24 2E 2E 2E 2E 
011B28 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B2C 2E 2E 2E 2E 
011B30 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B34 2E 2E 2E 2E 
011B38 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B3C 2E 2E 2E 2E 
011B40 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B44 2E 2E 2E 2E 
011B48 2E 2E FA 2E 		.byte	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
011B4C 2E 2E 2E 2E 
                	
                	shiftedScanCodes:
011B50 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B54 2E 2E 2E 2E 
011B58 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
011B5C 2E 09 7E 2E 
011B60 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
011B64 2E 51 21 2E 
011B68 2E 2E 5A 53 		.byte	$2e,$2e,$5a,$53,$41,$57,$40,$2e
011B6C 41 57 40 2E 
011B70 2E 43 58 44 		.byte	$2e,$43,$58,$44,$45,$24,$23,$2e
011B74 45 24 23 2E 
011B78 2E 20 56 46 		.byte	$2e,$20,$56,$46,$54,$52,$25,$2e
011B7C 54 52 25 2E 
011B80 2E 4E 42 48 		.byte	$2e,$4e,$42,$48,$47,$59,$5e,$2e
011B84 47 59 5E 2E 
011B88 2E 2E 4D 4A 		.byte	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
011B8C 55 26 2A 2E 
011B90 2E 3C 4B 49 		.byte	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
011B94 4F 29 28 2E 
011B98 2E 3E 3F 4C 		.byte	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
011B9C 3A 50 5F 2E 
011BA0 2E 2E 22 2E 		.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
011BA4 7B 2B 2E 2E 
011BA8 2E 2E 0D 7D 		.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
011BAC 2E 7C 2E 2E 
011BB0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
011BB4 2E 2E 08 2E 
011BB8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011BBC 2E 2E 2E 2E 
011BC0 2E 7F 2E 2E 		.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
011BC4 2E 2E 1B 2E 
011BC8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011BCC 2E 2E 2E 2E 
                	
011BD0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011BD4 2E 2E 2E 2E 
011BD8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011BDC 2E 2E 2E 2E 
011BE0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011BE4 2E 2E 2E 2E 
011BE8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011BEC 2E 2E 2E 2E 
011BF0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011BF4 2E 2E 2E 2E 
011BF8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011BFC 2E 2E 2E 2E 
011C00 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C04 2E 2E 2E 2E 
011C08 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C0C 2E 2E 2E 2E 
011C10 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C14 2E 2E 2E 2E 
011C18 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C1C 2E 2E 2E 2E 
011C20 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C24 2E 2E 2E 2E 
011C28 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C2C 2E 2E 2E 2E 
011C30 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C34 2E 2E 2E 2E 
011C38 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C3C 2E 2E 2E 2E 
011C40 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C44 2E 2E 2E 2E 
011C48 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C4C 2E 2E 2E 2E 
                	
                	; control
                	keybdControlCodes:
011C50 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C54 2E 2E 2E 2E 
011C58 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
011C5C 2E 09 7E 2E 
011C60 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
011C64 2E 11 21 2E 
011C68 2E 2E 1A 13 		.byte	$2e,$2e,$1a,$13,$01,$17,$40,$2e
011C6C 01 17 40 2E 
011C70 2E 03 18 04 		.byte	$2e,$03,$18,$04,$05,$24,$23,$2e
011C74 05 24 23 2E 
011C78 2E 20 16 06 		.byte	$2e,$20,$16,$06,$14,$12,$25,$2e
011C7C 14 12 25 2E 
011C80 2E 0E 02 08 		.byte	$2e,$0e,$02,$08,$07,$19,$5e,$2e
011C84 07 19 5E 2E 
011C88 2E 2E 0D 0A 		.byte	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
011C8C 15 26 2A 2E 
011C90 2E 3C 0B 09 		.byte	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
011C94 0F 29 28 2E 
011C98 2E 3E 3F 0C 		.byte	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
011C9C 3A 10 5F 2E 
011CA0 2E 2E 22 2E 		.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
011CA4 7B 2B 2E 2E 
011CA8 2E 2E 0D 7D 		.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
011CAC 2E 7C 2E 2E 
011CB0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
011CB4 2E 2E 08 2E 
011CB8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011CBC 2E 2E 2E 2E 
011CC0 2E 7F 2E 2E 		.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
011CC4 2E 2E 1B 2E 
011CC8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011CCC 2E 2E 2E 2E 
                	
                	keybdExtendedCodes:
011CD0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
011CD4 A3 A1 A2 2E 
011CD8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011CDC 2E 2E 2E 2E 
011CE0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011CE4 2E 2E 2E 2E 
011CE8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011CEC 2E 2E 2E 2E 
011CF0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011CF4 2E 2E 2E 2E 
011CF8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011CFC 2E 2E 2E 2E 
011D00 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D04 2E 2E 2E 2E 
011D08 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D0C 2E 2E 2E 2E 
011D10 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D14 2E 2E 2E 2E 
011D18 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D1C 2E 2E 2E 2E 
011D20 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D24 2E 2E 2E 2E 
011D28 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D2C 2E 2E 2E 2E 
011D30 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D34 2E 2E 2E 2E 
011D38 2E 95 2E 93 		.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
011D3C 94 2E 2E 2E 
011D40 98 99 92 2E 		.byte	$98,$99,$92,$2e,$91,$90,$2e,$2e
011D44 91 90 2E 2E 
011D48 2E 2E 97 2E 		.byte	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
011D4C 2E 96 2E 2E 
                	
                	
                	; ============================================================================
                	; I2C interface to RTCC
                	; ============================================================================
                	
                	I2C_INIT:
011D50 E7 E0 01 00 	    push    r1
011D54 67 E1 01 00 	    push    r2
011D58 7C DC FF 00 		ldi		r2,#I2C_MASTER
011D5C 0A 20 00 1C 
011D60 60 01 04 00 		sb		r0,I2C_CONTROL[r2]		; disable the contoller
011D64 60 01 02 00 		sb		r0,I2C_PRESCALE_HI[r2]	; set clock divisor for 100kHz
011D68 0A 10 C6 00 		ldi		r1,#99					; 24=400kHz, 99=100KHz
011D6C 60 11 00 00 		sb		r1,I2C_PRESCALE_LO[r2]
011D70 0A 10 00 01 		ldi		r1,#$80					; controller enable bit
011D74 60 11 04 00 		sb		r1,I2C_CONTROL[r2]
011D78 57 2F 10 00 		pop		r2
011D7C 57 1F 10 00 	    pop     r1
011D80 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; I2C Read
                	;
                	; Parameters:
                	; 	r1 = device ($6F for RTCC)
                	; 	r2 = register to read
                	; Returns
                	; 	r1 = register value $00 to $FF if successful, else r1 = -1 on error
                	;------------------------------------------------------------------------------
                	;
                	I2C_READ:
011D84 E7 EF 01 00 	    push    lr
011D88 67 E1 01 00 		push	r2
011D8C E7 E1 01 00 	    push    r3
011D90 67 E2 01 00 	    push    r4
011D94 82 10 02 70 		asl		r1,r1,#1				; clear rw bit for write
                	;	or		r1,r1,#1				; set rw bit for a read
011D98 82 40 00 1A 		mov		r4,r1					; save device address in r4
011D9C 02 31 00 1A 		mov		r3,r2
                		; transmit device #
011DA0 7C DC FF 00 		ldi		r2,#I2C_MASTER
011DA4 0A 20 00 1C 
011DA8 60 11 06 00 		sb		r1,I2C_TX[r2]
011DAC 0A 10 20 01 		ldi		r1,#$90					; STA($80) and WR($10) bits set
011DB0 60 11 08 00 		sb		r1,I2C_CMD[r2]
011DB4 B9 1F 00 00 		bsr		I2C_WAIT_TC				; wait for transmit to complete
                		; transmit register #
011DB8 40 11 08 00 		lb		r1,I2C_STAT[r2]
011DBC 8C 10 00 01 		and		r1,r1,#$80				; test RxACK bit
011DC0 BD 10 30 00 		bne	    r1,I2C_ERR
011DC4 60 31 06 00 		sb		r3,I2C_TX[r2]			; select register r3
011DC8 0A 10 20 00 		ldi		r1,#$10					; set WR bit
011DCC 60 11 08 00 		sb		r1,I2C_CMD[r2]
011DD0 39 1C 00 00 		bsr		I2C_WAIT_TC
                	
                		; transmit device #
011DD4 40 11 08 00 		lb		r1,I2C_STAT[r2]
011DD8 8C 10 00 01 		and		r1,r1,#$80				; test RxACK bit
011DDC BD 10 22 00 		bne	    r1,I2C_ERR
011DE0 0D 42 02 00 		or		r4,r4,#1				; set read flag
011DE4 60 41 06 00 		sb		r4,I2C_TX[r2]
011DE8 0A 10 20 01 		ldi		r1,#$90					; STA($80) and WR($10) bits set
011DEC 60 11 08 00 		sb		r1,I2C_CMD[r2]
011DF0 39 18 00 00 		bsr		I2C_WAIT_TC				; wait for transmit to complete
                	
                		; receive data byte
011DF4 40 11 08 00 		lb		r1,I2C_STAT[r2]
011DF8 8C 10 00 01 		and		r1,r1,#$80				; test RxACK bit
011DFC BD 10 12 00 		bne	    r1,I2C_ERR
011E00 0A 10 D0 00 		ldi		r1,#$68					; STO($40), RD($20), and NACK($08)
011E04 60 11 08 00 		sb		r1,I2C_CMD[r2]
011E08 39 15 00 00 		bsr		I2C_WAIT_TC
011E0C 41 11 06 00 		lbu		r1,I2C_RX[r2]			; $00 to $FF = byte read, -1=err
011E10 57 4F 10 00 		pop		r4
011E14 57 3F 10 00 	    pop     r3
011E18 57 2F 10 00 	    pop     r2
011E1C 3B FF 11 00 		rts

                	I2C_ERR:
011E20 0A 10 FE FF 		ldi		r1,#-1
011E24 82 02 00 3C 		mtspr	cr0,r5					; restore TMR
011E28 57 4F 10 00 		pop		r4/r3/r2/r5
011E2C 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; I2C Write
                	;
                	; Parameters:
                	; 	r1 = device ($6F)
                	; 	r2 = register to write
                	; 	r3 = value for register
                	; Returns
                	; 	r1 = 0 if successful, else r1 = -1 on error
                	;------------------------------------------------------------------------------
                	;
                	I2C_WRITE:
011E30 E7 EF 01 00 		push	lr
011E34 67 E1 01 00 	    push    r2
011E38 E7 E1 01 00 	    push    r3
011E3C 67 E2 01 00 	    push    r4
011E40 82 10 02 70 		asl		r1,r1,#1				; clear rw bit for write
011E44 82 41 00 1A 		mov		r4,r3					; save value r4
011E48 02 31 00 1A 		mov		r3,r2
                		; transmit device #
011E4C 7C DC FF 00 		ldi		r2,#I2C_MASTER			; r2 = I/O base address of controller
011E50 0A 20 00 1C 
011E54 60 11 06 00 		sb		r1,I2C_TX[r2]
011E58 0A 10 20 01 		ldi		r1,#$90					; STA($80) and WR($10) bits set
011E5C 60 11 08 00 		sb		r1,I2C_CMD[r2]
011E60 39 0A 00 00 		bsr		I2C_WAIT_TC				; wait for transmit to complete
                		; transmit register #
011E64 40 11 08 00 		lb		r1,I2C_STAT[r2]
011E68 8C 10 00 01 		and		r1,r1,#$80				; test RxACK bit
011E6C BD 10 DA FF 		bne  	r1,I2C_ERR
011E70 60 31 06 00 		sb		r3,I2C_TX[r2]			; select register r3
011E74 0A 10 20 00 		ldi		r1,#$10					; set WR bit
011E78 60 11 08 00 		sb		r1,I2C_CMD[r2]
011E7C B9 06 00 00 		bsr		I2C_WAIT_TC
                		; transmit value
011E80 40 11 08 00 		lb		r1,I2C_STAT[r2]
011E84 8C 10 00 01 		and		r1,r1,#$80				; test RxACK bit
011E88 BD 10 CC FF 		bne  	r1,I2C_ERR
011E8C 60 41 06 00 		sb		r4,I2C_TX[r2]			; select value in r4
011E90 0A 10 A0 00 		ldi		r1,#$50					; set STO, WR bit
011E94 60 11 08 00 		sb		r1,I2C_CMD[r2]
011E98 39 03 00 00 		bsr		I2C_WAIT_TC
011E9C 0A 10 00 00 		ldi		r1,#0					; everything okay
011EA0 57 4F 10 00 		pop		r4
011EA4 57 3F 10 00 	    pop     r3
011EA8 57 2F 10 00 	    pop     r2
011EAC 3B FF 11 00 		rts

                	; Wait for I2C controller transmit complete
                	
                	I2C_WAIT_TC:
                	.0001:
011EB0 40 11 08 00 		lb		r1,I2C_STAT[r2]
011EB4 8C 10 04 00 		and		r1,r1,#2
011EB8 BD 10 FC FF 		bne 	r1,.0001
011EBC 37 FF 01 00 		rtl

                	; Read the entire contents of the RTCC including 64 SRAM bytes
                	
                	RTCCReadbuf:
011EC0 E7 EF 01 00 	    push    lr
011EC4 B9 D1 FF FF 		bsr		I2C_INIT
011EC8 0A 20 00 00 		ldi		r2,#$00
                	.0001:
011ECC 0A 10 DE 00 		ldi		r1,#$6F
011ED0 B9 D6 FF FF 		bsr		I2C_READ
011ED4 60 11 A0 07 		sb		r1,RTCC_BUF[r2]
011ED8 04 21 02 00 		add		r2,r2,#1
011EDC 16 11 C0 00 		cmpu	r1,r2,#$60
011EE0 BD 40 F6 FF 		blt		r1,.0001
011EE4 3B FF 11 00 		rts

                	; Write the entire contents of the RTCC including 64 SRAM bytes
                	
                	RTCCWritebuf:
011EE8 E7 EF 01 00 	    push    lr
011EEC B9 CC FF FF 		bsr		I2C_INIT
011EF0 0A 20 00 00 		ldi		r2,#$00
                	.0001:
011EF4 0A 10 DE 00 		ldi		r1,#$6F
011EF8 41 31 A0 07 		lbu		r3,RTCC_BUF[r2]
011EFC B9 E6 FF FF 		bsr		I2C_WRITE
011F00 04 21 02 00 		add		r2,r2,#1
011F04 16 11 C0 00 		cmpu	r1,r2,#$60
011F08 BD 40 F6 FF 		blt		r1,.0001
011F0C 3B FF 11 00 		rts

                	RTCCOscOn:
011F10 E7 EF 01 00 	    push    lr
011F14 B9 C7 FF FF 		bsr		I2C_INIT
011F18 0A 10 DE 00 		ldi		r1,#$6F
011F1C 0A 20 00 00 		ldi		r2,#$00			; register zero
011F20 B9 CC FF FF 		bsr		I2C_READ		; read register zero
011F24 8D 30 00 01 		or		r3,r1,#$80		; set start osc bit
011F28 0A 10 DE 00 		ldi		r1,#$6F
011F2C B9 E0 FF FF 		bsr		I2C_WRITE
011F30 3B FF 11 00 		rts

                	; ============================================================================
                	; SD/MMC Card interface
                	; ============================================================================
                	SD_INIT:
011F34 E7 EF 01 00 	    push    lr
011F38 7C DC FF 00 		ldi		r3,#SD_MASTER
011F3C 0A 30 00 16 
011F40 7C 00 00 00 		ldi		r2,#25000
011F44 0A 20 50 C3 
011F48 E1 21 58 00 		sc		r2,0x2c[r3]		; timeout register
                		; Software reset should be held active for several cycles to allow
                		; reset to be detected on the sd_clk domain.
011F4C 0A 20 02 00 		ldi		r2,#1
011F50 E0 21 50 00 		sb		r2,0x28[r3]		; software reset reg
011F54 0A 20 04 00 		ldi		r2,#2
011F58 E0 21 98 00 		sb		r2,0x4c[r3]		; prog /6 for clock divider
011F5C 0A 10 C8 00 		ldi		r1,#100			; software reset delay
011F60 39 47 00 00 		bsr     MicroDelay
011F64 E0 01 50 00 		sb		r0,0x28[r3]		; clear software reset
011F68 E1 01 08 00 		sc		r0,0x04[r3]		; command 0
011F6C E2 01 00 00 		sh		r0,0x00[r3]		; arg 0
011F70 39 28 00 00 		bsr		SD_WAIT_RESP
011F74 C4 11 18 00 		lh		r1,0x0C[r3]		; read response register
011F78 39 EE FC FF 		bsr		DisplayHalf
011F7C 3B FF 11 00 		rts

                	SD_CMD8:
011F80 E7 EF 01 00 	    push    lr
011F84 7C DC FF 00 		ldi		r3,#SD_MASTER
011F88 0A 30 00 16 
011F8C 0A 20 34 10 		ldi		r2,#$81A
011F90 E1 21 08 00 		sc		r2,0x04[r3]		; set command register
011F94 0A 20 54 03 		ldi		r2,#$1AA
011F98 E2 21 00 00 		sh		r2,0x00[r3]		; set command argument x1AA
011F9C B9 22 00 00 		bsr		SD_WAIT_RESP
011FA0 7C 00 00 00 		sb		r1,SD_2_0
011FA4 7C 00 00 00 
011FA8 60 10 F0 03 
011FAC C4 11 18 00 		lh		r1,0x0C[r3]		; read response register
011FB0 39 E7 FC FF 		bsr		DisplayHalf
                		; send command zero
011FB4 E1 01 08 00 		sc		r0,0x04[r3]
011FB8 E2 01 00 00 		sh		r0,0x00[r3]
011FBC B9 1E 00 00 		bsr		SD_WAIT_RESP
011FC0 7C 00 00 00 		lbu		r1,SD_2_0
011FC4 7C 00 00 00 
011FC8 41 10 F0 03 
011FCC BD 00 12 00 		beq		r1,.0001
011FD0 0A 10 64 00 		ldi		r1,#'2'
011FD4 B9 28 FE FF 		bsr		OutChar
011FD8 0A 10 5C 00 		ldi		r1,#'.'
011FDC B9 27 FE FF 		bsr		OutChar
011FE0 0A 10 60 00 		ldi		r1,#'0'
011FE4 B9 26 FE FF 		bsr		OutChar
011FE8 39 F5 FC FF 		bsr		CRLF
011FEC 3B FF 11 00 		rts
.0001:
011FF0 E1 01 08 00 		sc		r0,0x04[r3]		; send CMD0
011FF4 E2 01 00 00 		sh		r0,0x00[r3]
                	.0002:
011FF8 C3 11 10 00 		lcu		r1,0x08[r3]
011FFC 8C 10 02 00 		and		r1,r1,#1
012000 BD 10 FC FF 		bne  	r1,.0002
012004 02 40 00 1A 		mov		r4,r0			; ret_reg = r4 = 0
                	.0004:
012008 02 52 00 1A 		mov		r5,r4
01200C 7C 00 80 00 		and		r4,r4,#$80000000
012010 0C 42 00 00 
012014 3D 12 20 00 		bne  	r4,.0003
012018 0A 10 04 6E 		ldi		r1,#$3702		; CMD55|RSP48
01201C E1 11 08 00 		sc		r1,0x04[r3]
012020 E2 01 00 00 		sh		r0,0x00[r3]
012024 B9 11 00 00 		bsr		SD_WAIT_RESP
012028 BD 10 38 00 		bne  	r1,.respOk
01202C 0A 10 04 52 		ldi		r1,#$2902		; ACMD41|RSP48
012030 E1 11 08 00 		sc		r1,0x04[r3]
012034 E2 01 00 00 		sh		r0,0x00[r3]
012038 39 0F 00 00 		bsr		SD_WAIT_RESP
01203C BD 10 2E 00 		bne  	r1,.respOk
012040 C4 41 18 00 		lh		r4,0x0c[r3]		; ret_reg = RESP1
012044 02 12 00 1A 		mov		r1,r4
012048 39 D4 FC FF 		bsr		DisplayHalf
01204C B9 E8 FC FF 		bsr		CRLF
012050 3A F7 FF FF 		bra		.0004
                	.0003:
012054 FC FF 00 00 		and		r1,r5,#$FFFFFF	; voltage mask
012058 8C 12 FE FF 
01205C B9 D1 FC FF 		bsr		DisplayHalf
012060 39 E6 FC FF 		bsr		CRLF
                		; GetCID
012064 0A 10 02 04 		ldi		r1,#$201		; CMD2 + RSP146
012068 E1 11 08 00 		sc		r1,0x04[r3]
01206C E2 01 00 00 		sh		r0,0x00[r3]
012070 39 08 00 00 		bsr		SD_WAIT_RESP
                		; GetRCA
012074 0A 10 34 06 		ldi		r1,#$31A		; CMD3 + CICE + CRCE + RSP48
012078 E1 11 08 00 		sc		r1,0x04[r3]
01207C E2 01 00 00 		sh		r0,0x00[r3]
012080 39 06 00 00 		bsr		SD_WAIT_RESP
012084 C4 41 18 00 		lh		r4,0x0c[r3]			; r4 = RESP1
012088 7C FF FF 00 		and		r1,r4,#$FFFF0000	; r4 & RCA_MASK
01208C 0C 12 00 00 
012090 39 CB FC FF 		bsr		DisplayHalf
012094 B9 DF FC FF 		bsr		CRLF
                	.respOk:
012098 0A 10 9E 00 		ldi		r1,#'O'
01209C B9 0F FE FF 		bsr		OutChar
0120A0 0A 10 D6 00 		ldi		r1,#'k'
0120A4 B9 0E FE FF 		bsr		OutChar
0120A8 39 DD FC FF 		bsr		CRLF
0120AC 3B FF 11 00 		rts

                	SD_WAIT_RESP:
0120B0 E7 EF 01 00 	    push    lr
0120B4 67 E1 01 00 		push	r2
0120B8 E7 E1 01 00 	    push    r3
0120BC 7C DC FF 00 		ldi		r2,#SD_MASTER
0120C0 0A 20 00 16 
                	.0001:
0120C4 42 31 68 00 		lc		r3,0x34[r2]		; read error interrupt status reg
0120C8 42 11 60 00 		lc		r1,0x30[r2]		; read normal interrupt status reg
0120CC 8C 31 02 00 		and		r3,r3,#1		; get command timeout indicator
0120D0 BD 11 10 00 		bne  	r3,.0002
0120D4 8C 10 02 00 		and		r1,r1,#1		; wait for command complete bit to set
0120D8 BD 00 F6 FF 		beq		r1,.0001
0120DC 0A 10 02 00 		ldi		r1,#1
0120E0 57 3F 10 00 		pop		r3
0120E4 57 2F 10 00 	    pop     r2
0120E8 57 FF 11 00 	    pop     lr
0120EC 37 FF 01 00 		rtl
.0002:
0120F0 0A 10 A8 00 		ldi		r1,#'T'
0120F4 B9 04 FE FF 		bsr		OutChar
0120F8 0A 10 9E 00 		ldi		r1,#'O'
0120FC B9 03 FE FF 		bsr		OutChar
012100 39 D2 FC FF 		bsr		CRLF
012104 0A 10 00 00 		ldi		r1,#0
012108 57 3F 10 00 		pop		r3
01210C 57 2F 10 00 	    pop     r2
012110 57 FF 11 00 	    pop     lr
012114 37 FF 01 00 		rtl

                	; ============================================================================
                	; ============================================================================
                	
012118 7C 01 00 00 	    ldi     r1,#brkpt1           ; set breakpoint address
01211C 0A 10 B8 42 
012120 82 00 64 3C 	    mtspr   dbad0,r1
012124 0A 10 00 00 	    ldi     r1,#$0000000000000000   ; enable instruction breakpoint, turn on single step mode
012128 82 00 6C 3C 	    mtspr   dbctrl,r1
01212C 02 00 54 3C 	    mtspr   lotgrp,r0            ; operating system is group #0
012130 B9 04 00 00 	    bsr     SetupMemtags
012134 0A 10 C8 00 	    ldi     r1,#100
012138 39 0C 00 00 	    bsr     MicroDelay
01213C 3F 00 00 00 	    nop
012140 3F 00 00 00 	    nop
                	hangprg:
012144 3F 00 00 00 	    nop
012148 3F 00 00 00 	    nop
01214C 3F 00 00 00 	    nop
012150 BA FE FF FF 	    bra     hangprg
                	
                	SetupMemtags:
012154 02 00 50 3C 	    mtspr   ea,r0                ; select tag for first 64kB
012158 0A 10 0C 00 	    ldi     r1,#$0006            ; system only: readable, writeable, not executable
                	brkpt1:
01215C 82 00 52 3C 	    mtspr   tag,r1
012160 7C 01 00 00 	    ldi     r1,#$10000           ; select tag for second 64kB
012164 0A 10 00 00 
012168 82 00 50 3C 	    mtspr   ea,r1
01216C 0A 20 0A 00 	    ldi     r2,#$0005            ; system only: readable, executable, not writeable
012170 02 01 52 3C 	    mtspr   tag,r2
012174 0A 30 24 00 	    ldi     r3,#20-2             ; number of tags to setup
                	.0001:
012178 7C 01 00 00 	    addui   r1,r1,#$10000
01217C 94 10 00 00 
012180 82 00 50 3C 	    mtspr   ea,r1
012184 0A 20 0C 00 	    ldi     r2,#$0006            ; set them up as data
012188 02 01 52 3C 	    mtspr   tag,r2
01218C 95 31 02 00 	    subui   r3,r3,#1
012190 BD 11 F4 FF 	    bne     r3,.0001
012194 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	; MicroDelay
                	;     Delay for a short time for at least the specified number of clock cycles
                	;
                	; Parameters:
                	;     r1 = required delay in clock ticks
                	;------------------------------------------------------------------------------
                	;
                	MicroDelay:
012198 67 E1 01 00 	    push    r2
01219C E7 E1 01 00 	    push    r3
0121A0 02 30 08 3E 	    mfspr   r3,tick             ; get starting tick
                	.0001:
0121A4 02 20 08 3E 	    mfspr   r2,tick
0121A8 02 21 06 2A 	    subu    r2,r2,r3
0121AC 02 21 02 0C 	    cmp     r2,r2,r1
0121B0 3D 41 FA FF 	    blt     r2,.0001
0121B4 57 3F 10 00 	    pop     r3
0121B8 57 2F 10 00 	    pop     r2
0121BC 37 FF 01 00 	    rtl
;
0121C0 3F 00 00 00 	    nop
0121C4 3F 00 00 00 	    nop
                	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	LoadFromSerial:
0121C8 E7 EF 01 00 	    push    lr
0121CC 7C 00 00 00 	    ldi     r3,#16384
0121D0 0A 30 00 80 
0121D4 7C 02 00 00 	    ldi     r2,#$24000          ; target store address
0121D8 0A 20 00 80 
                	.0001:
0121DC B9 20 FC FF 	    bsr     SerialGetCharDirect
0121E0 60 11 00 00 	    sb      r1,[r2]
0121E4 14 21 02 00 	    addui   r2,r2,#1
0121E8 95 31 02 00 	    subui   r3,r3,#1
0121EC BD 11 F8 FF 	    bne     r3,.0001
0121F0 3B FF 11 00 	    rts

                	;------------------------------------------------------------------------------
                	; Execution fault. Occurs when an attempt is made to execute code from a
                	; page marked as non-executable.
                	;------------------------------------------------------------------------------
                	
                	exf_rout:
0121F4 0A 10 76 01 		ldi		r1,#$bb
0121F8 7C DC FF 00 		sc		r1,LEDS
0121FC 61 10 00 0C 
012200 7C 01 00 00 		ldi		r1,#msgexf
012204 0A 10 C8 44 
012208 B9 AF FC FF 		bsr		DisplayStringCRLF
                	.0001:
01220C 3A 00 00 00 		bra .0001
                	
                	;------------------------------------------------------------------------------
                	; Data read fault. Occurs when an attempt is made to read from a page marked
                	; as non-readble.
                	;------------------------------------------------------------------------------
                	
                	drf_rout:
012210 0A 10 76 01 		ldi		r1,#$bb
012214 7C DC FF 00 		sc		r1,LEDS
012218 61 10 00 0C 
01221C 7C 01 00 00 		ldi		r1,#msgdrf
012220 0A 10 D2 44 
012224 39 AC FC FF 		bsr		DisplayStringCRLF
                	.0001:
012228 3A 00 00 00 		bra .0001
                	
                	;------------------------------------------------------------------------------
                	; Data write fault. Occurs when an attempt is made to write to a page marked
                	; as non-writeable.
                	;------------------------------------------------------------------------------
                	
                	dwf_rout:
01222C 0A 10 76 01 		ldi		r1,#$bb
012230 7C DC FF 00 		sc		r1,LEDS
012234 61 10 00 0C 
012238 7C 01 00 00 		ldi		r1,#msgdwf
01223C 0A 10 DC 44 
012240 B9 A8 FC FF 		bsr		DisplayStringCRLF
                	.0001:
012244 3A 00 00 00 		bra .0001
                	
                	;------------------------------------------------------------------------------
                	; Privilege violation fault. Occurs when the current privilege level isn't
                	; sufficient to allow access.
                	;------------------------------------------------------------------------------
                	
                	priv_rout:
012248 0A 10 78 01 		ldi		r1,#$bc
01224C 7C DC FF 00 		sc		r1,LEDS
012250 61 10 00 0C 
012254 7C 01 00 00 		ldi		r1,#msgPriv
012258 0A 10 E6 44 
01225C 39 A5 FC FF 		bsr		DisplayStringCRLF
                	.0001:
012260 3A 00 00 00 		bra .0001
                	
                	;------------------------------------------------------------------------------
                	; Message strings for the faults.
                	;------------------------------------------------------------------------------
                	
                	msgexf:
012264 65 78 66 20 		db	"exf ",0
012268 00          
                	msgdrf:
012269 64 72 66 20 		db	"drf ",0
01226D 00          
                	msgdwf:
01226E 64 77 66 20 		db	"dwf ",0
012272 00          
                	msgPriv:
012273 70 72 69 76 		db	"priv fault",0
012277 20 66 61 75 
01227B 6C 74 00    
                	msgUninit:
01227E 75 6E 69 6E 		db	"uninit int.",0
012282 69 74 20 69 
012286 6E 74 2E 00 
                	msgBusErr:
01228A 0D 0A 42 75 	    db  CR,LF,"Bus error PC=",0
01228E 73 20 65 72 
012292 72 6F 72 20 
012296 50 43 3D 00 
                	msgEA:
01229A 20 45 41 3D 	    db  " EA=",0
01229E 00          
                	
                	;------------------------------------------------------------------------------
                	; Bus error routine.
                	;------------------------------------------------------------------------------
                	
                	berr_rout:
01229F 00 7C 00 00 	    ldi     sp,#$7800
0122A3 00 0A E0 01 
0122A7 F0          
0122A8 FC 00 00 00 		ldi		r1,#$bebe
0122AC 0A 10 7C 7D 
0122B0 7C DC FF 00 		sc		r1,LEDS
0122B4 61 10 00 0C 
0122B8 7C 01 00 00 		ldi     r1,#msgBusErr
0122BC 0A 10 14 45 
0122C0 B9 92 FC FF 		bsr     DisplayString
0122C4 02 10 10 3E 		mfspr   r1,ipc
0122C8 B9 81 FC FF 		bsr		DisplayWord
0122CC 7C 01 00 00 		ldi     r1,#msgEA
0122D0 0A 10 34 45 
0122D4 39 90 FC FF 		bsr     DisplayString
0122D8 02 10 16 3E 	    mfspr   r1,bear
0122DC 39 7F FC FF 		bsr     DisplayWord
0122E0 39 96 FC FF 		bsr     CRLF
0122E4 B9 9A FE FF 		bsr		KeybdGetCharWait
                	
                		; In order to return an RTI must be used to exit the routine (or interrupts
                		; will permanently disabled). The RTI instruction clears an internal
                		; processor flag used to prevent nested interrupts.
                		; Since this is a serious error the system is just restarted. So the IPC
                		; is set to point to the restart address.
                	
0122E8 7C 01 00 00 		ldi     r1,#start
0122EC 0A 10 00 01 
0122F0 82 00 10 3C 		mtspr   ipc,r1
                		
                		; Allow pipeline time for IPC to update before RTI (there's no results
                		; forwarding on SPR's).
0122F4 3F 00 00 00 		nop     
0122F8 3F 00 00 00 		nop
0122FC 02 E0 3F 6E 		rti
                	
                	
                	SSM_ISR:
012300 02 E0 3B 6E 	    rtd
                	
                	IBPT_ISR:
012304 02 E0 3B 6E 	    rtd
                	.0001:
012308 3A 00 00 00 	    bra     .0001
                	
                		code
01230C 00 00 00 00 		align	1
                	
                	get_datetime:
012310 15 EF 21 00 		      	subui	sp,sp,#16
012314 E7 ED 01 00 		      	push 	bp
012318 02 BF 01 1A 		      	mov  	bp,sp
01231C 15 EF 11 00 		      	subui	sp,sp,#8
012320 E7 E5 01 00 		      	push 	r11
012324 67 E6 01 00 		      	push 	r12
012328 E7 E6 01 00 		      	push 	r13
01232C 67 E7 01 00 		      	push 	r14
012330 E7 E7 01 00 		      	push 	r15
012334 67 E8 01 00 		      	push 	r16
012338 E7 E8 01 00 		      	push 	r17
01233C 0A B0 A0 07 		      	ldi  	r11,#RTCC_BUF
012340 C6 CD A0 00 		      	lw   	r12,80[bp]
012344 C6 DD 90 00 		      	lw   	r13,72[bp]
012348 C6 ED 80 00 		      	lw   	r14,64[bp]
01234C C6 FD 70 00 		      	lw   	r15,56[bp]
012350 C6 0D 61 00 		      	lw   	r16,48[bp]
012354 C6 1D 51 00 		      	lw   	r17,40[bp]
012358 BD 08 20 00 		      	beq  	r17,set_time_serial_2
01235C C1 35 0C 00 		      	lbu  	r3,6[r11]
012360 82 31 00 20 		      	sxb  	r3,r3
012364 E3 3D F0 FF 		      	sw   	r3,-8[bp]
012368 0A 30 A0 0F 		      	ldi  	r3,#2000
01236C C6 4D F0 FF 		      	lw   	r4,-8[bp]
012370 0C 42 1E 00 		      	and  	r4,r4,#15
012374 C6 5D F0 FF 		      	lw   	r5,-8[bp]
012378 8C 52 E0 01 		      	and  	r5,r5,#240
01237C 82 52 08 78 		      	asri 	r5,r5,#4
012380 87 52 14 00 		      	mul  	r5,r5,#10
012384 02 42 0A 28 		      	addu 	r4,r4,r5
012388 82 31 08 28 		      	addu 	r3,r3,r4
01238C E3 3D F0 FF 		      	sw   	r3,-8[bp]
012390 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012394 E3 38 00 00 		      	sw   	r3,[r17]
                	set_time_serial_2:
012398 3D 08 1C 00 		      	beq  	r16,set_time_serial_4
01239C C1 35 08 00 		      	lbu  	r3,4[r11]
0123A0 82 31 00 20 		      	sxb  	r3,r3
0123A4 E3 3D F0 FF 		      	sw   	r3,-8[bp]
0123A8 C6 3D F0 FF 		      	lw   	r3,-8[bp]
0123AC 8C 31 1E 00 		      	and  	r3,r3,#15
0123B0 C6 4D F0 FF 		      	lw   	r4,-8[bp]
0123B4 0C 42 20 00 		      	and  	r4,r4,#16
0123B8 02 42 08 78 		      	asri 	r4,r4,#4
0123BC 07 42 14 00 		      	mul  	r4,r4,#10
0123C0 82 31 08 28 		      	addu 	r3,r3,r4
0123C4 E3 3D F0 FF 		      	sw   	r3,-8[bp]
0123C8 C6 3D F0 FF 		      	lw   	r3,-8[bp]
0123CC 63 38 00 00 		      	sw   	r3,[r16]
                	set_time_serial_4:
0123D0 BD 07 1C 00 		      	beq  	r15,set_time_serial_6
0123D4 C1 35 0A 00 		      	lbu  	r3,5[r11]
0123D8 82 31 00 20 		      	sxb  	r3,r3
0123DC E3 3D F0 FF 		      	sw   	r3,-8[bp]
0123E0 C6 3D F0 FF 		      	lw   	r3,-8[bp]
0123E4 8C 31 1E 00 		      	and  	r3,r3,#15
0123E8 C6 4D F0 FF 		      	lw   	r4,-8[bp]
0123EC 0C 42 60 00 		      	and  	r4,r4,#48
0123F0 02 42 08 78 		      	asri 	r4,r4,#4
0123F4 07 42 14 00 		      	mul  	r4,r4,#10
0123F8 82 31 08 28 		      	addu 	r3,r3,r4
0123FC E3 3D F0 FF 		      	sw   	r3,-8[bp]
012400 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012404 E3 37 00 00 		      	sw   	r3,[r15]
                	set_time_serial_6:
012408 3D 07 22 00 		      	beq  	r14,set_time_serial_8
01240C C1 35 04 00 		      	lbu  	r3,2[r11]
012410 82 31 00 20 		      	sxb  	r3,r3
012414 E3 3D F0 FF 		      	sw   	r3,-8[bp]
012418 C6 3D F0 FF 		      	lw   	r3,-8[bp]
01241C 8C 31 1E 00 		      	and  	r3,r3,#15
012420 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012424 0C 42 60 00 		      	and  	r4,r4,#48
012428 02 42 08 78 		      	asri 	r4,r4,#4
01242C 07 42 14 00 		      	mul  	r4,r4,#10
012430 82 31 08 28 		      	addu 	r3,r3,r4
012434 E3 3D F0 FF 		      	sw   	r3,-8[bp]
012438 C6 3D F0 FF 		      	lw   	r3,-8[bp]
01243C 8C 31 7E 00 		      	and  	r3,r3,#63
012440 E3 3D F0 FF 		      	sw   	r3,-8[bp]
012444 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012448 63 37 00 00 		      	sw   	r3,[r14]
                	set_time_serial_8:
01244C BD 06 1C 00 		      	beq  	r13,set_time_serial_10
012450 C1 35 02 00 		      	lbu  	r3,1[r11]
012454 82 31 00 20 		      	sxb  	r3,r3
012458 E3 3D F0 FF 		      	sw   	r3,-8[bp]
01245C C6 3D F0 FF 		      	lw   	r3,-8[bp]
012460 8C 31 1E 00 		      	and  	r3,r3,#15
012464 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012468 0C 42 E0 00 		      	and  	r4,r4,#112
01246C 02 42 08 78 		      	asri 	r4,r4,#4
012470 07 42 14 00 		      	mul  	r4,r4,#10
012474 82 31 08 28 		      	addu 	r3,r3,r4
012478 E3 3D F0 FF 		      	sw   	r3,-8[bp]
01247C C6 3D F0 FF 		      	lw   	r3,-8[bp]
012480 E3 36 00 00 		      	sw   	r3,[r13]
                	set_time_serial_10:
012484 3D 06 1C 00 		      	beq  	r12,set_time_serial_12
012488 C1 35 00 00 		      	lbu  	r3,[r11]
01248C 82 31 00 20 		      	sxb  	r3,r3
012490 E3 3D F0 FF 		      	sw   	r3,-8[bp]
012494 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012498 8C 31 1E 00 		      	and  	r3,r3,#15
01249C C6 4D F0 FF 		      	lw   	r4,-8[bp]
0124A0 0C 42 E0 00 		      	and  	r4,r4,#112
0124A4 02 42 08 78 		      	asri 	r4,r4,#4
0124A8 07 42 14 00 		      	mul  	r4,r4,#10
0124AC 82 31 08 28 		      	addu 	r3,r3,r4
0124B0 E3 3D F0 FF 		      	sw   	r3,-8[bp]
0124B4 C6 3D F0 FF 		      	lw   	r3,-8[bp]
0124B8 63 36 00 00 		      	sw   	r3,[r12]
                	set_time_serial_12:
                	set_time_serial_14:
0124BC 57 1F 11 00 		      	pop  	r17
0124C0 57 0F 11 00 		      	pop  	r16
0124C4 57 FF 10 00 		      	pop  	r15
0124C8 57 EF 10 00 		      	pop  	r14
0124CC 57 DF 10 00 		      	pop  	r13
0124D0 57 CF 10 00 		      	pop  	r12
0124D4 57 BF 10 00 		      	pop  	r11
0124D8 82 ED 01 1A 		      	mov  	sp,bp
0124DC 57 BF 11 00 		      	pop  	bp
0124E0 37 FF 21 00 		      	rtl  	#16
                	ToJul:
0124E4 15 EF 21 00 		      	subui	sp,sp,#16
0124E8 E7 ED 01 00 		      	push 	bp
0124EC 02 BF 01 1A 		      	mov  	bp,sp
0124F0 15 EF 41 00 		      	subui	sp,sp,#32
0124F4 C6 3D 50 00 		      	lw   	r3,40[bp]
0124F8 E3 3D E0 FF 		      	sw   	r3,-16[bp]
0124FC C6 3D 60 00 		      	lw   	r3,48[bp]
012500 E3 3D D0 FF 		      	sw   	r3,-24[bp]
012504 C6 3D 70 00 		      	lw   	r3,56[bp]
012508 E3 3D C0 FF 		      	sw   	r3,-32[bp]
01250C FC FF FF FF 		      	ldi  	r3,#-32075
012510 0A 30 6A 05 
012514 C6 4D C0 FF 		      	lw   	r4,-32[bp]
012518 7C 6B 00 00 		      	ldi  	r5,#7012800
01251C 0A 50 80 03 
012520 C6 6D E0 FF 		      	lw   	r6,-16[bp]
012524 C6 7D D0 FF 		      	lw   	r7,-24[bp]
012528 95 73 1C 00 		      	subu 	r7,r7,#14
01252C 88 73 18 00 		      	divs 	r7,r7,#12
012530 02 63 0E 28 		      	addu 	r6,r6,r7
012534 07 63 6A 0B 		      	mul  	r6,r6,#1461
012538 82 52 0C 28 		      	addu 	r5,r5,r6
01253C 82 52 04 78 		      	asri 	r5,r5,#2
012540 02 42 0A 28 		      	addu 	r4,r4,r5
012544 0A 50 44 FA 		      	ldi  	r5,#-734
012548 C6 6D D0 FF 		      	lw   	r6,-24[bp]
01254C C6 7D D0 FF 		      	lw   	r7,-24[bp]
012550 95 73 1C 00 		      	subu 	r7,r7,#14
012554 88 73 18 00 		      	divs 	r7,r7,#12
012558 87 73 18 00 		      	mul  	r7,r7,#12
01255C 02 63 0E 2A 		      	subu 	r6,r6,r7
012560 07 63 DE 02 		      	mul  	r6,r6,#367
012564 82 52 0C 28 		      	addu 	r5,r5,r6
012568 88 52 18 00 		      	divs 	r5,r5,#12
01256C 02 42 0A 28 		      	addu 	r4,r4,r5
012570 0A 50 48 26 		      	ldi  	r5,#4900
012574 C6 6D E0 FF 		      	lw   	r6,-16[bp]
012578 C6 7D D0 FF 		      	lw   	r7,-24[bp]
01257C 95 73 1C 00 		      	subu 	r7,r7,#14
012580 88 73 18 00 		      	divs 	r7,r7,#12
012584 02 63 0E 28 		      	addu 	r6,r6,r7
012588 82 52 0C 28 		      	addu 	r5,r5,r6
01258C 88 52 C8 00 		      	divs 	r5,r5,#100
012590 87 52 06 00 		      	mul  	r5,r5,#3
012594 82 52 04 78 		      	asri 	r5,r5,#2
012598 02 42 0A 2A 		      	subu 	r4,r4,r5
01259C 82 31 08 28 		      	addu 	r3,r3,r4
0125A0 E3 3D F0 FF 		      	sw   	r3,-8[bp]
0125A4 C6 3D F0 FF 		      	lw   	r3,-8[bp]
0125A8 82 11 00 1A 		      	mov  	r1,r3
                	set_time_serial_17:
0125AC 82 ED 01 1A 		      	mov  	sp,bp
0125B0 57 BF 11 00 		      	pop  	bp
0125B4 37 FF 21 00 		      	rtl  	#16
                	set_time_serial:
0125B8 E7 EF 01 00 		      	push 	lr
0125BC 67 EE 01 00 		      	push 	xlr
0125C0 E7 ED 01 00 		      	push 	bp
0125C4 7C 01 00 00 		      	ldi  	xlr,#set_time_serial_19
0125C8 0A C0 D1 4C 
0125CC 02 BF 01 1A 		      	mov  	bp,sp
0125D0 15 EF 91 00 		      	subui	sp,sp,#72
0125D4 E5 ED 81 FF 		      	pea  	-64[bp]
0125D8 E5 ED 91 FF 		      	pea  	-56[bp]
0125DC E5 ED A1 FF 		      	pea  	-48[bp]
0125E0 E5 ED B1 FF 		      	pea  	-40[bp]
0125E4 E5 ED C1 FF 		      	pea  	-32[bp]
0125E8 E5 ED D1 FF 		      	pea  	-24[bp]
0125EC B9 A4 FF FF 		      	bsr  	get_datetime
0125F0 14 EF 61 00 		      	addui	sp,sp,#48
0125F4 C6 3D 80 FF 		      	lw   	r3,-64[bp]
0125F8 82 31 14 70 		      	asli 	r3,r3,#10
0125FC C6 4D 90 FF 		      	lw   	r4,-56[bp]
012600 FC 00 00 00 		      	mul  	r4,r4,#61440
012604 07 42 00 E0 
012608 82 31 08 28 		      	addu 	r3,r3,r4
01260C C6 4D A0 FF 		      	lw   	r4,-48[bp]
012610 7C 38 00 00 		      	mul  	r4,r4,#3686400
012614 07 42 00 80 
012618 82 31 08 28 		      	addu 	r3,r3,r4
01261C E7 E1 01 00 		      	push 	r3
012620 E6 ED B1 FF 		      	push 	-40[bp]
012624 E6 ED C1 FF 		      	push 	-32[bp]
012628 E6 ED D1 FF 		      	push 	-24[bp]
01262C 39 D7 FF FF 		      	bsr  	ToJul
012630 14 EF 31 00 		      	addui	sp,sp,#24
012634 57 3F 10 00 		      	pop  	r3
012638 82 40 00 1A 		      	mov  	r4,r1
01263C 7C 46 05 00 		      	mul  	r4,r4,#88473600
012640 07 42 00 00 
012644 82 31 08 28 		      	addu 	r3,r3,r4
012648 63 30 10 02 		      	sw   	r3,Milliseconds
01264C C6 3D E0 FF 		      	lw   	r3,-16[bp]
012650 82 11 00 1A 		      	mov  	r1,r3
                	set_time_serial_20:
012654 82 ED 01 1A 		      	mov  	sp,bp
012658 57 BF 11 00 		      	pop  	bp
01265C 57 CF 11 00 		      	pop  	xlr
012660 57 FF 11 00 		      	pop  	lr
012664 37 FF 01 00 		      	rtl  	#0
                	set_time_serial_19:
012668 C6 FD 11 00 		      	lw   	lr,8[bp]
01266C E3 FD 21 00 		      	sw   	lr,16[bp]
012670 BA FC FF FF 		      	bra  	set_time_serial_20
                	        code
                	
                	pSpriteController:
012674 00 D0 DA FF 		dw	-2437120
012678 FF FF FF FF 
                	
                	sprite_demo:
01267C 15 EF 21 00 		      	subui	sp,sp,#16
012680 E7 ED 01 00 		      	push 	bp
012684 02 BF 01 1A 		      	mov  	bp,sp
012688 15 EF 31 00 		      	subui	sp,sp,#24
01268C E7 E5 01 00 		      	push 	r11
012690 67 E6 01 00 		      	push 	r12
012694 E7 E6 01 00 		      	push 	r13
012698 FC 03 00 00 		      	ldi  	r11,#sprites
01269C 0A B0 00 E0 
0126A0 7C DC FF FF 		      	ldi  	r12,#-2356224
0126A4 0A C0 00 18 
0126A8 7C D8 FF FF 		      	ldi  	r13,#-2621440
0126AC 0A D0 00 00 
0126B0 E3 0D F0 FF 		      	sw   	r0,-8[bp]
                	sprite_demo_4:
0126B4 C6 3D F0 FF 		      	lw   	r3,-8[bp]
0126B8 86 31 40 00 		      	cmp  	r3,r3,#32
0126BC BD 31 18 00 		      	bge  	r3,sprite_demo_5
0126C0 C6 3D F0 FF 		      	lw   	r3,-8[bp]
0126C4 82 31 04 70 		      	asli 	r3,r3,#2
0126C8 82 31 04 70 		      	asli 	r3,r3,#2
0126CC 7C 01 00 00 		      	lw   	r4,pSpriteController
0126D0 46 40 E8 4C 
0126D4 82 31 08 28 		      	addu 	r3,r3,r4
0126D8 C5 41 08 00 		      	lhu  	r4,4[r3]
0126DC 0D 42 98 01 		      	ori  	r4,r4,#204
0126E0 E2 41 08 00 		      	sh   	r4,4[r3]
                	sprite_demo_6:
0126E4 E4 1D F0 FF 		      	inc  	-8[bp],#1
0126E8 BA F9 FF FF 		      	bra  	sprite_demo_4
                	sprite_demo_5:
0126EC E3 0D F0 FF 		      	sw   	r0,-8[bp]
                	sprite_demo_7:
0126F0 C6 3D F0 FF 		      	lw   	r3,-8[bp]
0126F4 7C 00 00 00 		      	cmp  	r3,r3,#16384
0126F8 86 31 00 80 
0126FC BD 31 0E 00 		      	bge  	r3,sprite_demo_8
012700 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012704 82 31 04 70 		      	asli 	r3,r3,#2
012708 45 46 00 00 		      	lhu  	r4,[r12]
01270C EA 46 06 00 		      	sh   	r4,0[r13+r3]
                	sprite_demo_9:
012710 E4 1D F0 FF 		      	inc  	-8[bp],#1
012714 BA FB FF FF 		      	bra  	sprite_demo_7
                	sprite_demo_8:
012718 E3 0D F0 FF 		      	sw   	r0,-8[bp]
                	sprite_demo_10:
01271C C6 3D F0 FF 		      	lw   	r3,-8[bp]
012720 86 31 40 00 		      	cmp  	r3,r3,#32
012724 BD 31 38 00 		      	bge  	r3,sprite_demo_11
012728 46 36 00 00 		      	lw   	r3,[r12]
01272C 89 31 A8 0A 		      	mod  	r3,r3,#1364
012730 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012734 02 42 0A 70 		      	asli 	r4,r4,#5
012738 EB 35 08 00 		      	sw   	r3,0[r11+r4]
01273C 46 36 00 00 		      	lw   	r3,[r12]
012740 89 31 00 06 		      	mod  	r3,r3,#768
012744 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012748 02 42 0A 70 		      	asli 	r4,r4,#5
01274C 02 42 16 28 		      	addu 	r4,r4,r11
012750 63 32 10 00 		      	sw   	r3,8[r4]
012754 46 36 00 00 		      	lw   	r3,[r12]
012758 8C 31 0E 00 		      	and  	r3,r3,#7
01275C 95 31 08 00 		      	subu 	r3,r3,#4
012760 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012764 02 42 0A 70 		      	asli 	r4,r4,#5
012768 02 42 16 28 		      	addu 	r4,r4,r11
01276C 63 32 20 00 		      	sw   	r3,16[r4]
012770 46 36 00 00 		      	lw   	r3,[r12]
012774 8C 31 0E 00 		      	and  	r3,r3,#7
012778 95 31 08 00 		      	subu 	r3,r3,#4
01277C C6 4D F0 FF 		      	lw   	r4,-8[bp]
012780 02 42 0A 70 		      	asli 	r4,r4,#5
012784 02 42 16 28 		      	addu 	r4,r4,r11
012788 63 32 30 00 		      	sw   	r3,24[r4]
                	sprite_demo_12:
01278C E4 1D F0 FF 		      	inc  	-8[bp],#1
012790 BA F1 FF FF 		      	bra  	sprite_demo_10
                	sprite_demo_11:
                	sprite_demo_13:
012794 0A 30 02 00 		      	ldi  	r3,#1
012798 BD 01 68 00 		      	beq  	r3,sprite_demo_14
01279C E3 0D F0 FF 		      	sw   	r0,-8[bp]
                	sprite_demo_15:
0127A0 C6 3D F0 FF 		      	lw   	r3,-8[bp]
0127A4 86 31 40 00 		      	cmp  	r3,r3,#32
0127A8 BD 31 58 00 		      	bge  	r3,sprite_demo_16
0127AC C6 3D F0 FF 		      	lw   	r3,-8[bp]
0127B0 82 31 0A 70 		      	asli 	r3,r3,#5
0127B4 CE 35 06 00 		      	lw   	r3,0[r11+r3]
0127B8 C6 4D F0 FF 		      	lw   	r4,-8[bp]
0127BC 02 42 0A 70 		      	asli 	r4,r4,#5
0127C0 02 42 16 28 		      	addu 	r4,r4,r11
0127C4 46 42 20 00 		      	lw   	r4,16[r4]
0127C8 82 31 08 28 		      	addu 	r3,r3,r4
0127CC 8C 31 FE 07 		      	and  	r3,r3,#1023
0127D0 C6 4D F0 FF 		      	lw   	r4,-8[bp]
0127D4 02 42 0A 70 		      	asli 	r4,r4,#5
0127D8 EB 35 08 00 		      	sw   	r3,0[r11+r4]
0127DC C6 3D F0 FF 		      	lw   	r3,-8[bp]
0127E0 82 31 0A 70 		      	asli 	r3,r3,#5
0127E4 82 31 16 28 		      	addu 	r3,r3,r11
0127E8 C6 31 10 00 		      	lw   	r3,8[r3]
0127EC C6 4D F0 FF 		      	lw   	r4,-8[bp]
0127F0 02 42 0A 70 		      	asli 	r4,r4,#5
0127F4 02 42 16 28 		      	addu 	r4,r4,r11
0127F8 46 42 30 00 		      	lw   	r4,24[r4]
0127FC 82 31 08 28 		      	addu 	r3,r3,r4
012800 8C 31 FE 03 		      	and  	r3,r3,#511
012804 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012808 02 42 0A 70 		      	asli 	r4,r4,#5
01280C 02 42 16 28 		      	addu 	r4,r4,r11
012810 63 32 10 00 		      	sw   	r3,8[r4]
012814 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012818 82 31 0A 70 		      	asli 	r3,r3,#5
01281C CE 35 06 00 		      	lw   	r3,0[r11+r3]
012820 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012824 02 42 0A 70 		      	asli 	r4,r4,#5
012828 02 42 16 28 		      	addu 	r4,r4,r11
01282C 46 42 10 00 		      	lw   	r4,8[r4]
012830 02 42 20 70 		      	asli 	r4,r4,#16
012834 82 31 08 28 		      	addu 	r3,r3,r4
012838 C6 4D F0 FF 		      	lw   	r4,-8[bp]
01283C 02 42 04 70 		      	asli 	r4,r4,#2
012840 02 42 04 70 		      	asli 	r4,r4,#2
012844 7C 01 00 00 		      	lw   	r5,pSpriteController
012848 46 50 E8 4C 
01284C EA 32 08 00 		      	sh   	r3,0[r5+r4]
                	sprite_demo_17:
012850 E4 1D F0 FF 		      	inc  	-8[bp],#1
012854 BA E9 FF FF 		      	bra  	sprite_demo_15
                	sprite_demo_16:
012858 7C 0F 00 00 		      	     	            ldi  r1,#1000000
01285C 0A 10 80 84 
012860 39 27 FF FF 	            bsr  MicroDelay
                	        
012864 3A E6 FF FF 		      	bra  	sprite_demo_13
                	sprite_demo_14:
                	sprite_demo_18:
012868 57 DF 10 00 		      	pop  	r13
01286C 57 CF 10 00 		      	pop  	r12
012870 57 BF 10 00 		      	pop  	r11
012874 82 ED 01 1A 		      	mov  	sp,bp
012878 57 BF 11 00 		      	pop  	bp
01287C 37 FF 21 00 		      	rtl  	#16
                	
                	; error codes
                	E_Ok		=		0x00
                	E_Arg		=		0x01
                	E_BadMbx	=		0x04
                	E_QueFull	=		0x05
                	E_NoThread	=		0x06
                	E_NotAlloc	=		0x09
                	E_NoMsg		=		0x0b
                	E_Timeout	=		0x10
                	E_BadAlarm	=		0x11
                	E_NotOwner	=		0x12
                	E_QueStrategy =		0x13
                	E_BadDevNum	=		0x18
                	E_DCBInUse	=		0x19
                	; Device driver errors
                	E_BadDevNum	=		0x20
                	E_NoDev		=		0x21
                	E_BadDevOp	=		0x22
                	E_ReadError	=		0x23
                	E_WriteError =		0x24
                	E_BadBlockNum	=	0x25
                	E_TooManyBlocks	=	0x26
                	
                	; resource errors
                	E_NoMoreMbx	=		0x40
                	E_NoMoreMsgBlks	=	0x41
                	E_NoMoreAlarmBlks	=0x44
                	E_NoMoreTCBs	=	0x45
                	E_NoMem		= 12
                	
                	; task status
                	TS_NONE     =0
                	TS_TIMEOUT	=1
                	TS_WAITMSG	=2
                	TS_PREEMPT	=4
                	TS_RUNNING	=8
                	TS_READY	=16
                	TS_SLEEP	=32
                	
                	TS_TIMEOUT_BIT	=0
                	TS_WAITMSG_BIT	=1
                	TS_RUNNING_BIT	=3
                	TS_READY_BIT	=4
                	
                	PRI_HIGHEST	=0
                	PRI_HIGH	=1
                	PRI_NORMAL	=3
                	PRI_LOW		=5
                	PRI_LOWEST	=7
                	
                	
                	NR_TCB		EQU		256
                	TCB_BackLink    EQU     0
                	TCB_r1          EQU     8
                	TCB_r2          EQU     $10
                	TCB_r3          EQU     $18
                	TCB_r4          EQU     $20
                	TCB_r5          EQU     $28
                	TCB_r6          EQU     $30
                	TCB_r7          EQU     $38
                	TCB_r8          EQU     $40
                	TCB_r9          EQU     $48
                	TCB_r10         EQU     $50
                	TCB_r11         EQU     $58
                	TCB_r12         EQU     $60
                	TCB_r13         EQU     $68
                	TCB_r14         EQU     $70
                	TCB_r15         EQU     $78
                	TCB_r16         EQU     $80
                	TCB_r17         EQU     $88
                	TCB_r18         EQU     $90
                	TCB_r19         EQU     $98
                	TCB_r20         EQU     $A0
                	TCB_r21         EQU     $A8
                	TCB_r22         EQU     $B0
                	TCB_r23         EQU     $B8
                	TCB_r24         EQU     $C0
                	TCB_r25         EQU     $C8
                	TCB_r26         EQU     $D0
                	TCB_r27         EQU     $D8
                	TCB_r28         EQU     $E0
                	TCB_r29         EQU     $E8
                	TCB_r30         EQU     $F0
                	TCB_r31         EQU     $F8
                	
                	TCB_SP0Save		EQU		0x100
                	TCB_SP1Save		EQU		0x108
                	TCB_SP2Save		EQU		0x110
                	TCB_SP3Save		EQU		0x118
                	TCB_SP4Save		EQU		0x120
                	TCB_SP5Save		EQU		0x128
                	TCB_SP6Save		EQU		0x130
                	TCB_SP7Save		EQU		0x138
                	TCB_SP8Save		EQU		0x140
                	TCB_SP9Save		EQU		0x148
                	TCB_SP10Save	EQU		0x150
                	TCB_SP11Save	EQU		0x158
                	TCB_SP12Save	EQU		0x160
                	TCB_SP13Save	EQU		0x168
                	TCB_SP14Save	EQU		0x170
                	TCB_SP15Save	EQU		0x178
                	
                	TCB_IPC         EQU     0x180
                	TCB_DPC         EQU     0x188
                	TCB_EPC         EQU     0x190
                	
                	TCB_NextRdy     EQU     $200
                	TCB_PrevRdy     EQU     $208
                	TCB_Status      EQU     $210
                	TCB_Priority    EQU     $212
                	TCB_hJCB        EQU     $214
                	TCB_NextFree    EQU     $218
                	TCB_PrevFree    EQU     $220
                	TCB_NextTo      EQU     $228
                	TCB_PrevTo      EQU     $230
                	TCB_mbq_next    EQU     $238
                	TCB_mbq_prev    EQU     $240
                	TCB_MSG_D1      EQU     $248
                	TCB_MSG_D2      EQU     $250
                	TCB_hWaitMbx    EQU     $258
                	TCB_MbxList     EQU     $260
                	TCB_StackTop    EQU     $268
                	TCB_errno       EQU     $270
                	TCB_Timeout     EQU     $278
                	TCB_Affinity    EQU     $280
                	TCB_Size	    EQU	    $300
                	
                	; Mailboxes, room for 2048
                	;			.bss
                	;			.org		0x07E40000
                	NR_MBX		EQU		2048
                	MBX_LINK		EQU     $00       ; link to next mailbox in list (free list)
                	MBX_TQ_HEAD		EQU     $08       ; head of task queue
                	MBX_TQ_TAIL		EQU     $18
                	MBX_MQ_HEAD		EQU     $20	      ; head of message queue
                	MBX_MQ_TAIL		EQU     $28
                	MBX_TQ_COUNT	EQU     $30	      ; count of queued threads
                	MBX_MQ_SIZE		EQU     $38       ; number of messages that may be queued
                	MBX_MQ_COUNT	EQU     $40       ; count of messages that are queued
                	MBX_MQ_MISSED	EQU     $48	      ; number of messages dropped from queue
                	MBX_OWNER		EQU     $50	      ; job handle of mailbox owner
                	MBX_MQ_STRATEGY	EQU     $58	      ; message queueing strategy
                	MBX_Size        EQU     $60
                	
                	MQ_UNLIMITED    EQU     0
                	MQ_OLDEST       EQU     1
                	MQ_NEWEST       EQU     2
                	
                	; Messages, room for 64kW (16,384) messages
                	;			.bss
                	;			.org		0x07E80000
                	NR_MSG		EQU		32768
                	MSG_LINK	EQU     $00	        ; link to next message in queue or free list
                	MSG_D1		EQU     $08         ; message data 1
                	MSG_D2		EQU     $10	        ; message data 2
                	MSG_TYPE	EQU     $18	        ; message type
                	MSG_Size    EQU     $20
                	
                	MT_SEMA		EQU		-1
                	MT_IRQ		EQU		-16
                	MT_GETCHAR	EQU		-17
                	
                	
                	NR_JCB			EQU		51
                	JCB_Number		EQU		0
                	JCB_Name		EQU		4		; 32 bytes (1 len + 31)
                	JCB_MemGroup0	EQU		0x24	; memory map number associated with job
                	JCB_MemGroup1   EQU     0x26
                	JCB_MemGroup2   EQU     0x28
                	JCB_MemGroup3   EQU     0x2A
                	JCB_MemGroup4   EQU     0x2C
                	JCB_MemGroup5   EQU     0x2E
                	JCB_pCode		EQU		0x30
                	JCB_nCode		EQU		0x38	; size of code
                	JCB_pData		EQU		0x40
                	JCB_nData		EQU		0x48	; size of data
                	JCB_pStack		EQU		0x50
                	JCB_nStack		EQU		0x58
                	JCB_UserName	EQU		0x60	; 32 bytes
                	JCB_Path		EQU		0x80	; 256 bytes
                	JCB_ExitRF		EQU		0x180	; 256 bytes
                	JCB_CmdLine		EQU		0x280	; 256 bytes		
                	JCB_SysIn		EQU		0x380	; 48 chars
                	JCB_SysOut		EQU		0x3B0	; 48 chars
                	JCB_ExitError	EQU		0x3E0
                	JCB_pVidMem		EQU		0x3E8		; pointer to video memory
                	JCB_pVidMemAttr	EQU		0x3F0
                	JCB_pVirtVid	EQU		0x3F8		; pointer to virtual video buffer
                	JCB_pVirtVidAttr	EQU		0x400
                	JCB_VideoMode	EQU		0x408
                	JCB_VideoRows	EQU		0x40A
                	JCB_VideoCols	EQU		0x40B
                	JCB_CursorRow	EQU		0x40C
                	JCB_CursorCol	EQU		0x40D
                	JCB_CursorOn	EQU		0x40E
                	JCB_CursorFlash	EQU		0x40F
                	JCB_CursorType	EQU		0x410
                	JCB_NormAttr	EQU		0x414
                	JCB_CurrAttr	EQU		0x418
                	JCB_ScrlCnt		EQU		0x41C
                	JCB_fVidPause	EQU		0x41E
                	JCB_Next		EQU		0x420
                	JCB_iof_next	EQU		0x428		; I/O focus list
                	JCB_iof_prev	EQU		0x430
                	JCB_KeybdHead	EQU		0x438
                	JCB_KeybdTail	EQU		0x440
                	JCB_KeybdEcho	EQU		0x448
                	JCB_KeybdBad	EQU		0x449
                	JCB_KeybdAck	EQU		0x44A
                	JCB_KeybdLocks	EQU		0x44C
                	JCB_KeybdBuffer	EQU		0x450		; buffer is 16 words (chars = words)
                	JCB_esc			EQU		0x470		; escape flag for DisplayChar processing
                	JCB_Size		EQU		0x500
                	JCB_LogSize		EQU		10
                	
                	BITMAP_SCREEN1  EQU     $400000     ; bitmap graphics screen area (4MB)
                	BITMAP_SCREEN2  EQU     $800000     ; bitmap graphics screen area (4MB)
                	VAR_Area        EQU     $C00000     ; 64k block for OS vars
                	TCB_Array       EQU     $C10000     ; room for 256 TCB's (192kB)
                	TCB_ArrayEnd    EQU     $C40000
                	JCB_Array       EQU     $C40000
                	JCB_ArrayEnd    EQU     $C50000     ; room for 51 JCB's  (64kB)
                	MBX_Array       EQU     $C60000     ; room for 2048 mailboxes (192kB)
                	MBX_ArrayEnd    EQU     $C90000
                	MSG_Array       EQU     $C90000     ; room for 32,768 messages (1MB)
                	MSG_ArrayEnd    EQU     $D90000
                	SCREEN_Array    EQU     $D90000     ; room for 51 16kB screens
                	SCREEN_ArrayEnd EQU     $E90000
                	STACKS_Array    EQU    $7F00000     ; room for 256 TCB stacks of 4kB each
                	STACKS_ArrayEnd EQU    $8000000
                	MEM_END         EQU    $8000000
                	
                	    code
012880 00 00 00 00 		org		$14000
012884 00 00 00 00 
012888 00 00 00 00 
01288C 00 00 00 00 
012890 00 00 00 00 
012894 00 00 00 00 
012898 00 00 00 00 
01289C 00 00 00 00 
0128A0 00 00 00 00 
0128A4 00 00 00 00 
0128A8 00 00 00 00 
0128AC 00 00 00 00 
0128B0 00 00 00 00 
0128B4 00 00 00 00 
0128B8 00 00 00 00 
0128BC 00 00 00 00 
0128C0 00 00 00 00 
0128C4 00 00 00 00 
0128C8 00 00 00 00 
0128CC 00 00 00 00 
0128D0 00 00 00 00 
0128D4 00 00 00 00 
0128D8 00 00 00 00 
0128DC 00 00 00 00 
0128E0 00 00 00 00 
0128E4 00 00 00 00 
0128E8 00 00 00 00 
0128EC 00 00 00 00 
0128F0 00 00 00 00 
0128F4 00 00 00 00 
0128F8 00 00 00 00 
0128FC 00 00 00 00 
012900 00 00 00 00 
012904 00 00 00 00 
012908 00 00 00 00 
01290C 00 00 00 00 
012910 00 00 00 00 
012914 00 00 00 00 
012918 00 00 00 00 
01291C 00 00 00 00 
012920 00 00 00 00 
012924 00 00 00 00 
012928 00 00 00 00 
01292C 00 00 00 00 
012930 00 00 00 00 
012934 00 00 00 00 
012938 00 00 00 00 
01293C 00 00 00 00 
012940 00 00 00 00 
012944 00 00 00 00 
012948 00 00 00 00 
01294C 00 00 00 00 
012950 00 00 00 00 
012954 00 00 00 00 
012958 00 00 00 00 
01295C 00 00 00 00 
012960 00 00 00 00 
012964 00 00 00 00 
012968 00 00 00 00 
01296C 00 00 00 00 
012970 00 00 00 00 
012974 00 00 00 00 
012978 00 00 00 00 
01297C 00 00 00 00 
012980 00 00 00 00 
012984 00 00 00 00 
012988 00 00 00 00 
01298C 00 00 00 00 
012990 00 00 00 00 
012994 00 00 00 00 
012998 00 00 00 00 
01299C 00 00 00 00 
0129A0 00 00 00 00 
0129A4 00 00 00 00 
0129A8 00 00 00 00 
0129AC 00 00 00 00 
0129B0 00 00 00 00 
0129B4 00 00 00 00 
0129B8 00 00 00 00 
0129BC 00 00 00 00 
0129C0 00 00 00 00 
0129C4 00 00 00 00 
0129C8 00 00 00 00 
0129CC 00 00 00 00 
0129D0 00 00 00 00 
0129D4 00 00 00 00 
0129D8 00 00 00 00 
0129DC 00 00 00 00 
0129E0 00 00 00 00 
0129E4 00 00 00 00 
0129E8 00 00 00 00 
0129EC 00 00 00 00 
0129F0 00 00 00 00 
0129F4 00 00 00 00 
0129F8 00 00 00 00 
0129FC 00 00 00 00 
012A00 00 00 00 00 
012A04 00 00 00 00 
012A08 00 00 00 00 
012A0C 00 00 00 00 
012A10 00 00 00 00 
012A14 00 00 00 00 
012A18 00 00 00 00 
012A1C 00 00 00 00 
012A20 00 00 00 00 
012A24 00 00 00 00 
012A28 00 00 00 00 
012A2C 00 00 00 00 
012A30 00 00 00 00 
012A34 00 00 00 00 
012A38 00 00 00 00 
012A3C 00 00 00 00 
012A40 00 00 00 00 
012A44 00 00 00 00 
012A48 00 00 00 00 
012A4C 00 00 00 00 
012A50 00 00 00 00 
012A54 00 00 00 00 
012A58 00 00 00 00 
012A5C 00 00 00 00 
012A60 00 00 00 00 
012A64 00 00 00 00 
012A68 00 00 00 00 
012A6C 00 00 00 00 
012A70 00 00 00 00 
012A74 00 00 00 00 
012A78 00 00 00 00 
012A7C 00 00 00 00 
012A80 00 00 00 00 
012A84 00 00 00 00 
012A88 00 00 00 00 
012A8C 00 00 00 00 
012A90 00 00 00 00 
012A94 00 00 00 00 
012A98 00 00 00 00 
012A9C 00 00 00 00 
012AA0 00 00 00 00 
012AA4 00 00 00 00 
012AA8 00 00 00 00 
012AAC 00 00 00 00 
012AB0 00 00 00 00 
012AB4 00 00 00 00 
012AB8 00 00 00 00 
012ABC 00 00 00 00 
012AC0 00 00 00 00 
012AC4 00 00 00 00 
012AC8 00 00 00 00 
012ACC 00 00 00 00 
012AD0 00 00 00 00 
012AD4 00 00 00 00 
012AD8 00 00 00 00 
012ADC 00 00 00 00 
012AE0 00 00 00 00 
012AE4 00 00 00 00 
012AE8 00 00 00 00 
012AEC 00 00 00 00 
012AF0 00 00 00 00 
012AF4 00 00 00 00 
012AF8 00 00 00 00 
012AFC 00 00 00 00 
012B00 00 00 00 00 
012B04 00 00 00 00 
012B08 00 00 00 00 
012B0C 00 00 00 00 
012B10 00 00 00 00 
012B14 00 00 00 00 
012B18 00 00 00 00 
012B1C 00 00 00 00 
012B20 00 00 00 00 
012B24 00 00 00 00 
012B28 00 00 00 00 
012B2C 00 00 00 00 
012B30 00 00 00 00 
012B34 00 00 00 00 
012B38 00 00 00 00 
012B3C 00 00 00 00 
012B40 00 00 00 00 
012B44 00 00 00 00 
012B48 00 00 00 00 
012B4C 00 00 00 00 
012B50 00 00 00 00 
012B54 00 00 00 00 
012B58 00 00 00 00 
012B5C 00 00 00 00 
012B60 00 00 00 00 
012B64 00 00 00 00 
012B68 00 00 00 00 
012B6C 00 00 00 00 
012B70 00 00 00 00 
012B74 00 00 00 00 
012B78 00 00 00 00 
012B7C 00 00 00 00 
012B80 00 00 00 00 
012B84 00 00 00 00 
012B88 00 00 00 00 
012B8C 00 00 00 00 
012B90 00 00 00 00 
012B94 00 00 00 00 
012B98 00 00 00 00 
012B9C 00 00 00 00 
012BA0 00 00 00 00 
012BA4 00 00 00 00 
012BA8 00 00 00 00 
012BAC 00 00 00 00 
012BB0 00 00 00 00 
012BB4 00 00 00 00 
012BB8 00 00 00 00 
012BBC 00 00 00 00 
012BC0 00 00 00 00 
012BC4 00 00 00 00 
012BC8 00 00 00 00 
012BCC 00 00 00 00 
012BD0 00 00 00 00 
012BD4 00 00 00 00 
012BD8 00 00 00 00 
012BDC 00 00 00 00 
012BE0 00 00 00 00 
012BE4 00 00 00 00 
012BE8 00 00 00 00 
012BEC 00 00 00 00 
012BF0 00 00 00 00 
012BF4 00 00 00 00 
012BF8 00 00 00 00 
012BFC 00 00 00 00 
012C00 00 00 00 00 
012C04 00 00 00 00 
012C08 00 00 00 00 
012C0C 00 00 00 00 
012C10 00 00 00 00 
012C14 00 00 00 00 
012C18 00 00 00 00 
012C1C 00 00 00 00 
012C20 00 00 00 00 
012C24 00 00 00 00 
012C28 00 00 00 00 
012C2C 00 00 00 00 
012C30 00 00 00 00 
012C34 00 00 00 00 
012C38 00 00 00 00 
012C3C 00 00 00 00 
012C40 00 00 00 00 
012C44 00 00 00 00 
012C48 00 00 00 00 
012C4C 00 00 00 00 
012C50 00 00 00 00 
012C54 00 00 00 00 
012C58 00 00 00 00 
012C5C 00 00 00 00 
012C60 00 00 00 00 
012C64 00 00 00 00 
012C68 00 00 00 00 
012C6C 00 00 00 00 
012C70 00 00 00 00 
012C74 00 00 00 00 
012C78 00 00 00 00 
012C7C 00 00 00 00 
012C80 00 00 00 00 
012C84 00 00 00 00 
012C88 00 00 00 00 
012C8C 00 00 00 00 
012C90 00 00 00 00 
012C94 00 00 00 00 
012C98 00 00 00 00 
012C9C 00 00 00 00 
012CA0 00 00 00 00 
012CA4 00 00 00 00 
012CA8 00 00 00 00 
012CAC 00 00 00 00 
012CB0 00 00 00 00 
012CB4 00 00 00 00 
012CB8 00 00 00 00 
012CBC 00 00 00 00 
012CC0 00 00 00 00 
012CC4 00 00 00 00 
012CC8 00 00 00 00 
012CCC 00 00 00 00 
012CD0 00 00 00 00 
012CD4 00 00 00 00 
012CD8 00 00 00 00 
012CDC 00 00 00 00 
012CE0 00 00 00 00 
012CE4 00 00 00 00 
012CE8 00 00 00 00 
012CEC 00 00 00 00 
012CF0 00 00 00 00 
012CF4 00 00 00 00 
012CF8 00 00 00 00 
012CFC 00 00 00 00 
012D00 00 00 00 00 
012D04 00 00 00 00 
012D08 00 00 00 00 
012D0C 00 00 00 00 
012D10 00 00 00 00 
012D14 00 00 00 00 
012D18 00 00 00 00 
012D1C 00 00 00 00 
012D20 00 00 00 00 
012D24 00 00 00 00 
012D28 00 00 00 00 
012D2C 00 00 00 00 
012D30 00 00 00 00 
012D34 00 00 00 00 
012D38 00 00 00 00 
012D3C 00 00 00 00 
012D40 00 00 00 00 
012D44 00 00 00 00 
012D48 00 00 00 00 
012D4C 00 00 00 00 
012D50 00 00 00 00 
012D54 00 00 00 00 
012D58 00 00 00 00 
012D5C 00 00 00 00 
012D60 00 00 00 00 
012D64 00 00 00 00 
012D68 00 00 00 00 
012D6C 00 00 00 00 
012D70 00 00 00 00 
012D74 00 00 00 00 
012D78 00 00 00 00 
012D7C 00 00 00 00 
012D80 00 00 00 00 
012D84 00 00 00 00 
012D88 00 00 00 00 
012D8C 00 00 00 00 
012D90 00 00 00 00 
012D94 00 00 00 00 
012D98 00 00 00 00 
012D9C 00 00 00 00 
012DA0 00 00 00 00 
012DA4 00 00 00 00 
012DA8 00 00 00 00 
012DAC 00 00 00 00 
012DB0 00 00 00 00 
012DB4 00 00 00 00 
012DB8 00 00 00 00 
012DBC 00 00 00 00 
012DC0 00 00 00 00 
012DC4 00 00 00 00 
012DC8 00 00 00 00 
012DCC 00 00 00 00 
012DD0 00 00 00 00 
012DD4 00 00 00 00 
012DD8 00 00 00 00 
012DDC 00 00 00 00 
012DE0 00 00 00 00 
012DE4 00 00 00 00 
012DE8 00 00 00 00 
012DEC 00 00 00 00 
012DF0 00 00 00 00 
012DF4 00 00 00 00 
012DF8 00 00 00 00 
012DFC 00 00 00 00 
012E00 00 00 00 00 
012E04 00 00 00 00 
012E08 00 00 00 00 
012E0C 00 00 00 00 
012E10 00 00 00 00 
012E14 00 00 00 00 
012E18 00 00 00 00 
012E1C 00 00 00 00 
012E20 00 00 00 00 
012E24 00 00 00 00 
012E28 00 00 00 00 
012E2C 00 00 00 00 
012E30 00 00 00 00 
012E34 00 00 00 00 
012E38 00 00 00 00 
012E3C 00 00 00 00 
012E40 00 00 00 00 
012E44 00 00 00 00 
012E48 00 00 00 00 
012E4C 00 00 00 00 
012E50 00 00 00 00 
012E54 00 00 00 00 
012E58 00 00 00 00 
012E5C 00 00 00 00 
012E60 00 00 00 00 
012E64 00 00 00 00 
012E68 00 00 00 00 
012E6C 00 00 00 00 
012E70 00 00 00 00 
012E74 00 00 00 00 
012E78 00 00 00 00 
012E7C 00 00 00 00 
012E80 00 00 00 00 
012E84 00 00 00 00 
012E88 00 00 00 00 
012E8C 00 00 00 00 
012E90 00 00 00 00 
012E94 00 00 00 00 
012E98 00 00 00 00 
012E9C 00 00 00 00 
012EA0 00 00 00 00 
012EA4 00 00 00 00 
012EA8 00 00 00 00 
012EAC 00 00 00 00 
012EB0 00 00 00 00 
012EB4 00 00 00 00 
012EB8 00 00 00 00 
012EBC 00 00 00 00 
012EC0 00 00 00 00 
012EC4 00 00 00 00 
012EC8 00 00 00 00 
012ECC 00 00 00 00 
012ED0 00 00 00 00 
012ED4 00 00 00 00 
012ED8 00 00 00 00 
012EDC 00 00 00 00 
012EE0 00 00 00 00 
012EE4 00 00 00 00 
012EE8 00 00 00 00 
012EEC 00 00 00 00 
012EF0 00 00 00 00 
012EF4 00 00 00 00 
012EF8 00 00 00 00 
012EFC 00 00 00 00 
012F00 00 00 00 00 
012F04 00 00 00 00 
012F08 00 00 00 00 
012F0C 00 00 00 00 
012F10 00 00 00 00 
012F14 00 00 00 00 
012F18 00 00 00 00 
012F1C 00 00 00 00 
012F20 00 00 00 00 
012F24 00 00 00 00 
012F28 00 00 00 00 
012F2C 00 00 00 00 
012F30 00 00 00 00 
012F34 00 00 00 00 
012F38 00 00 00 00 
012F3C 00 00 00 00 
012F40 00 00 00 00 
012F44 00 00 00 00 
012F48 00 00 00 00 
012F4C 00 00 00 00 
012F50 00 00 00 00 
012F54 00 00 00 00 
012F58 00 00 00 00 
012F5C 00 00 00 00 
012F60 00 00 00 00 
012F64 00 00 00 00 
012F68 00 00 00 00 
012F6C 00 00 00 00 
012F70 00 00 00 00 
012F74 00 00 00 00 
012F78 00 00 00 00 
012F7C 00 00 00 00 
012F80 00 00 00 00 
012F84 00 00 00 00 
012F88 00 00 00 00 
012F8C 00 00 00 00 
012F90 00 00 00 00 
012F94 00 00 00 00 
012F98 00 00 00 00 
012F9C 00 00 00 00 
012FA0 00 00 00 00 
012FA4 00 00 00 00 
012FA8 00 00 00 00 
012FAC 00 00 00 00 
012FB0 00 00 00 00 
012FB4 00 00 00 00 
012FB8 00 00 00 00 
012FBC 00 00 00 00 
012FC0 00 00 00 00 
012FC4 00 00 00 00 
012FC8 00 00 00 00 
012FCC 00 00 00 00 
012FD0 00 00 00 00 
012FD4 00 00 00 00 
012FD8 00 00 00 00 
012FDC 00 00 00 00 
012FE0 00 00 00 00 
012FE4 00 00 00 00 
012FE8 00 00 00 00 
012FEC 00 00 00 00 
012FF0 00 00 00 00 
012FF4 00 00 00 00 
012FF8 00 00 00 00 
012FFC 00 00 00 00 
013000 00 00 00 00 
013004 00 00 00 00 
013008 00 00 00 00 
01300C 00 00 00 00 
013010 00 00 00 00 
013014 00 00 00 00 
013018 00 00 00 00 
01301C 00 00 00 00 
013020 00 00 00 00 
013024 00 00 00 00 
013028 00 00 00 00 
01302C 00 00 00 00 
013030 00 00 00 00 
013034 00 00 00 00 
013038 00 00 00 00 
01303C 00 00 00 00 
013040 00 00 00 00 
013044 00 00 00 00 
013048 00 00 00 00 
01304C 00 00 00 00 
013050 00 00 00 00 
013054 00 00 00 00 
013058 00 00 00 00 
01305C 00 00 00 00 
013060 00 00 00 00 
013064 00 00 00 00 
013068 00 00 00 00 
01306C 00 00 00 00 
013070 00 00 00 00 
013074 00 00 00 00 
013078 00 00 00 00 
01307C 00 00 00 00 
013080 00 00 00 00 
013084 00 00 00 00 
013088 00 00 00 00 
01308C 00 00 00 00 
013090 00 00 00 00 
013094 00 00 00 00 
013098 00 00 00 00 
01309C 00 00 00 00 
0130A0 00 00 00 00 
0130A4 00 00 00 00 
0130A8 00 00 00 00 
0130AC 00 00 00 00 
0130B0 00 00 00 00 
0130B4 00 00 00 00 
0130B8 00 00 00 00 
0130BC 00 00 00 00 
0130C0 00 00 00 00 
0130C4 00 00 00 00 
0130C8 00 00 00 00 
0130CC 00 00 00 00 
0130D0 00 00 00 00 
0130D4 00 00 00 00 
0130D8 00 00 00 00 
0130DC 00 00 00 00 
0130E0 00 00 00 00 
0130E4 00 00 00 00 
0130E8 00 00 00 00 
0130EC 00 00 00 00 
0130F0 00 00 00 00 
0130F4 00 00 00 00 
0130F8 00 00 00 00 
0130FC 00 00 00 00 
013100 00 00 00 00 
013104 00 00 00 00 
013108 00 00 00 00 
01310C 00 00 00 00 
013110 00 00 00 00 
013114 00 00 00 00 
013118 00 00 00 00 
01311C 00 00 00 00 
013120 00 00 00 00 
013124 00 00 00 00 
013128 00 00 00 00 
01312C 00 00 00 00 
013130 00 00 00 00 
013134 00 00 00 00 
013138 00 00 00 00 
01313C 00 00 00 00 
013140 00 00 00 00 
013144 00 00 00 00 
013148 00 00 00 00 
01314C 00 00 00 00 
013150 00 00 00 00 
013154 00 00 00 00 
013158 00 00 00 00 
01315C 00 00 00 00 
013160 00 00 00 00 
013164 00 00 00 00 
013168 00 00 00 00 
01316C 00 00 00 00 
013170 00 00 00 00 
013174 00 00 00 00 
013178 00 00 00 00 
01317C 00 00 00 00 
013180 00 00 00 00 
013184 00 00 00 00 
013188 00 00 00 00 
01318C 00 00 00 00 
013190 00 00 00 00 
013194 00 00 00 00 
013198 00 00 00 00 
01319C 00 00 00 00 
0131A0 00 00 00 00 
0131A4 00 00 00 00 
0131A8 00 00 00 00 
0131AC 00 00 00 00 
0131B0 00 00 00 00 
0131B4 00 00 00 00 
0131B8 00 00 00 00 
0131BC 00 00 00 00 
0131C0 00 00 00 00 
0131C4 00 00 00 00 
0131C8 00 00 00 00 
0131CC 00 00 00 00 
0131D0 00 00 00 00 
0131D4 00 00 00 00 
0131D8 00 00 00 00 
0131DC 00 00 00 00 
0131E0 00 00 00 00 
0131E4 00 00 00 00 
0131E8 00 00 00 00 
0131EC 00 00 00 00 
0131F0 00 00 00 00 
0131F4 00 00 00 00 
0131F8 00 00 00 00 
0131FC 00 00 00 00 
013200 00 00 00 00 
013204 00 00 00 00 
013208 00 00 00 00 
01320C 00 00 00 00 
013210 00 00 00 00 
013214 00 00 00 00 
013218 00 00 00 00 
01321C 00 00 00 00 
013220 00 00 00 00 
013224 00 00 00 00 
013228 00 00 00 00 
01322C 00 00 00 00 
013230 00 00 00 00 
013234 00 00 00 00 
013238 00 00 00 00 
01323C 00 00 00 00 
013240 00 00 00 00 
013244 00 00 00 00 
013248 00 00 00 00 
01324C 00 00 00 00 
013250 00 00 00 00 
013254 00 00 00 00 
013258 00 00 00 00 
01325C 00 00 00 00 
013260 00 00 00 00 
013264 00 00 00 00 
013268 00 00 00 00 
01326C 00 00 00 00 
013270 00 00 00 00 
013274 00 00 00 00 
013278 00 00 00 00 
01327C 00 00 00 00 
013280 00 00 00 00 
013284 00 00 00 00 
013288 00 00 00 00 
01328C 00 00 00 00 
013290 00 00 00 00 
013294 00 00 00 00 
013298 00 00 00 00 
01329C 00 00 00 00 
0132A0 00 00 00 00 
0132A4 00 00 00 00 
0132A8 00 00 00 00 
0132AC 00 00 00 00 
0132B0 00 00 00 00 
0132B4 00 00 00 00 
0132B8 00 00 00 00 
0132BC 00 00 00 00 
0132C0 00 00 00 00 
0132C4 00 00 00 00 
0132C8 00 00 00 00 
0132CC 00 00 00 00 
0132D0 00 00 00 00 
0132D4 00 00 00 00 
0132D8 00 00 00 00 
0132DC 00 00 00 00 
0132E0 00 00 00 00 
0132E4 00 00 00 00 
0132E8 00 00 00 00 
0132EC 00 00 00 00 
0132F0 00 00 00 00 
0132F4 00 00 00 00 
0132F8 00 00 00 00 
0132FC 00 00 00 00 
013300 00 00 00 00 
013304 00 00 00 00 
013308 00 00 00 00 
01330C 00 00 00 00 
013310 00 00 00 00 
013314 00 00 00 00 
013318 00 00 00 00 
01331C 00 00 00 00 
013320 00 00 00 00 
013324 00 00 00 00 
013328 00 00 00 00 
01332C 00 00 00 00 
013330 00 00 00 00 
013334 00 00 00 00 
013338 00 00 00 00 
01333C 00 00 00 00 
013340 00 00 00 00 
013344 00 00 00 00 
013348 00 00 00 00 
01334C 00 00 00 00 
013350 00 00 00 00 
013354 00 00 00 00 
013358 00 00 00 00 
01335C 00 00 00 00 
013360 00 00 00 00 
013364 00 00 00 00 
013368 00 00 00 00 
01336C 00 00 00 00 
013370 00 00 00 00 
013374 00 00 00 00 
013378 00 00 00 00 
01337C 00 00 00 00 
013380 00 00 00 00 
013384 00 00 00 00 
013388 00 00 00 00 
01338C 00 00 00 00 
013390 00 00 00 00 
013394 00 00 00 00 
013398 00 00 00 00 
01339C 00 00 00 00 
0133A0 00 00 00 00 
0133A4 00 00 00 00 
0133A8 00 00 00 00 
0133AC 00 00 00 00 
0133B0 00 00 00 00 
0133B4 00 00 00 00 
0133B8 00 00 00 00 
0133BC 00 00 00 00 
0133C0 00 00 00 00 
0133C4 00 00 00 00 
0133C8 00 00 00 00 
0133CC 00 00 00 00 
0133D0 00 00 00 00 
0133D4 00 00 00 00 
0133D8 00 00 00 00 
0133DC 00 00 00 00 
0133E0 00 00 00 00 
0133E4 00 00 00 00 
0133E8 00 00 00 00 
0133EC 00 00 00 00 
0133F0 00 00 00 00 
0133F4 00 00 00 00 
0133F8 00 00 00 00 
0133FC 00 00 00 00 
013400 00 00 00 00 
013404 00 00 00 00 
013408 00 00 00 00 
01340C 00 00 00 00 
013410 00 00 00 00 
013414 00 00 00 00 
013418 00 00 00 00 
01341C 00 00 00 00 
013420 00 00 00 00 
013424 00 00 00 00 
013428 00 00 00 00 
01342C 00 00 00 00 
013430 00 00 00 00 
013434 00 00 00 00 
013438 00 00 00 00 
01343C 00 00 00 00 
013440 00 00 00 00 
013444 00 00 00 00 
013448 00 00 00 00 
01344C 00 00 00 00 
013450 00 00 00 00 
013454 00 00 00 00 
013458 00 00 00 00 
01345C 00 00 00 00 
013460 00 00 00 00 
013464 00 00 00 00 
013468 00 00 00 00 
01346C 00 00 00 00 
013470 00 00 00 00 
013474 00 00 00 00 
013478 00 00 00 00 
01347C 00 00 00 00 
013480 00 00 00 00 
013484 00 00 00 00 
013488 00 00 00 00 
01348C 00 00 00 00 
013490 00 00 00 00 
013494 00 00 00 00 
013498 00 00 00 00 
01349C 00 00 00 00 
0134A0 00 00 00 00 
0134A4 00 00 00 00 
0134A8 00 00 00 00 
0134AC 00 00 00 00 
0134B0 00 00 00 00 
0134B4 00 00 00 00 
0134B8 00 00 00 00 
0134BC 00 00 00 00 
0134C0 00 00 00 00 
0134C4 00 00 00 00 
0134C8 00 00 00 00 
0134CC 00 00 00 00 
0134D0 00 00 00 00 
0134D4 00 00 00 00 
0134D8 00 00 00 00 
0134DC 00 00 00 00 
0134E0 00 00 00 00 
0134E4 00 00 00 00 
0134E8 00 00 00 00 
0134EC 00 00 00 00 
0134F0 00 00 00 00 
0134F4 00 00 00 00 
0134F8 00 00 00 00 
0134FC 00 00 00 00 
013500 00 00 00 00 
013504 00 00 00 00 
013508 00 00 00 00 
01350C 00 00 00 00 
013510 00 00 00 00 
013514 00 00 00 00 
013518 00 00 00 00 
01351C 00 00 00 00 
013520 00 00 00 00 
013524 00 00 00 00 
013528 00 00 00 00 
01352C 00 00 00 00 
013530 00 00 00 00 
013534 00 00 00 00 
013538 00 00 00 00 
01353C 00 00 00 00 
013540 00 00 00 00 
013544 00 00 00 00 
013548 00 00 00 00 
01354C 00 00 00 00 
013550 00 00 00 00 
013554 00 00 00 00 
013558 00 00 00 00 
01355C 00 00 00 00 
013560 00 00 00 00 
013564 00 00 00 00 
013568 00 00 00 00 
01356C 00 00 00 00 
013570 00 00 00 00 
013574 00 00 00 00 
013578 00 00 00 00 
01357C 00 00 00 00 
013580 00 00 00 00 
013584 00 00 00 00 
013588 00 00 00 00 
01358C 00 00 00 00 
013590 00 00 00 00 
013594 00 00 00 00 
013598 00 00 00 00 
01359C 00 00 00 00 
0135A0 00 00 00 00 
0135A4 00 00 00 00 
0135A8 00 00 00 00 
0135AC 00 00 00 00 
0135B0 00 00 00 00 
0135B4 00 00 00 00 
0135B8 00 00 00 00 
0135BC 00 00 00 00 
0135C0 00 00 00 00 
0135C4 00 00 00 00 
0135C8 00 00 00 00 
0135CC 00 00 00 00 
0135D0 00 00 00 00 
0135D4 00 00 00 00 
0135D8 00 00 00 00 
0135DC 00 00 00 00 
0135E0 00 00 00 00 
0135E4 00 00 00 00 
0135E8 00 00 00 00 
0135EC 00 00 00 00 
0135F0 00 00 00 00 
0135F4 00 00 00 00 
0135F8 00 00 00 00 
0135FC 00 00 00 00 
013600 00 00 00 00 
013604 00 00 00 00 
013608 00 00 00 00 
01360C 00 00 00 00 
013610 00 00 00 00 
013614 00 00 00 00 
013618 00 00 00 00 
01361C 00 00 00 00 
013620 00 00 00 00 
013624 00 00 00 00 
013628 00 00 00 00 
01362C 00 00 00 00 
013630 00 00 00 00 
013634 00 00 00 00 
013638 00 00 00 00 
01363C 00 00 00 00 
013640 00 00 00 00 
013644 00 00 00 00 
013648 00 00 00 00 
01364C 00 00 00 00 
013650 00 00 00 00 
013654 00 00 00 00 
013658 00 00 00 00 
01365C 00 00 00 00 
013660 00 00 00 00 
013664 00 00 00 00 
013668 00 00 00 00 
01366C 00 00 00 00 
013670 00 00 00 00 
013674 00 00 00 00 
013678 00 00 00 00 
01367C 00 00 00 00 
013680 00 00 00 00 
013684 00 00 00 00 
013688 00 00 00 00 
01368C 00 00 00 00 
013690 00 00 00 00 
013694 00 00 00 00 
013698 00 00 00 00 
01369C 00 00 00 00 
0136A0 00 00 00 00 
0136A4 00 00 00 00 
0136A8 00 00 00 00 
0136AC 00 00 00 00 
0136B0 00 00 00 00 
0136B4 00 00 00 00 
0136B8 00 00 00 00 
0136BC 00 00 00 00 
0136C0 00 00 00 00 
0136C4 00 00 00 00 
0136C8 00 00 00 00 
0136CC 00 00 00 00 
0136D0 00 00 00 00 
0136D4 00 00 00 00 
0136D8 00 00 00 00 
0136DC 00 00 00 00 
0136E0 00 00 00 00 
0136E4 00 00 00 00 
0136E8 00 00 00 00 
0136EC 00 00 00 00 
0136F0 00 00 00 00 
0136F4 00 00 00 00 
0136F8 00 00 00 00 
0136FC 00 00 00 00 
013700 00 00 00 00 
013704 00 00 00 00 
013708 00 00 00 00 
01370C 00 00 00 00 
013710 00 00 00 00 
013714 00 00 00 00 
013718 00 00 00 00 
01371C 00 00 00 00 
013720 00 00 00 00 
013724 00 00 00 00 
013728 00 00 00 00 
01372C 00 00 00 00 
013730 00 00 00 00 
013734 00 00 00 00 
013738 00 00 00 00 
01373C 00 00 00 00 
013740 00 00 00 00 
013744 00 00 00 00 
013748 00 00 00 00 
01374C 00 00 00 00 
013750 00 00 00 00 
013754 00 00 00 00 
013758 00 00 00 00 
01375C 00 00 00 00 
013760 00 00 00 00 
013764 00 00 00 00 
013768 00 00 00 00 
01376C 00 00 00 00 
013770 00 00 00 00 
013774 00 00 00 00 
013778 00 00 00 00 
01377C 00 00 00 00 
013780 00 00 00 00 
013784 00 00 00 00 
013788 00 00 00 00 
01378C 00 00 00 00 
013790 00 00 00 00 
013794 00 00 00 00 
013798 00 00 00 00 
01379C 00 00 00 00 
0137A0 00 00 00 00 
0137A4 00 00 00 00 
0137A8 00 00 00 00 
0137AC 00 00 00 00 
0137B0 00 00 00 00 
0137B4 00 00 00 00 
0137B8 00 00 00 00 
0137BC 00 00 00 00 
0137C0 00 00 00 00 
0137C4 00 00 00 00 
0137C8 00 00 00 00 
0137CC 00 00 00 00 
0137D0 00 00 00 00 
0137D4 00 00 00 00 
0137D8 00 00 00 00 
0137DC 00 00 00 00 
0137E0 00 00 00 00 
0137E4 00 00 00 00 
0137E8 00 00 00 00 
0137EC 00 00 00 00 
0137F0 00 00 00 00 
0137F4 00 00 00 00 
0137F8 00 00 00 00 
0137FC 00 00 00 00 
013800 00 00 00 00 
013804 00 00 00 00 
013808 00 00 00 00 
01380C 00 00 00 00 
013810 00 00 00 00 
013814 00 00 00 00 
013818 00 00 00 00 
01381C 00 00 00 00 
013820 00 00 00 00 
013824 00 00 00 00 
013828 00 00 00 00 
01382C 00 00 00 00 
013830 00 00 00 00 
013834 00 00 00 00 
013838 00 00 00 00 
01383C 00 00 00 00 
013840 00 00 00 00 
013844 00 00 00 00 
013848 00 00 00 00 
01384C 00 00 00 00 
013850 00 00 00 00 
013854 00 00 00 00 
013858 00 00 00 00 
01385C 00 00 00 00 
013860 00 00 00 00 
013864 00 00 00 00 
013868 00 00 00 00 
01386C 00 00 00 00 
013870 00 00 00 00 
013874 00 00 00 00 
013878 00 00 00 00 
01387C 00 00 00 00 
013880 00 00 00 00 
013884 00 00 00 00 
013888 00 00 00 00 
01388C 00 00 00 00 
013890 00 00 00 00 
013894 00 00 00 00 
013898 00 00 00 00 
01389C 00 00 00 00 
0138A0 00 00 00 00 
0138A4 00 00 00 00 
0138A8 00 00 00 00 
0138AC 00 00 00 00 
0138B0 00 00 00 00 
0138B4 00 00 00 00 
0138B8 00 00 00 00 
0138BC 00 00 00 00 
0138C0 00 00 00 00 
0138C4 00 00 00 00 
0138C8 00 00 00 00 
0138CC 00 00 00 00 
0138D0 00 00 00 00 
0138D4 00 00 00 00 
0138D8 00 00 00 00 
0138DC 00 00 00 00 
0138E0 00 00 00 00 
0138E4 00 00 00 00 
0138E8 00 00 00 00 
0138EC 00 00 00 00 
0138F0 00 00 00 00 
0138F4 00 00 00 00 
0138F8 00 00 00 00 
0138FC 00 00 00 00 
013900 00 00 00 00 
013904 00 00 00 00 
013908 00 00 00 00 
01390C 00 00 00 00 
013910 00 00 00 00 
013914 00 00 00 00 
013918 00 00 00 00 
01391C 00 00 00 00 
013920 00 00 00 00 
013924 00 00 00 00 
013928 00 00 00 00 
01392C 00 00 00 00 
013930 00 00 00 00 
013934 00 00 00 00 
013938 00 00 00 00 
01393C 00 00 00 00 
013940 00 00 00 00 
013944 00 00 00 00 
013948 00 00 00 00 
01394C 00 00 00 00 
013950 00 00 00 00 
013954 00 00 00 00 
013958 00 00 00 00 
01395C 00 00 00 00 
013960 00 00 00 00 
013964 00 00 00 00 
013968 00 00 00 00 
01396C 00 00 00 00 
013970 00 00 00 00 
013974 00 00 00 00 
013978 00 00 00 00 
01397C 00 00 00 00 
013980 00 00 00 00 
013984 00 00 00 00 
013988 00 00 00 00 
01398C 00 00 00 00 
013990 00 00 00 00 
013994 00 00 00 00 
013998 00 00 00 00 
01399C 00 00 00 00 
0139A0 00 00 00 00 
0139A4 00 00 00 00 
0139A8 00 00 00 00 
0139AC 00 00 00 00 
0139B0 00 00 00 00 
0139B4 00 00 00 00 
0139B8 00 00 00 00 
0139BC 00 00 00 00 
0139C0 00 00 00 00 
0139C4 00 00 00 00 
0139C8 00 00 00 00 
0139CC 00 00 00 00 
0139D0 00 00 00 00 
0139D4 00 00 00 00 
0139D8 00 00 00 00 
0139DC 00 00 00 00 
0139E0 00 00 00 00 
0139E4 00 00 00 00 
0139E8 00 00 00 00 
0139EC 00 00 00 00 
0139F0 00 00 00 00 
0139F4 00 00 00 00 
0139F8 00 00 00 00 
0139FC 00 00 00 00 
013A00 00 00 00 00 
013A04 00 00 00 00 
013A08 00 00 00 00 
013A0C 00 00 00 00 
013A10 00 00 00 00 
013A14 00 00 00 00 
013A18 00 00 00 00 
013A1C 00 00 00 00 
013A20 00 00 00 00 
013A24 00 00 00 00 
013A28 00 00 00 00 
013A2C 00 00 00 00 
013A30 00 00 00 00 
013A34 00 00 00 00 
013A38 00 00 00 00 
013A3C 00 00 00 00 
013A40 00 00 00 00 
013A44 00 00 00 00 
013A48 00 00 00 00 
013A4C 00 00 00 00 
013A50 00 00 00 00 
013A54 00 00 00 00 
013A58 00 00 00 00 
013A5C 00 00 00 00 
013A60 00 00 00 00 
013A64 00 00 00 00 
013A68 00 00 00 00 
013A6C 00 00 00 00 
013A70 00 00 00 00 
013A74 00 00 00 00 
013A78 00 00 00 00 
013A7C 00 00 00 00 
013A80 00 00 00 00 
013A84 00 00 00 00 
013A88 00 00 00 00 
013A8C 00 00 00 00 
013A90 00 00 00 00 
013A94 00 00 00 00 
013A98 00 00 00 00 
013A9C 00 00 00 00 
013AA0 00 00 00 00 
013AA4 00 00 00 00 
013AA8 00 00 00 00 
013AAC 00 00 00 00 
013AB0 00 00 00 00 
013AB4 00 00 00 00 
013AB8 00 00 00 00 
013ABC 00 00 00 00 
013AC0 00 00 00 00 
013AC4 00 00 00 00 
013AC8 00 00 00 00 
013ACC 00 00 00 00 
013AD0 00 00 00 00 
013AD4 00 00 00 00 
013AD8 00 00 00 00 
013ADC 00 00 00 00 
013AE0 00 00 00 00 
013AE4 00 00 00 00 
013AE8 00 00 00 00 
013AEC 00 00 00 00 
013AF0 00 00 00 00 
013AF4 00 00 00 00 
013AF8 00 00 00 00 
013AFC 00 00 00 00 
013B00 00 00 00 00 
013B04 00 00 00 00 
013B08 00 00 00 00 
013B0C 00 00 00 00 
013B10 00 00 00 00 
013B14 00 00 00 00 
013B18 00 00 00 00 
013B1C 00 00 00 00 
013B20 00 00 00 00 
013B24 00 00 00 00 
013B28 00 00 00 00 
013B2C 00 00 00 00 
013B30 00 00 00 00 
013B34 00 00 00 00 
013B38 00 00 00 00 
013B3C 00 00 00 00 
013B40 00 00 00 00 
013B44 00 00 00 00 
013B48 00 00 00 00 
013B4C 00 00 00 00 
013B50 00 00 00 00 
013B54 00 00 00 00 
013B58 00 00 00 00 
013B5C 00 00 00 00 
013B60 00 00 00 00 
013B64 00 00 00 00 
013B68 00 00 00 00 
013B6C 00 00 00 00 
013B70 00 00 00 00 
013B74 00 00 00 00 
013B78 00 00 00 00 
013B7C 00 00 00 00 
013B80 00 00 00 00 
013B84 00 00 00 00 
013B88 00 00 00 00 
013B8C 00 00 00 00 
013B90 00 00 00 00 
013B94 00 00 00 00 
013B98 00 00 00 00 
013B9C 00 00 00 00 
013BA0 00 00 00 00 
013BA4 00 00 00 00 
013BA8 00 00 00 00 
013BAC 00 00 00 00 
013BB0 00 00 00 00 
013BB4 00 00 00 00 
013BB8 00 00 00 00 
013BBC 00 00 00 00 
013BC0 00 00 00 00 
013BC4 00 00 00 00 
013BC8 00 00 00 00 
013BCC 00 00 00 00 
013BD0 00 00 00 00 
013BD4 00 00 00 00 
013BD8 00 00 00 00 
013BDC 00 00 00 00 
013BE0 00 00 00 00 
013BE4 00 00 00 00 
013BE8 00 00 00 00 
013BEC 00 00 00 00 
013BF0 00 00 00 00 
013BF4 00 00 00 00 
013BF8 00 00 00 00 
013BFC 00 00 00 00 
013C00 00 00 00 00 
013C04 00 00 00 00 
013C08 00 00 00 00 
013C0C 00 00 00 00 
013C10 00 00 00 00 
013C14 00 00 00 00 
013C18 00 00 00 00 
013C1C 00 00 00 00 
013C20 00 00 00 00 
013C24 00 00 00 00 
013C28 00 00 00 00 
013C2C 00 00 00 00 
013C30 00 00 00 00 
013C34 00 00 00 00 
013C38 00 00 00 00 
013C3C 00 00 00 00 
013C40 00 00 00 00 
013C44 00 00 00 00 
013C48 00 00 00 00 
013C4C 00 00 00 00 
013C50 00 00 00 00 
013C54 00 00 00 00 
013C58 00 00 00 00 
013C5C 00 00 00 00 
013C60 00 00 00 00 
013C64 00 00 00 00 
013C68 00 00 00 00 
013C6C 00 00 00 00 
013C70 00 00 00 00 
013C74 00 00 00 00 
013C78 00 00 00 00 
013C7C 00 00 00 00 
013C80 00 00 00 00 
013C84 00 00 00 00 
013C88 00 00 00 00 
013C8C 00 00 00 00 
013C90 00 00 00 00 
013C94 00 00 00 00 
013C98 00 00 00 00 
013C9C 00 00 00 00 
013CA0 00 00 00 00 
013CA4 00 00 00 00 
013CA8 00 00 00 00 
013CAC 00 00 00 00 
013CB0 00 00 00 00 
013CB4 00 00 00 00 
013CB8 00 00 00 00 
013CBC 00 00 00 00 
013CC0 00 00 00 00 
013CC4 00 00 00 00 
013CC8 00 00 00 00 
013CCC 00 00 00 00 
013CD0 00 00 00 00 
013CD4 00 00 00 00 
013CD8 00 00 00 00 
013CDC 00 00 00 00 
013CE0 00 00 00 00 
013CE4 00 00 00 00 
013CE8 00 00 00 00 
013CEC 00 00 00 00 
013CF0 00 00 00 00 
013CF4 00 00 00 00 
013CF8 00 00 00 00 
013CFC 00 00 00 00 
013D00 00 00 00 00 
013D04 00 00 00 00 
013D08 00 00 00 00 
013D0C 00 00 00 00 
013D10 00 00 00 00 
013D14 00 00 00 00 
013D18 00 00 00 00 
013D1C 00 00 00 00 
013D20 00 00 00 00 
013D24 00 00 00 00 
013D28 00 00 00 00 
013D2C 00 00 00 00 
013D30 00 00 00 00 
013D34 00 00 00 00 
013D38 00 00 00 00 
013D3C 00 00 00 00 
013D40 00 00 00 00 
013D44 00 00 00 00 
013D48 00 00 00 00 
013D4C 00 00 00 00 
013D50 00 00 00 00 
013D54 00 00 00 00 
013D58 00 00 00 00 
013D5C 00 00 00 00 
013D60 00 00 00 00 
013D64 00 00 00 00 
013D68 00 00 00 00 
013D6C 00 00 00 00 
013D70 00 00 00 00 
013D74 00 00 00 00 
013D78 00 00 00 00 
013D7C 00 00 00 00 
013D80 00 00 00 00 
013D84 00 00 00 00 
013D88 00 00 00 00 
013D8C 00 00 00 00 
013D90 00 00 00 00 
013D94 00 00 00 00 
013D98 00 00 00 00 
013D9C 00 00 00 00 
013DA0 00 00 00 00 
013DA4 00 00 00 00 
013DA8 00 00 00 00 
013DAC 00 00 00 00 
013DB0 00 00 00 00 
013DB4 00 00 00 00 
013DB8 00 00 00 00 
013DBC 00 00 00 00 
013DC0 00 00 00 00 
013DC4 00 00 00 00 
013DC8 00 00 00 00 
013DCC 00 00 00 00 
013DD0 00 00 00 00 
013DD4 00 00 00 00 
013DD8 00 00 00 00 
013DDC 00 00 00 00 
013DE0 00 00 00 00 
013DE4 00 00 00 00 
013DE8 00 00 00 00 
013DEC 00 00 00 00 
013DF0 00 00 00 00 
013DF4 00 00 00 00 
013DF8 00 00 00 00 
013DFC 00 00 00 00 
013E00 00 00 00 00 
013E04 00 00 00 00 
013E08 00 00 00 00 
013E0C 00 00 00 00 
013E10 00 00 00 00 
013E14 00 00 00 00 
013E18 00 00 00 00 
013E1C 00 00 00 00 
013E20 00 00 00 00 
013E24 00 00 00 00 
013E28 00 00 00 00 
013E2C 00 00 00 00 
013E30 00 00 00 00 
013E34 00 00 00 00 
013E38 00 00 00 00 
013E3C 00 00 00 00 
013E40 00 00 00 00 
013E44 00 00 00 00 
013E48 00 00 00 00 
013E4C 00 00 00 00 
013E50 00 00 00 00 
013E54 00 00 00 00 
013E58 00 00 00 00 
013E5C 00 00 00 00 
013E60 00 00 00 00 
013E64 00 00 00 00 
013E68 00 00 00 00 
013E6C 00 00 00 00 
013E70 00 00 00 00 
013E74 00 00 00 00 
013E78 00 00 00 00 
013E7C 00 00 00 00 
013E80 00 00 00 00 
013E84 00 00 00 00 
013E88 00 00 00 00 
013E8C 00 00 00 00 
013E90 00 00 00 00 
013E94 00 00 00 00 
013E98 00 00 00 00 
013E9C 00 00 00 00 
013EA0 00 00 00 00 
013EA4 00 00 00 00 
013EA8 00 00 00 00 
013EAC 00 00 00 00 
013EB0 00 00 00 00 
013EB4 00 00 00 00 
013EB8 00 00 00 00 
013EBC 00 00 00 00 
013EC0 00 00 00 00 
013EC4 00 00 00 00 
013EC8 00 00 00 00 
013ECC 00 00 00 00 
013ED0 00 00 00 00 
013ED4 00 00 00 00 
013ED8 00 00 00 00 
013EDC 00 00 00 00 
013EE0 00 00 00 00 
013EE4 00 00 00 00 
013EE8 00 00 00 00 
013EEC 00 00 00 00 
013EF0 00 00 00 00 
013EF4 00 00 00 00 
013EF8 00 00 00 00 
013EFC 00 00 00 00 
013F00 00 00 00 00 
013F04 00 00 00 00 
013F08 00 00 00 00 
013F0C 00 00 00 00 
013F10 00 00 00 00 
013F14 00 00 00 00 
013F18 00 00 00 00 
013F1C 00 00 00 00 
013F20 00 00 00 00 
013F24 00 00 00 00 
013F28 00 00 00 00 
013F2C 00 00 00 00 
013F30 00 00 00 00 
013F34 00 00 00 00 
013F38 00 00 00 00 
013F3C 00 00 00 00 
013F40 00 00 00 00 
013F44 00 00 00 00 
013F48 00 00 00 00 
013F4C 00 00 00 00 
013F50 00 00 00 00 
013F54 00 00 00 00 
013F58 00 00 00 00 
013F5C 00 00 00 00 
013F60 00 00 00 00 
013F64 00 00 00 00 
013F68 00 00 00 00 
013F6C 00 00 00 00 
013F70 00 00 00 00 
013F74 00 00 00 00 
013F78 00 00 00 00 
013F7C 00 00 00 00 
013F80 00 00 00 00 
013F84 00 00 00 00 
013F88 00 00 00 00 
013F8C 00 00 00 00 
013F90 00 00 00 00 
013F94 00 00 00 00 
013F98 00 00 00 00 
013F9C 00 00 00 00 
013FA0 00 00 00 00 
013FA4 00 00 00 00 
013FA8 00 00 00 00 
013FAC 00 00 00 00 
013FB0 00 00 00 00 
013FB4 00 00 00 00 
013FB8 00 00 00 00 
013FBC 00 00 00 00 
013FC0 00 00 00 00 
013FC4 00 00 00 00 
013FC8 00 00 00 00 
013FCC 00 00 00 00 
013FD0 00 00 00 00 
013FD4 00 00 00 00 
013FD8 00 00 00 00 
013FDC 00 00 00 00 
013FE0 00 00 00 00 
013FE4 00 00 00 00 
013FE8 00 00 00 00 
013FEC 00 00 00 00 
013FF0 00 00 00 00 
013FF4 00 00 00 00 
013FF8 00 00 00 00 
013FFC 00 00 00 00 
                		; Compress vector table by storing only the low order 16 bits of the
                		; vector. The high order bits are always the same.
                	syscall_vectors:
014000 1C 40       		dc		FMTKInitialize
014002 08 45       		dc		StartTask
014004 58 46       		dc		ExitTask
014006 C4 46       		dc   	KillTask
014008 61 48       		dc		SetTaskPriority
01400A 48 4B       		dc		Sleep
01400C 80 4B       		dc		AllocMbx
01400E 64 4C       		dc		FreeMbx
014010 E4 4F       		dc		PostMsg
014012 FC 4F       		dc		SendMsg
014014 64 51       		dc		WaitMsg
014016 FC 52       		dc		CheckMsg
                	
                	message "InitFMTK"
                	BranchToSelf:
014018 3A 00 00 00 	    bra     BranchToSelf
                	
                	FMTKInitialize:
                	InitFMTK:
                		; Initialize semaphores
01401C 7C C0 00 00 		sw		r0,freetcb_sema
014020 63 00 60 02 
014024 7C C0 00 00 		sw		r0,freembx_sema
014028 63 00 70 02 
01402C 7C C0 00 00 		sw		r0,freemsg_sema
014030 63 00 80 02 
014034 7C C0 00 00 		sw		r0,tcb_sema
014038 63 00 90 02 
01403C 7C C0 00 00 		sw		r0,readylist_sema
014040 63 00 A0 02 
014044 7C C0 00 00 		sw		r0,tolist_sema
014048 63 00 B0 02 
01404C 7C C0 00 00 		sw		r0,mbx_sema
014050 63 00 D0 02 
014054 7C C0 00 00 		sw		r0,msg_sema
014058 63 00 E0 02 
01405C 7C C0 00 00 		sw		r0,jcb_sema
014060 63 00 F0 02 
                	
014064 02 20 14 3E 		mfspr	r2,vbr
014068 7C 01 00 00 		ldi		r1,#reschedule
01406C 0A 10 40 A8 
014070 63 11 20 00 		sw		r1,16[r2]
014074 7C 01 00 00 		ldi		r1,#syscall_exception
014078 0A 10 88 A7 
01407C 63 11 40 00 		sw		r1,32[r2]
014080 7C 01 00 00 		ldi		r1,#FMTKTick
014084 0A 10 A0 AA 
014088 63 11 30 1C 		sw		r1,(448+3)<<3[r2]
01408C 7C C0 00 00 		sw		r0,UserTick
014090 63 00 00 00 
                	
014094 7C C0 00 00 		sw		r0,TimeoutList		; no entries in timeout list
014098 63 00 10 01 
01409C 7C C0 00 00 		sw		r0,QNdx0
0140A0 63 00 70 00 
0140A4 7C C0 00 00 		sw		r0,QNdx1
0140A8 63 00 80 00 
0140AC 7C C0 00 00 		sw		r0,QNdx2
0140B0 63 00 90 00 
0140B4 7C C0 00 00 		sw		r0,QNdx3
0140B8 63 00 A0 00 
0140BC 7C C0 00 00 		sw		r0,QNdx4
0140C0 63 00 B0 00 
0140C4 7C C0 00 00 		sw		r0,QNdx5
0140C8 63 00 C0 00 
0140CC 7C C0 00 00 		sw		r0,QNdx6
0140D0 63 00 D0 00 
0140D4 7C C0 00 00 		sw		r0,QNdx7
0140D8 63 00 E0 00 
                	
0140DC 7C C0 00 00 		sw		r0,missed_ticks
0140E0 63 00 70 01 
                	
                		; Initialize IO Focus List
                		;
0140E4 7C C0 00 00 		sw      r0,IOFocusTbl
0140E8 63 00 30 00 
0140EC 7C C0 00 00 		sw      r0,IOFocusTbl+8
0140F0 63 00 40 00 
0140F4 7C C0 00 00 		sw      r0,IOFocusTbl+16
0140F8 63 00 50 00 
0140FC 7C C0 00 00 		sw      r0,IOFocusTbl+32
014100 63 00 70 00 
                	
                		; zero out JCB's
                		; This will NULL out the I/O focus list pointers
014104 0A 10 B0 3F 		ldi     r1,#NR_JCB * JCB_Size / 8 - 8
014108 7C C4 00 00 		ldi     r2,#JCB_Array
01410C 0A 20 00 00 
                	.0001:
014110 6B 01 C2 00 		sw      r0,[r2+r1*8]
014114 95 10 02 00 		subui   r1,r1,#1
014118 BD 30 FC FF 		bge     r1,.0001
                	
                		; Setup default values in the JCB's
01411C 0A 30 00 00 		ldi		r3,#0
014120 0A 20 66 00 		ldi		r2,#NR_JCB
014124 7C C4 00 00 		ldi     r4,#JCB_Array
014128 0A 40 00 00 
                	ijcb1:
01412C 61 32 00 00 		sc		r3,JCB_Number[r4]
014130 60 02 E0 08 		sb		r0,JCB_esc[r4]
014134 0A 10 3E 00 		ldi     r1,#31
014138 60 12 14 08 		sb		r1,JCB_VideoRows[r4]
01413C 0A 10 A8 00 		ldi		r1,#84
014140 60 12 16 08 		sb		r1,JCB_VideoCols[r4]
014144 0A 10 02 00 		ldi		r1,#1				; turn on keyboard echo
014148 60 12 90 08 		sb		r1,JCB_KeybdEcho[r4]
01414C 60 12 1C 08 		sb		r1,JCB_CursorOn[r4]
014150 60 12 1E 08 		sb		r1,JCB_CursorFlash[r4]
014154 60 02 18 08 		sb		r0,JCB_CursorRow[r4]
014158 60 02 1A 08 		sb		r0,JCB_CursorCol[r4]
01415C 60 02 20 08 		sb		r0,JCB_CursorType[r4]
014160 FC 97 04 00 		ldi		r1,#%010010010_111111111_0000000000	; white on grey
014164 0A 10 00 F8 
014168 62 12 28 08 		sh		r1,JCB_NormAttr[r4]
01416C 62 12 30 08 		sh		r1,JCB_CurrAttr[r4]
014170 7C 00 00 00 		mulu	r5,r3,#16384		; 8192 words per screen
014174 97 51 00 80 
014178 7C D9 00 00 		addui   r5,r5,#SCREEN_Array
01417C 94 52 00 00 
014180 62 52 F0 07 		sh		r5,JCB_pVirtVid[r4]
014184 62 52 D0 07 		sh		r5,JCB_pVidMem[r4]
014188 BD 11 0E 00 		bne		r3,ijcb2
01418C 7C 32 02 00 		ldi		r1,#%001000110_010010010_0000000000	; grey on blue
014190 0A 10 00 90 
014194 62 12 28 08 		sh		r1,JCB_NormAttr[r4]
014198 62 12 30 08 		sh		r1,JCB_CurrAttr[r4]
01419C 44 50 00 00 		lh		r5,#TEXTSCR
0141A0 62 52 D0 07 		sh		r5,JCB_pVidMem[r4]
                	ijcb2:
0141A4 94 31 02 00 	    addui   r3,r3,#1
0141A8 14 42 00 0A 		addui	r4,r4,#JCB_Size
0141AC 86 21 66 00 		cmp     r2,r3,#NR_JCB
0141B0 3D 41 BE FF 		blt		r2,ijcb1
                	
                		; Initialize free message list
0141B4 FC 00 00 00 		ldi		r1,#NR_MSG
0141B8 0A 10 00 00 
0141BC 7C C0 00 00 		sw		r1,nMsgBlk
0141C0 63 10 60 01 
0141C4 7C C9 00 00 		ldi     r1,#MSG_Array
0141C8 0A 10 00 00 
0141CC 7C C0 00 00 		sw		r1,FreeMsg
0141D0 63 10 50 01 
0141D4 94 20 40 00 		addui   r2,r1,MSG_Size
                	st4:
0141D8 E3 20 00 00 		sw		r2,MSG_LINK[r1]
0141DC E3 00 10 00 		sw      r0,MSG_D1[r1]
0141E0 E3 00 20 00 		sw      r0,MSG_D2[r1]
0141E4 E3 00 30 00 		sw      r0,MSG_TYPE[r1]
0141E8 94 10 40 00 		addui	r1,r1,#MSG_Size
0141EC 14 21 40 00 		addui   r2,r2,#MSG_Size
0141F0 FC D8 00 00 		cmp     r3,r2,#MSG_ArrayEnd-MSG_Size
0141F4 06 31 C0 FF 
0141F8 BD 41 F0 FF 		blt     r3,st4
0141FC E3 00 00 00 		sw      r0,MSG_LINK[r1]
                	
                		; Initialize free mailbox list
                		; Note the first NR_TCB mailboxes are statically allocated to the tasks.
                		; They are effectively pre-allocated.
014200 0A 50 00 0E 		ldi		r5,#NR_MBX-NR_TCB
014204 7C C0 00 00 		sw		r5,nMailbox
014208 63 50 40 01 
                	
01420C 0A 10 00 02 	    ldi     r1,#NR_TCB
014210 97 20 C0 00 	    mulu    r2,r1,#MBX_Size
014214 7C C6 00 00 	    addui   r2,r2,#MBX_Array
014218 14 21 00 00 
01421C 7C C0 00 00 	    sw      r2,FreeMbxHandle
014220 63 20 30 01 
014224 02 31 00 1A 	    mov     r3,r2
014228 94 31 C0 00 	    addui   r3,r3,#MBX_Size
                	.imbxl1:
01422C 63 31 00 00 	    sw      r3,MBX_LINK[r2]
014230 14 21 C0 00 	    addui   r2,r2,#MBX_Size
014234 94 31 C0 00 	    addui   r3,r3,#MBX_Size
014238 95 52 02 00 	    subui   r5,r5,#1
01423C BD 22 F8 FF 	    bgt     r5,.imbxl1
                	
                		; Initialize the FreeJCB list
014240 7C C4 00 00 		ldi		r1,#JCB_Array+JCB_Size		; the next available JCB
014244 0A 10 00 0A 
014248 7C C0 00 00 		sw		r1,FreeJCB
01424C 63 10 F0 00 
014250 82 20 00 1A 		mov     r2,r1
014254 94 10 00 0A 		addui	r1,r1,#JCB_Size
014258 0A 30 64 00 		ldi		r3,#NR_JCB-1
                	st5:
01425C 63 11 40 08 		sw		r1,JCB_Next[r2]
014260 94 10 00 0A 		addui	r1,r1,#JCB_Size
014264 14 21 00 0A 		addui	r2,r2,#JCB_Size
014268 95 31 02 00 		subui   r3,r3,#1
01426C BD 11 F8 FF 		bne		r3,st5
014270 63 01 40 08 		sw      r0,JCB_Next[r2]
                	
                	    ; Initialize the free TCB list
                	    ; The first two TCB's are pre-allocated and so aren't part of the list
014274 7C C1 00 00 	    ldi     r2,#TCB_Array+2*TCB_Size
014278 0A 20 00 0C 
01427C 7C C0 00 00 	    sw      r2,FreeTCB
014280 63 20 00 01 
014284 63 01 40 04 	    sw      r0,TCB_PrevFree[r2]
                	.0001:
014288 14 31 00 06 	    addui   r3,r2,#TCB_Size
01428C 63 31 30 04 	    sw      r3,TCB_NextFree[r2]
014290 E3 21 40 04 	    sw      r2,TCB_PrevFree[r3]
014294 14 21 00 06 	    addui   r2,r2,#TCB_Size
014298 FC C3 00 00 	    cmpu    r4,r2,#TCB_ArrayEnd-TCB_Size
01429C 16 41 00 FA 
0142A0 3D 42 F4 FF 	    blt     r4,.0001
0142A4 63 01 30 04 	    sw      r0,TCB_NextFree[r2]
                	
0142A8 7C C1 00 00 	    ldi     r2,#TCB_Array
0142AC 0A 20 00 00 
0142B0 0A 40 00 00 	    ldi     r4,#0
                	.nextTCB:
0142B4 7C C4 00 00 	    ldi     r5,#JCB_Array
0142B8 0A 50 00 00 
0142BC 63 51 28 04 	    sw      r5,TCB_hJCB[r2]   ; owning JOB = monitor
0142C0 7C 01 00 00 	    ldi     r3,#BranchToSelf
0142C4 0A 30 30 80 
0142C8 63 31 00 03 	    sw      r3,TCB_IPC[r2]    ; set startup address
0142CC 17 32 00 20 	    mulu    r3,r4,#4096       ; initial stack size=4096
0142D0 7C F0 07 00 	    addui   r3,r3,#STACKS_Array+4088
0142D4 94 31 F0 1F 
0142D8 63 31 E0 01 	    sw      r3,TCB_r30[r2]    ; set the stack pointer to the default stack
0142DC 14 21 00 06 	    addui   r2,r2,#TCB_Size   ; move to next TCB 768B TCB size
0142E0 14 42 02 00 	    addui   r4,r4,#1
0142E4 16 12 00 02 	    cmpu    r1,r4,#NR_TCB
0142E8 BD 40 E6 FF 	    blt     r1,.nextTCB
                	
                		; Manually setup the BIOS task
0142EC 7C C1 00 00 		ldi     tr,#TCB_Array
0142F0 0A 80 01 00 
                	;	sw		tr,RunningTCB	; BIOS is task #0
0142F4 63 8C 01 04 		sw		tr,TCB_NextRdy[tr]	; manually build the ready list
0142F8 63 8C 11 04 		sw		tr,TCB_PrevRdy[tr]
0142FC 63 0C 50 04 		sw		r0,TCB_NextTo[tr]
014300 63 0C 60 04 		sw		r0,TCB_PrevTo[tr]
014304 7C C0 00 00 		sw		tr,QNdx3		; insert at priority 3
014308 63 80 A1 00 
                		; manually build the IO focus list
01430C 7C C4 00 00 		ldi		r1,#JCB_Array
014310 0A 10 00 00 
014314 7C C0 00 00 		sw	    r1,IOFocusNdx		; Job #0 (Monitor) has the focus
014318 63 10 20 00 
01431C E3 10 50 08 		sw		r1,JCB_iof_next[r1]
014320 E3 10 60 08 		sw		r1,JCB_iof_prev[r1]
014324 0A 10 02 00 		ldi		r1,#1
014328 7C C0 00 00 		sw		r1,IOFocusTbl		; set the job #0 request bit
01432C 63 10 30 00 
                	
014330 0A 10 06 00 		ldi		r1,#3
014334 61 1C 24 04 		sc		r1,TCB_Priority[tr]
014338 63 0C F0 04 		sw		r0,TCB_Timeout[tr]
01433C 0A 10 30 00 		ldi		r1,#TS_RUNNING|TS_READY
014340 60 1C 20 04 		sb		r1,TCB_Status[tr]
014344 7C F0 07 00 		ldi     r1,#STACKS_Array+$FF8   ; setup stack pointer top of memory
014348 0A 10 F0 1F 
01434C 63 1C F0 01 		sw		r1,TCB_r31[tr]
                	
014350 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	StartIdleTask:
014354 E7 EF 01 00 	    push    lr
014358 0A 10 0E 00 		ldi		r1,#7
01435C 0A 20 00 00 		ldi		r2,#0
014360 7C 01 00 00 		ldi		r3,#IdleTask
014364 0A 30 E0 86 
014368 39 34 00 00 		bsr		StartTask
01436C 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; IdleTask
                	;
                	; IdleTask is a low priority task that is always running. It runs when there
                	; is nothing else to run.
                	; This task check for tasks that are stuck in infinite loops and kills them.
                	;------------------------------------------------------------------------------
                	IdleTask:
                	it3:
014370 7C C1 00 00 	    ldi     r2,#TCB_Array
014374 0A 20 00 00 
                	it2:
                	;	inc		TEXTSCR+444		; increment IDLE active flag
014378 7C C1 00 00 		cmpu    r1,r2,#TCB_Array
01437C 16 11 00 00 
014380 BD 00 0E 00 		beq		r1,it1
014384 40 11 20 04 		lb		r1,TCB_Status[r2]
014388 86 10 40 00 		cmp		r1,r1,#TS_SLEEP
01438C BD 10 08 00 		bne		r1,it1
014390 02 11 00 1A 		mov     r1,r2
014394 38 0F 08 00 		sys		#4				; KillTask function
014398 03 00 00 00 		dh		3
                	it1:
01439C 14 21 00 06 	    addui   r2,r2,#TCB_Size
0143A0 FC C3 00 00 	    cmpu    r1,r2,#TCB_ArrayEnd-TCB_Size
0143A4 16 11 00 FA 
0143A8 BD 40 E8 FF 	    blt     r1,it2
0143AC BA F8 FF FF 	    bra     it3
0143B0 02 00 00 6E 		cli						; enable interrupts
                	;	wai						; wait for one to happen
0143B4 BA F8 FF FF 		bra		it2
                	
                	;------------------------------------------------------------------------------
                	; Parameters:
                	;	r1 = job name
                	;	r2 = start address
                	;------------------------------------------------------------------------------
                	
                	StartJob:
0143B8 E7 E0 01 00 		push    r1
                		
                		; Get a free JCB
                	sjob4:
0143BC 7C C0 00 00 	    lwar    r1,freejcb_sema
0143C0 5C 10 50 02 
0143C4 BD 10 FC FF 	    bne     r1,sjob4
0143C8 7C C0 00 00 	    swcr    tr,freejcb_sema
0143CC 6E 80 51 02 
0143D0 02 10 00 3E 	    mfspr   r1,cr0
0143D4 7C 00 00 10 	    and     r1,r1,#$1000000000
0143D8 8C 10 00 00 
0143DC BD 00 F0 FF 	    beq     r1,sjob4
                	
0143E0 7C C0 00 00 		lw		r6,FreeJCB
0143E4 46 60 F0 00 
0143E8 3D 03 24 00 		beq		r6,sjob1
0143EC 46 73 40 08 		lw		r7,JCB_Next[r6]
0143F0 7C C0 00 00 		sw		r7,FreeJCB
0143F4 63 70 F0 00 
0143F8 7C C0 00 00 		sw		r0,freejcb_sema
0143FC 63 00 50 02 
                	
014400 47 73 08 00 		lea		r7,JCB_Name[r6]		; r7 = address of name field
014404 82 93 00 1A 		mov		r9,r7				; save off buffer address
014408 0A 80 00 00 		ldi		r8,#0				; r8 = count of characters (0 to 31)
                	sjob3:
01440C C0 50 00 00 		lb	    r5,[r1]				; get a character
014410 BD 02 0E 00 		beq		r5,sjob2			; end of string ?
014414 E0 53 02 00 		sb		r5,1[r7]
014418 94 10 02 00 		addui   r1,r1,#1
01441C 94 73 02 00 		addui   r7,r7,#1
014420 14 84 02 00 		addui   r8,r8,#1
014424 16 54 3E 00 		cmpu	r5,r8,#31   		; max number of chars ?
014428 BD 42 F2 FF 		blt		r5,sjob3
                	sjob2:
01442C E0 84 00 00 		sb		r8,[r9]				; save name length
                	
                	sjob1:
014430 7C C0 00 00 		sw		r0,freejcb_sema
014434 63 00 50 02 
014438 57 1F 10 00 		pop     r1
01443C 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; Lock the task control blocks semaphore.
                	;------------------------------------------------------------------------------
                	
                	LockFreeMBX:
014440 E7 EF 01 00 	    push    lr
014444 E7 E0 01 00 	    push    r1
014448 7C C0 00 00 	    lea     r1,freembx_sema
01444C 47 10 70 02 
014450 B9 0F 00 00 	    bsr     LockSema
014454 57 1F 10 00 	    pop     r1
014458 3B FF 11 00 	    rts

                	LockFreeMSG:
01445C E7 EF 01 00 	    push    lr
014460 E7 E0 01 00 	    push    r1
014464 7C C0 00 00 	    lea     r1,freemsg_sema
014468 47 10 80 02 
01446C 39 0C 00 00 	    bsr     LockSema
014470 57 1F 10 00 	    pop     r1
014474 3B FF 11 00 	    rts

                	LockMBX:
014478 E7 EF 01 00 	    push    lr
01447C E7 E0 01 00 	    push    r1
014480 7C C0 00 00 	    lea     r1,mbx_sema
014484 47 10 D0 02 
014488 B9 08 00 00 	    bsr     LockSema
01448C 57 1F 10 00 	    pop     r1
014490 3B FF 11 00 	    rts

                	LockFreeTCB:
014494 E7 EF 01 00 	    push    lr
014498 E7 E0 01 00 	    push    r1
01449C 7C C0 00 00 	    lea     r1,freetcb_sema
0144A0 47 10 60 02 
0144A4 39 05 00 00 	    bsr     LockSema
0144A8 57 1F 10 00 	    pop     r1
0144AC 3B FF 11 00 	    rts

                	LockTCB:
0144B0 E7 EF 01 00 	    push    lr
0144B4 E7 E0 01 00 	    push    r1
0144B8 7C C0 00 00 	    lea     r1,tcb_sema
0144BC 47 10 90 02 
0144C0 B9 01 00 00 	    bsr     LockSema
0144C4 57 1F 10 00 	    pop     r1
0144C8 3B FF 11 00 	    rts

                	;------------------------------------------------------------------------------
                	; Lock the semaphore.
                	;
                	; While locking, a test is made to see if the task already owns the
                	; semaphore. This helps prevent problems in case of a software error in the
                	; OS. If an attempt is made to lock the semaphore twice (or more) by the same
                	; task, the OS would lock up waiting for the semaphore. Checking if it's
                	; already owned prevents this lockup.
                	; Parameters:
                	; r1 = address of semaphore to lock
                	;------------------------------------------------------------------------------
                	
                	LockSema:
0144CC 67 E1 01 00 	    push    r2
0144D0 E7 E1 01 00 	    push    r3
                	
                	    ; Interrupts should be already enabled or there would be no way for a locked
                	    ; semaphore to clear. Let's enable interrupts just in case.
0144D4 02 00 00 6E 	    cli
                	.0001:
0144D8 DC 30 00 00 	    lwar    r3,[r1]
0144DC 82 21 30 2C 	    cmpu    r2,r3,tr            ; does the task already own the lock ?
0144E0 3D 01 0E 00 	    beq     r2,.0002
0144E4 BD 11 FA FF 	    bne     r3,.0001            ; branch if not yet free
0144E8 EE 80 01 00 	    swcr    tr,[r1]             ; try and lock it
0144EC 02 30 00 3E 	    mfspr   r3,cr0
0144F0 7C 00 00 10 	    and     r3,r3,#$1000000000
0144F4 8C 31 00 00 
0144F8 BD 01 F0 FF 	    beq     r3,.0001            ; lock failed, go try again
                	.0002:
0144FC 57 3F 10 00 	    pop     r3
014500 57 2F 10 00 	    pop     r2
014504 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	; StartTask
                	;
                	; Startup a task. The task is automatically allocated a 1kW stack from the BIOS
                	; stacks area. 
                	;
                	; Parameters:
                	;	r1 = task priority
                	;	r2 = start flags
                	;	r3 = start address
                	;	r4 = start parameter
                	;	r5 = job handle
                	;------------------------------------------------------------------------------
                	
                	StartTask:
014508 E7 EF 01 00 	    push    lr
01450C E7 E0 01 00 	    push    r1
014510 67 E1 01 00 	    push    r2
014514 E7 E1 01 00 	    push    r3
014518 67 E2 01 00 	    push    r4
01451C E7 E2 01 00 	    push    r5
014520 67 E3 01 00 		push    r6
014524 E7 E3 01 00 		push    r7
014528 67 E4 01 00 		push    r8
01452C 82 60 00 1A 		mov		r6,r1				; r6 = task priority
014530 02 81 00 1A 		mov		r8,r2				; r8 = flag register value on startup
                		
                		; get a free TCB
                		;
014534 39 EC FF FF 	    bsr     LockFreeTCB
014538 7C C0 00 00 		lw		r1,FreeTCB			; get free tcb list pointer
01453C 46 10 00 01 
014540 BD 00 70 00 		beq		r1,stask1
014544 82 20 00 1A 		mov     r2,r1
014548 46 11 30 04 		lw		r1,TCB_NextFree[r2]
01454C 7C C0 00 00 		sw		r1,FreeTCB			; update the FreeTCB list pointer
014550 63 10 00 01 
014554 7C C0 00 00 		sw		r0,freetcb_sema
014558 63 00 60 02 
01455C 0A 10 A2 00 		ldi		r1,#81
014560 7C DC FF 00 		sc		r1,LEDS
014564 61 10 00 0C 
014568 02 11 00 1A 		mov     r1,r2				; r1 = TCB pointer
                	
                	;	sw		r1,TCB_mbx[r2]???
                		
                		; setup the stack for the task
                		; Zap the stack memory.
01456C 02 71 00 1A 		mov		r7,r2
014570 7C C1 00 00 		subui   r2,r2,#TCB_Array
014574 15 21 00 00 
014578 18 21 00 06 		divu    r2,r2,#TCB_Size     ; r2 = index number of TCB
01457C 02 21 18 70 		asl		r2,r2,#12			; 4kB stack per task
014580 7C F0 07 00 		addui	r8,r2,#STACKS_Array	; add in stack base
014584 14 81 00 00 
014588 02 24 00 1A 		mov     r2,r8
01458C 14 21 F0 1F 		addui   r2,r2,#4088
014590 E3 23 D0 04 		sw      r2,TCB_StackTop[r7]
014594 E3 23 F0 01 		sw      r2,TCB_r31[r7]
                		
                		; Fill the stack with the ExitTask address. This will cause a return
                		; to the ExitTask routine when the task finishes.
014598 E7 E0 01 00 		push    r1
01459C 67 E1 01 00 		push    r2
0145A0 E7 E1 01 00 		push    r3
0145A4 7C 01 00 00 		ldi		r1,#ExitTask		; r1 = fill value
0145A8 0A 10 B0 8C 
                	.stask6:
0145AC 63 11 00 00 		sw      r1,[r2]
0145B0 15 21 10 00 		subui   r2,r2,#8
0145B4 02 31 10 2C 		cmpu    r3,r2,r8
0145B8 BD 21 FA FF 		bgt     r3,.stask6
0145BC 57 3F 10 00 		pop     r3
0145C0 57 2F 10 00 		pop     r2
0145C4 57 1F 10 00 		pop     r1
                	
0145C8 39 DD FF FF 	    bsr     LockTCB
                	    	
0145CC E0 63 24 04 		sb		r6,TCB_Priority[r7]
0145D0 E0 03 20 04 		sb		r0,TCB_Status[r7]
0145D4 E3 03 F0 04 		sw		r0,TCB_Timeout[r7]
0145D8 E3 53 28 04 		sw		r5,TCB_hJCB[r7]		; save job handle
0145DC 0A 10 A4 00 		ldi		r1,#82
0145E0 7C DC FF 00 		sc		r1,LEDS
0145E4 61 10 00 0C 
0145E8 E3 03 C0 04 		sw		r0,TCB_MbxList[r7]
                	
                		; Insert the task into the ready list
0145EC 82 13 00 1A 		mov     r1,r7
0145F0 39 56 00 00 		bsr		AddTaskToReadyList
0145F4 7C C0 00 00 		sw		r0,tcb_sema       ; unlock TCB semaphore
0145F8 63 00 90 02 
                	stask2:
0145FC 57 8F 10 00 		pop     r8
014600 57 7F 10 00 		pop     r7
014604 57 6F 10 00 		pop     r6
014608 57 5F 10 00 		pop     r5
01460C 57 4F 10 00 		pop     r4
014610 57 3F 10 00 		pop     r3
014614 57 2F 10 00 		pop     r2
014618 57 1F 10 00 		pop     r1
01461C 3B FF 11 00 		rts
stask1:
014620 7C C0 00 00 		sw		r0,freetcb_sema
014624 63 00 60 02 
014628 39 59 02 00 		bsr		kernel_panic
01462C 4E 6F 20 6D 		db		"No more task control blocks available.",0
014630 6F 72 65 20 
014634 74 61 73 6B 
014638 20 63 6F 6E 
01463C 74 72 6F 6C 
014640 20 62 6C 6F 
014644 63 6B 73 20 
014648 61 76 61 69 
01464C 6C 61 62 6C 
014650 65 2E 00    
014653 00 3A F5 FF 		bra		stask2
014657 FF          
                	
                	;------------------------------------------------------------------------------
                	; ExitTask
                	;
                	; This routine is called when the task exits with an rts instruction. OR
                	; it may be invoked with a JMP ExitTask. In either case the task must be
                	; running so it can't be on the timeout list.
                	;------------------------------------------------------------------------------
                	message "ExitTask"
                	ExitTask:
                		; release any aquired resources
                		; - mailboxes
                		; - messages
                	;	hoff
014658 39 CB FF FF 	    bsr     LockTCB
01465C 02 1C 00 1A 	    mov     r1,tr
014660 39 58 00 00 		bsr		RemoveTaskFromReadyList
014664 39 81 00 00 		bsr		RemoveFromTimeoutList
014668 E3 00 20 04 		sw		r0,TCB_Status[r1]				; set task status to TS_NONE
01466C B9 97 D7 FF 		bsr		ReleaseIOFocus
                		; Free up all the mailboxes associated with the task.
                	xtsk7:
014670 E7 E0 01 00 		push    r1
014674 C6 10 C0 04 		lw		r1,TCB_MbxList[r1]
014678 BD 00 08 00 		beq		r1,xtsk6
01467C 39 BD 00 00 		bsr		FreeMbx
014680 57 1F 10 00 		pop     r1
014684 BA FD FF FF 		bra		xtsk7
                	xtsk6:
014688 57 1F 10 00 		pop     r1
01468C 0A 20 AC 00 		ldi		r2,#86
014690 7C DC FF 00 		sc		r2,LEDS
014694 61 20 00 0C 
014698 B9 BF FF FF 		bsr     LockFreeTCB
01469C 7C C0 00 00 		lw		r2,FreeTCB						; add the task control block to the free list
0146A0 46 20 00 01 
0146A4 E3 20 30 04 		sw		r2,TCB_NextFree[r1]
0146A8 7C C0 00 00 		sw		r1,FreeTCB
0146AC 63 10 00 01 
0146B0 7C C0 00 00 		sw		r0,freetcb_sema
0146B4 63 00 60 02 
0146B8 7C C0 00 00 		sw      r0,tcb_sema
0146BC 63 00 90 02 
                		; This loop will eventually be interrupted, the interrupt return will not
                		; return to here.
                	xtsk1:
0146C0 3A 00 00 00 		bra     xtsk1
                	
                	;------------------------------------------------------------------------------
                	; KillTask
                	;
                	; "Kills" a task, removing it from all system lists. If the task has the 
                	; IO focus, the IO focus is switched. Task #0 is immortal and cannot be
                	; killed. Task #1 is immortal and cannot be killed.
                	;
                	; Registers Affected: none
                	; Parameters:
                	;	r1 = task number
                	;------------------------------------------------------------------------------
                	;
                	KillTask:
0146C4 E7 EF 01 00 	    push    lr
0146C8 67 E1 01 00 		push    r2
0146CC 7C C1 00 00 		cmpu    r2,r1,#TCB_Array+TCB_Size  ; BIOS task and IDLE task are immortal
0146D0 96 20 00 06 
0146D4 3D 51 46 00 		ble		r2,kt1
0146D8 FC C3 00 00 		cmpu    r2,r1,#TCB_ArrayEnd-TCB_Size
0146DC 96 20 00 FA 
0146E0 3D 21 40 00 		bgt		r2,kt1
0146E4 82 20 00 1A 		mov     r2,r1
0146E8 C6 10 28 04 		lw		r1,TCB_hJCB[r1]
0146EC B9 88 D7 FF 		bsr		ForceReleaseIOFocus
0146F0 02 11 00 1A 		mov     r1,r2
0146F4 B9 B7 FF FF 		bsr     LockTCB
0146F8 7C 00 00 00 		jsr		RemoveTaskFromReadyList
0146FC 3C F0 91 A4 
014700 7C 00 00 00 		jsr		RemoveFromTimeoutList
014704 3C F0 37 A5 
014708 E0 00 20 04 		sb		r0,TCB_Status[r1]    		; set task status to TS_NONE
                	
                		; Free up all the mailboxes associated with the task.
                	kt7:
01470C E7 E0 01 00 		push    r1
014710 82 20 00 1A 		mov     r2,r1
014714 C6 10 C0 04 		lw		r1,TCB_MbxList[r1]
014718 BD 00 08 00 		beq		r1,kt6
01471C 39 AC 00 00 		bsr		FreeMbx2
014720 57 1F 10 00 		pop     r1
014724 3A FD FF FF 		bra		kt7
                	kt6:
014728 7C C0 00 00 	    sw      r0,tcb_sema
01472C 63 00 90 02 
014730 57 1F 10 00 	    pop     r1
014734 39 AC FF FF 	    bsr     LockFreeTCB
014738 7C C0 00 00 		lw		r2,FreeTCB					; add the task control block to the free list
01473C 46 20 00 01 
014740 E3 20 30 04 		sw		r2,TCB_NextFree[r1]
014744 7C C0 00 00 		sw		r1,FreeTCB
014748 63 10 00 01 
01474C 7C C0 00 00 		sw		r0,freetcb_sema
014750 63 00 60 02 
014754 82 20 30 0C 		cmp     r2,r1,tr                    ; keep running the current task as long as
014758 3D 11 04 00 		bne		r2,kt1						; the task didn't kill itself.
                	.self:
01475C 3A 00 00 00 		bra     .self
                	kt1:
014760 57 2F 10 00 		pop     r2
014764 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	message "DumpTaskList"
                	DumpTaskList:
014768 E7 EF 01 00 	    push    lr
01476C E7 E0 01 00 		push    r1
014770 67 E1 01 00 		push    r2
014774 E7 E1 01 00 		push    r3
014778 67 E2 01 00 		push	r4
01477C 7C 01 00 00 		ldi		r1,#msgTaskList
014780 0A 10 68 90 
014784 39 FA F7 FF 		bsr		DisplayString
014788 0A 30 00 00 		ldi		r3,#0
                	.0001:
                	;    lwar    r4,tcb_sema
                	;    bne     r4,.0001
                	;    swcr    tr,tcb_sema
                	;    mfspr   r4,cr0
                	;    and     r4,r4,#$1000000000
                	;    beq     r4,.0001
                	dtl2:
01478C 7C C0 00 00 		lw		r1,QNdx0[r3]
014790 C6 11 70 00 
014794 82 40 00 1A 		mov		r4,r1
014798 3D 02 3A 00 		beq		r4,dtl1
                	dtl3:
01479C 0A 20 06 00 		ldi	    r2,#3
0147A0 82 11 06 72 		lsr     r1,r3,#3
0147A4 B9 0B F8 FF 		bsr		PRTNUM
0147A8 39 08 F8 FF 		bsr		DisplaySpace
0147AC 02 12 00 1A 		mov		r1,r4
0147B0 39 E7 F7 FF 		bsr		DisplayHalf
0147B4 B9 06 F8 FF 		bsr		DisplaySpace
0147B8 39 06 F8 FF 		bsr		DisplaySpace
0147BC 02 12 00 1A 		mov		r1,r4
0147C0 C0 10 20 04 		lb		r1,TCB_Status[r1]
0147C4 B9 E9 F7 FF 		bsr		DisplayByte
0147C8 39 04 F8 FF 		bsr		DisplaySpace
0147CC 0A 20 06 00 		ldi		r2,#3
0147D0 46 12 10 04 		lw		r1,TCB_PrevRdy[r4]
0147D4 B9 E2 F7 FF 		bsr		DisplayHalf
0147D8 39 02 F8 FF 		bsr		DisplaySpace
0147DC 0A 20 06 00 		ldi		r2,#3
0147E0 46 12 00 04 		lw		r1,TCB_NextRdy[r4]
0147E4 B9 E0 F7 FF 		bsr		DisplayHalf
0147E8 39 00 F8 FF 		bsr		DisplaySpace
0147EC 46 12 F0 04 		lw		r1,TCB_Timeout[r4]
0147F0 B9 DC F7 FF 		bsr		DisplayWord
0147F4 B9 F3 F7 FF 		bsr		CRLF
0147F8 46 42 00 04 		lw		r4,TCB_NextRdy[r4]
0147FC 7C C0 00 00 		lw      r1,QNdx0[r3]
014800 C6 11 70 00 
014804 02 12 02 0C 		cmp		r1,r4,r1
014808 BD 10 CA FF 		bne		r1,dtl3
                	dtl1:
01480C 94 31 10 00 		addui   r3,r3,#8
014810 86 41 80 00 		cmp     r4,r3,#64
014814 3D 42 BC FF 		blt		r4,dtl2
014818 7C C0 00 00 		sw		r0,tcb_sema       ; release semaphore
01481C 63 00 90 02 
014820 57 4F 10 00 		pop		r4
014824 57 3F 10 00 		pop     r3
014828 57 2F 10 00 		pop     r2
01482C 57 1F 10 00 		pop     r1
014830 3B FF 11 00 		rts

                	msgTaskList:
014834 0D 0A 50 72 		db	CR,LF,"Pri Task Stat    Prv     Nxt     Timeout",CR,LF,0
014838 69 20 54 61 
01483C 73 6B 20 53 
014840 74 61 74 20 
014844 20 20 20 50 
014848 72 76 20 20 
01484C 20 20 20 4E 
014850 78 74 20 20 
014854 20 20 20 54 
014858 69 6D 65 6F 
01485C 75 74 0D 0A 
014860 00          
                	
                	
                	;------------------------------------------------------------------------------
                	; r1 = task number
                	; r2 = new priority
                	;------------------------------------------------------------------------------
                	
                	SetTaskPriority:
014861 00 00 00 E7 	    push    lr
014865 EF 01 00    
014868 E7 E1 01 00 		push    r3
01486C B9 88 FF FF 		bsr     LockTCB
014870 C0 30 20 04 		lb		r3,TCB_Status[r1]			    ; if the task is on the ready list
014874 8C 31 30 00 		and		r3,r3,#TS_READY|TS_RUNNING		; then remove it and re-add it.
014878 BD 01 0A 00 		beq		r3,.stp2						; Otherwise just go set the priority field
01487C B9 14 00 00 		bsr		RemoveTaskFromReadyList
014880 E0 30 24 04 		sb		r3,TCB_Priority[r1]
014884 B9 03 00 00 		bsr		AddTaskToReadyList
014888 3A 01 00 00 		bra		.stp3
                	.stp2:
01488C E0 30 24 04 		sb		r3,TCB_Priority[r1]
                	.stp3:
014890 7C C0 00 00 		sw		r0,tcb_sema
014894 63 00 90 02 
014898 57 3F 10 00 		pop     r3
01489C 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; AddTaskToReadyList
                	;
                	; The ready list is a group of eight ready lists, one for each priority
                	; level. Each ready list is organized as a doubly linked list to allow fast
                	; insertions and removals. The list is organized as a ring (or bubble) with
                	; the last entry pointing back to the first. This allows a fast task switch
                	; to the next task. Which task is at the head of the list is maintained
                	; in the variable QNdx for the priority level.
                	;
                	; Registers Affected: none
                	; Parameters:
                	;	r1 = pointer to task control block
                	; Returns:
                	;	none
                	;------------------------------------------------------------------------------
                	message "AddToReadyList"
                	AddTaskToReadyList:
0148A0 67 E1 01 00 	    push    r2
0148A4 E7 E1 01 00 	    push    r3
0148A8 67 E2 01 00 	    push    r4
0148AC 0A 20 20 00 		ldi     r2,#TS_READY
0148B0 E0 20 20 04 		sb		r2,TCB_Status[r1]
0148B4 E3 00 00 04 		sw		r0,TCB_NextRdy[r1]
0148B8 E3 00 10 04 		sw		r0,TCB_PrevRdy[r1]
0148BC C0 30 24 04 		lb		r3,TCB_Priority[r1]
0148C0 86 41 10 00 		cmp		r4,r3,#8
0148C4 3D 42 04 00 		blt		r4,arl1
0148C8 0A 30 0E 00 		ldi		r3,#PRI_LOWEST
                	arl1:
0148CC 82 31 06 70 	    asl     r3,r3,#3
0148D0 7C C0 00 00 		lw		r2,QNdx0[r3]
0148D4 C6 21 70 00 
0148D8 3D 01 14 00 		beq		r2,arl5
0148DC 46 31 10 04 		lw		r3,TCB_PrevRdy[r2]
0148E0 E3 21 00 04 		sw		r2,TCB_NextRdy[r3]
0148E4 E3 30 10 04 		sw		r3,TCB_PrevRdy[r1]
0148E8 63 11 10 04 		sw		r1,TCB_PrevRdy[r2]
0148EC E3 20 00 04 		sw		r2,TCB_NextRdy[r1]
0148F0 57 4F 10 00 		pop     r4
0148F4 57 3F 10 00 		pop     r3
0148F8 57 2F 10 00 		pop     r2
0148FC 37 FF 01 00 		rtl

                		; Here the ready list was empty, so add at head
                	arl5:
014900 7C C0 00 00 		sw		r1,QNdx0[r3]
014904 E3 11 70 00 
014908 E3 10 00 04 		sw		r1,TCB_NextRdy[r1]
01490C E3 10 10 04 		sw		r1,TCB_PrevRdy[r1]
014910 57 4F 10 00 		pop     r4
014914 57 3F 10 00 		pop     r3
014918 57 2F 10 00 		pop     r2
01491C 37 FF 01 00 		rtl
	
                	
                	;------------------------------------------------------------------------------
                	; RemoveTaskFromReadyList
                	;
                	; This subroutine removes a task from the ready list.
                	;
                	; Registers Affected: none
                	; Parameters:
                	;	r1 = pointer to task control block
                	; Returns:
                	;   r1 = pointer to task control block
                	;------------------------------------------------------------------------------
                	message "RemoveFromReadyList"
                	RemoveTaskFromReadyList:
014920 67 E1 01 00 	    push    r2
014924 E7 E1 01 00 	    push    r3
014928 67 E2 01 00 		push	r4
01492C E7 E2 01 00 		push	r5
                	
014930 C0 30 20 04 		lb		r3,TCB_Status[r1]	; is the task on the ready list ?
014934 8C 41 30 00 		and		r4,r3,#TS_READY|TS_RUNNING
014938 3D 02 2A 00 		beq		r4,rfr2
01493C 8C 31 CE FF 		and		r3,r3,#~(TS_READY|TS_RUNNING)
	sb		r3,TCB_Status[r1]	; task status no longer running or ready
014940 E0 30 20 04 
014944 C6 40 00 04 		lw		r4,TCB_NextRdy[r1]	; Get previous and next fields.
014948 C6 50 10 04 		lw		r5,TCB_PrevRdy[r1]
01494C E3 42 00 04 		sw		r4,TCB_NextRdy[r5]
014950 63 52 10 04 		sw		r5,TCB_PrevRdy[r4]
014954 C0 30 24 04 		lb		r3,TCB_Priority[r1]
014958 82 31 06 70 		asl     r3,r3,#3
01495C 7C C0 00 00 		lw      r5,QNdx0[r3]
014960 C6 51 70 00 
014964 82 50 0A 0C 		cmp		r5,r1,r5			; Are we removing the QNdx task ?
014968 BD 12 12 00 		bne		r5,rfr2
01496C 7C C0 00 00 		sw		r4,QNdx0[r3]
014970 E3 41 70 00 
                		; Now we test for the case where the task being removed was the only one
                		; on the ready list of that priority level. We can tell because the
                		; NxtRdy would point to the task itself.
014974 02 52 02 0C 		cmp		r5,r4,r1				
014978 BD 12 0A 00 		bne		r5,rfr2
01497C 7C C0 00 00 		sw		r0,QNdx0[r3]        ; Make QNdx NULL
014980 E3 01 70 00 
014984 E3 00 00 04 		sw		r0,TCB_NextRdy[r1]
014988 E3 00 10 04 		sw		r0,TCB_PrevRdy[r1]
                	rfr2:
01498C 57 5F 10 00 		pop		r5
014990 57 4F 10 00 		pop		r4
014994 57 3F 10 00 		pop     r3
014998 57 2F 10 00 		pop     r2
01499C 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; AddToTimeoutList
                	; AddToTimeoutList adds a task to the timeout list. The task is placed in the
                	; list depending on it's timeout value.
                	;
                	; Registers Affected: none
                	; Parameters:
                	;	r1 = task
                	;	r2 = timeout value
                	;------------------------------------------------------------------------------
                	message "AddToTimeoutList"
                	AddToTimeoutList:
0149A0 67 E1 01 00 		push    r2
0149A4 E7 E1 01 00 		push    r3
0149A8 67 E2 01 00 		push	r4
0149AC E7 E2 01 00 		push	r5
                	
0149B0 0A 50 00 00 	    ldi     r5,#0
0149B4 E3 00 50 04 		sw		r0,TCB_NextTo[r1]   ; these fields should already be NULL
0149B8 E3 00 60 04 		sw		r0,TCB_PrevTo[r1]
0149BC 7C C0 00 00 		lw		r4,TimeoutList		; are there any tasks on the timeout list ?
0149C0 46 40 10 01 
0149C4 3D 02 3A 00 		beq		r4,attl_add_at_head	; If not, update head of list
                	attl_check_next:
0149C8 46 32 F0 04 	    lw      r3,TCB_Timeout[r4]            
0149CC 02 21 06 2A 		subu	r2,r2,r3	        ; is this timeout > next
0149D0 3D 41 12 00 		blt		r2,attl_insert_before
0149D4 02 52 00 1A 		mov		r5,r4
0149D8 46 42 50 04 		lw		r4,TCB_NextTo[r4]
0149DC 3D 12 F6 FF 		bne		r4,attl_check_next
                	
                		; timeout of a greater value. So we add the task to the end of the list.
                	attl_add_at_end:
                		; Here we scanned until the end of the timeout list and didn't find a 
0149E0 E3 00 50 04 		sw		r0,TCB_NextTo[r1]		; 
0149E4 E3 12 50 04 		sw		r1,TCB_NextTo[r5]
0149E8 E3 50 60 04 		sw		r5,TCB_PrevTo[r1]
0149EC E3 20 F0 04 		sw		r2,TCB_Timeout[r1]
0149F0 BA 0B 00 00 		bra		attl_exit
                	
                	attl_insert_before:
0149F4 BD 02 0C 00 		beq		r5,attl_insert_before_head
0149F8 E3 40 50 04 		sw		r4,TCB_NextTo[r1]	; next on list goes after this task
0149FC E3 50 60 04 		sw		r5,TCB_PrevTo[r1]	; set previous link
014A00 E3 12 50 04 		sw		r1,TCB_NextTo[r5]
014A04 63 12 60 04 		sw		r1,TCB_PrevTo[r4]
014A08 3A 03 00 00 		bra		attl_adjust_timeout
                	
                		; Here there is no previous entry in the timeout list
                		; Add at start
                	attl_insert_before_head:
014A0C 63 12 60 04 		sw		r1,TCB_PrevTo[r4]
014A10 E3 00 60 04 		sw		r0,TCB_PrevTo[r1]	;
014A14 E3 40 50 04 		sw		r4,TCB_NextTo[r1]
014A18 7C C0 00 00 		sw		r1,TimeoutList			; update the head pointer
014A1C 63 10 10 01 
                	attl_adjust_timeout:
014A20 02 21 06 28 		addu	r2,r2,r3	       ; get back timeout
014A24 E3 20 F0 04 		sw		r2,TCB_Timeout[r1]
014A28 46 52 F0 04 		lw		r5,TCB_Timeout[r4]	; adjust the timeout of the next task
014A2C 82 52 04 2A 		subu	r5,r5,r2
014A30 63 52 F0 04 		sw		r5,TCB_Timeout[r4]
014A34 3A 03 00 00 		bra		attl_exit
                	
                		; Here there were no tasks on the timeout list, so we add at the
                		; head of the list.
                	attl_add_at_head:
014A38 7C C0 00 00 		sw		r1,TimeoutList		; set the head of the timeout list
014A3C 63 10 10 01 
014A40 E3 20 F0 04 		sw		r2,TCB_Timeout[r1]
                		; flag no more entries in timeout list
014A44 E3 00 50 04 		sw		r0,TCB_NextTo[r1]	; no next entries
014A48 E3 00 60 04 		sw		r0,TCB_PrevTo[r1]	; and no prev entries
                	attl_exit:
014A4C C0 20 20 04 		lb		r2,TCB_Status[r1]	; set the task's status as timing out
014A50 0D 21 02 00 		or		r2,r2,#TS_TIMEOUT
014A54 E0 20 20 04 		sb		r2,TCB_Status[r1]
014A58 57 5F 10 00 		pop		r5
014A5C 57 4F 10 00 		pop		r4
014A60 57 3F 10 00 		pop     r3
014A64 57 2F 10 00 		pop     r2
014A68 37 FF 01 00 		rtl
	
                	;------------------------------------------------------------------------------
                	; RemoveFromTimeoutList
                	;
                	; This routine is called when a task is killed. The task may need to be
                	; removed from the middle of the timeout list.
                	;
                	; On entry: the timeout list semaphore must be already set.
                	; Registers Affected: none
                	; Parameters:
                	;	 r1 = pointer to task control block
                	;------------------------------------------------------------------------------
                	
                	RemoveFromTimeoutList:
014A6C 67 E1 01 00 		push    r2
014A70 E7 E1 01 00 		push    r3
014A74 67 E2 01 00 		push	r4
014A78 E7 E2 01 00 		push	r5
                	
014A7C C0 40 20 04 		lb		r4,TCB_Status[r1]		; Is the task even on the timeout list ?
014A80 0C 42 02 00 		and		r4,r4,#TS_TIMEOUT
014A84 3D 02 40 00 		beq		r4,rftl_not_on_list
014A88 7C C0 00 00 		lw      r5,TimeoutList
014A8C 46 50 10 01 
014A90 82 40 0A 0C 		cmp		r4,r1,r5         		; Are we removing the head of the list ?
014A94 3D 02 18 00 		beq		r4,rftl_remove_from_head
014A98 C6 40 60 04 		lw		r4,TCB_PrevTo[r1]		; adjust the links of the next and previous
014A9C 3D 02 26 00 		beq		r4,rftl_empty_list		; no previous link - list corrupt?
014AA0 C6 50 50 04 		lw		r5,TCB_NextTo[r1]		; tasks on the list to point around the task
014AA4 63 52 50 04 		sw		r5,TCB_NextTo[r4]
014AA8 BD 02 20 00 		beq		r5,rftl_empty_list
014AAC E3 42 60 04 		sw		r4,TCB_PrevTo[r5]
014AB0 C6 20 F0 04 		lw		r2,TCB_Timeout[r1]		; update the timeout of the next on list
014AB4 C6 32 F0 04 		lw      r3,TCB_Timeout[r5]
014AB8 02 21 06 08 		add		r2,r2,r3            	; with any remaining timeout in the task
014ABC E3 22 F0 04 		sw		r2,TCB_Timeout[r5]		; removed from the list
014AC0 3A 05 00 00 		bra		rftl_empty_list
                	
                		; Update the head of the list.
                	rftl_remove_from_head:
014AC4 C6 50 50 04 		lw		r5,TCB_NextTo[r1]
014AC8 7C C0 00 00 		sw		r5,TimeoutList			; store next field into list head
014ACC 63 50 10 01 
014AD0 BD 02 0C 00 		beq		r5,rftl_empty_list
014AD4 C6 40 F0 04 		lw		r4,TCB_Timeout[r1]		; add any remaining timeout to the timeout
014AD8 C6 32 F0 04 		lw      r3,TCB_Timeout[r5]
014ADC 02 42 06 08 		add		r4,r4,r3            	; of the next task on the list.
014AE0 E3 42 F0 04 		sw		r4,TCB_Timeout[r5]
014AE4 E3 02 60 04 		sw		r0,TCB_PrevTo[r5]       ; there is no previous item to the head
                		
                		; Here there is no previous or next items in the list, so the list
                		; will be empty once this task is removed from it.
                	rftl_empty_list:
014AE8 82 20 00 1A 		mov     r2,r1
014AEC 40 31 20 04 		lb		r3,TCB_Status[r2]	; clear timeout status (bit #0)
014AF0 8C 31 FC 01 		and     r3,r3,#$FE
014AF4 60 31 20 04 		sb      r3,TCB_Status[r2]
014AF8 63 01 50 04 		sw		r0,TCB_NextTo[r2]	; make sure the next and prev fields indicate	
014AFC 63 01 60 04 		sw	    r0,TCB_PrevTo[r2]   ; the task is not on a list.
014B00 02 11 00 1A 		mov     r1,r2
                	rftl_not_on_list:
014B04 57 5F 10 00 		pop		r5
014B08 57 4F 10 00 		pop		r4
014B0C 57 3F 10 00 		pop     r3
014B10 57 2F 10 00 		pop     r2
                	rftl_not_on_list2:
014B14 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; PopTimeoutList
                	;
                	; This subroutine is called from within the timer ISR when the task's 
                	; timeout expires. It's always the head of the list that's being removed in
                	; the timer ISR so the removal from the timeout list is optimized. We know
                	; the timeout expired, so the amount of time to add to the next task is zero.
                	;
                	; Registers Affected: 
                	; Parameters:
                	;	r2: head of timeout list
                	; Returns:
                	;	r1 = task id of task popped from timeout list
                	;------------------------------------------------------------------------------
                	
                	PopTimeoutList:
014B18 46 11 50 04 		lw		r1,TCB_NextTo[r2]
014B1C 7C C0 00 00 		sw		r1,TimeoutList  ; store next field into list head
014B20 63 10 10 01 
014B24 BD 00 04 00 		beq		r1,ptl1
014B28 E3 00 60 04 		sw		r0,TCB_PrevTo[r1]; previous link = NULL
                	ptl1:
014B2C 40 11 20 04 	    lb      r1,TCB_Status[r2]
014B30 8C 10 FC 01 	    and     r1,r1,#$FE       ; clear timeout status
014B34 60 11 20 04 	    sb      r1,TCB_Status[r2]
014B38 63 01 50 04 		sw		r0,TCB_NextTo[r2]	; make sure the next and prev fields indicate
014B3C 63 01 60 04 		sw		r0,TCB_PrevTo[r2]		; the task is not on a list.
014B40 02 11 00 1A 		mov     r1,r2
014B44 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	; Sleep
                	;
                	; Put the currently running task to sleep for a specified time.
                	;
                	; Registers Affected: none
                	; Parameters:
                	;	r1 = time duration in jiffies (1/60 second).
                	; Returns: none
                	;------------------------------------------------------------------------------
                	message "sleep"
                	
                	Sleep:
014B48 E7 EF 01 00 	    push    lr
014B4C E7 E0 01 00 	    push    r1
014B50 67 E1 01 00 	    push    r2
014B54 82 20 00 1A 		mov     r2,r1
014B58 39 2B FF FF 		bsr     LockTCB
014B5C 02 1C 00 1A 		mov		r1,tr
014B60 39 B8 FF FF 		bsr		RemoveTaskFromReadyList
014B64 B9 C7 FF FF 		bsr		AddToTimeoutList	; The scheduler will be returning to this
014B68 7C C0 00 00 		sw		r0,tcb_sema
014B6C 63 00 90 02 
014B70 38 0F 04 80 		int		#2				; task eventually, once the timeout expires,
014B74 57 2F 10 00 		pop     r2
014B78 57 1F 10 00 		pop     r1
014B7C 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; Allocate a mailbox
                	; Parameters:
                	;	r1 = pointer to place to store handle
                	; Returns:
                	;	r1 = E_Ok	means mailbox allocated properly
                	;	r1 = E_Arg	means a NULL pointer was passed in r1
                	;	r1 = E_NoMoreMbx	means no more mailboxes were available
                	;	zf is set if everything is ok, otherwise zf is clear
                	;------------------------------------------------------------------------------
                	;
                	AllocMbx:
014B80 BD 00 60 00 		beq		r1,ambx_bad_ptr
014B84 E7 EF 01 00 		push    lr
014B88 67 E1 01 00 		push    r2
014B8C E7 E1 01 00 		push    r3
014B90 67 E2 01 00 		push	r4
                		ld		r4,r1			; r4 = pointer to returned handle
014B94 B9 15 FF FF 		bsr     LockFreeMBX
014B98 7C C0 00 00 		lw		r1,FreeMbxHandle			; Get mailbox off of free mailbox list
014B9C 46 10 30 01 
014BA0 63 12 00 00 		sw		r1,[r4]			; store off the mailbox number
014BA4 BD 00 52 00 		beq		r1,ambx_no_mbxs
014BA8 C6 20 00 00 		lw		r2,MBX_LINK[r1]		; and update the head of the list
014BAC 7C C0 00 00 		sw		r2,FreeMbxHandle
014BB0 63 20 30 01 
014BB4 7C C0 00 00 		dec		nMailbox		; decrement number of available mailboxes
014BB8 64 F0 41 01 
014BBC 7C C0 00 00 		sw		r0,freembx_sema
014BC0 63 00 70 02 
014BC4 B9 1D FF FF 		bsr     LockTCB
014BC8 02 3C 00 1A 		mov		r3,tr           ; Add the mailbox to the list of mailboxes
014BCC 46 2C C0 04 		lw		r2,TCB_MbxList[tr]	; managed by the task.
014BD0 E3 20 00 00 		sw		r2,MBX_LINK[r1]
014BD4 63 1C C0 04 		sw		r1,TCB_MbxList[tr]
014BD8 82 20 00 1A 		mov     r2,r1
014BDC 46 1C 28 04 		lw		r1,TCB_hJCB[tr]
014BE0 7C C0 00 00 		sw		r0,tcb_sema
014BE4 63 00 90 02 
                	
014BE8 39 12 FF FF 		bsr     LockMBX
014BEC 63 81 A1 00 		sw		tr,MBX_OWNER[r2]
014BF0 63 01 10 00 		sw		r0,MBX_TQ_HEAD[r2] ; initialize the head and tail of the queues
014BF4 63 01 30 00 		sw		r0,MBX_TQ_TAIL[r2]
014BF8 63 01 40 00 		sw		r0,MBX_MQ_HEAD[r2]
014BFC 63 01 50 00 		sw		r0,MBX_MQ_TAIL[r2]
014C00 63 01 60 00 		sw		r0,MBX_TQ_COUNT[r2]	; initialize counts to zero
014C04 63 01 80 00 		sw		r0,MBX_MQ_COUNT[r2]
014C08 63 01 90 00 		sw		r0,MBX_MQ_MISSED[r2]
014C0C 0A 10 10 00 		ldi		r1,#8				; set the max queue size
014C10 63 11 70 00 		sw		r1,MBX_MQ_SIZE[r2]	; and
014C14 7C 00 00 00 		ldi		r1,#MQS_NEWEST		; queueing strategy
014C18 7C 00 00 00 
014C1C 0A 10 A6 06 
014C20 63 11 B0 00 		sw		r1,MBX_MQ_STRATEGY[r2]
014C24 7C C0 00 00 		sw		r0,mbx_sema
014C28 63 00 D0 02 
014C2C 57 4F 10 00 		pop		r4
014C30 57 3F 10 00 		pop     r3
014C34 57 2F 10 00 		pop     r2
014C38 0A 10 00 00 		ldi		r1,#E_Ok
014C3C 3B FF 11 00 		rts
ambx_bad_ptr:
014C40 0A 10 02 00 		ldi		r1,#E_Arg
014C44 37 FF 01 00 		rtl
ambx_no_mbxs:
014C48 7C C0 00 00 		sw		r0,freembx_sema
014C4C 63 00 70 02 
014C50 57 4F 10 00 		pop		r4
014C54 57 3F 10 00 		pop     r3
014C58 57 2F 10 00 		pop     r2
014C5C 0A 10 80 00 		ldi		r1,#E_NoMoreMbx
014C60 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; Free up a mailbox.
                	;	This function frees a mailbox from the currently running task. It may be
                	; called by ExitTask().
                	;
                	; Parameters:
                	;	r1 = mailbox handle
                	;------------------------------------------------------------------------------
                	
                	FreeMbx:
014C64 E7 EF 01 00 	    push    lr
014C68 67 E1 01 00 		push    r2
014C6C 02 2C 00 1A 		mov     r2,tr
014C70 B9 01 00 00 		bsr		FreeMbx2
014C74 57 2F 10 00 		pop     r2
014C78 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; Free up a mailbox.
                	;	This function dequeues any messages from the mailbox and adds the messages
                	; back to the free message pool. The function also dequeues any threads from
                	; the mailbox.
                	;	Called from KillTask() and FreeMbx().
                	;
                	; Parameters:
                	;	r1 = mailbox handle
                	;	r2 = task handle
                	; Returns:
                	;	r1 = E_Ok	if everything ok
                	;	r1 = E_Arg	if a bad handle is passed
                	;------------------------------------------------------------------------------
                	
                	FreeMbx2:
014C7C E7 EF 01 00 	    push    lr
014C80 67 E1 01 00 		push    r2
014C84 E7 E1 01 00 		push    r3
014C88 67 E2 01 00 		push    r4
014C8C B9 FD FE FF 		bsr     LockMBX
                	
                		; Dequeue messages from mailbox and add them back to the free message list.
                	fmbx5:
014C90 E7 E0 01 00 		push    r1
014C94 39 43 00 00 		bsr		DequeueMsgFromMbx
014C98 BD 00 1A 00 		beq		r1,fmbx3
014C9C 39 F8 FE FF 		bsr     LockFreeMSG
014CA0 67 E1 01 00 		push    r2
014CA4 7C C0 00 00 		lw		r2,FreeMsg
014CA8 46 20 50 01 
014CAC E3 20 00 00 		sw		r2,MSG_LINK[r1]
014CB0 7C C0 00 00 		sw		r1,FreeMsg
014CB4 63 10 50 01 
014CB8 7C C0 00 00 		sw		r0,freemsg_sema
014CBC 63 00 80 02 
014CC0 57 2F 10 00 		pop     r2
014CC4 57 1F 10 00 		pop     r1
014CC8 3A F9 FF FF 		bra		fmbx5
                	fmbx3:
014CCC 57 1F 10 00 		pop     r1
                	
                		; Dequeue threads from mailbox.
                	fmbx6:
014CD0 E7 E0 01 00 		push    r1
014CD4 B9 55 00 00 		bsr		DequeueThreadFromMbx2
014CD8 BD 00 06 00 		beq		r1,fmbx7
014CDC 57 1F 10 00 		pop     r1
014CE0 3A FE FF FF 		bra		fmbx6
                	fmbx7:
014CE4 57 1F 10 00 		pop     r1
                	
                		; Remove mailbox from TCB list
014CE8 46 31 C0 04 		lw		r3,TCB_MbxList[r2]
014CEC 67 E1 01 00 		push    r2
014CF0 0A 20 FE FF 		ldi		r2,#-1
                	fmbx10:
014CF4 82 40 06 0C 		cmp		r4,r1,r3
014CF8 3D 02 0C 00 		beq		r4,fmbx9
014CFC 82 21 00 1A 		mov     r2,r3
014D00 C6 31 00 00 		lw		r3,MBX_LINK[r3]
014D04 BD 11 F8 FF 		bne		r3,fmbx10
                		; ?The mailbox was not in the list managed by the task.
014D08 57 2F 10 00 		pop     r2
014D0C BA 08 00 00 		bra		fmbx2
                	fmbx9:
014D10 3D 01 0A 00 		beq		r2,fmbx11
014D14 C6 31 00 00 		lw		r3,MBX_LINK[r3]
014D18 63 31 00 00 		sw		r3,MBX_LINK[r2]
014D1C 57 2F 10 00 		pop     r2
014D20 3A 02 00 00 		bra		fmbx12
                	fmbx11:
                		; No prior mailbox in list, update head
014D24 C6 30 00 00 		lw		r3,MBX_LINK[r1]
014D28 57 2F 10 00 		pop     r2
014D2C 63 31 C0 04 		sw		r3,TCB_MbxList[r2]
                	
                	fmbx12:
                		; Add mailbox back to mailbox pool
014D30 39 E2 FE FF 		bsr     LockFreeMBX
014D34 7C C0 00 00 		lw		r2,FreeMbxHandle
014D38 46 20 30 01 
014D3C E3 20 00 00 		sw		r2,MBX_LINK[r1]
014D40 7C C0 00 00 		sw		r1,FreeMbxHandle
014D44 63 10 30 01 
014D48 7C C0 00 00 		sw		r0,freembx_sema
014D4C 63 00 70 02 
                	fmbx2:
014D50 7C C0 00 00 		sw		r0,mbx_sema
014D54 63 00 D0 02 
014D58 57 4F 10 00 		pop     r4
014D5C 57 3F 10 00 		pop     r3
014D60 57 2F 10 00 		pop     r2
014D64 0A 10 00 00 		ldi		r1,#E_Ok
014D68 3B FF 11 00 		rts
fmbx1:
014D6C 0A 10 02 00 		ldi		r1,#E_Arg
014D70 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; Queue a message at a mailbox.
                	; On entry the mailbox semaphore is already activated.
                	;
                	; Parameters:
                	;	r1 = message
                	;	r2 = mailbox
                	;------------------------------------------------------------------------------
                	
                	QueueMsgAtMbx:
014D74 BD 00 52 00 		beq		r1,qmam_bad_msg
014D78 E7 EF 01 00 		push    lr
014D7C E7 E0 01 00 		push    r1
014D80 67 E1 01 00 		push    r2
014D84 E7 E1 01 00 		push    r3
014D88 67 E2 01 00 		push	r4
014D8C 46 41 B0 00 		lw		r4,MBX_MQ_STRATEGY[r2]
014D90 7C 00 00 00 		cmp		r3,r4,#MQS_UNLIMITED
014D94 7C 00 00 00 
014D98 06 32 C4 06 
014D9C BD 01 26 00 		beq		r3,qmam_unlimited
014DA0 7C 00 00 00 		cmp		r3,r4,#MQS_NEWEST
014DA4 7C 00 00 00 
014DA8 06 32 A6 06 
014DAC BD 01 38 00 		beq		r3,qmam_newest
014DB0 7C 00 00 00 		cmp		r3,r4,#MQS_OLDEST
014DB4 7C 00 00 00 
014DB8 06 32 CA 06 
014DBC BD 01 6E 00 		beq		r3,qmam_oldest
014DC0 39 66 01 00 		bsr		kernel_panic
014DC4 49 6C 6C 65 		db		"Illegal message queue strategy",0
014DC8 67 61 6C 20 
014DCC 6D 65 73 73 
014DD0 61 67 65 20 
014DD4 71 75 65 75 
014DD8 65 20 73 74 
014DDC 72 61 74 65 
014DE0 67 79 00    
014DE3 00 BA 0E 00 		bra		qmam8
014DE7 00          
                		; Here we assumed "unlimited" message storage. Just add the new message at
                		; the tail of the queue.
                	qmam_unlimited:
014DE8 46 31 50 00 		lw		r3,MBX_MQ_TAIL[r2]
014DEC BD 01 06 00 		beq		r3,qmam_add_at_head
014DF0 E3 11 00 00 		sw		r1,MSG_LINK[r3]
014DF4 3A 01 00 00 		bra		qmam2
                	qmam_add_at_head:
014DF8 63 11 40 00 		sw		r1,MBX_MQ_HEAD[r2]
                	qmam2:
014DFC 63 11 50 00 		sw		r1,MBX_MQ_TAIL[r2]
                	qmam6:
014E00 64 11 80 00 		inc		MBX_MQ_COUNT[r2]		; increase the queued message count
	sw		r0,MSG_LINK[r1]
014E04 57 4F 10 00 		pop		r4
014E08 57 3F 10 00 		pop     r3
014E0C 57 2F 10 00 		pop     r2
014E10 57 1F 10 00 		pop     r1
014E14 3B FF 11 00 		rts
qmam_bad_msg:
014E18 37 FF 01 00 		rtl
	; Here we are queueing a limited number of messages. As new messages are
                		; added at the tail of the queue, messages drop off the head of the queue.
                	qmam_newest:
014E1C 46 31 50 00 		lw		r3,MBX_MQ_TAIL[r2]
014E20 BD 01 06 00 		beq		r3,qmam3
014E24 E3 11 00 00 		sw		r1,MSG_LINK[r3]
014E28 3A 01 00 00 		bra		qmam4
                	qmam3:
014E2C 63 11 40 00 		sw		r1,MBX_MQ_HEAD[r2]
                	qmam4:
014E30 63 11 50 00 		sw		r1,MBX_MQ_TAIL[r2]
014E34 46 31 80 00 		lw		r3,MBX_MQ_COUNT[r2]
014E38 94 31 02 00 		addui   r3,r3,#1
014E3C 46 41 70 00 		lw      r4,MBX_MQ_SIZE[r2]
014E40 82 31 08 2C 		cmpu    r3,r3,r4
014E44 BD 51 DE FF 		ble		r3,qmam6
014E48 E3 00 00 00 		sw		r0,MSG_LINK[r1]
                		; Remove the oldest message which is the one at the head of the mailbox queue.
                		; Add the message back to the pool of free messages.
014E4C 46 11 40 00 		lw		r1,MBX_MQ_HEAD[r2]
014E50 C6 30 00 00 		lw		r3,MSG_LINK[r1]		; move next in queue
014E54 63 31 40 00 		sw		r3,MBX_MQ_HEAD[r2]	; to head of list
                	qmam8:
014E58 64 11 90 00 		inc		MBX_MQ_MISSED[r2]
qmam1:
014E5C 39 C0 FE FF 	    bsr     LockFreeMSG
014E60 7C C0 00 00 		lw		r3,FreeMsg				; put old message back into free message list
014E64 46 30 50 01 
014E68 E3 30 00 00 		sw		r3,MSG_LINK[r1]
014E6C 7C C0 00 00 		sw		r1,FreeMsg
014E70 63 10 50 01 
014E74 7C C0 00 00 		inc		nMsgBlk
014E78 64 10 60 01 
014E7C 7C C0 00 00 		sw		r0,freemsg_sema
014E80 63 00 80 02 
                		;GoReschedule
014E84 57 4F 10 00 		pop		r4
014E88 57 3F 10 00 		pop     r3
014E8C 57 2F 10 00 		pop     r2
014E90 57 1F 10 00 		pop     r1
014E94 3B FF 11 00 		rts
	; Here we are buffering the oldest messages. So if there are too many messages
                		; in the queue already, then the queue doesn't change and the new message is
                		; lost.
                	qmam_oldest:
014E98 46 31 80 00 		lw		r3,MBX_MQ_COUNT[r2]		; Check if the queue is full
014E9C 46 41 70 00 		lw      r4,MBX_MQ_SIZE[r2]
014EA0 82 31 08 2C 		cmpu	r3,r3,r4
014EA4 BD 31 DA FF 		bge		r3,qmam8			; If the queue is full, then lose the current message
014EA8 3A E8 FF FF 		bra		qmam_unlimited		; Otherwise add message to queue
                	
                	;------------------------------------------------------------------------------
                	; Dequeue a message from a mailbox.
                	;
                	; Returns
                	;	r1 = message pointer (NULL if there are no messages)
                	;------------------------------------------------------------------------------
                	
                	DequeueMsgFromMbx:
014EAC 67 E1 01 00 	    push    r2
014EB0 E7 E1 01 00 	    push    r3
014EB4 82 20 00 1A 		mov     r2,r1				; x = mailbox index
014EB8 46 11 80 00 		lw		r1,MBX_MQ_COUNT[r2]		; are there any messages available ?
014EBC BD 00 1A 00 		beq		r1,dmfm3
014EC0 95 10 02 00 		subui   r1,r1,#1
014EC4 63 11 80 00 		sw		r1,MBX_MQ_COUNT[r2]		; update the message count
014EC8 46 11 40 00 		lw		r1,MBX_MQ_HEAD[r2]		; Get the head of the list, this should not be NULL
014ECC BD 00 12 00 		beq		r1,dmfm3			; since the message count > 0
014ED0 C6 30 00 00 		lw		r3,MSG_LINK[r1]		; get the link to the next message
014ED4 63 31 40 00 		sw		r3,MBX_MQ_HEAD[r2]		; update the head of the list
014ED8 BD 11 04 00 		bne		r3,dmfm2			; if there was no more messages then update the
014EDC 63 31 50 00 		sw		r3,MBX_MQ_TAIL[r2]	; tail of the list as well.
                	dmfm2:
014EE0 E3 10 00 00 		sw		r1,MSG_LINK[r1]		; point the link to the message itself to indicate it's dequeued
                	dmfm1:
014EE4 57 3F 10 00 	    pop     r3
014EE8 57 2F 10 00 	    pop     r2
014EEC 3B FF 11 00 		rts
dmfm3:
014EF0 57 3F 10 00 	    pop     r3
014EF4 57 2F 10 00 	    pop     r2
014EF8 0A 10 00 00 		ldi		r1,#0
014EFC 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; Parameters:
                	;	r1 = mailbox handle
                	; Returns:
                	;	r1 = E_arg		means pointer is invalid
                	;	r1 = E_NoThread	means no thread was queued at the mailbox
                	;	r2 = thead handle
                	;------------------------------------------------------------------------------
                	
                	DequeueThreadFromMbx:
014F00 67 E2 01 00 		push	r4
014F04 C6 40 10 00 		lw		r4,MBX_TQ_HEAD[r1]
014F08 3D 12 0A 00 		bne		r4,dtfm2
014F0C 57 4F 10 00 		pop		r4
014F10 0A 20 00 00 		ldi		r2,#0
014F14 0A 10 0C 00 		ldi		r1,#E_NoThread
014F18 37 FF 01 00 		rtl
dtfm2:
014F1C E7 E2 01 00 		push	r5
014F20 E4 F0 61 00 		dec		MBX_TQ_COUNT[r1]
	mov		r2,r4
014F24 46 42 70 04 		lw		r4,TCB_mbq_next[r4]
014F28 E3 40 10 00 		sw		r4,MBX_TQ_HEAD[r1]
014F2C 3D 02 06 00 		beq		r4,dtfm3
014F30 63 02 80 04 			sw		r0,TCB_mbq_prev[r4]
014F34 3A 01 00 00 			bra		dtfm4
                	dtfm3:
014F38 E3 00 30 00 			sw		r0,MBX_TQ_TAIL[r1]
                	dtfm4:
014F3C 02 51 00 1A 		mov		r5,r2
014F40 C0 12 20 04 		lb		r1,TCB_Status[r5]
014F44 8C 10 02 00 		and		r1,r1,#TS_TIMEOUT
014F48 BD 00 0C 00 		beq		r1,dtfm5
014F4C 82 12 00 1A 		mov		r1,r5
014F50 E7 EF 01 00 		push    lr
014F54 7C 00 00 00 		jsr		RemoveFromTimeoutList
014F58 3C F0 37 A5 
014F5C 57 FF 11 00 		pop     lr
                	dtfm5:
014F60 E3 02 70 04 		sw		r0,TCB_mbq_next[r5]
014F64 E3 02 80 04 		sw		r0,TCB_mbq_prev[r5]
014F68 E3 02 B0 04 		sw		r0,TCB_hWaitMbx[r5]
014F6C E0 02 20 04 		sb		r0,TCB_Status[r5]		; set task status = TS_NONE
014F70 57 5F 10 00 		pop		r5
014F74 57 4F 10 00 		pop		r4
014F78 0A 10 00 00 		ldi		r1,#E_Ok
014F7C 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	;	This function is called from FreeMbx(). It dequeues threads from the
                	; mailbox without removing the thread from the timeout list. The thread will
                	; then timeout waiting for a message that can never be delivered.
                	;
                	; Parameters:
                	;	r1 = mailbox handle
                	; Returns:
                	;	r1 = E_arg		means pointer is invalid
                	;	r1 = E_NoThread	means no thread was queued at the mailbox
                	;	r2 = thead handle
                	;------------------------------------------------------------------------------
                	
                	DequeueThreadFromMbx2:
014F80 67 E2 01 00 		push	r4
014F84 C6 40 10 00 		lw		r4,MBX_TQ_HEAD[r1]
014F88 3D 12 0A 00 		bne		r4,dtfm2a
014F8C 57 4F 10 00 		pop		r4
014F90 0A 20 00 00 		ldi		r2,#0
014F94 0A 10 0C 00 		ldi		r1,#E_NoThread
014F98 37 FF 01 00 		rtl
dtfm2a:
014F9C E7 E2 01 00 		push	r5
014FA0 E4 F0 61 00 		dec		MBX_TQ_COUNT[r1]
	mov		r2,r4
014FA4 46 42 70 04 		lw		r4,TCB_mbq_next[r4]
014FA8 E3 40 10 00 		sw		r4,MBX_TQ_HEAD[r1]
014FAC 3D 02 06 00 		beq		r4,dtfm3a
014FB0 63 02 80 04 			sw		r0,TCB_mbq_prev[r4]
014FB4 3A 01 00 00 			bra		dtfm4a
                	dtfm3a:
014FB8 E3 00 30 00 			sw		r0,MBX_TQ_TAIL[r1]
                	dtfm4a:
014FBC 63 01 70 04 		sw	    r0,TCB_mbq_next[r2]
014FC0 63 01 80 04 		sw		r0,TCB_mbq_prev[r2]
014FC4 63 01 B0 04 		sw		r0,TCB_hWaitMbx[r2]
                	;	sei
014FC8 40 11 20 04 	    lb      r1,TCB_Status[r2]
014FCC 8C 10 FA FF 	    and     r1,r1,#~TS_WAITMSG
014FD0 60 11 20 04 	    sb      r1,TCB_Status[r2]
                	;	cli
014FD4 57 5F 10 00 		pop		r5
014FD8 57 4F 10 00 		pop		r4
014FDC 0A 10 00 00 		ldi		r1,#E_Ok
014FE0 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; PostMsg and SendMsg are the same operation except that PostMsg doesn't
                	; invoke rescheduling while SendMsg does. So they both call the same
                	; SendMsgPrim primitive routine. This two wrapper functions for convenience.
                	;------------------------------------------------------------------------------
                	
                	PostMsg:
014FE4 E7 EF 01 00 	    push    lr
014FE8 67 E2 01 00 		push	r4
014FEC 0A 40 00 00 		ldi		r4,#0			; Don't invoke scheduler
014FF0 39 05 00 00 		bsr		SendMsgPrim
014FF4 57 4F 10 00 		pop		r4
014FF8 3B FF 11 00 		rts

                	SendMsg:
014FFC E7 EF 01 00 	    push    lr
015000 67 E2 01 00 		push	r4
015004 0A 40 02 00 		ldi		r4,#1			; Do invoke scheduler
015008 7C 00 00 00 		jsr		SendMsgPrim
01500C 3C F0 0D A8 
015010 57 4F 10 00 		pop		r4
015014 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; SendMsgPrim
                	; Send a message to a mailbox
                	;
                	; Parameters
                	;	r1 = handle to mailbox
                	;	r2 = message D1
                	;	r3 = message D2
                	;	r4 = scheduler flag		1=invoke,0=don't invoke
                	;
                	; Returns
                	;	r1=E_Ok			everything is ok
                	;	r1=E_BadMbx		for a bad mailbox number
                	;	r1=E_NotAlloc	for a mailbox that isn't allocated
                	;	r1=E_NoMsg		if there are no more message blocks available
                	;------------------------------------------------------------------------------
                	message "SendMsgPrim"
                	SendMsgPrim:
015018 E7 EF 01 00 	    push    lr
01501C E7 E2 01 00 		push	r5
015020 67 E3 01 00 		push	r6
015024 E7 E3 01 00 		push	r7
                	
015028 39 8A FE FF 	    bsr     LockMBX
01502C C6 70 A0 00 		lw		r7,MBX_OWNER[r1]
015030 BD 03 7A 00 		beq		r7,smsg2				; error: no owner
015034 E7 E0 01 00 		push    r1
015038 67 E1 01 00 		push    r2
01503C B9 D8 FF FF 		bsr		DequeueThreadFromMbx	; r1=mbx
015040 02 61 00 1A 		mov		r6,r2					; r6 = thread
015044 57 2F 10 00 		pop     r2
015048 57 1F 10 00 		pop     r1
01504C 3D 13 2C 00 		bne		r6,smsg3
                			; Here there was no thread waiting at the mailbox, so a message needs to
                			; be allocated
                	smp2:
015050 B9 81 FE FF 	        bsr     LockFreeMSG
015054 7C C0 00 00 			lw		r7,FreeMsg
015058 46 70 50 01 
01505C BD 03 72 00 			beq		r7,smsg4		; no more messages available
015060 C6 53 00 00 			lw		r5,MSG_LINK[r7]
015064 7C C0 00 00 			sw		r5,FreeMsg
015068 63 50 50 01 
01506C 7C C0 00 00 			dec		nMsgBlk		; decrement the number of available messages
015070 64 F0 61 01 
015074 7C C0 00 00 			sw		r0,freemsg_sema
015078 63 00 80 02 
01507C E3 23 10 00 			sw		r2,MSG_D1[r7]
015080 E3 33 20 00 			sw		r3,MSG_D2[r7]
015084 E7 E0 01 00 			push    r1
015088 67 E1 01 00 			push    r2
01508C 82 20 00 1A 			mov     r2,r1			; r2 = mailbox
015090 82 13 00 1A 			mov		r1,r7			; r1 = message
015094 39 9C FF FF 			bsr		QueueMsgAtMbx
015098 57 2F 10 00 			pop     r2
01509C 57 1F 10 00 			pop     r1
0150A0 3D 03 30 00 			beq		r6,smsg5    ; check if there is a thread waiting for a message
                	smsg3:
0150A4 63 23 90 04 		sw		r2,TCB_MSG_D1[r6]
0150A8 63 33 A0 04 		sw		r3,TCB_MSG_D2[r6]
                	smsg7:
0150AC B9 80 FE FF 	    bsr     LockTCB
0150B0 40 53 20 04 		lb		r5,TCB_Status[r6]
0150B4 8C 52 02 00 		and		r5,r5,#TS_TIMEOUT
0150B8 BD 02 06 00 		beq		r5,smsg8
0150BC 02 13 00 1A 		mov		r1,r6
0150C0 B9 35 FF FF 		bsr		RemoveFromTimeoutList
                	smsg8:
0150C4 40 13 20 04 	    lb      r1,TCB_Status[r6]
0150C8 8C 10 FA FF 	    and     r1,r1,#~TS_WAITMSG
0150CC 60 13 20 04 	    sb      r1,TCB_Status[r6]
0150D0 7C C0 00 00 		sw		r0,tcb_sema
0150D4 63 00 90 02 
0150D8 02 13 00 1A 		mov		r1,r6
0150DC B9 7A FE FF 		bsr     LockTCB
0150E0 39 F8 FE FF 		bsr		AddTaskToReadyList
0150E4 7C C0 00 00 		sw		r0,tcb_sema
0150E8 63 00 90 02 
0150EC 3D 02 0A 00 		beq		r4,smsg5
0150F0 7C C0 00 00 		sw		r0,mbx_sema
0150F4 63 00 D0 02 
0150F8 38 0F 04 80 		int		#2
                		;GoReschedule
0150FC BA 01 00 00 		bra		smsg9
                	smsg5:
015100 7C C0 00 00 		sw		r0,mbx_sema
015104 63 00 D0 02 
                	smsg9:
015108 57 7F 10 00 		pop		r7
01510C 57 6F 10 00 		pop		r6
015110 57 5F 10 00 		pop		r5
015114 0A 10 00 00 		ldi		r1,#E_Ok
015118 3B FF 11 00 		rts
smsg1:
01511C 0A 10 08 00 		ldi		r1,#E_BadMbx
015120 37 FF 01 00 		rtl
smsg2:
015124 7C C0 00 00 		sw		r0,mbx_sema
015128 63 00 D0 02 
01512C 57 7F 10 00 		pop		r7
015130 57 6F 10 00 		pop		r6
015134 57 5F 10 00 		pop		r5
015138 0A 10 12 00 		ldi		r1,#E_NotAlloc
01513C 3B FF 11 00 		rts
smsg4:
015140 7C C0 00 00 		sw		r0,freemsg_sema
015144 63 00 80 02 
015148 7C C0 00 00 		sw		r0,mbx_sema
01514C 63 00 D0 02 
015150 57 7F 10 00 		pop		r7
015154 57 6F 10 00 		pop		r6
015158 57 5F 10 00 		pop		r5
01515C 0A 10 16 00 		ldi		r1,#E_NoMsg
015160 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; WaitMsg
                	; Wait at a mailbox for a message to arrive. This subroutine will block the
                	; task until a message is available or the task times out on the timeout
                	; list.
                	;
                	; Parameters
                	;	r1=mailbox
                	;	r2=timeout
                	; Returns:
                	;	r1=E_Ok			if everything is ok
                	;	r1=E_BadMbx		for a bad mailbox number
                	;	r1=E_NotAlloc	for a mailbox that isn't allocated
                	;	r2=message D1
                	;	r3=message D2
                	;------------------------------------------------------------------------------
                	message "WaitMsg"
                	WaitMsg:
                	;	cmp		r3,r1,#NR_MBX			; check the mailbox number to make sure
                	;	bge		r3,wmsg1				; that it's sensible
015164 E7 EF 01 00 		push    lr
015168 67 E2 01 00 		push	r4
01516C E7 E2 01 00 		push	r5
015170 67 E3 01 00 		push	r6
015174 E7 E3 01 00 		push	r7
015178 82 60 00 1A 		mov		r6,r1
                	wmsg11:
01517C B9 5F FE FF 	    bsr     LockMBX
015180 C6 50 A0 00 		lw		r5,MBX_OWNER[r1]
015184 7C 00 00 00 		cmp		r3,r5,#MAX_TASKNO
015188 7C 00 00 00 
01518C 86 32 06 07 
015190 BD 21 9E 00 		bgt		r3,wmsg2				; error: no owner
015194 39 A3 FF FF 		bsr		DequeueMsgFromMbx
015198 BD 10 5E 00 		bne		r1,wmsg3
                	
                		; Here there was no message available, remove the task from
                		; the ready list, and optionally add it to the timeout list.
                		; Queue the task at the mailbox.
                	wmsg12:
01519C B9 62 FE FF 	    bsr     LockTCB
0151A0 02 1C 00 1A 		mov		r1,tr				; remove the task from the ready list
0151A4 B9 EF FE FF 		bsr		RemoveTaskFromReadyList
0151A8 7C C0 00 00 		sw		r0,tcb_sema
0151AC 63 00 90 02 
                	wmsg13:
0151B0 39 60 FE FF 	    bsr     LockTCB
0151B4 C0 70 20 04 		lb		r7,TCB_Status[r1]
0151B8 8D 73 04 00 		or		r7,r7,#TS_WAITMSG			; set task status to waiting
0151BC E0 70 20 04 		sb		r7,TCB_Status[r1]
0151C0 E3 60 B0 04 		sw		r6,TCB_hWaitMbx[r1]			; set which mailbox is waited for
0151C4 E3 00 70 04 		sw		r0,TCB_mbq_next[r1]			; adding at tail, so there is no next
0151C8 46 73 10 00 		lw		r7,MBX_TQ_HEAD[r6]			; is there a task que setup at the mailbox ?
0151CC BD 03 36 00 		beq		r7,wmsg6
0151D0 46 73 30 00 		lw		r7,MBX_TQ_TAIL[r6]
0151D4 E3 70 80 04 		sw		r7,TCB_mbq_prev[r1]
0151D8 E3 13 70 04 		sw		r1,TCB_mbq_next[r7]
0151DC 63 13 30 00 		sw		r1,MBX_TQ_TAIL[r6]
0151E0 64 13 60 00 		inc		MBX_TQ_COUNT[r6]			; increment number of tasks queued
	
                	
                	wmsg7:
0151E4 7C C0 00 00 		sw		r0,tcb_sema
0151E8 63 00 90 02 
0151EC 7C C0 00 00 		sw		r0,mbx_sema
0151F0 63 00 D0 02 
0151F4 3D 01 0C 00 		beq		r2,wmsg10                   ; check for a timeout
                	wmsg14:
0151F8 39 57 FE FF 	    bsr     LockTCB
0151FC B9 F4 FE FF 		bsr		AddToTimeoutList
015200 7C C0 00 00 		sw		r0,tcb_sema
015204 63 00 90 02 
015208 38 0F 04 80 		int		#2	;	GoReschedule			; invoke the scheduler
                	wmsg10:
                		; At this point either a message was sent to the task, or the task
                		; timed out. If a message is still not available then the task must
                		; have timed out. Return a timeout error.
                		; Note that SendMsg will directly set the message D1, D2 data
                		; without queing a message at the mailbox (if there is a task
                		; waiting already). So we cannot just try dequeing a message again.
01520C C6 20 90 04 		lw		r2,TCB_MSG_D1[r1]
015210 C6 30 A0 04 		lw		r3,TCB_MSG_D2[r1]
015214 C0 40 20 04 		lb		r4,TCB_Status[r1]
015218 0C 42 04 00 		and		r4,r4,#TS_WAITMSG	; Is the task still waiting for a message ?
01521C 3D 02 48 00 		beq		r4,wmsg8			; If not, go return OK status
015220 57 7F 10 00 		pop		r7				; Otherwise return timeout error
015224 57 6F 10 00 		pop		r6
015228 57 5F 10 00 		pop		r5
01522C 57 4F 10 00 		pop		r4
015230 0A 10 20 00 		ldi		r1,#E_Timeout
015234 3B FF 11 00 		rts
	
                		; Here there were no prior tasks queued at the mailbox
                	wmsg6:
015238 E3 00 80 04 		sw		r0,TCB_mbq_prev[r1]		; no previous tasks
01523C E3 00 70 04 		sw		r0,TCB_mbq_next[r1]
015240 63 13 10 00 		sw		r1,MBX_TQ_HEAD[r6]		; set both head and tail indexes
015244 63 13 30 00 		sw		r1,MBX_TQ_TAIL[r6]
015248 0A 70 02 00 		ldi		r7,#1
01524C 63 73 60 00 		sw		r7,MBX_TQ_COUNT[r6]		; one task queued
015250 BA F2 FF FF 		bra		wmsg7					; check for a timeout value
                		
                	wmsg3:
015254 7C C0 00 00 		sw		r0,mbx_sema
015258 63 00 D0 02 
01525C C6 20 10 00 		lw		r2,MSG_D1[r1]
015260 C6 30 20 00 		lw		r3,MSG_D2[r1]
                		; Add the newly dequeued message to the free messsage list
                	wmsg5:
015264 7C C0 00 00 		lwar    r6,freemsg_sema
015268 5C 60 80 02 
01526C 3D 13 FC FF 		bne     r6,wmsg5
015270 7C C0 00 00 		swcr    tr,freemsg_sema
015274 6E 80 81 02 
015278 02 60 00 3E 		mfspr   r6,cr0
01527C 7C 00 00 10 		and     r6,r6,#$1000000000
015280 0C 63 00 00 
015284 3D 03 F0 FF 		beq     r6,wmsg5
015288 7C C0 00 00 		lw		r7,FreeMsg
01528C 46 70 50 01 
015290 E3 70 00 00 		sw		r7,MSG_LINK[r1]
015294 7C C0 00 00 		sw		r1,FreeMsg
015298 63 10 50 01 
01529C 7C C0 00 00 		inc		nMsgBlk
0152A0 64 10 60 01 
0152A4 7C C0 00 00 		sw		r0,freemsg_sema
0152A8 63 00 80 02 
                	wmsg8:
0152AC 57 7F 10 00 		pop		r7
0152B0 57 6F 10 00 		pop		r6
0152B4 57 5F 10 00 		pop		r5
0152B8 57 4F 10 00 		pop		r4
0152BC 0A 10 00 00 		ldi		r1,#E_Ok
0152C0 3B FF 11 00 		rts
wmsg1:
0152C4 0A 10 08 00 		ldi		r1,#E_BadMbx
0152C8 37 FF 01 00 		rtl
wmsg2:
0152CC 7C C0 00 00 		sw		r0,mbx_sema
0152D0 63 00 D0 02 
0152D4 57 7F 10 00 		pop		r7
0152D8 57 6F 10 00 		pop		r6
0152DC 57 5F 10 00 		pop		r5
0152E0 57 4F 10 00 		pop		r4
0152E4 0A 10 12 00 		ldi		r1,#E_NotAlloc
0152E8 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; Check for a message at a mailbox. Does not block. This function is a
                	; convenience wrapper for CheckMsg().
                	;
                	; Parameters
                	;	r1=mailbox handle
                	; Returns:
                	;	r1=E_Ok			if everything is ok
                	;	r1=E_NoMsg		if no message is available
                	;	r1=E_BadMbx		for a bad mailbox number
                	;	r1=E_NotAlloc	for a mailbox that isn't allocated
                	;	r2=message D1
                	;	r3=message D2
                	;------------------------------------------------------------------------------
                	
                	PeekMsg:
0152EC E7 EF 01 00 	    push    lr
0152F0 0A 20 00 00 		ldi		r2,#0		; don't remove from queue
0152F4 39 01 00 00 		bsr		CheckMsg
0152F8 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; CheckMsg
                	; Check for a message at a mailbox. Does not block.
                	;
                	; Parameters
                	;	r1=mailbox handle
                	;	r2=remove from queue if present
                	; Returns:
                	;	r1=E_Ok			if everything is ok
                	;	r1=E_NoMsg		if no message is available
                	;	r1=E_BadMbx		for a bad mailbox number
                	;	r1=E_NotAlloc	for a mailbox that isn't allocated
                	;	r2=message D1
                	;	r3=message D2
                	;------------------------------------------------------------------------------
                	message "CheckMsg"
                	CheckMsg:
0152FC E7 EF 01 00 	    push    lr
015300 67 E3 01 00 	    push    r6
                	;	cmp		r3,r1,#NR_MBX			; check the mailbox number to make sure
                	;	bge		r3,cmsg1				; that it's sensible
015304 67 E2 01 00 		push	r4
015308 E7 E2 01 00 		push	r5
                	
01530C B9 2D FE FF 	    bsr     LockMBX
                	
015310 C6 50 A0 00 		lw		r5,MBX_OWNER[r1]
015314 BD 02 3C 00 		beq		r5,cmsg2				; error: no owner
015318 3D 01 06 00 		beq		r2,cmsg3                ; are we to dequeue the message ?
01531C 39 72 FF FF 		bsr		DequeueMsgFromMbx
015320 3A 01 00 00 		bra		cmsg4
                	cmsg3:
015324 C6 10 40 00 		lw		r1,MBX_MQ_HEAD[r1]		; peek the message at the head of the messages queue
                	cmsg4:
015328 BD 00 40 00 		beq		r1,cmsg5
01532C 02 41 00 1A 		mov     r4,r2
015330 C6 20 10 00 		lw		r2,MSG_D1[r1]
015334 C6 30 20 00 		lw		r3,MSG_D2[r1]
015338 3D 02 16 00 		beq		r4,cmsg8
                	cmsg10:
01533C 39 24 FE FF 	    bsr     LockFreeMSG
015340 7C C0 00 00 		lw		r5,FreeMsg
015344 46 50 50 01 
015348 E3 50 00 00 		sw		r5,MSG_LINK[r1]
01534C 7C C0 00 00 		sw		r1,FreeMsg
015350 63 10 50 01 
015354 7C C0 00 00 		inc		nMsgBlk
015358 64 10 60 01 
01535C 7C C0 00 00 		sw		r0,freemsg_sema
015360 63 00 80 02 
                	cmsg8:
015364 7C C0 00 00 		sw		r0,mbx_sema
015368 63 00 D0 02 
01536C 57 5F 10 00 		pop		r5
015370 57 4F 10 00 		pop		r4
015374 57 6F 10 00 		pop     r6
015378 0A 10 00 00 		ldi		r1,#E_Ok
01537C 3B FF 11 00 		rts
cmsg1:
015380 0A 10 08 00 		ldi		r1,#E_BadMbx
015384 57 6F 10 00 		pop     r6
015388 3B FF 11 00 		rts
cmsg2:
01538C 7C C0 00 00 		sw		r0,mbx_sema            ; unlock semaphore
015390 63 00 D0 02 
015394 57 5F 10 00 		pop		r5
015398 57 4F 10 00 		pop		r4
01539C 57 6F 10 00 		pop     r6
0153A0 0A 10 12 00 		ldi		r1,#E_NotAlloc
0153A4 3B FF 11 00 		rts
cmsg5:
0153A8 7C C0 00 00 		sw		r0,mbx_sema            ; unlock semaphore
0153AC 63 00 D0 02 
0153B0 57 5F 10 00 		pop		r5
0153B4 57 4F 10 00 		pop		r4
0153B8 57 6F 10 00 		pop     r6
0153BC 0A 10 16 00 		ldi		r1,#E_NoMsg
0153C0 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; System Call Exception
                	;
                	;------------------------------------------------------------------------------
                	;
                	syscall_exception:
0153C4 02 E0 01 6C 	    cpuid   sp,r0,#0
0153C8 3D 0F 08 00 	    beq     sp,.0001
0153CC 7C 02 00 00 	    ldi     sp,#CPU1_SYS_STACK
0153D0 0A E0 01 20 
0153D4 BA 01 00 00 	    bra     .0002
                	.0001:
0153D8 7C 00 00 00 	    ldi     sp,#CPU0_SYS_STACK
0153DC 0A E0 01 A0 
                	.0002:
0153E0 67 E3 01 00 		push	r6					; save off some working registers
0153E4 E7 E3 01 00 		push	r7
0153E8 02 60 12 3E 		mfspr   r6,epc              ; get return address into r6
0153EC 44 73 08 00 		lh	    r7,4[r6]			; get static call number parameter into r7
0153F0 14 63 10 00 		addui   r6,r6,#8			; update return address
0153F4 02 03 12 3C 		mtspr   epc,r6
0153F8 7C 01 00 00 		lcu     r6,syscall_vectors[r7]       ; load the vector into r6
0153FC C3 63 00 80 
015400 7C 01 00 00 		or      r6,r6,#syscall_exception & 0xFFFFFFFFFFFF0000
015404 0D 63 00 00 
015408 E7 EF 01 00 		push    lr
01540C 3C F3 01 00 		jsr		[r6]				; do the system function
015410 57 FF 11 00 		pop     lr
015414 57 7F 10 00 		pop		r7
015418 57 6F 10 00 		pop		r6
01541C 02 E0 3D 6E 		rte
                	
                	;------------------------------------------------------------------------------
                	; Reschedule tasks to run without affecting the timeout list timing.
                	;------------------------------------------------------------------------------
                	
                	reschedule:
015420 02 E0 01 6C 	    cpuid   sp,r0,#0
015424 3D 0F 08 00 	    beq     sp,.0001
015428 7C 02 00 00 	    ldi     sp,#CPU1_IRQ_STACK
01542C 0A E0 01 10 
015430 BA 01 00 00 	    bra     .0003
                	.0001:
015434 FC 00 00 00 	    ldi     sp,#IRQ_STACK
015438 0A E0 01 00 
                	.0003:
01543C E7 E0 01 00 	    push    r1
015440 67 E1 01 00 		push    r2
015444 7C C0 00 00 		lwar    r1,tcb_sema
015448 5C 10 90 02 
01544C BD 10 10 00 		bne     r1,.0004
015450 7C C0 00 00 		swcr    tr,tcb_sema
015454 6E 80 91 02 
015458 02 10 00 3E 		mfspr   r1,cr0
01545C 7C 00 00 10 		and     r1,r1,#$1000000000
015460 8C 10 00 00 
015464 BD 10 0E 00 		bne     r1,.0005
015468 BA 01 00 00 		bra     .0006
                	.0004:
01546C 7C C0 00 00 	    swcr    r1,tcb_sema
015470 6E 10 90 02 
                	.0006:
015474 57 2F 10 00 		pop     r2
015478 57 1F 10 00 		pop     r1
01547C 02 E0 3F 6E 		rti
                	.0005:
015480 57 2F 10 00 	    pop     r2
015484 57 1F 10 00 	    pop     r1
015488 63 1C 10 00 	    sw      r1,TCB_r1[tr]
01548C 63 2C 20 00 	    sw      r2,TCB_r2[tr]
015490 63 3C 30 00 	    sw      r3,TCB_r3[tr]
015494 63 4C 40 00 	    sw      r4,TCB_r4[tr]
015498 63 5C 50 00 	    sw      r5,TCB_r5[tr]
01549C 63 6C 60 00 	    sw      r6,TCB_r6[tr]
0154A0 63 7C 70 00 	    sw      r7,TCB_r7[tr]
0154A4 63 8C 80 00 	    sw      r8,TCB_r8[tr]
0154A8 63 9C 90 00 	    sw      r9,TCB_r9[tr]
0154AC 63 AC A0 00 	    sw      r10,TCB_r10[tr]
0154B0 63 BC B0 00 	    sw      r11,TCB_r11[tr]
0154B4 63 CC C0 00 	    sw      r12,TCB_r12[tr]
0154B8 63 DC D0 00 	    sw      r13,TCB_r13[tr]
0154BC 63 EC E0 00 	    sw      r14,TCB_r14[tr]
0154C0 63 FC F0 00 	    sw      r15,TCB_r15[tr]
0154C4 63 0C 01 01 	    sw      r16,TCB_r16[tr]
0154C8 63 1C 11 01 	    sw      r17,TCB_r17[tr]
0154CC 63 2C 21 01 	    sw      r18,TCB_r18[tr]
0154D0 63 3C 31 01 	    sw      r19,TCB_r19[tr]
0154D4 63 4C 41 01 	    sw      r20,TCB_r20[tr]
0154D8 63 5C 51 01 	    sw      r21,TCB_r21[tr]
0154DC 63 6C 61 01 	    sw      r22,TCB_r22[tr]
0154E0 63 7C 71 01 	    sw      r23,TCB_r23[tr]
0154E4 63 8C 81 01 	    sw      r24,TCB_r24[tr]
0154E8 63 9C 91 01 	    sw      r25,TCB_r25[tr]
0154EC 63 AC A1 01 	    sw      r26,TCB_r26[tr]
0154F0 63 BC B1 01 	    sw      r27,TCB_r27[tr]
0154F4 63 CC C1 01 	    sw      r28,TCB_r28[tr]
0154F8 63 DC D1 01 	    sw      r29,TCB_r29[tr]
0154FC 02 10 1E 3E 	    mfspr   r1,isp
015500 63 1C E0 01 	    sw      r1,TCB_r30[tr]
015504 63 FC F1 01 	    sw      r31,TCB_r31[tr]
015508 02 10 10 3E 	    mfspr   r1,ipc
01550C 63 1C 00 03 	    sw      r1,TCB_IPC[tr]
015510 02 10 0E 3E 	    mfspr   r1,dpc
015514 63 1C 10 03 	    sw      r1,TCB_DPC[tr]
015518 02 10 12 3E 	    mfspr   r1,epc
01551C 63 1C 20 03 	    sw      r1,TCB_EPC[tr]
                	resched1:
015520 40 1C 20 04 	    lb      r1,TCB_Status[tr]  ; clear RUNNING status (bit #3)
015524 8C 10 EE FF 	    and     r1,r1,#~TS_RUNNING
015528 60 1C 20 04 	    sb      r1,TCB_Status[tr]
01552C 7C 00 00 00 		jmp		SelectTaskToRun
015530 3C 00 7A AB 
                	
                	strStartQue:
015534 00 00 00 01 		db		0,0,0,1,0,0,0,2,0,1,0,3,0,0,0,4,0,1,0,5,0,0,0,6,0,1,0,7
015538 00 00 00 02 
01553C 00 01 00 03 
015540 00 00 00 04 
015544 00 01 00 05 
015548 00 00 00 06 
01554C 00 01 00 07 
                	;	db		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                	
                	;------------------------------------------------------------------------------
                	; 60 Hz interrupt
                	; - takes care of "flashing" the cursor
                	; - decrements timeouts for tasks on timeout list
                	; - switching tasks
                	;------------------------------------------------------------------------------
                	
                	FMTKTick:
015550 02 E0 01 6C 	    cpuid   sp,r0,#0
015554 3D 0F 0C 00 	    beq     sp,.0001
015558 02 E0 3F 6E 	    rti
01555C 7C 02 00 00 	    ldi     sp,#CPU1_IRQ_STACK
015560 0A E0 01 10 
015564 E7 E0 01 00 	    push    r1
015568 BA 04 00 00 	    bra     .0003
                	.0001:
01556C FC 00 00 00 	    ldi     sp,#IRQ_STACK
015570 0A E0 01 00 
015574 E7 E0 01 00 		push    r1
015578 0A 10 06 00 		ldi		r1,#3				; reset the edge sense circuit
01557C 7C DC FF 00 		sh		r1,PIC_RSTE
015580 62 10 A8 1F 
015584 7C C0 00 00 		inc		IRQFlag
015588 64 10 10 00 
                	.0003:
                		; Try and aquire the ready list and tcb. If unsuccessful it means there is
                		; a system function in the process of updating the list. All we can do is
                		; return to the system function and let it complete whatever it was doing.
                		; As if we don't return to the system function we will be deadlocked.
                		; The tick will be deferred; however if the system function was busy updating
                		; the ready list, in all likelyhood it's about to call the reschedule
                		; interrupt.
01558C 67 E1 01 00 		push    r2
015590 7C C0 00 00 		lwar    r1,tcb_sema
015594 5C 10 90 02 
015598 BD 10 0E 00 		bne     r1,.0006
01559C 7C C0 00 00 		swcr    tr,tcb_sema
0155A0 6E 80 91 02 
0155A4 02 10 00 3E 		mfspr   r1,cr0
0155A8 7C 00 00 10 		and     r1,r1,#$1000000000
0155AC 8C 10 00 00 
0155B0 BD 10 0C 00 		bne     r1,.0005
                	.0006:
0155B4 7C C0 00 00 		inc		missed_ticks
0155B8 64 10 70 01 
0155BC 57 2F 10 00 		pop     r2
0155C0 57 1F 10 00 		pop     r1
0155C4 02 E0 3F 6E 		rti
                	.0005:
0155C8 57 2F 10 00 	    pop     r2
0155CC 57 1F 10 00 	    pop     r1
                	p100Hz11:
0155D0 63 1C 10 00 	    sw      r1,TCB_r1[tr]
0155D4 63 2C 20 00 	    sw      r2,TCB_r2[tr]
0155D8 63 3C 30 00 	    sw      r3,TCB_r3[tr]
0155DC 63 4C 40 00 	    sw      r4,TCB_r4[tr]
0155E0 63 5C 50 00 	    sw      r5,TCB_r5[tr]
0155E4 63 6C 60 00 	    sw      r6,TCB_r6[tr]
0155E8 63 7C 70 00 	    sw      r7,TCB_r7[tr]
0155EC 63 8C 80 00 	    sw      r8,TCB_r8[tr]
0155F0 63 9C 90 00 	    sw      r9,TCB_r9[tr]
0155F4 63 AC A0 00 	    sw      r10,TCB_r10[tr]
0155F8 63 BC B0 00 	    sw      r11,TCB_r11[tr]
0155FC 63 CC C0 00 	    sw      r12,TCB_r12[tr]
015600 63 DC D0 00 	    sw      r13,TCB_r13[tr]
015604 63 EC E0 00 	    sw      r14,TCB_r14[tr]
015608 63 FC F0 00 	    sw      r15,TCB_r15[tr]
01560C 63 0C 01 01 	    sw      r16,TCB_r16[tr]
015610 63 1C 11 01 	    sw      r17,TCB_r17[tr]
015614 63 2C 21 01 	    sw      r18,TCB_r18[tr]
015618 63 3C 31 01 	    sw      r19,TCB_r19[tr]
01561C 63 4C 41 01 	    sw      r20,TCB_r20[tr]
015620 63 5C 51 01 	    sw      r21,TCB_r21[tr]
015624 63 6C 61 01 	    sw      r22,TCB_r22[tr]
015628 63 7C 71 01 	    sw      r23,TCB_r23[tr]
01562C 63 8C 81 01 	    sw      r24,TCB_r24[tr]
015630 63 9C 91 01 	    sw      r25,TCB_r25[tr]
015634 63 AC A1 01 	    sw      r26,TCB_r26[tr]
015638 63 BC B1 01 	    sw      r27,TCB_r27[tr]
01563C 63 CC C1 01 	    sw      r28,TCB_r28[tr]
015640 63 DC D1 01 	    sw      r29,TCB_r29[tr]
015644 02 10 1E 3E 	    mfspr   r1,isp
015648 63 1C E0 01 	    sw      r1,TCB_r30[tr]
01564C 63 FC F1 01 	    sw      r31,TCB_r31[tr]
015650 02 10 10 3E 	    mfspr   r1,ipc
015654 63 1C 00 03 	    sw      r1,TCB_IPC[tr]
015658 02 10 0E 3E 	    mfspr   r1,dpc
01565C 63 1C 10 03 	    sw      r1,TCB_DPC[tr]
015660 02 10 12 3E 	    mfspr   r1,epc
015664 63 1C 20 03 	    sw      r1,TCB_EPC[tr]
015668 0A 10 C0 00 		ldi		r1,#96
01566C 7C DC FF 00 		sc		r1,LEDS
015670 61 10 00 0C 
015674 7C C0 00 00 		lw		r1,UserTick
015678 46 10 00 00 
01567C BD 00 08 00 		beq		r1,p100Hz4
015680 E7 EF 01 00 		push    lr
015684 BC F0 01 00 		jsr		[r1]
015688 57 FF 11 00 		pop     lr
                	p100Hz4:
01568C 40 1C 20 04 	    lb      r1,TCB_Status[tr]
015690 8C 10 EE FF 	    and     r1,r1,#~TS_RUNNING
015694 60 1C 20 04 	    sb      r1,TCB_Status[tr]
015698 0A 10 C2 00 		ldi		r1,#97
01569C 7C DC FF 00 		sc		r1,LEDS
0156A0 61 10 00 0C 
                	
                		; Check the timeout list to see if there are items ready to be removed from
                		; the list. Also decrement the timeout of the item at the head of the list.
                	p100Hz15:
0156A4 7C C0 00 00 		lw		r2,TimeoutList
0156A8 46 20 10 01 
0156AC 3D 01 1E 00 		beq		r2,p100Hz12				; are there any entries in the timeout list ?
0156B0 46 11 F0 04 		lw		r1,TCB_Timeout[r2]
0156B4 BD 10 0C 00 		bne		r1,p100Hz14				; has this entry timed out ?
0156B8 E7 EF 01 00 		push    lr
0156BC B9 8B FE FF 		bsr     PopTimeoutList
0156C0 39 3C FE FF 		bsr		AddTaskToReadyList
0156C4 57 FF 11 00 		pop     lr
0156C8 BA FB FF FF 		bra		p100Hz15				; go back and see if there's another task to be removed
                										; there could be a string of tasks to make ready.
                	p100Hz14:
0156CC 95 10 02 00 		subui   r1,r1,#1				; decrement the entry's timeout
0156D0 7C C0 00 00 		lw      r3,missed_ticks
0156D4 46 30 70 01 
0156D8 82 10 06 2A 		subu	r1,r1,r3        		; account for any missed ticks
0156DC 7C C0 00 00 		sw		r0,missed_ticks
0156E0 63 00 70 01 
0156E4 63 11 F0 04 		sw		r1,TCB_Timeout[r2]
                		
                	p100Hz12:
                		; Falls through into selecting a task to run
                	tck3:
0156E8 0A 10 C4 00 		ldi		r1,#98
0156EC 7C DC FF 00 		sc		r1,LEDS
0156F0 61 10 00 0C 
                	
                	;------------------------------------------------------------------------------
                	; Search the ready queues for a ready task.
                	; The search is occasionally started at a lower priority queue in order
                	; to prevent starvation of lower priority tasks. This is managed by 
                	; using a tick count as an index to a string containing the start que.
                	;------------------------------------------------------------------------------
                	;
                	SelectTaskToRun:
0156F4 0A 60 10 00 		ldi		r6,#8			; number of queues to search
0156F8 7C C0 00 00 		lw		r3,IRQFlag		; use the IRQFlag as a buffer index
0156FC 46 30 10 00 
                	;	lsr		r3,r3,#1		; the LSB is always the same
015700 8C 31 3E 00 		and		r3,r3,#$1F		; counts from 0 to 31
015704 7C 01 00 00 		lb	    r3,strStartQue[r3]	; get the queue to start search at
015708 C0 31 68 AA 
01570C 8C 31 0E 00 		and     r3,r3,#7
                	sttr2:
015710 82 41 06 70 	    asl     r4,r3,#3
015714 7C C0 00 00 		lw		r1,QNdx0[r4]
015718 46 12 70 00 
01571C BD 00 B0 00 		beq		r1,sttr1
015720 C6 10 00 04 		lw		r1,TCB_NextRdy[r1]		; Advance the queue index
015724 8C 70 FE 01 		and     r7,r1,#$FF
015728 BD 13 D4 00 		bne     r7,sttr_badtask
01572C 7C C1 00 00 		cmpu    r7,r1,#TCB_Array
015730 96 70 00 00 
015734 BD 43 CE 00 		blt     r7,sttr_badtask
015738 FC C3 00 00 		cmpu    r7,r1,#TCB_ArrayEnd-TCB_Size
01573C 96 70 00 FA 
015740 BD 23 C8 00 		bgt     r7,sttr_badtask
015744 7C C0 00 00 		sw		r1,QNdx0[r4]
015748 63 12 70 00 
01574C 02 70 00 6C 		cpuid   r7,r0,#0
015750 BD 03 08 00 		beq     r7,sttr5
015754 C2 80 00 05 		lc      r8,TCB_Affinity[r1]
015758 82 73 10 0C 		cmp     r7,r7,r8
01575C BD 13 90 00 		bne     r7,sttr1
                	sttr5:
                		; This is the only place the RunningTCB is set (except for initialization).
015760 82 80 01 1A 		mov     tr,r1
015764 3F 00 00 00 		nop
015768 3F 00 00 00 		nop
01576C 40 1C 20 04 		lb      r1,TCB_Status[tr]
015770 8D 10 10 00 		or      r1,r1,#TS_RUNNING    ; flag the task as the running task
015774 60 1C 20 04 		sb      r1,TCB_Status[tr]
015778 0A 10 C6 00 		ldi		r1,#99
01577C 7C DC FF 00 		sc		r1,LEDS
015780 61 10 00 0C 
015784 7C C0 00 00 		lw		r1,iof_switch		
015788 46 10 F0 01 
01578C BD 00 22 00 		beq		r1,sttr6				
015790 7C C0 00 00 		lwar	r1,iof_sema		; just ignore the request to switch
015794 5C 10 C0 02 
015798 BD 10 6C 00 		bne		r1,sttr7		; I/O focus if the semaphore can't be aquired
01579C 7C C0 00 00 		swcr    tr,iof_sema
0157A0 6E 80 C1 02 
0157A4 02 10 00 3E 		mfspr   r1,cr0
0157A8 7C 00 00 10 		and     r1,r1,#$1000000000
0157AC 8C 10 00 00 
0157B0 BD 00 10 00 		beq     r1,sttr6
0157B4 7C C0 00 00 		sw		r0,iof_switch
0157B8 63 00 F0 01 
0157BC E7 EF 01 00 		push    lr
0157C0 B9 7E D5 FF 		bsr		SwitchIOFocus
0157C4 57 FF 11 00 		pop     lr
0157C8 7C C0 00 00 		sw		r0,iof_sema
0157CC 63 00 C0 02 
                	sttr6:
0157D0 46 1C 20 03 	    lw      r1,TCB_EPC[tr]
0157D4 82 00 12 3C 	    mtspr   epc,r1
0157D8 46 1C 10 03 	    lw      r1,TCB_DPC[tr]
0157DC 82 00 0E 3C 	    mtspr   dpc,r1
0157E0 46 1C 00 03 	    lw      r1,TCB_IPC[tr]
0157E4 82 00 10 3C 	    mtspr   ipc,r1
0157E8 46 FC F1 01 	    lw      r31,TCB_r31[tr]
0157EC 46 1C E0 01 	    lw      r1,TCB_r30[tr]
0157F0 82 00 1E 3C 	    mtspr   isp,r1
0157F4 46 DC D1 01 	    lw      r29,TCB_r29[tr]
0157F8 46 CC C1 01 	    lw      r28,TCB_r28[tr]
0157FC 46 BC B1 01 	    lw      r27,TCB_r27[tr]
015800 46 AC A1 01 	    lw      r26,TCB_r26[tr]
015804 46 9C 91 01 	    lw      r25,TCB_r25[tr]
                	;   lw      r24,TCB_r24[tr]    ; r24 is the task register - no need to load
015808 46 7C 71 01 	    lw      r23,TCB_r23[tr]
01580C 46 6C 61 01 	    lw      r22,TCB_r22[tr]
015810 46 5C 51 01 	    lw      r21,TCB_r21[tr]
015814 46 4C 41 01 	    lw      r20,TCB_r20[tr]
015818 46 3C 31 01 	    lw      r19,TCB_r19[tr]
01581C 46 2C 21 01 	    lw      r18,TCB_r18[tr]
015820 46 1C 11 01 	    lw      r17,TCB_r17[tr]
015824 46 0C 01 01 	    lw      r16,TCB_r16[tr]
015828 46 FC F0 00 	    lw      r15,TCB_r15[tr]
01582C 46 EC E0 00 	    lw      r14,TCB_r14[tr]
015830 46 DC D0 00 	    lw      r13,TCB_r13[tr]
015834 46 CC C0 00 	    lw      r12,TCB_r12[tr]
015838 46 BC B0 00 	    lw      r11,TCB_r11[tr]
01583C 46 AC A0 00 	    lw      r10,TCB_r10[tr]
015840 46 9C 90 00 	    lw      r9,TCB_r9[tr]
015844 46 8C 80 00 	    lw      r8,TCB_r8[tr]
015848 46 7C 70 00 	    lw      r7,TCB_r7[tr]
01584C 46 6C 60 00 	    lw      r6,TCB_r6[tr]
015850 46 5C 50 00 	    lw      r5,TCB_r5[tr]
015854 46 4C 40 00 	    lw      r4,TCB_r4[tr]
015858 46 3C 30 00 	    lw      r3,TCB_r3[tr]
01585C 46 2C 20 00 	    lw      r2,TCB_r2[tr]
015860 46 1C 10 00 	    lw      r1,TCB_r1[tr]
015864 7C C0 00 00 		sw		r0,tcb_sema
015868 63 00 90 02 
01586C 02 E0 3F 6E 		rti
                	sttr7:
015870 7C C0 00 00 	    swcr    r1,iof_sema
015874 6E 10 C0 02 
015878 3A EB FF FF 	    bra     sttr6
                	
                		; Set index to check the next ready list for a task to run
                	sttr1:
01587C 94 31 02 00 		addui   r3,r3,#1
015880 8C 31 0E 00 		and     r3,r3,#7
015884 15 63 02 00 		subui   r6,r6,#1
015888 3D 33 44 FF 		bge		r6,sttr2
                	
                		; Here there were no tasks ready
                		; This should not be able to happen, so hang the machine (in a lower
                		; power mode).
                	sttr3:
01588C 0A 20 BC 00 		ldi     r2,#94
015890 7C DC FF 00 		sc		r2,LEDS
015894 61 20 00 0C 
015898 E7 EF 01 00 		push    lr
01589C B9 0A 00 00 		bsr		kernel_panic
0158A0 4E 6F 20 74 		db		"No tasks in ready queue.",0
0158A4 61 73 6B 73 
0158A8 20 69 6E 20 
0158AC 72 65 61 64 
0158B0 79 20 71 75 
0158B4 65 75 65 2E 
0158B8 00          
0158B9 00 00 00 B9 		bsr     DumpTaskList
0158BD D5 FD FF    
0158C0 57 FF 11 00 		pop     lr
                		; Might as well power down the clock and wait for a reset or
                		; NMI. In the case of an NMI the kernel is reinitialized without
                		; doing the boot reset.
0158C4 02 00 04 6E 		stp								
0158C8 7C 00 00 00 		jmp		FMTKInitialize
0158CC 3C 00 0E A0 
                	
                	sttr_badtask:
0158D0 39 04 00 00 	    bsr     kernel_panic
0158D4 42 61 64 20 	    db      "Bad task on ready list.",0
0158D8 74 61 73 6B 
0158DC 20 6F 6E 20 
0158E0 72 65 61 64 
0158E4 79 20 6C 69 
0158E8 73 74 2E 00 
0158EC 3A F2 FF FF 	    bra     sttr1
                	
                	;------------------------------------------------------------------------------
                	; kernal_panic:
                	;	All this does right now is display the panic message on the screen.
                	; Parameters:
                	;	inline: string
                	;------------------------------------------------------------------------------
                	;
                	kernel_panic:
0158F0 E7 E0 01 00 	    push    r1
                	kpan2:
0158F4 C1 1F 00 00 		lbu	    r1,[lr]		; get a byte from the code space
0158F8 BD 00 0C 00 		beq		r1,kpan1		; is it end of string ?
0158FC 94 FF 03 00 		addui	lr,lr,#1	; increment pointer
015900 E7 EF 01 00 		push    lr
015904 B9 02 F7 FF 		bsr		OutChar
015908 57 FF 11 00 		pop     lr
01590C 3A FD FF FF 		bra		kpan2
                	kpan1:
015910 E7 EF 01 00 	    push    lr   		; must update the return address !
015914 B9 CF F5 FF 		bsr		CRLF
015918 57 FF 11 00 		pop     lr
01591C 57 1F 10 00 		pop     r1
015920 94 FF 07 00 		addui   lr,lr,#3    ; round the link register to the next instruction address
015924 8C FF F9 FF 		and     lr,lr,#-4
015928 37 FF 01 00 		rtl

                	
                	         
01592C 3F 00 00 00 	    nop
015930 3F 00 00 00 	    nop
                	
                	
                		rodata
                		align	16                	
                		align	8                	
                		extern	RTCC_BUF
                		extern	Milliseconds
                		extern	Milliseconds
985 symbols
  Symbol Name                              seg     address
  API_AREA                                    bss  000430
  API_head                                    bss  00037e
  API_sema                                    bss  000388
  API_tail                                    bss  000380
  AddTaskToReadyList                         code  0148a0
  AddToTimeoutList                           code  0149a0
  AllocMbx                                   code  014b80
  AsciiToHexNybble                           code  011430
  AsciiToHexNybble.gthx3                     code  011490
  AsciiToHexNybble.gthx5                     code  011450
  AsciiToHexNybble.gthx6                     code  011470
  AsciiToScreen                              code  010614
  AsciiToScreen.00001                        code  010634
  BIOSCall                                   code  01088c
  BIOSCall.0002                              code  0108ac
  BIOSCall.0003                              code  8000000000000110
  BIOSCall.0005                              code  0108c0
  BIOSCall.0006                              code  0108d8
  BIOS_DONE                                 const  000001
  BIOS_FREE                                 const  000000
  BIOS_FuncTable                             code  010004
  BIOS_INSERVICE                            const  000002
  BIOS_arg1                                 const  000008
  BIOS_arg2                                 const  000010
  BIOS_arg3                                 const  000018
  BIOS_arg4                                 const  000020
  BIOS_arg5                                 const  000028
  BIOS_op                                   const  000000
  BIOS_resp                                 const  000030
  BIOS_sema                                   bss  000390
  BIOS_stat                                 const  000038
  BITMAP_SCREEN1                            const  400000
  BITMAP_SCREEN2                            const  800000
  BMP_CLUT                                  const  0c5800
  BSI_BootSig                               const  000026
  BSI_DriveNum                              const  000024
  BSI_FATS                                  const  000010
  BSI_FileSysType                           const  000036
  BSI_Heads                                 const  00001a
  BSI_HiddenSecs                            const  00001c
  BSI_HugeSecs                              const  00001e
  BSI_JMP                                   const  000000
  BSI_Media                                 const  000015
  BSI_OEMName                               const  000003
  BSI_ResSectors                            const  00000e
  BSI_RootDirEnts                           const  000011
  BSI_Rsvd1                                 const  000025
  BSI_SecPerCluster                         const  00000d
  BSI_SecPerFAT                             const  000016
  BSI_SecPerTrack                           const  000018
  BSI_Sectors                               const  000013
  BSI_VolID                                 const  000027
  BSI_VolLabel                              const  00002b
  BSI_bps                                   const  00000b
  BYTE_SECTOR_BUF                           const  03a000
  BlankLine                                  code  010e78
  BlankLine.0001                             code  010eb4
  BranchToSelf                               code  014018
  BranchToSelf2                              code  0107e4
  CPU0_BIOS_STACK                           const  006800
  CPU0_SYS_STACK                            const  005000
  CPU1_BIOS_STACK                           const  021800
  CPU1_IRQ_STACK                            const  020800
  CPU1_SYS_STACK                            const  021000
  CPUIdleTick                                 bss  0003a8
  CR                                        const  00000d
  CRLF                                       code  010790
  CRLF1                                      code  010794
  CTRLC                                     const  000003
  CTRLCCheck                                 code  011390
  CTRLCCheck.0001                            code  0113b8
  CTRLH                                     const  000008
  CTRLI                                     const  000009
  CTRLJ                                     const  00000a
  CTRLK                                     const  00000b
  CTRLM                                     const  00000d
  CTRLS                                     const  000013
  CTRLX                                     const  000018
  CalcScreenLoc                              code  010ba4
  CharsInRxBuf                               code  01040c
  CheckKeys                                  code  01137c
  CheckMsg                                   code  0152fc
  CheckScrollLock                            code  0113c0
  CheckScrollLock.0001                       code  0113e0
  CheckScrollLock.0002                       code  0113cc
  ClearBmpScreen                             code  8000000000000090
  ClearScreen                                code  010674
  ClearScreen.cs1                            code  0106b4
  CursorCol                                   bss  000139
  CursorOff                                  code  010658
  CursorOn                                   code  01065c
  CursorRow                                   bss  000138
  DBG_STACK                                 const  007000
  DequeueMsgFromMbx                          code  014eac
  DequeueThreadFromMbx                       code  014f00
  DequeueThreadFromMbx2                      code  014f80
  DispCharQ                                  code  0107b0
  DispStartMsg                               code  0107c4
  DisplayByte                                code  010710
  DisplayChar                                code  010bf0
  DisplayChar.dcx12                          code  010d08
  DisplayChar.dcx4                           code  010c78
  DisplayChar.dcx5                           code  010d3c
  DisplayChar.dcx7                           code  010cb0
  DisplayChar.doBackspace                    code  010d20
  DisplayChar.doCursorDown                   code  010ce0
  DisplayChar.doCursorHome                   code  010cf8
  DisplayChar.doCursorLeft                   code  010ccc
  DisplayChar.doCursorRight                  code  010c9c
  DisplayChar.doCursorUp                     code  010cb8
  DisplayChar.doDelete                       code  010d10
  DisplayChar.doLinefeed                     code  010d70
  DisplayChar.docr                           code  010c90
  DisplayCharHex                             code  0106fc
  DisplayErr                                 code  01149c
  DisplayHalf                                code  0106e8
  DisplayMemBytes                            code  0112bc
  DisplayMemBytes.001                        code  0112f0
  DisplayMemBytes.002                        code  011328
  DisplayMemBytes.003                        code  011348
  DisplayMemBytes.004                        code  01133c
  DisplayNybble                              code  010724
  DisplayNybble.0001                         code  010744
  DisplaySpace                               code  0107e8
  DisplayString                              code  010754
  DisplayString.dm1                          code  010778
  DisplayString.dm2                          code  010764
  DisplayStringCRLF                          code  010784
  DisplayWord                                code  0106d4
  Dummy1                                      bss  00013a
  DumpTaskList                               code  014768
  DumpTaskList.0001                          code  01478c
  E_Arg                                     const  000001
  E_BadAlarm                                const  000011
  E_BadBlockNum                             const  000025
  E_BadDevNum                               const  000020
  E_BadDevOp                                const  000022
  E_BadFuncno                               const  000001
  E_BadMbx                                  const  000004
  E_DCBInUse                                const  000019
  E_NoDev                                   const  000021
  E_NoMem                                   const  00000c
  E_NoMoreAlarmBlks                         const  000044
  E_NoMoreMbx                               const  000040
  E_NoMoreMsgBlks                           const  000041
  E_NoMoreTCBs                              const  000045
  E_NoMsg                                   const  00000b
  E_NoThread                                const  000006
  E_NotAlloc                                const  000009
  E_NotOwner                                const  000012
  E_Ok                                      const  000000
  E_QueFull                                 const  000005
  E_QueStrategy                             const  000013
  E_ReadError                               const  000023
  E_Timeout                                 const  000010
  E_TooManyBlocks                           const  000026
  E_WriteError                              const  000024
  EndStaticAllocations                        bss  03f400
  EndStaticAllocations.bss                    bss  03f408
  ExitTask                                   code  014658
  FMTKInitialize                             code  01401c
  FMTKTick                                   code  015550
  FMTKTick.0001                              code  01556c
  FMTKTick.0003                              code  01558c
  FMTKTick.0005                              code  0155c8
  FMTKTick.0006                              code  0155b4
  ForceReleaseIOFocus                        code  8000000000000330
  FreeJCB                                     bss  c00078
  FreeMbx                                    code  014c64
  FreeMbx2                                   code  014c7c
  FreeMbxHandle                               bss  c00098
  FreeMsg                                     bss  c000a8
  FreeTCB                                     bss  c00080
  GetCurrAttr                                code  010b54
  GetHexNumber                               code  0113f0
  GetHexNumber.gthxn1                        code  011420
  GetHexNumber.gthxn2                        code  011404
  GetRandomNumber                            code  01155c
  GetRange                                   code  011030
  GetScreenLocation                          code  010b48
  GetSystemTime                              code  010b3c
  GetTwoParams                               code  011014
  HomeCursor                                 code  010660
  I2C_CMD                                   const  000004
  I2C_CONTROL                               const  000002
  I2C_ERR                                    code  011e20
  I2C_INIT                                   code  011d50
  I2C_MASTER                                const  ffdc0e00
  I2C_PRESCALE_HI                           const  000001
  I2C_PRESCALE_LO                           const  000000
  I2C_READ                                   code  011d84
  I2C_RX                                    const  000003
  I2C_STAT                                  const  000004
  I2C_TX                                    const  000003
  I2C_WAIT_TC                                code  011eb0
  I2C_WAIT_TC.0001                           code  011eb0
  I2C_WRITE                                  code  011e30
  IBPT_ISR                                   code  012304
  IBPT_ISR.0001                              code  012308
  IOFocusNdx                                  bss  c00010
  IOFocusTbl                                  bss  c00018
  IRQFlag                                     bss  c00008
  IRQ_STACK                                 const  008000
  IdleTask                                   code  014370
  IncCursorPos                               code  010d78
  IncCursorRow                               code  010da4
  InitFMTK                                   code  01401c
  InitFMTK.0001                              code  014110
  InitPIC                                    code  010258
  InitUart                                   code  010274
  InputVec                                    bss  000118
  JCB_Array                                 const  c40000
  JCB_ArrayEnd                              const  c50000
  JCB_CmdLine                               const  000280
  JCB_CurrAttr                              const  000418
  JCB_CursorCol                             const  00040d
  JCB_CursorFlash                           const  00040f
  JCB_CursorOn                              const  00040e
  JCB_CursorRow                             const  00040c
  JCB_CursorType                            const  000410
  JCB_ExitError                             const  0003e0
  JCB_ExitRF                                const  000180
  JCB_KeybdAck                              const  00044a
  JCB_KeybdBad                              const  000449
  JCB_KeybdBuffer                           const  000450
  JCB_KeybdEcho                             const  000448
  JCB_KeybdHead                             const  000438
  JCB_KeybdLocks                            const  00044c
  JCB_KeybdTail                             const  000440
  JCB_LogSize                               const  00000a
  JCB_MemGroup0                             const  000024
  JCB_MemGroup1                             const  000026
  JCB_MemGroup2                             const  000028
  JCB_MemGroup3                             const  00002a
  JCB_MemGroup4                             const  00002c
  JCB_MemGroup5                             const  00002e
  JCB_Name                                  const  000004
  JCB_Next                                  const  000420
  JCB_NormAttr                              const  000414
  JCB_Number                                const  000000
  JCB_Path                                  const  000080
  JCB_ScrlCnt                               const  00041c
  JCB_Size                                  const  000500
  JCB_SysIn                                 const  000380
  JCB_SysOut                                const  0003b0
  JCB_UserName                              const  000060
  JCB_VideoCols                             const  00040b
  JCB_VideoMode                             const  000408
  JCB_VideoRows                             const  00040a
  JCB_esc                                   const  000470
  JCB_fVidPause                             const  00041e
  JCB_iof_next                              const  000428
  JCB_iof_prev                              const  000430
  JCB_nCode                                 const  000038
  JCB_nData                                 const  000048
  JCB_nStack                                const  000058
  JCB_pCode                                 const  000030
  JCB_pData                                 const  000040
  JCB_pStack                                const  000050
  JCB_pVidMem                               const  0003e8
  JCB_pVidMemAttr                           const  0003f0
  JCB_pVirtVid                              const  0003f8
  JCB_pVirtVidAttr                          const  000400
  KEYBD                                     const  ffdc0000
  KEYBDCLR                                  const  ffdc0004
  KEYBD_DELAY                               const  0003e8
  KeyState1                                   bss  000140
  KeyState2                                   bss  000141
  KeybdBad                                    bss  00013d
  KeybdEcho                                   bss  00013c
  KeybdGetChar                               code  0117c0
  KeybdGetChar.0001                          code  0117f4
  KeybdGetChar.0003                          code  0117cc
  KeybdGetChar.0004                          code  01190c
  KeybdGetChar.0005                          code  011938
  KeybdGetChar.0006                          code  0117f0
  KeybdGetChar.0007                          code  0118a4
  KeybdGetChar.0008                          code  0118b8
  KeybdGetChar.0009                          code  01188c
  KeybdGetChar.0010                          code  011870
  KeybdGetChar.doCapsLock                    code  01195c
  KeybdGetChar.doCtrl                        code  0118f0
  KeybdGetChar.doExtend                      code  0118e0
  KeybdGetChar.doKeyup                       code  0118d4
  KeybdGetChar.doNumLock                     code  011948
  KeybdGetChar.doScrollLock                  code  011970
  KeybdGetChar.doShift                       code  01191c
  KeybdGetCharDirect                         code  0115dc
  KeybdGetCharDirect.0001                    code  0115e4
  KeybdGetCharDirect.gk1                     code  011628
  KeybdGetCharDirect.gk2                     code  011624
  KeybdGetCharDirectNB                       code  011568
  KeybdGetCharDirectNB.0001                  code  0115c8
  KeybdGetCharDirectNB.0002                  code  0115bc
  KeybdGetCharDirectNB.0003                  code  0115b8
  KeybdGetCharNoWait                         code  0117b0
  KeybdGetCharWait                           code  0117b8
  KeybdGetScancode                           code  01170c
  KeybdGetStatus                             code  011700
  KeybdIRQ                                   code  0107d8
  KeybdInit                                  code  01164d
  KeybdInit.0001                             code  011658
  KeybdInit.0002                             code  011668
  KeybdInit.0004                             code  0116e8
  KeybdInit.config                           code  0116a4
  KeybdInit.keybdErr                         code  0116d4
  KeybdInit.tryAgain                         code  0116cc
  KeybdLEDs                                   bss  000143
  KeybdLocks                                  bss  00013e
  KeybdRecvByte                              code  011720
  KeybdRecvByte.0003                         code  01172c
  KeybdRecvByte.0004                         code  011750
  KeybdSendByte                              code  011a08
  KeybdSetLEDStatus                          code  011984
  KeybdSetLEDStatus.0001                     code  0119f8
  KeybdSetLEDStatus.0002                     code  0119a8
  KeybdSetLEDStatus.0003                     code  0119bc
  KeybdSetLEDStatus.0004                     code  0119d0
  KeybdWaitFlag                               bss  000142
  KeybdWaitTx                                code  011760
  KeybdWaitTx.0001                           code  011770
  KeybdWaitTx.0002                           code  01179c
  KillTask                                   code  0146c4
  LEDS                                      const  ffdc0600
  LF                                        const  00000a
  LoadFromSerial                             code  0121c8
  LoadFromSerial.0001                        code  0121dc
  LockFreeMBX                                code  014440
  LockFreeMSG                                code  01445c
  LockFreeTCB                                code  014494
  LockMBX                                    code  014478
  LockSema                                   code  0144cc
  LockSema.0001                              code  0144d8
  LockSema.0002                              code  0144fc
  LockTCB                                    code  0144b0
  MAX_BIOS_CALL                             const  000064
  MAX_TASKNO                                 code  8000000000000383
  MBX_Array                                 const  c60000
  MBX_ArrayEnd                              const  c90000
  MBX_LINK                                  const  000000
  MBX_MQ_COUNT                              const  000040
  MBX_MQ_HEAD                               const  000020
  MBX_MQ_MISSED                             const  000048
  MBX_MQ_SIZE                               const  000038
  MBX_MQ_STRATEGY                           const  000058
  MBX_MQ_TAIL                               const  000028
  MBX_OWNER                                 const  000050
  MBX_Size                                  const  000060
  MBX_TQ_COUNT                              const  000030
  MBX_TQ_HEAD                               const  000008
  MBX_TQ_TAIL                               const  000018
  MEM_END                                   const  8000000
  MON_STACK                                 const  006000
  MON_r1                                      bss  000010
  MON_r10                                     bss  000058
  MON_r11                                     bss  000060
  MON_r12                                     bss  000068
  MON_r13                                     bss  000070
  MON_r14                                     bss  000078
  MON_r15                                     bss  000080
  MON_r16                                     bss  000088
  MON_r17                                     bss  000090
  MON_r18                                     bss  000098
  MON_r19                                     bss  0000a0
  MON_r2                                      bss  000018
  MON_r20                                     bss  0000a8
  MON_r21                                     bss  0000b0
  MON_r22                                     bss  0000b8
  MON_r23                                     bss  0000c0
  MON_r24                                     bss  0000c8
  MON_r25                                     bss  0000d0
  MON_r26                                     bss  0000d8
  MON_r27                                     bss  0000e0
  MON_r28                                     bss  0000e8
  MON_r29                                     bss  0000f0
  MON_r3                                      bss  000020
  MON_r30                                     bss  0000f8
  MON_r31                                     bss  000100
  MON_r4                                      bss  000028
  MON_r5                                      bss  000030
  MON_r6                                      bss  000038
  MON_r7                                      bss  000040
  MON_r8                                      bss  000048
  MON_r9                                      bss  000050
  MQS_NEWEST                                 code  8000000000000353
  MQS_OLDEST                                 code  8000000000000365
  MQS_UNLIMITED                              code  8000000000000362
  MQ_NEWEST                                 const  000002
  MQ_OLDEST                                 const  000001
  MQ_UNLIMITED                              const  000000
  MRTest                                     code  800000000000015f
  MSG_Array                                 const  c90000
  MSG_ArrayEnd                              const  d90000
  MSG_D1                                    const  000008
  MSG_D2                                    const  000010
  MSG_LINK                                  const  000000
  MSG_Size                                  const  000020
  MSG_TYPE                                  const  000018
  MT_GETCHAR                                const  ffffffffffffffef
  MT_IRQ                                    const  fffffffffffffff0
  MT_SEMA                                   const  ffffffffffffffff
  MicroDelay                                 code  012198
  MicroDelay.0001                            code  0121a4
  Milliseconds                                bss  000108
  MonGetch                                   code  010fd8
  Monitor                                    code  010ef6
  NR_JCB                                    const  000033
  NR_MBX                                    const  000800
  NR_MSG                                    const  008000
  NR_PTBL                                   const  000020
  NR_TCB                                    const  000100
  NUMWKA                                      bss  000144
  NormAttr                                    bss  000130
  OutCRLF                                    code  010790
  OutChar                                    code  011118
  OutputVec                                   bss  000110
  PIC                                       const  ffdc0fc0
  PIC_ES                                    const  ffdc0fd0
  PIC_IE                                    const  ffdc0fc4
  PIC_RSTE                                  const  ffdc0fd4
  PN1                                        code  01082c
  PN2                                        code  01082c
  PN3                                        code  01084c
  PN4                                        code  010858
  PN5                                        code  010864
  PN6                                        code  010848
  PNRET                                      code  010878
  PRI_HIGH                                  const  000001
  PRI_HIGHEST                               const  000000
  PRI_LOW                                   const  000005
  PRI_LOWEST                                const  000007
  PRI_NORMAL                                const  000003
  PROG_LOAD_AREA                            const  03b000
  PRTNUM                                     code  010800
  PeekMsg                                    code  0152ec
  PopTimeoutList                             code  014b18
  PostMsg                                    code  014fe4
  QNdx0                                       bss  c00038
  QNdx1                                       bss  c00040
  QNdx2                                       bss  c00048
  QNdx3                                       bss  c00050
  QNdx4                                       bss  c00058
  QNdx5                                       bss  c00060
  QNdx6                                       bss  c00068
  QNdx7                                       bss  c00070
  QueueMsgAtMbx                              code  014d74
  RANDOM_NUM                                const  ffdc0c00
  ROOTDIR_BUF                                 bss  03b000
  RTCCOscOn                                  code  011f10
  RTCCReadbuf                                code  011ec0
  RTCCReadbuf.0001                           code  011ecc
  RTCCWritebuf                               code  011ee8
  RTCCWritebuf.0001                          code  011ef4
  RTCC_BUF                                    bss  0003d0
  RW_READ_SD_BLOCK                          const  000002
  RW_WRITE_SD_BLOCK                         const  000003
  ReleaseIOFocus                             code  800000000000032b
  RemoveFromTimeoutList                      code  014a6c
  RemoveTaskFromReadyList                    code  014920
  RunningTCB                                  bss  c00090
  SCREEN_Array                              const  d90000
  SCREEN_ArrayEnd                           const  e90000
  SC_ALT                                    const  000011
  SC_CAPSLOCK                               const  000058
  SC_CTRL                                   const  000014
  SC_DEL                                    const  000071
  SC_EXTEND                                 const  0000e0
  SC_KEYUP                                  const  0000f0
  SC_LCTRL                                  const  000058
  SC_LSHIFT                                 const  000012
  SC_NUMLOCK                                const  000077
  SC_RSHIFT                                 const  000059
  SC_SCROLLLOCK                             const  00007e
  SDDiskSize                                 code  8000000000000096
  SDInit                                     code  8000000000000092
  SDReadBoot                                 code  8000000000000173
  SDReadMultiple                             code  8000000000000093
  SDReadPart                                 code  8000000000000095
  SDWriteMultiple                            code  8000000000000094
  SD_2_0                                     code  80000000000001f8
  SD_CMD8                                    code  011f80
  SD_CMD8.0001                               code  011ff0
  SD_CMD8.0002                               code  011ff8
  SD_CMD8.0003                               code  012054
  SD_CMD8.0004                               code  012008
  SD_CMD8.respOk                             code  012098
  SD_INIT                                    code  011f34
  SD_MASTER                                 const  ffdc0b00
  SD_WAIT_RESP                               code  0120b0
  SD_WAIT_RESP.0001                          code  0120c4
  SD_WAIT_RESP.0002                          code  0120f0
  SECTOR_BUF                                  bss  03a000
  SPIMASTER                                 const  ffdc0500
  SPI_DIRECT_ACCESS_DATA_REG                const  000018
  SPI_INIT_NO_ERROR                         const  000000
  SPI_INIT_SD                               const  000001
  SPI_MASTER_CONTROL_REG                    const  000004
  SPI_MASTER_VERSION_REG                    const  000000
  SPI_READ_NO_ERROR                         const  000000
  SPI_RESP_BYTE1                            const  0000c0
  SPI_RESP_BYTE2                            const  0000c4
  SPI_RESP_BYTE3                            const  0000c8
  SPI_RESP_BYTE4                            const  0000cc
  SPI_RX_FIFO_CTRL_REG                      const  000050
  SPI_RX_FIFO_DATA_COUNT_LSB                const  00004c
  SPI_RX_FIFO_DATA_COUNT_MSB                const  000048
  SPI_RX_FIFO_DATA_REG                      const  000040
  SPI_SD_SECT_15_8_REG                      const  000020
  SPI_SD_SECT_23_16_REG                     const  000024
  SPI_SD_SECT_31_24_REG                     const  000028
  SPI_SD_SECT_7_0_REG                       const  00001c
  SPI_TRANS_BUSY                            const  000001
  SPI_TRANS_CTRL_REG                        const  00000c
  SPI_TRANS_ERROR_REG                       const  000014
  SPI_TRANS_START                           const  000001
  SPI_TRANS_STATUS_REG                      const  000010
  SPI_TRANS_TYPE_REG                        const  000008
  SPI_TX_FIFO_CTRL_REG                      const  000090
  SPI_TX_FIFO_DATA_REG                      const  000080
  SPI_WRITE_NO_ERROR                        const  000000
  SSM_ISR                                    code  012300
  STACKS_Array                              const  7f00000
  STACKS_ArrayEnd                           const  8000000
  ScreenToAscii                              code  01063c
  ScreenToAscii.stasc1                       code  010650
  ScrollUp                                   code  010df4
  ScrollUp.0001                              code  010e38
  SelectTaskToRun                            code  0156f4
  SelectTaskToRun2                           code  010af8
  SelectTaskToRun2.0001                      code  010b28
  SendMsg                                    code  014ffc
  SendMsgPrim                                code  015018
  SerialCheckForCharDirect                   code  0102fc
  SerialGetChar                              code  010430
  SerialGetCharDirect                        code  0102e0
  SerialIRQ                                  code  0104f4
  SerialPutChar                              code  01030c
  SerialStartMsg                             code  010160
  ServiceRequestIRQ                          code  80000000000000b8
  SetTaskPriority                            code  014861
  SetTaskPriority.stp2                       code  01488c
  SetTaskPriority.stp3                       code  014890
  SetupIntVectors                            code  01018c
  SetupMemtags                               code  012154
  Sleep                                      code  014b48
  StartCPU1Addr                               bss  0003a0
  StartCPU1Flag                               bss  000398
  StartIdleTask                              code  014354
  StartJob                                   code  0143b8
  StartTask                                  code  014508
  StartTask.stask6                           code  0145ac
  SwitchIOFocus                              code  80000000000003b4
  TAB                                       const  000009
  TCB_Affinity                              const  000280
  TCB_Array                                 const  c10000
  TCB_ArrayEnd                              const  c40000
  TCB_BASE                                  const  c00000
  TCB_BackLink                              const  000000
  TCB_DPC                                   const  000188
  TCB_EPC                                   const  000190
  TCB_IPC                                   const  000180
  TCB_MSG_D1                                const  000248
  TCB_MSG_D2                                const  000250
  TCB_MbxList                               const  000260
  TCB_NextFree                              const  000218
  TCB_NextRdy                               const  000200
  TCB_NextTo                                const  000228
  TCB_PrevFree                              const  000220
  TCB_PrevRdy                               const  000208
  TCB_PrevTo                                const  000230
  TCB_Priority                              const  000212
  TCB_SP0Save                               const  000100
  TCB_SP10Save                              const  000150
  TCB_SP11Save                              const  000158
  TCB_SP12Save                              const  000160
  TCB_SP13Save                              const  000168
  TCB_SP14Save                              const  000170
  TCB_SP15Save                              const  000178
  TCB_SP1Save                               const  000108
  TCB_SP2Save                               const  000110
  TCB_SP3Save                               const  000118
  TCB_SP4Save                               const  000120
  TCB_SP5Save                               const  000128
  TCB_SP6Save                               const  000130
  TCB_SP7Save                               const  000138
  TCB_SP8Save                               const  000140
  TCB_SP9Save                               const  000148
  TCB_Size                                  const  000300
  TCB_StackTop                              const  000268
  TCB_Status                                const  000210
  TCB_TOP                                   const  1c00000
  TCB_Timeout                               const  000278
  TCB_errno                                 const  000270
  TCB_hJCB                                  const  000214
  TCB_hWaitMbx                              const  000258
  TCB_mbq_next                              const  000238
  TCB_mbq_prev                              const  000240
  TCB_r1                                    const  000008
  TCB_r10                                   const  000050
  TCB_r11                                   const  000058
  TCB_r12                                   const  000060
  TCB_r13                                   const  000068
  TCB_r14                                   const  000070
  TCB_r15                                   const  000078
  TCB_r16                                   const  000080
  TCB_r17                                   const  000088
  TCB_r18                                   const  000090
  TCB_r19                                   const  000098
  TCB_r2                                    const  000010
  TCB_r20                                   const  0000a0
  TCB_r21                                   const  0000a8
  TCB_r22                                   const  0000b0
  TCB_r23                                   const  0000b8
  TCB_r24                                   const  0000c0
  TCB_r25                                   const  0000c8
  TCB_r26                                   const  0000d0
  TCB_r27                                   const  0000d8
  TCB_r28                                   const  0000e0
  TCB_r29                                   const  0000e8
  TCB_r3                                    const  000018
  TCB_r30                                   const  0000f0
  TCB_r31                                   const  0000f8
  TCB_r4                                    const  000020
  TCB_r5                                    const  000028
  TCB_r6                                    const  000030
  TCB_r7                                    const  000038
  TCB_r8                                    const  000040
  TCB_r9                                    const  000048
  TCBs                                        bss  00a000
  TEXTREG                                   const  0a0000
  TEXTSCR                                   const  000000
  TEXT_COLS                                 const  000000
  TEXT_CURCTL                               const  000020
  TEXT_CURPOS                               const  00002c
  TEXT_ROWS                                 const  000004
  TSSBaseAddress                              bss  00a000
  TS_NONE                                   const  000000
  TS_PREEMPT                                const  000004
  TS_READY                                  const  000010
  TS_READY_BIT                              const  000004
  TS_RUNNING                                const  000008
  TS_RUNNING_BIT                            const  000003
  TS_SLEEP                                  const  000020
  TS_TIMEOUT                                const  000001
  TS_TIMEOUT_BIT                            const  000000
  TS_WAITMSG                                const  000002
  TS_WAITMSG_BIT                            const  000001
  TXTCOLS                                   const  000054
  TXTROWS                                   const  00001f
  TempTCB                                     bss  008000
  Tick1024Rout                               code  010ac8
  Tick1024Rout.0001                          code  010ad4
  TickRout                                   code  010920
  TickRout.SaveContext                       code  010930
  TickRout.acknowledgeInterrupt              code  010a54
  TickVec                                     bss  000128
  Ticks                                       bss  000008
  TimeoutList                                 bss  c00088
  ToJul                                      code  0124e4
  UART                                      const  ffdc0a00
  UART_CM0                                  const  000008
  UART_CM1                                  const  000009
  UART_CM2                                  const  00000a
  UART_CM3                                  const  00000b
  UART_CTRL                                 const  000007
  UART_FF                                   const  000005
  UART_IE                                   const  000004
  UART_IS                                   const  000003
  UART_LS                                   const  000001
  UART_MC                                   const  000006
  UART_MS                                   const  000002
  UART_RX                                   const  000000
  UART_SPR                                  const  00000f
  UART_TX                                   const  000000
  Uart_foff                                   bss  000176
  Uart_fon                                    bss  000178
  Uart_ms                                     bss  00016c
  Uart_rxdtr                                  bss  000174
  Uart_rxfifo                                 bss  00017d
  Uart_rxflow                                 bss  000172
  Uart_rxhead                                 bss  00016e
  Uart_rxrts                                  bss  000173
  Uart_rxtail                                 bss  000170
  Uart_rxxon                                  bss  000175
  Uart_txdtr                                  bss  00017b
  Uart_txrts                                  bss  00017a
  Uart_txxon                                  bss  00017c
  Uart_txxonoff                               bss  00016d
  UpdateCursorPos                            code  010b5c
  UserTick                                    bss  c00000
  UserTickRout                               code  010a98
  VAR_Area                                  const  c00000
  Wait10ms                                   code  011a14
  Wait10ms.0001                              code  011a20
  Wait10ms.0002                              code  011a38
  WaitMsg                                    code  015164
  XOFF                                      const  000013
  XON                                       const  000011
  ambx_bad_ptr                               code  014c40
  ambx_no_mbxs                               code  014c48
  arl1                                       code  0148cc
  arl5                                       code  014900
  attl_add_at_end                            code  0149e0
  attl_add_at_head                           code  014a38
  attl_adjust_timeout                        code  014a20
  attl_check_next                            code  0149c8
  attl_exit                                  code  014a4c
  attl_insert_before                         code  0149f4
  attl_insert_before_head                    code  014a0c
  berr_rout                                  code  01229f
  brkpt1                                     code  01215c
  brkpt1.0001                                code  012178
  cirxb1                                     code  01042c
  clockmsg_d1                                 bss  c00100
  clockmsg_d2                                 bss  c00108
  cmsg1                                      code  015380
  cmsg10                                     code  01533c
  cmsg2                                      code  01538c
  cmsg3                                      code  015324
  cmsg4                                      code  015328
  cmsg5                                      code  0153a8
  cmsg8                                      code  015364
  disk_size                                   bss  000168
  dmfm1                                      code  014ee4
  dmfm2                                      code  014ee0
  dmfm3                                      code  014ef0
  doCLS                                      code  01154e
  doCS                                       code  800000000000015c
  doDate                                     code  011228
  doDate.0001                                code  011268
  doDay                                      code  0112a0
  doDumpmem                                  code  011050
  doDumpmem.001                              code  01105c
  doFillmem                                  code  011070
  doFillmem.0001                             code  0110cc
  doFillmem.0002                             code  0110b4
  doFillmem.0003                             code  0110d4
  doFillmem.0004                             code  011084
  doJump                                     code  01111c
  doRand                                     code  8000000000000161
  doSDBoot                                   code  0110f4
  drf_rout                                   code  012210
  drf_rout.0001                              code  012228
  dtfm2                                      code  014f1c
  dtfm2a                                     code  014f9c
  dtfm3                                      code  014f38
  dtfm3a                                     code  014fb8
  dtfm4                                      code  014f3c
  dtfm4a                                     code  014fbc
  dtfm5                                      code  014f60
  dtl1                                       code  01480c
  dtl2                                       code  01478c
  dtl3                                       code  01479c
  dwf_rout                                   code  01222c
  dwf_rout.0001                              code  012244
  eval                                       code  8000000000000162
  exf_rout                                   code  0121f4
  exf_rout.0001                              code  01220c
  fmbx1                                      code  014d6c
  fmbx10                                     code  014cf4
  fmbx11                                     code  014d24
  fmbx12                                     code  014d30
  fmbx2                                      code  014d50
  fmbx3                                      code  014ccc
  fmbx5                                      code  014c90
  fmbx6                                      code  014cd0
  fmbx7                                      code  014ce4
  fmbx9                                      code  014d10
  freejcb_sema                                bss  c00128
  freembx_sema                                bss  c00138
  freemsg_sema                                bss  c00140
  freetcb_sema                                bss  c00130
  get_datetime                               code  012310
  hangprg                                    code  012144
  icc1                                       code  010dd4
  icr1                                       code  010db4
  ignBlanks                                  code  010ff4
  ignBlanks1                                 code  010ffc
  ijcb1                                      code  01412c
  ijcb2                                      code  0141a4
  iof_sema                                    bss  c00160
  iof_switch                                  bss  c000f8
  it1                                        code  01439c
  it2                                        code  014378
  it3                                        code  014370
  jcb_sema                                    bss  c00178
  jmp_vector                                  bss  000120
  kbdi5                                      code  011634
  kernel_panic                               code  0158f0
  keybdControlCodes                          code  011c50
  keybdExtendedCodes                         code  011cd0
  keybdInIRQ                                  bss  c000f0
  keybdIsSetup                                bss  c000e0
  keybdLock                                   bss  c000e8
  keybd_char                                  bss  c000d8
  keybd_mbx                                   bss  c000d0
  keybdmsg_d1                                 bss  c000c0
  keybdmsg_d2                                 bss  c000c8
  kpan1                                      code  015910
  kpan2                                      code  0158f4
  kt1                                        code  014760
  kt6                                        code  014728
  kt6.self                                   code  01475c
  kt7                                        code  01470c
  ld                                         code  014b94
  loadBootFile                               code  8000000000000174
  mbx_sema                                    bss  c00168
  missed_ticks                                bss  c000b8
  mmu_acc_save                                bss  c00120
  mon1                                       code  010f14
  mon1.Prompt1                               code  010f50
  mon1.Prompt2                               code  010f6c
  mon1.Prompt3                               code  010f38
  mon1.PromptLn                              code  010f2c
  mon1.doHelp                                code  010fc8
  msgBadKeybd                                code  011634
  msgBusErr                                  code  01228a
  msgEA                                      code  01229a
  msgErr                                     code  0114ac
  msgHelp                                    code  0114b4
  msgMonitorStarted                          code  01153d
  msgPriv                                    code  012273
  msgStart                                   code  010ed9
  msgTaskList                                code  014834
  msgUninit                                  code  01227e
  msg_sema                                    bss  c00170
  msgdrf                                     code  012269
  msgdwf                                     code  01226e
  msgexf                                     code  012264
  nMailbox                                    bss  c000a0
  nMsgBlk                                     bss  c000b0
  p100Hz11                                   code  0155d0
  p100Hz12                                   code  0156e8
  p100Hz14                                   code  0156cc
  p100Hz15                                   code  0156a4
  p100Hz4                                    code  01568c
  pSpriteController                          code  012674
  priv_rout                                  code  012248
  priv_rout.0001                             code  012260
  ptl1                                       code  014b2c
  qmam2                                      code  014dfc
  qmam3                                      code  014e2c
  qmam4                                      code  014e30
  qmam6                                      code  014e00
  qmam8                                      code  014e58
  qmam_add_at_head                           code  014df8
  qmam_bad_msg                               code  014e18
  qmam_newest                                code  014e1c
  qmam_oldest                                code  014e98
  qmam_unlimited                             code  014de8
  r1                                         code  014b94
  r11                                        code  010900
  r11.0003                                   code  010918
  r11.0004                                   code  010904
  r2                                         code  011e2c
  r3                                         code  011e2c
  r4                                         code  014b94
  r5                                         code  011e2c
  readylist_sema                              bss  c00150
  resched1                                   code  015520
  reschedule                                 code  015420
  reschedule.0001                            code  015434
  reschedule.0003                            code  01543c
  reschedule.0004                            code  01546c
  reschedule.0005                            code  015480
  reschedule.0006                            code  015474
  rfr2                                       code  01498c
  rftl_empty_list                            code  014ae8
  rftl_not_on_list                           code  014b04
  rftl_not_on_list2                          code  014b14
  rftl_remove_from_head                      code  014ac4
  rxfull                                    const  000001
  set_time_serial                            code  0125b8
  set_time_serial_10                         code  012484
  set_time_serial_12                         code  0124bc
  set_time_serial_14                         code  0124bc
  set_time_serial_17                         code  0125ac
  set_time_serial_19                         code  012668
  set_time_serial_2                          code  012398
  set_time_serial_20                         code  012654
  set_time_serial_4                          code  0123d0
  set_time_serial_6                          code  012408
  set_time_serial_8                          code  01244c
  sgc1                                       code  0102e0
  sgcfifo1                                   code  0104dc
  sgcfifo2                                   code  0104c8
  sgcfifo3                                   code  0104a0
  sgcfifo4                                   code  0104b4
  sgcfifo5                                   code  0104c8
  shiftedScanCodes                           code  011b50
  sirq1                                      code  010538
  sjob1                                      code  014430
  sjob2                                      code  01442c
  sjob3                                      code  01440c
  sjob4                                      code  0143bc
  smp2                                       code  015050
  smsg1                                      code  01511c
  smsg2                                      code  015124
  smsg3                                      code  0150a4
  smsg4                                      code  015140
  smsg5                                      code  015100
  smsg7                                      code  0150ac
  smsg8                                      code  0150c4
  smsg9                                      code  015108
  smsirq                                     code  01054c
  spcabort                                   code  0103f4
  spcb1                                      code  01036c
  spcb2                                      code  0103a4
  spcb3                                      code  010344
  spcb4                                      code  01037c
  spcb5                                      code  0103c0
  spcb6                                      code  0103ac
  spcb7                                      code  0103f0
  spcb8                                      code  0103c8
  sprite_demo                                code  01267c
  sprite_demo_10                             code  01271c
  sprite_demo_11                             code  012794
  sprite_demo_12                             code  01278c
  sprite_demo_13                             code  012794
  sprite_demo_14                             code  012868
  sprite_demo_15                             code  0127a0
  sprite_demo_16                             code  012858
  sprite_demo_17                             code  012850
  sprite_demo_18                             code  012868
  sprite_demo_4                              code  0126b4
  sprite_demo_5                              code  0126ec
  sprite_demo_6                              code  0126e4
  sprite_demo_7                              code  0126f0
  sprite_demo_8                              code  012718
  sprite_demo_9                              code  012710
  sprites                                     bss  03f000
  srxirq                                     code  01055c
  srxirq1                                    code  01055c
  srxirq2                                    code  01057c
  srxirq3                                    code  01058c
  srxirq5                                    code  0105a4
  srxirq6                                    code  0105ec
  srxirq7                                    code  010600
  srxirq8                                    code  010610
  st4                                        code  0141d8
  st4.imbxl1                                 code  01422c
  st5                                        code  01425c
  st5.0001                                   code  014288
  st5.nextTCB                                code  0142b4
  start                                      code  010080
  start.0001                                 code  0100c8
  start.0002                                 code  0100b0
  start.0003                                 code  010094
  startSector                                 bss  000164
  stask1                                     code  014620
  stask2                                     code  0145fc
  strStartQue                                code  015534
  sttr1                                      code  01587c
  sttr2                                      code  015710
  sttr3                                      code  01588c
  sttr5                                      code  015760
  sttr6                                      code  0157d0
  sttr7                                      code  015870
  sttr_badtask                               code  0158d0
  stxirq                                     code  010558
  syscall_exception                          code  0153c4
  syscall_exception.0001                     code  0153d8
  syscall_exception.0002                     code  0153e0
  syscall_vectors                            code  014000
  tcb_sema                                    bss  c00148
  tcbsema_d1                                  bss  c00110
  tcbsema_d2                                  bss  c00118
  tck3                                       code  0156e8
  tolist_sema                                 bss  c00158
  unshiftedScanCodes                         code  011a50
  wmsg1                                      code  0152c4
  wmsg10                                     code  01520c
  wmsg11                                     code  01517c
  wmsg12                                     code  01519c
  wmsg13                                     code  0151b0
  wmsg14                                     code  0151f8
  wmsg2                                      code  0152cc
  wmsg3                                      code  015254
  wmsg5                                      code  015264
  wmsg6                                      code  015238
  wmsg7                                      code  0151e4
  wmsg8                                      code  0152ac
  xtsk1                                      code  0146c0
  xtsk6                                      code  014688
  xtsk7                                      code  014670
