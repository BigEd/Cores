                	; ============================================================================
                	; bootrom.s
                	;        __
                	;   \\__/ o\    (C) 2014  Robert Finch, Stratford
                	;    \  __ /    All rights reserved.
                	;     \/_//     robfinch<remove>@finitron.ca
                	;       ||
                	;  
                	;
                	; This source file is free software: you can redistribute it and/or modify 
                	; it under the terms of the GNU Lesser General Public License as published 
                	; by the Free Software Foundation, either version 3 of the License, or     
                	; (at your option) any later version.                                      
                	;                                                                          
                	; This source file is distributed in the hope that it will be useful,      
                	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                	; GNU General Public License for more details.                             
                	;                                                                          
                	; You should have received a copy of the GNU General Public License        
                	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                	;                                                                          
                	; ============================================================================
                	;
                	TXTCOLS		EQU		84
                	TXTROWS		EQU		31
                	
                	CR	EQU	0x0D		;ASCII equates
                	LF	EQU	0x0A
                	TAB	EQU	0x09
                	CTRLC	EQU	0x03
                	CTRLH	EQU	0x08
                	CTRLI	EQU	0x09
                	CTRLJ	EQU	0x0A
                	CTRLK	EQU	0x0B
                	CTRLM   EQU 0x0D
                	CTRLS	EQU	0x13
                	CTRLX	EQU	0x18
                	XON		EQU	0x11
                	XOFF	EQU	0x13
                	
                	SC_LSHIFT	EQU		$12
                	SC_RSHIFT	EQU		$59
                	SC_KEYUP	EQU		$F0
                	SC_EXTEND	EQU		$E0
                	SC_CTRL		EQU		$14
                	SC_ALT		EQU		$11
                	SC_DEL		EQU		$71		; extend
                	SC_LCTRL	EQU		$58
                	SC_NUMLOCK	EQU		$77
                	SC_SCROLLLOCK	EQU	$7E
                	SC_CAPSLOCK	EQU		$58
                	
                	; Boot sector info (62 byte structure) */
                	BSI_JMP		= 0x00
                	BSI_OEMName	= 0x03
                	BSI_bps		= 0x0B
                	BSI_SecPerCluster	= 0x0D
                	BSI_ResSectors	= 0x0E
                	BSI_FATS	= 0x10
                	BSI_RootDirEnts	= 0x11
                	BSI_Sectors	= 0x13
                	BSI_Media	= 0x15
                	BSI_SecPerFAT	= 0x16
                	BSI_SecPerTrack	= 0x18
                	BSI_Heads	= 0x1A
                	BSI_HiddenSecs	= 0x1C
                	BSI_HugeSecs	= 0x1E
                	
                	BSI_DriveNum	= 0x24
                	BSI_Rsvd1		= 0x25
                	BSI_BootSig		= 0x26
                	BSI_VolID		= 0x27
                	BSI_VolLabel	= 0x2B
                	BSI_FileSysType = 0x36
                	
                	; error codes
                	E_Ok		=		0x00
                	E_Arg		=		0x01
                	E_BadMbx	=		0x04
                	E_QueFull	=		0x05
                	E_NoThread	=		0x06
                	E_NotAlloc	=		0x09
                	E_NoMsg		=		0x0b
                	E_Timeout	=		0x10
                	E_BadAlarm	=		0x11
                	E_NotOwner	=		0x12
                	E_QueStrategy =		0x13
                	E_DCBInUse	=		0x19
                	; Device driver errors
                	E_BadDevNum	=		0x20
                	E_NoDev		=		0x21
                	E_BadDevOp	=		0x22
                	E_ReadError	=		0x23
                	E_WriteError =		0x24
                	E_BadBlockNum	=	0x25
                	E_TooManyBlocks	=	0x26
                	
                	; resource errors
                	E_NoMoreMbx	=		0x40
                	E_NoMoreMsgBlks	=	0x41
                	E_NoMoreAlarmBlks	= 0x44
                	E_NoMoreTCBs	=	0x45
                	E_NoMem		= 12
                	
                	CPU1_IRQ_STACK  EQU     $20800
                	IRQ_STACK   EQU     $8000
                	DBG_STACK   EQU     $7000
                	BIOS_STACK  EQU     $6800
                	MON_STACK   EQU     $6000
                	
                	; task status
                	TS_NONE     EQU     0
                	TS_TIMEOUT	EQU     1
                	TS_WAITMSG	EQU     2
                	TS_PREEMPT	EQU     4
                	TS_RUNNING	EQU     8
                	TS_READY	EQU     16
                	TS_SLEEP	EQU     32
                	
                	TS_TIMEOUT_BIT	EQU 0
                	TS_WAITMSG_BIT	EQU 1
                	TS_RUNNING_BIT	EQU 3
                	TS_READY_BIT	EQU 4
                	
                	LEDS	equ		$FFDC0600
                	
                	BIOS_FREE      EQU       0
                	BIOS_DONE      EQU       1
                	BIOS_INSERVICE EQU       2
                	
                	; The following offsets in the I/O segment
                	TEXTSCR	equ		$00000
                	TEXTREG		EQU		$A0000
                	TEXT_COLS	EQU		0x00
                	TEXT_ROWS	EQU		0x04
                	TEXT_CURPOS	EQU		0x2C
                	TEXT_CURCTL	EQU		0x20
                	
                	BMP_CLUT	EQU		$C5800
                	
                	PIC			EQU		0xFFDC0FC0
                	PIC_IE		EQU		0xFFDC0FC4
                	PIC_ES		EQU		0xFFDC0FD0
                	PIC_RSTE	EQU		0xFFDC0FD4
                	
                	KEYBD		EQU		0xFFDC0000
                	KEYBDCLR	EQU		0xFFDC0004
                	
                	SPIMASTER	EQU		0xFFDC0500
                	SPI_MASTER_VERSION_REG	EQU	0x00
                	SPI_MASTER_CONTROL_REG	EQU	0x04
                	SPI_TRANS_TYPE_REG	EQU		0x08
                	SPI_TRANS_CTRL_REG	EQU		0x0C
                	SPI_TRANS_STATUS_REG	EQU	0x10
                	SPI_TRANS_ERROR_REG		EQU	0x14
                	SPI_DIRECT_ACCESS_DATA_REG		EQU	0x18
                	SPI_SD_SECT_7_0_REG		EQU	0x1C
                	SPI_SD_SECT_15_8_REG	EQU	0x20
                	SPI_SD_SECT_23_16_REG	EQU	0x24
                	SPI_SD_SECT_31_24_REG	EQU	0x28
                	SPI_RX_FIFO_DATA_REG	EQU	0x40
                	SPI_RX_FIFO_DATA_COUNT_MSB	EQU	0x48
                	SPI_RX_FIFO_DATA_COUNT_LSB  EQU 0x4C
                	SPI_RX_FIFO_CTRL_REG		EQU	0x50
                	SPI_TX_FIFO_DATA_REG	EQU	0x80
                	SPI_TX_FIFO_CTRL_REG	EQU	0x90
                	SPI_RESP_BYTE1			EQU	0xC0
                	SPI_RESP_BYTE2			EQU	0xC4
                	SPI_RESP_BYTE3			EQU	0xC8
                	SPI_RESP_BYTE4			EQU	0xCC
                	
                	SPI_INIT_SD			EQU		0x01
                	SPI_TRANS_START		EQU		0x01
                	SPI_TRANS_BUSY		EQU		0x01
                	SPI_INIT_NO_ERROR	EQU		0x00
                	SPI_READ_NO_ERROR	EQU		0x00
                	SPI_WRITE_NO_ERROR	EQU		0x00
                	RW_READ_SD_BLOCK	EQU		0x02
                	RW_WRITE_SD_BLOCK	EQU		0x03
                	
                	I2C_MASTER		EQU		0xFFDC0E00
                	I2C_PRESCALE_LO	EQU		0x00
                	I2C_PRESCALE_HI	EQU		0x01
                	I2C_CONTROL		EQU		0x02
                	I2C_TX			EQU		0x03
                	I2C_RX			EQU		0x03
                	I2C_CMD			EQU		0x04
                	I2C_STAT		EQU		0x04
                	
                	SD_MASTER		EQU		0xFFDC0B00
                	
                	RANDOM_NUM      EQU     0xFFDC0C00
                	
                	UART            EQU     0xFFDC0A00
                	UART_TX         EQU     0
                	UART_RX         EQU     0
                	UART_LS         EQU     1
                	UART_MS         EQU     2
                	UART_IS         EQU     3
                	UART_IE         EQU     4
                	UART_FF         EQU     5
                	UART_MC         EQU     6
                	UART_CTRL       EQU     7
                	UART_CM0        EQU     8
                	UART_CM1        EQU     9
                	UART_CM2        EQU     10
                	UART_CM3        EQU     11
                	UART_SPR        EQU     15
                	
                	TCB_BASE       EQU     $0C00000
                	TCB_TOP        EQU     $1C00000
                	
                	; BIOS request structure
                	BIOS_op        EQU     $00
                	BIOS_arg1      EQU     $08
                	BIOS_arg2      EQU     $10
                	BIOS_arg3      EQU     $18
                	BIOS_arg4      EQU     $20
                	BIOS_arg5      EQU     $28
                	BIOS_resp      EQU     $30
                	BIOS_stat      EQU     $38
                	
                	NR_TCB		EQU		16
                	TCB_BackLink    EQU     0
                	TCB_r1          EQU     8
                	TCB_r2          EQU     $10
                	TCB_r3          EQU     $18
                	TCB_r4          EQU     $20
                	TCB_r5          EQU     $28
                	TCB_r6          EQU     $30
                	TCB_r7          EQU     $38
                	TCB_r8          EQU     $40
                	TCB_r9          EQU     $48
                	TCB_r10         EQU     $50
                	TCB_r11         EQU     $58
                	TCB_r12         EQU     $60
                	TCB_r13         EQU     $68
                	TCB_r14         EQU     $70
                	TCB_r15         EQU     $78
                	TCB_r16         EQU     $80
                	TCB_r17         EQU     $88
                	TCB_r18         EQU     $90
                	TCB_r19         EQU     $98
                	TCB_r20         EQU     $A0
                	TCB_r21         EQU     $A8
                	TCB_r22         EQU     $B0
                	TCB_r23         EQU     $B8
                	TCB_r24         EQU     $C0
                	TCB_r25         EQU     $C8
                	TCB_r26         EQU     $D0
                	TCB_r27         EQU     $D8
                	TCB_r28         EQU     $E0
                	TCB_r29         EQU     $E8
                	TCB_r30         EQU     $F0
                	TCB_r31         EQU     $F8
                	TCB_IPC         EQU     $100
                	TCB_NextRdy     EQU     $200
                	TCB_PrevRdy     EQU     $208
                	TCB_Status      EQU     $210
                	TCB_Priority    EQU     $212
                	TCB_hJCB        EQU     $214
                	TCB_NextFree    EQU     $218
                	TCB_PrevFree    EQU     $220
                	TCB_NextTo      EQU     $228
                	TCB_PrevTo      EQU     $230
                	
                	TCB_Regs		EQU		8
                	TCB_SP0Save		EQU		0x800
                	TCB_SS0Save     EQU     0x808
                	TCB_SP1Save		EQU		0x810
                	TCB_SS1Save     EQU     0x818
                	TCB_SP2Save		EQU		0x820
                	TCB_SS2Save     EQU     0x828
                	TCB_SP3Save		EQU		0x830
                	TCB_SS3Save     EQU     0x838
                	TCB_SP4Save		EQU		0x840
                	TCB_SS4Save     EQU     0x848
                	TCB_SP5Save		EQU		0x850
                	TCB_SS5Save     EQU     0x858
                	TCB_SP6Save		EQU		0x860
                	TCB_SS6Save     EQU     0x868
                	TCB_SP7Save		EQU		0x870
                	TCB_SS7Save     EQU     0x878
                	TCB_SP8Save		EQU		0x880
                	TCB_SS8Save     EQU     0x888
                	TCB_SP9Save		EQU		0x890
                	TCB_SS9Save     EQU     0x898
                	TCB_SP10Save	EQU		0x8A0
                	TCB_SS10Save    EQU     0x8A8
                	TCB_SP11Save	EQU		0x8B0
                	TCB_SS11Save    EQU     0x8B8
                	TCB_SP12Save	EQU		0x8C0
                	TCB_SS12Save    EQU     0x8C8
                	TCB_SP13Save	EQU		0x8D0
                	TCB_SS13Save    EQU     0x8D8
                	TCB_SP14Save	EQU		0x8E0
                	TCB_SS14Save    EQU     0x8E8
                	TCB_SP15Save	EQU		0x8F0
                	TCB_SS15Save    EQU     0x8F8
                	TCB_Seg0Save    EQU     0x900
                	TCB_Seg1Save	EQU		0x908
                	TCB_Seg2Save	EQU		0x910
                	TCB_Seg3Save	EQU		0x918
                	TCB_Seg4Save	EQU		0x920
                	TCB_Seg5Save	EQU		0x928
                	TCB_Seg6Save	EQU		0x930
                	TCB_Seg7Save	EQU		0x938
                	TCB_Seg8Save	EQU		0x940
                	TCB_Seg9Save	EQU		0x948
                	TCB_Seg10Save	EQU		0x950
                	TCB_Seg11Save	EQU		0x958
                	TCB_Seg12Save	EQU		0x960
                	TCB_Seg13Save	EQU		0x968
                	TCB_Seg14Save	EQU		0x970
                	TCB_Seg15Save	EQU		0x978
                	TCB_PCSave      EQU     0x980
                	TCB_SPSave		EQU		0x988
                	TCB_Next		EQU		0xA00
                	TCB_Prev		EQU		0xA08
                	
                	
                	TCB_Size	EQU		1024
                	
                		code
                		org		$00010000
010000 3A 10 00 00 		bra     start
010004 00 00 00 00 		align   
                	
010008 78 06 01 00 		dw		ClearScreen		; $8000
01000C 00 00 00 00 
010010 64 06 01 00 		dw		HomeCursor		; $8008
010014 00 00 00 00 
010018 58 07 01 00 		dw		DisplayString	; $8010
01001C 00 00 00 00 
010020 54 1B 01 00 		dw		KeybdGetCharNoWait; $8018
010024 00 00 00 00 
010028 0E 01 00 00 		dw		ClearBmpScreen	; $8020
01002C 00 00 00 80 
010030 8C 10 01 00 		dw		DisplayChar		; $8028
010034 00 00 00 00 
010038 10 01 00 00 		dw		SDInit			; $8030
01003C 00 00 00 80 
010040 11 01 00 00 		dw		SDReadMultiple	; $8038
010044 00 00 00 80 
010048 12 01 00 00 		dw		SDWriteMultiple	; $8040
01004C 00 00 00 80 
010050 13 01 00 00 		dw		SDReadPart		; $8048
010054 00 00 00 80 
010058 14 01 00 00 		dw		SDDiskSize		; $8050
01005C 00 00 00 80 
010060 D8 06 01 00 		dw		DisplayWord		; $8058
010064 00 00 00 00 
010068 EC 06 01 00 		dw		DisplayHalf		; $8060
01006C 00 00 00 00 
010070 00 07 01 00 		dw		DisplayCharHex	; $8068
010074 00 00 00 00 
010078 14 07 01 00 		dw		DisplayByte		; $8070
01007C 00 00 00 00 
                	message "start"
                	start:
010080 02 00 02 6E 	    sei     ; interrupts off
010084 02 10 00 6C 	    cpuid   r1,r0,#0
010088 BD 00 14 00 	    beq     r1,.0002
01008C 7C C1 00 00 	    ldi     tr,#$C10000          ; IDLE task for CPU #1
010090 0A 80 01 00 
                	.0003:
010094 7C 02 00 00 	    inc     $20000
010098 64 10 00 00 
01009C 46 10 80 01 	    lw      r1,StartCPU1Flag
0100A0 7C 34 12 00 	    cmp     r1,r1,#$12345678
0100A4 86 10 F0 AC 
0100A8 BD 10 F6 FF 	    bne     r1,.0003
0100AC 3E 00 90 01 	    jmp     (StartCPU1Addr)
                	.0002:
0100B0 7C 00 00 00 	    ldi     sp,#MON_STACK        ; set stack pointer to top of 32k Area
0100B4 0A E0 01 C0 
0100B8 7C C0 00 00 		ldi     tr,#$C00000          ; load task register with IDLE task
0100BC 0A 80 01 00 
0100C0 0A 50 00 00 	    ldi     r5,#$0000
0100C4 0A 10 28 00 	    ldi     r1,#20
                	.0001:
0100C8 7C DC FF 00 	    sc      r5,LEDS
0100CC 61 50 00 0C 
0100D0 94 52 02 00 	    addui   r5,r5,#1
0100D4 63 00 20 00 		sw		r0,Milliseconds
0100D8 0A 10 FE FF 		ldi     r1,#-1
0100DC 63 10 60 01 		sw      r1,API_sema
0100E0 63 00 70 01 		sw      r0,BIOS_sema
0100E4 FC 26 00 00 		ldi		r1,#%000000100_110101110_0000000000
0100E8 0A 10 00 70 
0100EC 60 10 08 01 		sb		r1,KeybdEcho
0100F0 60 00 0A 01 		sb		r0,KeybdBad
0100F4 62 10 F0 00 		sh		r1,NormAttr
0100F8 60 00 00 01 		sb		r0,CursorRow
0100FC 60 00 02 01 		sb		r0,CursorCol
010100 7C 01 00 00 		ldi		r1,#DisplayChar
010104 0A 10 18 21 
010108 63 10 30 00 		sw		r1,OutputVec
01010C B9 AD 00 00 		bsr		ClearScreen
010110 B9 AA 00 00 		bsr		HomeCursor
010114 7C 01 00 00 		ldi     r1,#msgStart
010118 0A 10 EA 26 
01011C B9 CD 00 00 		bsr     DisplayStringCRLF
010120 0A 10 10 00 		ldi     r1,#8
010124 7C DC FF 00 		sb      r1,LEDS
010128 60 10 00 0C 
01012C 39 0A 00 00 		bsr		SetupIntVectors
                	;	bsr		KeybdInit
010130 B9 D7 00 00 	    bsr     InitFMTK
010134 39 22 00 00 		bsr		InitPIC
010138 39 25 00 00 		bsr     InitUart
01013C B9 24 04 00 		bsr     RTCCReadbuf          ; read the real-time clock
010140 39 03 05 00 		bsr     set_time_serial      ; set the system time serial
010144 BA 49 02 00 		bra		Monitor
010148 39 FD DF FF 		bsr		FMTKInitialize
01014C 02 00 00 6E 		cli
                	
                	SerialStartMsg:
010150 E7 EF 01 00 	    push    lr
010154 7C 01 00 00 		ldi     r1,#SerialPutChar
010158 0A 10 00 06 
01015C 63 10 30 00 		sw      r1,OutputVec
010160 7C 01 00 00 		ldi     r1,#msgStart
010164 0A 10 EA 26 
010168 39 C4 00 00 		bsr     DisplayStringCRLF
01016C 7C 01 00 00 		ldi		r1,#DisplayChar
010170 0A 10 18 21 
010174 63 10 30 00 		sw		r1,OutputVec
010178 3B FF 11 00 	    rts
 
                	SetupIntVectors:
01017C 0A 10 4E 01 		ldi     r1,#$00A7
010180 7C DC FF 00 		sc      r1,LEDS
010184 61 10 00 0C 
010188 02 00 14 3C 		mtspr   vbr,r0               ; place vector table at $0000
01018C 3F 00 00 00 		nop
010190 3F 00 00 00 		nop
010194 02 20 14 3E 		mfspr   r2,vbr
010198 7C 01 00 00 		ldi		r1,#Tick1024Rout
01019C 0A 10 C8 1E 
0101A0 63 11 20 1C 		sw		r1,450*8[r2]
0101A4 7C 01 00 00 		ldi		r1,#TickRout         ; This vector will be taken over by FMTK
0101A8 0A 10 D8 1B 
0101AC 63 11 30 1C 		sw		r1,451*8[r2]
0101B0 7C 01 00 00 		ldi     r1,#SerialIRQ
0101B4 0A 10 E0 09 
0101B8 63 11 80 1C 		sw      r1,456*8[r2]
0101BC 7C 01 00 00 		ldi     r1,#ServiceRequestIRQ
0101C0 0A 10 D8 1B 
0101C4 63 11 90 1C 		sw      r1,457*8[r2]
0101C8 7C 01 00 00 		ldi		r1,#KeybdIRQ
0101CC 0A 10 B8 0F 
0101D0 63 11 F0 1C 		sw		r1,463*8[r2]
0101D4 7C 01 00 00 	    ldi     r1,#SSM_ISR          ; set ISR vector for single step routine
0101D8 0A 10 40 4D 
0101DC 63 11 F0 1E 	    sw      r1,495*8[r2]
0101E0 7C 01 00 00 	    ldi     r1,#IBPT_ISR         ; set ISR vector for instruction breakpoint routine
0101E4 0A 10 48 4D 
0101E8 63 11 00 1F 	    sw      r1,496*8[r2]
0101EC 7C 01 00 00 		ldi		r1,#exf_rout
0101F0 0A 10 28 4B 
0101F4 63 11 10 1F 		sw		r1,497*8[r2]
0101F8 7C 01 00 00 		ldi		r1,#dwf_rout
0101FC 0A 10 98 4B 
010200 63 11 20 1F 		sw		r1,498*8[r2]
010204 7C 01 00 00 		ldi		r1,#drf_rout
010208 0A 10 60 4B 
01020C 63 11 30 1F 		sw		r1,499*8[r2]
010210 7C 01 00 00 		ldi		r1,#priv_rout
010214 0A 10 D0 4B 
010218 63 11 50 1F 		sw		r1,501*8[r2]
01021C 7C 01 00 00 		ldi		r1,#berr_rout
010220 0A 10 7E 4C 
010224 63 11 C0 1F 		sw		r1,508*8[r2]
010228 7C 01 00 00 		ldi		r1,#berr_rout
01022C 0A 10 7E 4C 
010230 63 11 D0 1F 		sw		r1,509*8[r2]
010234 0A 10 54 01 		ldi     r1,#$00AA
010238 7C DC FF 00 		sc      r1,LEDS
01023C 61 10 00 0C 
010240 37 FF 01 00 	    rtl
 
                	;------------------------------------------------------------------------------
                	; Initialize the interrupt controller.
                	;------------------------------------------------------------------------------
                	
                	InitPIC:
010244 0A 10 18 04 		ldi		r1,#$020C		; timer interrupt(s) are edge sensitive
010248 7C DC FF 00 		sh		r1,PIC_ES
01024C 62 10 A0 1F 
010250 0A 10 1E 04 		ldi		r1,#$020F		; enable keyboard reset, timer interrupts
010254 7C DC FF 00 		sh		r1,PIC_IE
010258 62 10 88 1F 
01025C 37 FF 01 00 		rtl

                	
                	;==============================================================================
                	; Serial port
                	;==============================================================================
                		code
                	;------------------------------------------------------------------------------
                	; Initialize UART
                	;------------------------------------------------------------------------------
                	
                	InitUart:
010260 7C DC FF 00 	    ldi     r2,#UART
010264 0A 20 00 14 
                	;    ldi     r1,#$025BF7BA   ; constant for clock multiplier with 16.667MHz clock for 9600 baud
010268 FC 27 0E 00 	    ldi     r1,#$0E27CE61   ; constant for clock multiplier with 16.667MHz clock for 57600 baud
01026C 0A 10 C2 9C 
010270 82 10 10 72 	    lsr     r1,r1,#8          ; drop the LSB (not used)
010274 60 11 12 00 	    sb      r1,UART_CM1[r2]
010278 82 10 10 72 	    lsr     r1,r1,#8
01027C 60 11 14 00 	    sb      r1,UART_CM2[r2]
010280 82 10 10 72 	    lsr     r1,r1,#8
010284 60 11 16 00 	    sb      r1,UART_CM3[r2]
010288 60 01 0E 00 	    sb      r0,UART_CTRL[r2]           ; no hardware flow control
01028C 61 00 2C 01 		sc		r0,Uart_rxhead			; reset buffer indexes
010290 61 00 30 01 		sc		r0,Uart_rxtail
010294 0A 10 E0 03 		ldi		r1,#0x1f0
010298 61 10 3C 01 		sc		r1,Uart_foff		; set threshold for XOFF
01029C 0A 10 20 00 		ldi		r1,#0x010
0102A0 61 10 40 01 		sc		r1,Uart_fon			; set threshold for XON
0102A4 0A 10 02 00 		ldi		r1,#1
0102A8 60 11 08 00 		sb		r1,UART_IE[r2]		; enable receive interrupt only
0102AC 60 00 36 01 		sb		r0,Uart_rxrts		; no RTS/CTS signals available
0102B0 60 00 44 01 		sb		r0,Uart_txrts		; no RTS/CTS signals available
0102B4 60 00 46 01 		sb		r0,Uart_txdtr		; no DTR signals available
0102B8 60 00 38 01 		sb		r0,Uart_rxdtr		; no DTR signals available
0102BC 0A 10 02 00 		ldi		r1,#1
0102C0 60 10 48 01 		sb		r1,Uart_txxon		; for now
0102C4 0A 10 02 00 		ldi		r1,#1
                	;	sb		r1,SERIAL_SEMA
0102C8 37 FF 01 00 	    rtl

                	;---------------------------------------------------------------------------------
                	; Get character directly from serial port. Blocks until a character is available.
                	;---------------------------------------------------------------------------------
                	;
                	SerialGetCharDirect:
                	sgc1:
0102CC 7C DC FF 00 		lb		r1,UART+UART_LS	; uart status
0102D0 40 10 02 14 
0102D4 8C 10 02 00 		and		r1,r1,#1		; is there a char available ?
0102D8 BD 00 FA FF 		beq		r1,sgc1
0102DC 7C DC FF 00 		lb		r1,UART+UART_RX
0102E0 40 10 00 14 
0102E4 37 FF 01 00 		rtl

                	;------------------------------------------------
                	; Check for a character at the serial port
                	; returns r1 = 1 if char available, 0 otherwise
                	;------------------------------------------------
                	;
                	SerialCheckForCharDirect:
0102E8 7C DC FF 00 		lb		r1,UART+UART_LS			; uart status
0102EC 40 10 02 14 
0102F0 7C 00 00 00 		and		r1,r1,#rxfull			; is there a char available ?
0102F4 7C 00 00 00 
0102F8 8C 10 96 02 
0102FC 37 FF 01 00 		rtl

                	;-----------------------------------------
                	; Put character to serial port
                	; r1 = char to put
                	;-----------------------------------------
                	;
                	SerialPutChar:
010300 67 E1 01 00 	    push    r2
010304 E7 E1 01 00 	    push    r3
010308 67 E2 01 00 		push	r4
01030C E7 E2 01 00 		push	r5
010310 67 E3 01 00 	    push    r6
010314 7C DC FF 00 	    ldi     r6,#UART
010318 0A 60 00 14 
01031C 40 23 0C 00 		lb		r2,UART_MC[r6]
010320 0D 21 06 00 		or		r2,r2,#3		; assert DTR / RTS
010324 60 23 0C 00 		sb		r2,UART_MC[r6]
010328 40 20 44 01 		lb		r2,Uart_txrts
01032C 3D 01 1A 00 		beq		r2,spcb1
010330 46 40 20 00 		lw		r4,Milliseconds
010334 0A 30 00 08 		ldi		r3,#1024		; delay count (1 s)
                	spcb3:
010338 40 23 04 00 		lb		r2,UART_MS[r6]
01033C 0C 21 20 00 		and		r2,r2,#$10		; is CTS asserted ?
010340 3D 11 10 00 		bne		r2,spcb1
010344 46 50 20 00 		lw		r5,Milliseconds
010348 02 22 0A 0C 		cmp		r2,r4,r5
01034C 3D 01 F6 FF 		beq		r2,spcb3
010350 82 42 00 1A 		mov		r4,r5
010354 95 31 02 00 		subui   r3,r3,#1
010358 BD 11 F0 FF 		bne		r3,spcb3
01035C BA 11 00 00 		bra		spcabort
                	spcb1:
010360 40 20 46 01 		lb		r2,Uart_txdtr
010364 3D 01 1A 00 		beq		r2,spcb2
010368 46 40 20 00 		lw		r4,Milliseconds
01036C 0A 30 00 08 		ldi		r3,#1024		; delay count
                	spcb4:
010370 40 23 04 00 		lb		r2,UART_MS[r6]
010374 0C 21 40 00 		and		r2,r2,#$20		; is DSR asserted ?
010378 3D 11 10 00 		bne		r2,spcb2
01037C 46 50 20 00 		lw		r5,Milliseconds
010380 02 22 0A 0C 		cmp		r2,r4,r5
010384 3D 01 F6 FF 		beq		r2,spcb4
010388 82 42 00 1A 		mov		r4,r5
01038C 95 31 02 00 		subui   r3,r3,#1
010390 BD 11 F0 FF 		bne		r3,spcb4
010394 BA 0A 00 00 		bra		spcabort
                	spcb2:	
010398 40 20 48 01 		lb		r2,Uart_txxon
01039C 3D 01 0C 00 		beq		r2,spcb5
                	spcb6:
0103A0 40 20 2A 01 		lb		r2,Uart_txxonoff
0103A4 3D 01 08 00 		beq		r2,spcb5
0103A8 40 43 04 00 		lb		r4,UART_MS[r6]
0103AC 0C 42 00 01 		and		r4,r4,#0x80			; DCD ?
0103B0 3D 12 F8 FF 		bne		r4,spcb6
                	spcb5:
0103B4 46 40 20 00 		lw		r4,Milliseconds
0103B8 0A 30 00 08 		ldi		r3,#1024			; wait up to 1s
                	spcb8:
0103BC 40 23 02 00 		lb		r2,UART_LS[r6]
0103C0 0C 21 40 00 		and		r2,r2,#0x20			; tx not full ?
0103C4 3D 11 10 00 		bne		r2,spcb7
0103C8 46 50 20 00 		lw		r5,Milliseconds
0103CC 02 22 0A 0C 		cmp		r2,r4,r5
0103D0 3D 01 F6 FF 		beq		r2,spcb8
0103D4 82 42 00 1A 		mov		r4,r5
0103D8 95 31 02 00 		subui   r3,r3,#1
0103DC BD 11 F0 FF 		bne		r3,spcb8
0103E0 3A 01 00 00 		bra		spcabort
                	spcb7:
0103E4 60 13 00 00 		sb		r1,UART_TX[r6]
                	spcabort:
0103E8 57 6F 10 00 	    pop     r6
0103EC 57 5F 10 00 		pop		r5
0103F0 57 4F 10 00 		pop		r4
0103F4 57 3F 10 00 		pop     r3
0103F8 57 2F 10 00 		pop     r2
0103FC 37 FF 01 00 		rtl

                	
                	;-------------------------------------------------
                	; Compute number of characters in recieve buffer.
                	; r4 = number of chars
                	;-------------------------------------------------
                	CharsInRxBuf:
010400 43 40 2C 01 		lcu		r4,Uart_rxhead
010404 43 30 30 01 		lcu		r3,Uart_rxtail
010408 02 42 06 2A 		subu	r4,r4,r3
01040C 3D 22 0A 00 		bgt		r4,cirxb1
010410 0A 40 00 04 		ldi		r4,#0x200
010414 02 42 06 28 		addu	r4,r4,r3
010418 43 30 2C 01 		lcu		r3,Uart_rxhead
01041C 02 42 06 2A 		subu	r4,r4,r3
                	cirxb1:
010420 37 FF 01 00 		rtl

                	;----------------------------------------------
                	; Get character from rx fifo
                	; If the fifo is empty enough then send an XON
                	;----------------------------------------------
                	;
                	SerialGetChar:
010424 67 E1 01 00 	    push    r2
010428 E7 E1 01 00 	    push    r3
01042C 67 E2 01 00 		push	r4
010430 E7 E2 01 00 	    push    r5
010434 7C DC FF 00 	    ldi     r5,#UART
010438 0A 50 00 14 
01043C 43 30 2C 01 		lcu		r3,Uart_rxhead
010440 43 20 30 01 		lcu		r2,Uart_rxtail
010444 02 31 06 0C 		cmp		r3,r2,r3
010448 BD 01 48 00 		beq		r3,sgcfifo1		    ; is there a char available ?
01044C 7C 00 00 00 		lbu		r1,Uart_rxfifo[r2]	; get the char from the fifo into r1
010450 7C 00 00 00 
010454 41 11 B4 02 
010458 14 21 02 00 		addui   r2,r2,#1    		; increment the fifo pointer
01045C 0C 21 FE 03 		and		r2,r2,#$1ff
010460 61 20 30 01 		sc		r2,Uart_rxtail
010464 40 20 34 01 		lb		r2,Uart_rxflow		; using flow control ?
010468 3D 01 2E 00 		beq		r2,sgcfifo2
01046C 43 30 40 01 		lcu		r3,Uart_fon		; enough space in Rx buffer ?
010470 E7 EF 01 00 		push    lr
010474 B9 F1 FF FF 		bsr		CharsInRxBuf
010478 57 FF 11 00 		pop     lr
01047C 02 42 06 0C 		cmp		r4,r4,r3
010480 3D 22 22 00 		bgt		r4,sgcfifo2
010484 60 00 34 01 		sb		r0,Uart_rxflow		; flow off
010488 40 40 36 01 		lb		r4,Uart_rxrts
01048C 3D 02 08 00 		beq		r4,sgcfifo3
010490 C0 42 0C 00 		lb		r4,UART_MC[r5]		; set rts bit in MC
010494 0D 42 04 00 		or		r4,r4,#2
010498 E0 42 0C 00 		sb		r4,UART_MC[r5]
                	sgcfifo3:
01049C 40 40 38 01 		lb		r4,Uart_rxdtr
0104A0 3D 02 08 00 		beq		r4,sgcfifo4
0104A4 C0 42 0C 00 		lb		r4,UART_MC[r5]		; set DTR
0104A8 0D 42 02 00 		or		r4,r4,#1
0104AC E0 42 0C 00 		sb		r4,UART_MC[r5]
                	sgcfifo4:
0104B0 40 40 3A 01 		lb		r4,Uart_rxxon
0104B4 3D 02 08 00 		beq		r4,sgcfifo5
0104B8 0A 40 22 00 		ldi		r4,#XON
0104BC 7C DC FF 00 		sb		r4,UART[r5]
0104C0 E0 42 00 14 
                	sgcfifo5:
                	sgcfifo2:					; return with char in r1
0104C4 57 5F 10 00 	    pop     r5
0104C8 57 4F 10 00 		pop		r4
0104CC 57 3F 10 00 		pop     r3
0104D0 57 2F 10 00 		pop     r2
0104D4 37 FF 01 00 		rtl
sgcfifo1:
0104D8 0A 10 FE FF 		ldi		r1,#-1				; no char available
0104DC 57 5F 10 00 		pop     r5
0104E0 57 4F 10 00 		pop		r4
0104E4 57 3F 10 00 		pop     r3
0104E8 57 2F 10 00 		pop     r2
0104EC 3B FF 11 00 		rts

                	
                	;-----------------------------------------
                	; Serial port IRQ
                	;-----------------------------------------
                	;
                	SerialIRQ:
0104F0 FC 00 00 00 	    ldi     sp,#$8000
0104F4 0A E0 01 00 
0104F8 E7 E0 01 00 		push    r1
0104FC 67 E1 01 00 		push    r2
010500 E7 E1 01 00 		push    r3
010504 67 E2 01 00 		push	r4
                	
010508 7C DC FF 00 	    ldi     r2,#UART
01050C 0A 20 00 14 
010510 40 11 06 00 	    lb      r1,UART_IS[r2]  ; get interrupt status
010514 BD 20 10 00 		bgt		r1,sirq1		; no interrupt
010518 8C 10 FE 00 		and		r1,r1,#0x7f  	; switch on interrupt type
01051C 86 30 08 00 		cmp		r3,r1,#4
010520 BD 01 1C 00 		beq		r3,srxirq
010524 86 30 18 00 		cmp		r3,r1,#$0C
010528 BD 01 16 00 		beq		r3,stxirq
01052C 86 30 20 00 		cmp		r3,r1,#$10
010530 BD 01 0C 00 		beq		r3,smsirq
                		; unknown IRQ type
                	sirq1:
010534 57 4F 10 00 		pop		r4
010538 57 3F 10 00 		pop     r3
01053C 57 2F 10 00 		pop     r2
010540 57 1F 10 00 		pop     r1
010544 02 E0 3F 6E 		rti
                	
                	; Get the modem status and record it
                	smsirq:
010548 41 11 04 00 	    lbu     r1,UART_MS[r2]
01054C 60 10 28 01 		sb      r1,Uart_ms
010550 BA FC FF FF 		bra		sirq1
                	
                	stxirq:
010554 3A FC FF FF 		bra		sirq1
                	
                	; Get a character from the uart and store it in the rx fifo
                	srxirq:
                	srxirq1:
010558 41 11 00 00 	    lbu     r1,UART_RX[r2]      ; get the char (clears interrupt)
01055C 41 30 48 01 	    lbu     r3,Uart_txxon
010560 BD 01 14 00 		beq		r3,srxirq3
010564 86 40 26 00 		cmp		r4,r1,#XOFF
010568 3D 12 08 00 		bne		r4,srxirq2
01056C 0A 10 02 00 		ldi     r1,#1
010570 60 10 2A 01 		sb		r1,Uart_txxonoff
010574 BA 06 00 00 		bra		srxirq5
                	srxirq2:
010578 86 40 22 00 		cmp		r4,r1,#XON
01057C 3D 12 06 00 		bne		r4,srxirq3
010580 60 00 2A 01 		sb		r0,Uart_txxonoff
010584 BA 04 00 00 		bra		srxirq5
                	srxirq3:
010588 60 00 2A 01 		sb		r0,Uart_txxonoff
01058C 43 40 2C 01 		lcu		r4,Uart_rxhead
010590 7C 00 00 00 		sb		r1,Uart_rxfifo[r4]  ; store in buffer
010594 7C 00 00 00 
010598 60 12 B4 02 
01059C 14 42 02 00 		addui   r4,r4,#1
0105A0 0C 42 FE 03 		and		r4,r4,#$1ff
0105A4 61 40 2C 01 		sc		r4,Uart_rxhead
                	srxirq5:
0105A8 40 11 02 00 	    lb      r1,UART_LS[r2]      ; check for another ready character
0105AC 8C 10 02 00 		and		r1,r1,#1            ; check rxfull bit
0105B0 BD 10 D4 FF 		bne		r1,srxirq1          ; loop back for another character
0105B4 40 10 34 01 		lb		r1,Uart_rxflow		; are we using flow controls?
0105B8 BD 10 2E 00 		bne		r1,srxirq8
0105BC E7 EF 01 00 		push    lr
0105C0 39 C8 FF FF 		bsr		CharsInRxBuf
0105C4 57 FF 11 00 		pop     lr
0105C8 40 10 3C 01 		lb		r1,Uart_foff
0105CC 02 12 02 0C 		cmp		r1,r4,r1
0105D0 BD 40 22 00 		blt		r1,srxirq8
0105D4 0A 10 02 00 		ldi		r1,#1
0105D8 60 10 34 01 		sb		r1,Uart_rxflow
0105DC 40 10 36 01 		lb		r1,Uart_rxrts
0105E0 BD 00 08 00 		beq		r1,srxirq6
0105E4 40 11 0C 00 		lb		r1,UART_MC[r2]
0105E8 8C 10 FA 01 		and		r1,r1,#$FD		; turn off RTS
0105EC 60 11 0C 00 		sb		r1,UART_MC[r2]
                	srxirq6:
0105F0 40 10 38 01 		lb		r1,Uart_rxdtr
0105F4 BD 00 08 00 		beq		r1,srxirq7
0105F8 40 11 0C 00 		lb		r1,UART_MC[r2]
0105FC 8C 10 FC 01 		and		r1,r1,#$FE		; turn off DTR
010600 60 11 0C 00 		sb		r1,UART_MC[r2]
                	srxirq7:
010604 40 10 3A 01 		lb		r1,Uart_rxxon
010608 BD 00 06 00 		beq		r1,srxirq8
01060C 0A 10 26 00 		ldi		r1,#XOFF
010610 60 11 00 00 		sb		r1,UART_TX[r2]
                	srxirq8:
010614 3A E4 FF FF 		bra		sirq1
                	
                	
                	
                	;------------------------------------------------------------------------------
                	; Convert ASCII character to screen display character.
                	;------------------------------------------------------------------------------
                	
                	AsciiToScreen:
010618 67 E1 01 00 	    push    r2
01061C 8C 10 FE 01 		and		r1,r1,#$FF
010620 8D 10 00 02 		or		r1,r1,#$100
010624 8C 20 40 00 		and		r2,r1,#%00100000	; if bit 5 or 6 isn't set
010628 3D 01 08 00 		beq		r2,.00001
01062C 8C 20 80 00 		and		r2,r1,#%01000000
010630 3D 01 04 00 		beq		r2,.00001
010634 8C 10 3E 03 		and		r1,r1,#%110011111
                	.00001:
010638 57 2F 10 00 	    pop     r2
01063C 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; Convert screen display character to ascii.
                	;------------------------------------------------------------------------------
                	
                	ScreenToAscii:
010640 67 E1 01 00 	    push    r2
010644 8C 10 FE 01 		and		r1,r1,#$FF
010648 96 20 36 00 		cmpu	r2,r1,#26+1
01064C 3D 31 04 00 		bge		r2,.stasc1
010650 84 10 C0 00 		add		r1,r1,#$60
                	.stasc1:
010654 57 2F 10 00 	    pop     r2
010658 37 FF 01 00 		rtl

                	CursorOff:
01065C 37 FF 01 00 		rtl
CursorOn:
010660 37 FF 01 00 		rtl
HomeCursor:
010664 60 00 00 01 		sb		r0,CursorRow
010668 60 00 02 01 		sb		r0,CursorCol
01066C 7C DA FF 00 		sc	    r0,TEXTREG+TEXT_CURPOS+$FFD00000
010670 61 00 58 00 
010674 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	                                                                               
                	ClearScreen:
010678 E7 EF 01 00 	    push    lr
01067C E7 E0 01 00 	    push	r1
010680 67 E1 01 00 	    push    r2
010684 E7 E1 01 00 	    push    r3
010688 67 E2 01 00 	    push    r4
01068C 7C DA FF 00 		lbu	    r1,TEXTREG+TEXT_COLS+$FFD00000
010690 41 10 00 00 
010694 7C DA FF 00 		lbu	    r2,TEXTREG+TEXT_ROWS+$FFD00000
010698 41 20 08 00 
01069C 02 41 02 2E 		mulu	r4,r2,r1
0106A0 7C D0 FF 00 		ldi		r3,#TEXTSCR+$FFD00000
0106A4 0A 30 00 00 
0106A8 0A 10 40 00 		ldi		r1,#' '
0106AC B9 ED FF FF 		bsr		AsciiToScreen
0106B0 45 20 F0 00 		lhu		r2,NormAttr
0106B4 82 10 04 1A 		or		r1,r1,r2
                	.cs1:
0106B8 EA 11 88 00 	    sh	    r1,[r3+r4*4]
0106BC 15 42 02 00 	    subui   r4,r4,#1
0106C0 3D 12 FC FF 		bne	    r4,.cs1
0106C4 57 4F 10 00 		pop     r4
0106C8 57 3F 10 00 		pop     r3
0106CC 57 2F 10 00 		pop     r2
0106D0 57 1F 10 00 		pop     r1
0106D4 3B FF 11 00 	    rts

                	;------------------------------------------------------------------------------
                	; Display the word in r1
                	;------------------------------------------------------------------------------
                	
                	DisplayWord:
0106D8 E7 EF 01 00 	    push    lr
0106DC 82 10 40 74 		rol	    r1,r1,#32
0106E0 B9 01 00 00 		bsr		DisplayHalf
0106E4 82 10 40 74 		rol	    r1,r1,#32
0106E8 57 FF 11 00 	    pop     lr
                	
                	;------------------------------------------------------------------------------
                	; Display the half-word in r1
                	;------------------------------------------------------------------------------
                	
                	DisplayHalf:
0106EC E7 EF 01 00 	    push    lr
0106F0 82 10 20 76 		ror		r1,r1,#16
0106F4 B9 01 00 00 		bsr		DisplayCharHex
0106F8 82 10 20 74 		rol		r1,r1,#16
0106FC 57 FF 11 00 	    pop     lr
                	
                	;------------------------------------------------------------------------------
                	; Display the char in r1
                	;------------------------------------------------------------------------------
                	
                	DisplayCharHex:
010700 E7 EF 01 00 	    push    lr
010704 82 10 10 76 		ror		r1,r1,#8
010708 B9 01 00 00 		bsr		DisplayByte
01070C 82 10 10 74 		rol		r1,r1,#8
010710 57 FF 11 00 	    pop     lr
                	
                	;------------------------------------------------------------------------------
                	; Display the byte in r1
                	;------------------------------------------------------------------------------
                	
                	DisplayByte:
010714 E7 EF 01 00 	    push    lr
010718 82 10 08 76 		ror		r1,r1,#4
01071C B9 01 00 00 		bsr		DisplayNybble
010720 82 10 08 74 		rol		r1,r1,#4
010724 57 FF 11 00 		pop     lr
                	 
                	;------------------------------------------------------------------------------
                	; Display nybble in r1
                	;------------------------------------------------------------------------------
                	
                	DisplayNybble:
010728 E7 EF 01 00 	    push    lr
01072C E7 E0 01 00 		push	r1
010730 67 E1 01 00 		push    r2
010734 8C 10 1E 00 		and		r1,r1,#$0F
010738 94 10 60 00 		addui	r1,r1,#'0'
01073C 96 20 74 00 		cmpu	r2,r1,#'9'+1
010740 3D 41 04 00 		blt		r2,.0001
010744 94 10 0E 00 		addui	r1,r1,#7
                	.0001:
010748 B9 CD 01 00 		bsr		OutChar
01074C 57 2F 10 00 		pop     r2
010750 57 1F 10 00 		pop		r1
010754 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; Display a string pointer to string in r1.
                	;------------------------------------------------------------------------------
                	
                	DisplayString:
010758 E7 EF 01 00 	    push    lr
01075C E7 E0 01 00 		push	r1
010760 67 E1 01 00 		push    r2
010764 82 20 00 1A 		mov		r2,r1
                	.dm2:
010768 41 11 00 00 		lbu		r1,[r2]
01076C 14 21 02 00 		addui   r2,r2,#1	; increment text pointer
010770 BD 00 06 00 		beq		r1,.dm1
010774 39 C8 01 00 		bsr		OutChar
010778 3A FE FF FF 		bra		.dm2
                	.dm1:
01077C 57 2F 10 00 		pop		r2
010780 57 1F 10 00 	    pop     r1
010784 3B FF 11 00 		rts

                	DisplayStringCRLF:
010788 E7 EF 01 00 	    push    lr
01078C B9 F9 FF FF 		bsr		DisplayString
010790 3A 01 00 00 		bra     CRLF1
                	OutCRLF:
                	CRLF:
010794 E7 EF 01 00 	    push    lr
                	CRLF1:
010798 E7 E0 01 00 		push	r1
01079C 0A 10 1A 00 		ldi		r1,#CR
0107A0 B9 C2 01 00 		bsr		OutChar
0107A4 0A 10 14 00 		ldi		r1,#LF
0107A8 B9 C1 01 00 		bsr		OutChar
0107AC 57 1F 10 00 		pop		r1
0107B0 3B FF 11 00 		rts

                	
                	DispCharQ:
0107B4 E7 EF 01 00 	    push    lr
0107B8 39 CC FF FF 		bsr		AsciiToScreen
0107BC E1 11 00 00 		sc		r1,[r3]
0107C0 84 31 08 00 		add		r3,r3,#4
0107C4 3B FF 11 00 	    rts

                	DispStartMsg:
0107C8 E7 EF 01 00 	    push    lr
0107CC 7C 01 00 00 		ldi		r1,#msgStart
0107D0 0A 10 EA 26 
0107D4 B9 F0 FF FF 		bsr		DisplayString
0107D8 3B FF 11 00 	    rts

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	KeybdIRQ:
0107DC 7C DC FF 00 		sb		r0,KEYBD+1
0107E0 60 00 02 00 
0107E4 02 E0 3F 6E 		rti
                	
                	BranchToSelf:
0107E8 3A 00 00 00 	    bra      BranchToSelf
                	
                	;==============================================================================
                	; Finitron Multi-Tasking Kernel (FMTK)
                	;        __
                	;   \\__/ o\    (C) 2013, 2014, 2015  Robert Finch, Stratford
                	;    \  __ /    All rights reserved.
                	;     \/_//     robfinch<remove>@finitron.ca
                	;       ||
                	;==============================================================================
                	message "InitFMTK"
                	InitFMTK:
0107EC 7C C0 00 00 	    ldi     r2,#$0C00000
0107F0 0A 20 00 00 
                	.nextTCB:
0107F4 14 31 00 08 	    addui   r3,r2,#$400       ; 1kb TCB size
0107F8 63 31 00 02 	    sw      r3,TCB_IPC[r2]    ; set startup address
0107FC 7C 01 00 00 	    lw      r3,BranchToSelf
010800 46 30 D0 0F 
010804 63 31 00 08 	    sw      r3,$400[r2]
010808 FC 00 00 00 	    addui   r3,r2,#$FFF8
01080C 14 31 F0 FF 
010810 63 31 E0 01 	    sw      r3,TCB_r30[r2]    ; set the stack pointer to the end of the base lot
010814 94 21 10 00 	    addui   r2,r3,#8
010818 7C C0 01 00 	    cmpu    r1,r2,#$1C00000
01081C 16 11 00 00 
010820 BD 40 EA FF 	    blt     r1,.nextTCB
                	
                	    ; Initialize the free TCB list
010824 7C C2 00 00 	    ldi     r2,#$C20000
010828 0A 20 00 00 
01082C 63 20 60 00 	    sw      r2,FreeTCB
010830 63 01 40 04 	    sw      r0,TCB_PrevFree[r2]
                	.0001:
010834 7C 01 00 00 	    addui   r3,r2,#$10000
010838 14 31 00 00 
01083C 63 31 30 04 	    sw      r3,TCB_NextFree[r2]
010840 E3 21 40 04 	    sw      r2,TCB_PrevFree[r3]
010844 7C 01 00 00 	    addui   r2,r2,#$10000
010848 14 21 00 00 
01084C 7C BF 01 00 	    cmpu    r4,r2,#$1BF0000
010850 16 41 00 00 
010854 3D 42 F0 FF 	    blt     r4,.0001
010858 63 01 30 04 	    sw      r0,TCB_NextFree[r2]
                	
01085C 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	; AddTaskToReadyList
                	;
                	; The ready list is a group of eight ready lists, one for each priority
                	; level. Each ready list is organized as a doubly linked list to allow fast
                	; insertions and removals. The list is organized as a ring (or bubble) with
                	; the last entry pointing back to the first. This allows a fast task switch
                	; to the next task. Which task is at the head of the list is maintained
                	; in the variable QNdx for the priority level.
                	;
                	; Registers Affected: none
                	; Parameters:
                	;	r1 = pointer to task control block
                	; Returns:
                	;	none
                	;------------------------------------------------------------------------------
                	message "AddToReadyList"
                	AddTaskToReadyList:
010860 67 E1 01 00 	    push    r2
010864 E7 E1 01 00 	    push    r3
010868 67 E2 01 00 	    push    r4
01086C 0A 20 20 00 		ldi     r2,#TS_READY
010870 E0 20 20 04 		sb		r2,TCB_Status[r1]
010874 E3 00 00 04 		sw		r0,TCB_NextRdy[r1]
010878 E3 00 10 04 		sw		r0,TCB_PrevRdy[r1]
01087C C0 30 24 04 		lb		r3,TCB_Priority[r1]
010880 86 41 10 00 		cmp		r4,r3,#8
010884 3D 42 08 00 		blt		r4,arl1
010888 7C 00 00 00 		ldi		r3,#PRI_LOWEST
01088C 7C 00 00 00 
010890 0A 30 08 03 
                	arl1:
010894 82 31 06 70 	    asl     r3,r3,#3
010898 C6 21 70 00 		lw		r2,QNdx0[r3]
01089C 3D 01 14 00 		beq		r2,arl5
0108A0 46 31 10 04 		lw		r3,TCB_PrevRdy[r2]
0108A4 E3 21 00 04 		sw		r2,TCB_NextRdy[r3]
0108A8 E3 30 10 04 		sw		r3,TCB_PrevRdy[r1]
0108AC 63 11 10 04 		sw		r1,TCB_PrevRdy[r2]
0108B0 E3 20 00 04 		sw		r2,TCB_NextRdy[r1]
0108B4 57 4F 10 00 		pop     r4
0108B8 57 3F 10 00 		pop     r3
0108BC 57 2F 10 00 		pop     r2
0108C0 37 FF 01 00 		rtl

                		; Here the ready list was empty, so add at head
                	arl5:
0108C4 E3 11 70 00 		sw		r1,QNdx0[r3]
0108C8 E3 10 00 04 		sw		r1,TCB_NextRdy[r1]
0108CC E3 10 10 04 		sw		r1,TCB_PrevRdy[r1]
0108D0 57 4F 10 00 		pop     r4
0108D4 57 3F 10 00 		pop     r3
0108D8 57 2F 10 00 		pop     r2
0108DC 37 FF 01 00 		rtl
	
                	
                	;------------------------------------------------------------------------------
                	; RemoveTaskFromReadyList
                	;
                	; This subroutine removes a task from the ready list.
                	;
                	; Registers Affected: none
                	; Parameters:
                	;	r1 = pointer to task control block
                	; Returns:
                	;   r1 = pointer to task control block
                	;------------------------------------------------------------------------------
                	message "RemoveFromReadyList"
                	RemoveTaskFromReadyList:
0108E0 67 E1 01 00 	    push    r2
0108E4 E7 E1 01 00 	    push    r3
0108E8 67 E2 01 00 		push	r4
0108EC E7 E2 01 00 		push	r5
                	
0108F0 C0 30 20 04 		lb		r3,TCB_Status[r1]	; is the task on the ready list ?
                	message "0"
0108F4 8C 41 30 00 		and		r4,r3,#TS_READY|TS_RUNNING
                	message "A"
0108F8 3D 02 24 00 		beq		r4,rfr2
                	message "B
0108FC 8C 31 CE FF 		and		r3,r3,#~(TS_READY|TS_RUNNING)
message "1"
010900 E0 30 20 04 		sb		r3,TCB_Status[r1]	; task status no longer running or ready
010904 C6 40 00 04 		lw		r4,TCB_NextRdy[r1]	; Get previous and next fields.
010908 C6 50 10 04 		lw		r5,TCB_PrevRdy[r1]
01090C E3 42 00 04 		sw		r4,TCB_NextRdy[r5]
010910 63 52 10 04 		sw		r5,TCB_PrevRdy[r4]
010914 C0 30 24 04 		lb		r3,TCB_Priority[r1]
010918 82 31 06 70 		asl     r3,r3,#3
01091C C6 51 70 00 		lw      r5,QNdx0[r3]
010920 82 50 0A 0C 		cmp		r5,r1,r5			; Are we removing the QNdx task ?
010924 BD 12 0E 00 		bne		r5,rfr2
010928 E3 41 70 00 		sw		r4,QNdx0[r3]
                	message "2"
                		; Now we test for the case where the task being removed was the only one
                		; on the ready list of that priority level. We can tell because the
                		; NxtRdy would point to the task itself.
01092C 02 52 02 0C 		cmp		r5,r4,r1				
010930 BD 12 08 00 		bne		r5,rfr2
010934 E3 01 70 00 		sw		r0,QNdx0[r3]        ; Make QNdx NULL
010938 E3 00 00 04 		sw		r0,TCB_NextRdy[r1]
01093C E3 00 10 04 		sw		r0,TCB_PrevRdy[r1]
                	rfr2:
010940 57 5F 10 00 		pop		r5
010944 57 4F 10 00 		pop		r4
010948 57 3F 10 00 		pop     r3
01094C 57 2F 10 00 		pop     r2
010950 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; AddToTimeoutList
                	; AddToTimeoutList adds a task to the timeout list. The task is placed in the
                	; list depending on it's timeout value.
                	;
                	; Registers Affected: none
                	; Parameters:
                	;	r1 = task
                	;	r2 = timeout value
                	;------------------------------------------------------------------------------
                	message "AddToTimeoutList"
                	AddToTimeoutList:
010954 67 E1 01 00 		push    r2
010958 E7 E1 01 00 		push    r3
01095C 67 E2 01 00 		push	r4
010960 E7 E2 01 00 		push	r5
                	
010964 0A 50 00 00 	    ldi     r5,#0
010968 E3 00 50 04 		sw		r0,TCB_NextTo[r1]   ; these fields should already be NULL
01096C E3 00 60 04 		sw		r0,TCB_PrevTo[r1]
010970 7C 01 00 00 		lw		r4,TimeoutList		; are there any tasks on the timeout list ?
010974 46 40 E0 14 
010978 3D 02 4E 00 		beq		r4,attl_add_at_head	; If not, update head of list
                	attl_check_next:
01097C 7C 00 00 00 	    lw      r3,TCB_Timeout[r4]            
010980 7C 00 00 00 
010984 46 32 1A 03 
010988 02 21 06 2A 		subu	r2,r2,r3	        ; is this timeout > next
01098C 3D 41 16 00 		blt		r2,attl_insert_before
010990 02 52 00 1A 		mov		r5,r4
010994 46 42 50 04 		lw		r4,TCB_NextTo[r4]
010998 3D 12 F2 FF 		bne		r4,attl_check_next
                	
                		; Here we scanned until the end of the timeout list and didn't find a 
                		; timeout of a greater value. So we add the task to the end of the list.
                	attl_add_at_end:
01099C E3 00 50 04 		sw		r0,TCB_NextTo[r1]		; 
0109A0 E3 12 50 04 		sw		r1,TCB_NextTo[r5]
0109A4 E3 50 60 04 		sw		r5,TCB_PrevTo[r1]
0109A8 7C 00 00 00 		sw		r2,TCB_Timeout[r1]
0109AC 7C 00 00 00 
0109B0 E3 20 1A 03 
0109B4 BA 0F 00 00 		bra		attl_exit
                	
                	attl_insert_before:
0109B8 BD 02 0C 00 		beq		r5,attl_insert_before_head
0109BC E3 40 50 04 		sw		r4,TCB_NextTo[r1]	; next on list goes after this task
0109C0 E3 50 60 04 		sw		r5,TCB_PrevTo[r1]	; set previous link
0109C4 E3 12 50 04 		sw		r1,TCB_NextTo[r5]
0109C8 63 12 60 04 		sw		r1,TCB_PrevTo[r4]
0109CC 3A 03 00 00 		bra		attl_adjust_timeout
                	
                		; Here there is no previous entry in the timeout list
                		; Add at start
                	attl_insert_before_head:
0109D0 63 12 60 04 		sw		r1,TCB_PrevTo[r4]
0109D4 E3 00 60 04 		sw		r0,TCB_PrevTo[r1]	;
0109D8 E3 40 50 04 		sw		r4,TCB_NextTo[r1]
0109DC 7C 01 00 00 		sw		r1,TimeoutList			; update the head pointer
0109E0 63 10 E0 14 
                	attl_adjust_timeout:
0109E4 02 21 06 28 		addu	r2,r2,r3	       ; get back timeout
0109E8 7C 00 00 00 		sw		r2,TCB_Timeout[r1]
0109EC 7C 00 00 00 
0109F0 E3 20 1A 03 
0109F4 7C 00 00 00 		lw		r5,TCB_Timeout[r4]	; adjust the timeout of the next task
0109F8 7C 00 00 00 
0109FC 46 52 1A 03 
010A00 82 52 04 2A 		subu	r5,r5,r2
010A04 7C 00 00 00 		sw		r5,TCB_Timeout[r4]
010A08 7C 00 00 00 
010A0C 63 52 1A 03 
010A10 3A 04 00 00 		bra		attl_exit
                	
                		; Here there were no tasks on the timeout list, so we add at the
                		; head of the list.
                	attl_add_at_head:
010A14 7C 01 00 00 		sw		r1,TimeoutList		; set the head of the timeout list
010A18 63 10 E0 14 
010A1C 7C 00 00 00 		sw		r2,TCB_Timeout[r1]
010A20 7C 00 00 00 
010A24 E3 20 1A 03 
                		; flag no more entries in timeout list
010A28 E3 00 50 04 		sw		r0,TCB_NextTo[r1]	; no next entries
010A2C E3 00 60 04 		sw		r0,TCB_PrevTo[r1]	; and no prev entries
                	attl_exit:
010A30 C0 20 20 04 		lb		r2,TCB_Status[r1]	; set the task's status as timing out
010A34 0D 21 02 00 		or		r2,r2,#TS_TIMEOUT
010A38 E0 20 20 04 		sb		r2,TCB_Status[r1]
010A3C 57 5F 10 00 		pop		r5
010A40 57 4F 10 00 		pop		r4
010A44 57 3F 10 00 		pop     r3
010A48 57 2F 10 00 		pop     r2
010A4C 37 FF 01 00 		rtl
	
                	;------------------------------------------------------------------------------
                	; RemoveFromTimeoutList
                	;
                	; This routine is called when a task is killed. The task may need to be
                	; removed from the middle of the timeout list.
                	;
                	; On entry: the timeout list semaphore must be already set.
                	; Registers Affected: none
                	; Parameters:
                	;	 r1 = pointer to task control block
                	;------------------------------------------------------------------------------
                	
                	RemoveFromTimeoutList:
010A50 67 E1 01 00 		push    r2
010A54 E7 E1 01 00 		push    r3
010A58 67 E2 01 00 		push	r4
010A5C E7 E2 01 00 		push	r5
                	
010A60 C0 40 20 04 		lb		r4,TCB_Status[r1]		; Is the task even on the timeout list ?
010A64 0C 42 02 00 		and		r4,r4,#TS_TIMEOUT
010A68 3D 02 54 00 		beq		r4,rftl_not_on_list
010A6C 82 40 FE FF 		cmp		r4,r1,TimeoutList		; Are we removing the head of the list ?
010A70 3D 02 24 00 		beq		r4,rftl_remove_from_head
010A74 C6 40 60 04 		lw		r4,TCB_PrevTo[r1]		; adjust the links of the next and previous
010A78 3D 02 3E 00 		beq		r4,rftl_empty_list		; no previous link - list corrupt?
010A7C C6 50 50 04 		lw		r5,TCB_NextTo[r1]		; tasks on the list to point around the task
010A80 63 52 50 04 		sw		r5,TCB_NextTo[r4]
010A84 BD 02 38 00 		beq		r5,rftl_empty_list
010A88 E3 42 60 04 		sw		r4,TCB_PrevTo[r5]
010A8C 7C 00 00 00 		lw		r2,TCB_Timeout[r1]		; update the timeout of the next on list
010A90 7C 00 00 00 
010A94 C6 20 1A 03 
010A98 7C 00 00 00 		lw      r3,TCB_Timeout[r5]
010A9C 7C 00 00 00 
010AA0 C6 32 1A 03 
010AA4 02 21 06 08 		add		r2,r2,r3            	; with any remaining timeout in the task
010AA8 7C 00 00 00 		sw		r2,TCB_Timeout[r5]		; removed from the list
010AAC 7C 00 00 00 
010AB0 E3 22 1A 03 
010AB4 3A 08 00 00 		bra		rftl_empty_list
                	
                		; Update the head of the list.
                	rftl_remove_from_head:
010AB8 C6 50 50 04 		lw		r5,TCB_NextTo[r1]
010ABC 7C 01 00 00 		sw		r5,TimeoutList			; store next field into list head
010AC0 63 50 E0 14 
010AC4 BD 02 18 00 		beq		r5,rftl_empty_list
010AC8 7C 00 00 00 		lw		r4,TCB_Timeout[r1]		; add any remaining timeout to the timeout
010ACC 7C 00 00 00 
010AD0 C6 40 1A 03 
010AD4 7C 00 00 00 		lw      r3,TCB_Timeout[r5]
010AD8 7C 00 00 00 
010ADC C6 32 1A 03 
010AE0 02 42 06 08 		add		r4,r4,r3            	; of the next task on the list.
010AE4 7C 00 00 00 		sw		r4,TCB_Timeout[r5]
010AE8 7C 00 00 00 
010AEC E3 42 1A 03 
010AF0 E3 02 60 04 		sw		r0,TCB_PrevTo[r5]       ; there is no previous item to the head
                		
                		; Here there is no previous or next items in the list, so the list
                		; will be empty once this task is removed from it.
                	rftl_empty_list:
010AF4 82 20 00 1A 		mov     r2,r1
010AF8 40 31 20 04 		lb		r3,TCB_Status[r2]	; clear timeout status (bit #0)
010AFC 8C 31 FC 01 		and     r3,r3,#$FE
010B00 60 31 20 04 		sb      r3,TCB_Status[r2]
010B04 63 01 50 04 		sw		r0,TCB_NextTo[r2]	; make sure the next and prev fields indicate	
010B08 63 01 60 04 		sw	    r0,TCB_PrevTo[r2]   ; the task is not on a list.
010B0C 02 11 00 1A 		mov     r1,r2
                	rftl_not_on_list:
010B10 57 5F 10 00 		pop		r5
010B14 57 4F 10 00 		pop		r4
010B18 57 3F 10 00 		pop     r3
010B1C 57 2F 10 00 		pop     r2
                	rftl_not_on_list2:
010B20 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; PopTimeoutList
                	;
                	; This subroutine is called from within the timer ISR when the task's 
                	; timeout expires. It's always the head of the list that's being removed in
                	; the timer ISR so the removal from the timeout list is optimized. We know
                	; the timeout expired, so the amount of time to add to the next task is zero.
                	;
                	; Registers Affected: 
                	; Parameters:
                	;	r2: head of timeout list
                	; Returns:
                	;	r1 = task id of task popped from timeout list
                	;------------------------------------------------------------------------------
                	
                	PopTimeoutList:
010B24 46 11 50 04 		lw		r1,TCB_NextTo[r2]
010B28 7C 01 00 00 		sw		r1,TimeoutList  ; store next field into list head
010B2C 63 10 E0 14 
010B30 BD 00 04 00 		beq		r1,ptl1
010B34 E3 00 60 04 		sw		r0,TCB_PrevTo[r1]; previous link = NULL
                	ptl1:
010B38 40 11 20 04 	    lb      r1,TCB_Status[r2]
010B3C 8C 10 FC 01 	    and     r1,r1,#$FE       ; clear timeout status
010B40 60 11 20 04 	    sb      r1,TCB_Status[r2]
010B44 63 01 50 04 		sw		r0,TCB_NextTo[r2]	; make sure the next and prev fields indicate
010B48 63 01 60 04 		sw		r0,TCB_PrevTo[r2]		; the task is not on a list.
010B4C 02 11 00 1A 		mov     r1,r2
010B50 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	; Sleep
                	;
                	; Put the currently running task to sleep for a specified time.
                	;
                	; Registers Affected: none
                	; Parameters:
                	;	r1 = time duration in jiffies (1/60 second).
                	; Returns: none
                	;------------------------------------------------------------------------------
                	message "sleep"
                	
                	Sleep:
010B54 E7 EF 01 00 	    push    lr
010B58 E7 E0 01 00 	    push    r1
010B5C 67 E1 01 00 	    push    r2
010B60 82 20 00 1A 		mov     r2,r1
                	;	spl		tcb_sema + 4
010B64 46 10 50 00 		lw		r1,RunningTCB
010B68 39 AF FF FF 		bsr		RemoveTaskFromReadyList
010B6C 39 BD FF FF 		bsr		AddToTimeoutList	; The scheduler will be returning to this
010B70 0A 10 02 00 		ldi		r1,#1
                	;	sb		r1,tcb_sema
010B74 38 0F 04 00 		sys		2				; task eventually, once the timeout expires,
010B78 57 2F 10 00 		pop     r2
010B7C 57 1F 10 00 		pop     r1
010B80 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; Perform a synchronous BIOS call. Waits until the BIOS is finished before
                	; returning.
                	; Returns:
                	; r1 = response result from BIOS
                	;------------------------------------------------------------------------------
                	;
                	Sync_BIOS_Call:
010B84 7C 00 00 00 	    ldi     sp,#BIOS_STACK
010B88 0A E0 01 D0 
010B8C E7 E3 01 00 	    push    r7
010B90 67 E4 01 00 	    push    r8
010B94 E7 E4 01 00 	    push    r9
                	.0001:
010B98 5C 70 70 01 	    lwar    r7,BIOS_sema
010B9C BD 13 FE FF 	    bne     r7,.0001          ; free ?
010BA0 6E 80 71 01 	    swcr    tr,BIOS_sema
010BA4 02 80 00 3E 	    mfspr   r8,cr0            ; check if store succeeded
010BA8 7C 00 00 10 	    and     r8,r8,#$1000000000
010BAC 0C 84 00 00 
010BB0 3D 04 F4 FF 	    beq     r8,.0001
                	
010BB4 7C 00 00 00 	    lc      r9,BIOS_tail
010BB8 7C 00 00 00 
010BBC 42 90 3C 03 
010BC0 7C 00 00 00 	    lc      r7,BIOS_tail
010BC4 7C 00 00 00 
010BC8 42 70 3C 03 
010BCC 7C 00 00 00 	    lc      r8,BIOS_head       ; check for space available
010BD0 7C 00 00 00 
010BD4 42 80 3E 03 
010BD8 82 83 0E 0C 	    cmp     r8,r7,r7
010BDC 3D 04 DE FF 	    beq     r8,.0001          ; no space, go back and wait
010BE0 7C 00 00 00 	    ldi     r8,#BIOS_AREA
010BE4 7C 00 00 00 
010BE8 0A 80 40 03 
010BEC EB 13 10 00 	    sw      r1,BIOS_op[r7+r8]
010BF0 EB 23 10 08 	    sw      r2,BIOS_arg1[r7+r8]
010BF4 EB 33 10 10 	    sw      r3,BIOS_arg2[r7+r8]
010BF8 EB 43 10 18 	    sw      r4,BIOS_arg3[r7+r8]
010BFC EB 53 10 20 	    sw      r5,BIOS_arg4[r7+r8]
010C00 EB 63 10 28 	    sw      r6,BIOS_arg5[r7+r8]
010C04 EB 03 10 30 	    sw      r0,BIOS_resp[r7+r8]
010C08 EB 03 10 38 	    sw      r0,BIOS_stat[r7+r8]
010C0C 94 73 80 00 	    addui   r7,r7,#64
010C10 8C 73 80 0F 	    and     r7,r7,#$7c0
010C14 7C 00 00 00 	    sc      r7,BIOS_tail
010C18 7C 00 00 00 
010C1C 61 70 3C 03 
010C20 63 00 70 01 	    sw      r0,BIOS_sema      ; unlock the semaphore
                	.0003:
010C24 CE 74 10 38 	    lw      r7,BIOS_stat[r9+r8]
010C28 BD 13 04 00 	    bne     r7,.0002
                	;    hwi     2                 ; reschedule tasks
010C2C 3A FF FF FF 	    bra     .0003
                	.0002:
010C30 CE 14 10 30 	    lw      r1,BIOS_resp[r9+r8]
010C34 57 9F 10 00 	    pop     r9
010C38 57 8F 10 00 	    pop     r8
010C3C 57 7F 10 00 	    pop     r7
010C40 02 E0 3D 6E 	    rte
                	
                	;------------------------------------------------------------------------------
                	; Perform an asynchronous BIOS call. Returns as soon as the BIOS information
                	; can be registered.
                	; Returns:
                	; r1 = handle for BIOS call
                	;------------------------------------------------------------------------------
                	
                	BIOS_Call:
010C44 7C 00 00 00 	    ldi     sp,#BIOS_STACK
010C48 0A E0 01 D0 
010C4C E7 E3 01 00 	    push    r7
010C50 67 E4 01 00 	    push    r8
010C54 E7 E4 01 00 	    push    r9
                	.0001:
010C58 5C 70 70 01 	    lwar    r7,BIOS_sema
010C5C BD 13 FE FF 	    bne     r7,.0001          ; free ?
010C60 6E 80 71 01 	    swcr    tr,BIOS_sema
010C64 02 80 00 3E 	    mfspr   r8,cr0            ; check if store succeeded
010C68 7C 00 00 10 	    and     r8,r8,#$1000000000
010C6C 0C 84 00 00 
010C70 3D 04 F4 FF 	    beq     r8,.0001
                	
010C74 7C 00 00 00 	    lc      r7,BIOS_tail
010C78 7C 00 00 00 
010C7C 42 70 3C 03 
010C80 7C 00 00 00 	    ldi     r8,#BIOS_AREA
010C84 7C 00 00 00 
010C88 0A 80 40 03 
010C8C CE 93 10 38 	    lw      r9,BIOS_stat[r7+r8]
010C90 86 94 00 00 	    cmp     r9,r9,#BIOS_FREE
010C94 BD 14 2E 00 	    bne     r9,.0002
010C98 EB 13 10 00 	    sw      r1,BIOS_op[r7+r8]
010C9C EB 23 10 08 	    sw      r2,BIOS_arg1[r7+r8]
010CA0 EB 33 10 10 	    sw      r3,BIOS_arg2[r7+r8]
010CA4 EB 43 10 18 	    sw      r4,BIOS_arg3[r7+r8]
010CA8 EB 53 10 20 	    sw      r5,BIOS_arg4[r7+r8]
010CAC EB 63 10 28 	    sw      r6,BIOS_arg5[r7+r8]
010CB0 EB 03 10 30 	    sw      r0,BIOS_resp[r7+r8]
010CB4 7C 00 00 00 	    ldi     r9,#BIOS_WAIT_SVC
010CB8 7C 00 00 00 
010CBC 0A 90 4C 03 
010CC0 EB 93 10 38 	    sw      r9,BIOS_stat[r7+r8]
010CC4 82 13 00 1A 	    mov     r1,r7             ; record BIOS handle in r1
010CC8 94 73 80 00 	    addui   r7,r7,#64
010CCC 8C 73 80 0F 	    and     r7,r7,#$7c0
010CD0 7C 00 00 00 	    sc      r7,BIOS_tail
010CD4 7C 00 00 00 
010CD8 61 70 3C 03 
010CDC 63 00 70 01 	    sw      r0,BIOS_sema      ; unlock the semaphore
010CE0 57 9F 10 00 	    pop     r9
010CE4 57 8F 10 00 	    pop     r8
010CE8 57 7F 10 00 	    pop     r7
010CEC 02 E0 3D 6E 	    rte
                	.0002:
010CF0 63 00 70 01 	    sw      r0,BIOS_sema
010CF4 BA EC FF FF 	    bra     .0001
                	
                	;------------------------------------------------------------------------------
                	; BIOS Dispatcher
                	;    Dispatch a BIOS request.
                	;------------------------------------------------------------------------------
                	
                	BIOS_Dispatcher:
010CF8 E7 E0 01 00 	    push    r1
010CFC 67 E1 01 00 	    push    r2
010D00 E7 E1 01 00 	    push    r3
010D04 67 E2 01 00 	    push    r4
010D08 E7 E2 01 00 	    push    r5
010D0C 67 E3 01 00 	    push    r6
010D10 E7 E3 01 00 	    push    r7
010D14 67 E4 01 00 	    push    r8
010D18 E7 E4 01 00 	    push    r9
                	.0001:
010D1C 5C 70 70 01 	    lwar    r7,BIOS_sema
010D20 BD 13 FE FF 	    bne     r7,.0001          ; free ?
010D24 6E 80 71 01 	    swcr    tr,BIOS_sema
010D28 02 80 00 3E 	    mfspr   r8,cr0            ; check if store succeeded
010D2C 7C 00 00 10 	    and     r8,r8,#$1000000000
010D30 0C 84 00 00 
010D34 3D 04 F4 FF 	    beq     r8,.0001
010D38 7C 00 00 00 	    ldi     r7,#BIOS_AREA
010D3C 7C 00 00 00 
010D40 0A 70 40 03 
010D44 7C 00 00 00 	    lc      r8,BIOS_head
010D48 7C 00 00 00 
010D4C 42 80 3E 03 
010D50 CE 93 10 38 	    lw      r9,BIOS_stat[r7+r8]
010D54 7C 00 00 00 	    cmp     r9,r9,#BIOS_WAIT_SVC
010D58 7C 00 00 00 
010D5C 86 94 4C 03 
010D60 BD 14 24 7A 	    bne     r9,.advanceHead
010D64 0A 90 04 00 	    ldi     r9,#BIOS_INSERVICE
010D68 EB 93 10 38 	    sw      r9,BIOS_stat[r7+r8]
010D6C CE 13 10 00 	    lw      r1,BIOS_op[r7+r8]
010D70 CE 23 10 08 	    lw      r2,BIOS_arg1[r7+r8]
010D74 CE 33 10 10 	    lw      r3,BIOS_arg2[r7+r8]
010D78 CE 43 10 18 	    lw      r4,BIOS_arg3[r7+r8]
010D7C CE 53 10 20 	    lw      r5,BIOS_arg4[r7+r8]
010D80 CE 63 10 28 	    lw      r6,BIOS_arg5[r7+r8]
010D84 86 A0 00 00 	    cmp     r10,r1,#0
010D88 3D 15 0E 00 	    bne     r10,.0002
010D8C 02 11 00 1A 	    mov     r1,r2
010D90 39 39 FF FF 	    bsr     DisplayString
010D94 0A 10 02 00 	    ldi     r1,#BIOS_DONE
010D98 EB 03 10 30 	    sw      r0,BIOS_resp[r7+r8]
010D9C EB 13 10 38 	    sw      r1,BIOS_stat[r7+r8]
010DA0 BA 01 00 00 	    bra     BIOS_dx
                	.0002:
                	;.0001:
                	;    addui   sp,sp,#48
                	;    lc      r3,BIOS_head
                	;    ldi     r2,#1
                	;    sw      r1,BIOS_resp[r3]
                	;    sw      r2,BIOS_done[r3]
                	;    addui   r1,r3,#64
                	;    and     r1,r1,#$7FF
                	;    sc      r1,BIOS_head
                	;    bra     .0001          ; check for another BIOS call
                	.sleep:
010DA4 63 00 70 01 	    sw     r0,BIOS_sema
                	;    hwi    2
010DA8 BA EE FF FF 	    bra     .0001
                	BIOS_dx:
                	.advanceHead:
010DAC 14 84 80 00 	    addui    r8,r8,#64
010DB0 0C 84 80 0F 	    and      r8,r8,#$7C0
010DB4 7C 00 00 00 	    sc       r8,BIOS_head
010DB8 7C 00 00 00 
010DBC 61 80 3E 03 
                	.x1:
010DC0 63 00 70 01 	    sw       r0,BIOS_sema
010DC4 57 9F 10 00 	    pop      r9
010DC8 57 8F 10 00 	    pop      r8
010DCC 57 7F 10 00 	    pop      r7
010DD0 57 6F 10 00 	    pop      r6
010DD4 57 5F 10 00 	    pop      r5
010DD8 57 4F 10 00 	    pop      r4
010DDC 57 3F 10 00 	    pop      r3
010DE0 57 2F 10 00 	    pop      r2
010DE4 57 1F 10 00 	    pop      r1
010DE8 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	ServiceRequestIRQ:
                	;    rti
                	;    cpuid   sp,r0,#0
                	;    beq     sp,.0001
                	;    rti
                	.0001:
                	;    ldi     sp,#$8000
                	;    push    r1
                	;    push    r2
                	;    mfspr   r1,ipc
                	;    push    r1
                	;    ldi     r1,#9
                	;    sh      r1,PIC_RSTE
                	;    lw      r1,SRI_head
                	;    push    SRI_op[r1]
                	;    push    SRI_arg1[r1]
                	;    push    SRI_arg2[r1]
                	;    push    SRI_arg3[r1]
                	;    push    SRI_arg4[r1]
                	;    push    SRI_arg5[r1]
                	;    sys     4
                	;    addui   sp,sp,#48
                	;    lw      r2,SRI_head
                	;    sw      r1,SRI_resp[r2]
                	;    ldi     r1,#1
                	;    sw      r1,SRI_done[r2]
                	;    addui   r2,r2,#64
                	;    and     r2,r2,#$7FF
                	;    sw      r2,SRI_head
                	;    pop     r2
                	;    pop     r1
                	;    rti
                	
                	;------------------------------------------------------------------------------
                	; 60 Hz interrupt routine.
                	; Both cpu's will execute this interrupt (necessary for multi-tasking).
                	; Only cpu#0 needs to reset the I/O hardware.
                	;------------------------------------------------------------------------------
                	
                	TickRout:
010DEC 02 E0 01 6C 	    cpuid   sp,r0,#0
010DF0 3D 0F 98 00 	    beq     sp,.acknowledgeInterrupt
                	    ; The stacks for the CPUs' must not overlap
010DF4 7C 02 00 00 	    ldi     sp,#CPU1_IRQ_STACK
010DF8 0A E0 01 10 
                	.SaveContext:
                	    ; Do something here that takes a few cycles in order to allow cpu#0 to
                	    ; reset the PIC. Otherwise the IRQ line going high will cause a bounce back
                	    ; to here.
010DFC 63 1C 10 00 	    sw      r1,TCB_r1[tr]
010E00 63 2C 20 00 	    sw      r2,TCB_r2[tr]
010E04 63 3C 30 00 	    sw      r3,TCB_r3[tr]
010E08 63 4C 40 00 	    sw      r4,TCB_r4[tr]
010E0C 63 5C 50 00 	    sw      r5,TCB_r5[tr]
010E10 63 6C 60 00 	    sw      r6,TCB_r6[tr]
010E14 63 7C 70 00 	    sw      r7,TCB_r7[tr]
010E18 63 8C 80 00 	    sw      r8,TCB_r8[tr]
010E1C 63 9C 90 00 	    sw      r9,TCB_r9[tr]
010E20 63 AC A0 00 	    sw      r10,TCB_r10[tr]
010E24 63 BC B0 00 	    sw      r11,TCB_r11[tr]
010E28 63 CC C0 00 	    sw      r12,TCB_r12[tr]
010E2C 63 DC D0 00 	    sw      r13,TCB_r13[tr]
010E30 63 EC E0 00 	    sw      r14,TCB_r14[tr]
010E34 63 FC F0 00 	    sw      r15,TCB_r15[tr]
010E38 63 0C 01 01 	    sw      r16,TCB_r16[tr]
010E3C 63 1C 11 01 	    sw      r17,TCB_r17[tr]
010E40 63 2C 21 01 	    sw      r18,TCB_r18[tr]
010E44 63 3C 31 01 	    sw      r19,TCB_r19[tr]
010E48 63 4C 41 01 	    sw      r20,TCB_r20[tr]
010E4C 63 5C 51 01 	    sw      r21,TCB_r21[tr]
010E50 63 6C 61 01 	    sw      r22,TCB_r22[tr]
010E54 63 7C 71 01 	    sw      r23,TCB_r23[tr]
010E58 63 8C 81 01 	    sw      r24,TCB_r24[tr]
010E5C 63 9C 91 01 	    sw      r25,TCB_r25[tr]
010E60 63 AC A1 01 	    sw      r26,TCB_r26[tr]
010E64 63 BC B1 01 	    sw      r27,TCB_r27[tr]
010E68 63 CC C1 01 	    sw      r28,TCB_r28[tr]
010E6C 63 DC D1 01 	    sw      r29,TCB_r29[tr]
010E70 02 10 1E 3E 	    mfspr   r1,isp
010E74 63 1C E0 01 	    sw      r1,TCB_r30[tr]
010E78 63 FC F1 01 	    sw      r31,TCB_r31[tr]
010E7C 02 10 10 3E 	    mfspr   r1,ipc
010E80 63 1C 00 02 	    sw      r1,TCB_IPC[tr]
010E84 46 1C 10 00 	    lw      r1,TCB_r1[tr]
                	
010E88 B9 21 00 00 	    bsr     SelectTaskToRun
010E8C 82 80 01 1A 	    mov     tr,r1
                	
                	    ; Restore the context of the selected task
010E90 46 1C 00 02 	    lw      r1,TCB_IPC[tr]
010E94 82 00 10 3C 	    mtspr   ipc,r1
010E98 46 FC F1 01 	    lw      r31,TCB_r31[tr]
010E9C 46 1C E0 01 	    lw      r1,TCB_r30[tr]
010EA0 82 00 1E 3C 	    mtspr   isp,r1
010EA4 46 DC D1 01 	    lw      r29,TCB_r29[tr]
010EA8 46 CC C1 01 	    lw      r28,TCB_r28[tr]
010EAC 46 BC B1 01 	    lw      r27,TCB_r27[tr]
010EB0 46 AC A1 01 	    lw      r26,TCB_r26[tr]
010EB4 46 9C 91 01 	    lw      r25,TCB_r25[tr]
                	;   lw      r24,TCB_r24[tr]    ; r24 is the task register - no need to load
010EB8 46 7C 71 01 	    lw      r23,TCB_r23[tr]
010EBC 46 6C 61 01 	    lw      r22,TCB_r22[tr]
010EC0 46 5C 51 01 	    lw      r21,TCB_r21[tr]
010EC4 46 4C 41 01 	    lw      r20,TCB_r20[tr]
010EC8 46 3C 31 01 	    lw      r19,TCB_r19[tr]
010ECC 46 2C 21 01 	    lw      r18,TCB_r18[tr]
010ED0 46 1C 11 01 	    lw      r17,TCB_r17[tr]
010ED4 46 0C 01 01 	    lw      r16,TCB_r16[tr]
010ED8 46 FC F0 00 	    lw      r15,TCB_r15[tr]
010EDC 46 EC E0 00 	    lw      r14,TCB_r14[tr]
010EE0 46 DC D0 00 	    lw      r13,TCB_r13[tr]
010EE4 46 CC C0 00 	    lw      r12,TCB_r12[tr]
010EE8 46 BC B0 00 	    lw      r11,TCB_r11[tr]
010EEC 46 AC A0 00 	    lw      r10,TCB_r10[tr]
010EF0 46 9C 90 00 	    lw      r9,TCB_r9[tr]
010EF4 46 8C 80 00 	    lw      r8,TCB_r8[tr]
010EF8 46 7C 70 00 	    lw      r7,TCB_r7[tr]
010EFC 46 6C 60 00 	    lw      r6,TCB_r6[tr]
010F00 46 5C 50 00 	    lw      r5,TCB_r5[tr]
010F04 46 4C 40 00 	    lw      r4,TCB_r4[tr]
010F08 46 3C 30 00 	    lw      r3,TCB_r3[tr]
010F0C 46 2C 20 00 	    lw      r2,TCB_r2[tr]
010F10 46 1C 10 00 	    lw      r1,TCB_r1[tr]
010F14 02 E0 3F 6E 	    rti
010F18 3F 00 00 00 	    nop
010F1C 3F 00 00 00 	    nop
                	    
                	.acknowledgeInterrupt:
010F20 FC 00 00 00 	    ldi     sp,#IRQ_STACK       ; set stack pointer to interrupt processing stack
010F24 0A E0 01 00 
010F28 E7 E0 01 00 	    push    r1
010F2C 0A 10 06 00 		ldi		r1,#3				; reset the edge sense circuit
010F30 7C DC FF 00 		sh		r1,PIC_RSTE
010F34 62 10 A8 1F 
010F38 7C D0 FF 00 		lh	    r1,TEXTSCR+220+$FFD00000
010F3C 44 10 B8 01 
010F40 94 10 02 00 		addui	r1,r1,#1
010F44 7C D0 FF 00 		sh	    r1,TEXTSCR+220+$FFD00000
010F48 62 10 B8 01 
010F4C 7C 02 00 00 		lw      r1,$20000
010F50 46 10 00 00 
010F54 7C D0 FF 00 		sh      r1,TEXTSCR+224+$FFD00000
010F58 62 10 C0 01 
010F5C 57 1F 10 00 		pop     r1
010F60 BA D3 FF FF 		bra     .SaveContext
                	
                	;------------------------------------------------------------------------------
                	; 1024Hz interupt routine. This must be fast. Allows the system time to be
                	; gotten by right shifting by 10 bits.
                	;------------------------------------------------------------------------------
                	
                	Tick1024Rout:
010F64 02 E0 01 6C 	    cpuid   sp,r0,#0
010F68 3D 0F 04 00 	    beq     sp,.0001
010F6C 02 E0 3F 6E 	    rti                         ; nothing for cpu >0 to do here
                	.0001:
010F70 FC 00 00 00 	    ldi     sp,#$8000           ; set stack pointer to interrupt processing stack
010F74 0A E0 01 00 
010F78 E7 E0 01 00 		push	r1
010F7C 0A 10 04 00 		ldi		r1,#2				; reset the edge sense circuit
010F80 7C DC FF 00 		sh		r1,PIC_RSTE
010F84 62 10 A8 1F 
010F88 64 10 20 00 		inc     Milliseconds
010F8C 57 1F 10 00 		pop		r1
010F90 02 E0 3F 6E 		rti                         ; restore stack pointer and return
                	
                	;------------------------------------------------------------------------------
                	; For now, just pick one at random.
                	;------------------------------------------------------------------------------
                	SelectTaskToRun:
010F94 02 1C 00 1A 	    mov     r1,tr             ; stay in the same task for now
010F98 37 FF 01 00 	    rtl
    lw      r1,RANDOM_NUM
010F9C 7C DC FF 00 
010FA0 46 10 00 18 
010FA4 02 20 00 6C 	    cpuid   r2,r0,#0
010FA8 3D 01 0E 00 	    beq     r2,.0001
010FAC 8C 10 3E 00 	    and     r1,r1,#$1F
010FB0 8D 10 02 00 	    or      r1,r1,#1         ; make sure it's an odd task for CPU1
010FB4 82 10 20 70 	    asl     r1,r1,#16
010FB8 7C C0 00 00 	    addui   r1,r1,#$C00000
010FBC 94 10 00 00 
010FC0 37 FF 01 00 	    rtl    
.0001:
010FC4 8C 10 3C 00 	    and     r1,r1,#$1E       ; make sure it's an even task for CPU0
010FC8 82 10 20 70 	    asl     r1,r1,#16
010FCC 7C C0 00 00 	    addui   r1,r1,#$C00000
010FD0 94 10 00 00 
010FD4 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	; GetSystemTime
                	;
                	; Returns 
                	;    r1 = the system time in seconds.
                	;------------------------------------------------------------------------------
                	
                	GetSystemTime:
010FD8 46 10 20 00 	    lw      r1,Milliseconds
010FDC 82 10 14 72 	    lsr     r1,r1,#10
010FE0 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	GetScreenLocation:
010FE4 7C D0 FF 00 		ldi		r1,#TEXTSCR+$FFD00000
010FE8 0A 10 00 00 
010FEC 37 FF 01 00 		rtl
GetCurrAttr:
010FF0 45 10 F0 00 		lhu		r1,NormAttr
010FF4 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	UpdateCursorPos:
010FF8 E7 EF 01 00 	    push    lr
010FFC E7 E0 01 00 		push	r1
011000 67 E1 01 00 		push    r2
011004 67 E2 01 00 		push    r4
011008 41 10 00 01 		lbu		r1,CursorRow
01100C 8C 10 7E 00 		and		r1,r1,#$3f
011010 7C DA FF 00 		lbu	    r2,TEXTREG+TEXT_COLS+$FFD00000
011014 41 20 00 00 
011018 02 21 02 2E 		mulu	r2,r2,r1
01101C 41 10 02 01 		lbu		r1,CursorCol
011020 8C 10 FE 00 		and		r1,r1,#$7f
011024 02 21 02 28 		addu	r2,r2,r1
011028 7C DA FF 00 		sc	    r2,TEXTREG+TEXT_CURPOS+$FFD00000
01102C 61 20 58 00 
011030 57 4F 10 00 		pop		r4
011034 57 2F 10 00 	    pop     r2
011038 57 1F 10 00 	    pop     r1
01103C 3B FF 11 00 	    rts
	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	CalcScreenLoc:
011040 E7 EF 01 00 	    push    lr
011044 67 E1 01 00 		push	r2
011048 67 E2 01 00 		push    r4
01104C 41 10 00 01 		lbu		r1,CursorRow
011050 8C 10 7E 00 		and		r1,r1,#$3f
011054 7C DA FF 00 		lbu	    r2,TEXTREG+TEXT_COLS+$FFD00000
011058 41 20 00 00 
01105C 02 21 02 2E 		mulu	r2,r2,r1
011060 41 10 02 01 		lbu		r1,CursorCol
011064 8C 10 FE 00 		and		r1,r1,#$7f
011068 02 21 02 28 		addu	r2,r2,r1
01106C 7C DA FF 00 		sc	    r2,TEXTREG+TEXT_CURPOS+$FFD00000
011070 61 20 58 00 
011074 39 EE FF FF 		bsr		GetScreenLocation
011078 02 21 04 70 		shl		r2,r2,#2
01107C 82 10 04 28 		addu	r1,r1,r2
011080 57 4F 10 00 		pop		r4
011084 57 2F 10 00 	    pop     r2
011088 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	DisplayChar:
01108C E7 EF 01 00 	    push    lr
011090 E7 E0 01 00 		push	r1
011094 67 E1 01 00 	    push    r2
011098 E7 E1 01 00 	    push    r3
01109C 67 E2 01 00 	    push    r4
0110A0 8C 10 FE 01 		and		r1,r1,#$FF
0110A4 86 20 1A 00 		cmp		r2,r1,#'\r'
0110A8 3D 01 42 00 		beq		r2,.docr
0110AC 86 20 22 01 		cmp		r2,r1,#$91		; cursor right ?
0110B0 3D 01 44 00 		beq		r2,.doCursorRight
0110B4 86 20 20 01 		cmp		r2,r1,#$90		; cursor up ?
0110B8 3D 01 4E 00 		beq		r2,.doCursorUp
0110BC 86 20 26 01 		cmp		r2,r1,#$93		; cursor left ?
0110C0 3D 01 54 00 		beq		r2,.doCursorLeft
0110C4 86 20 24 01 		cmp		r2,r1,#$92		; cursor down ?
0110C8 3D 01 5A 00 		beq		r2,.doCursorDown
0110CC 86 20 28 01 		cmp		r2,r1,#$94		; cursor home ?
0110D0 3D 01 62 00 		beq		r2,.doCursorHome
0110D4 86 20 32 01 		cmp		r2,r1,#$99		; delete ?
0110D8 3D 01 6A 00 		beq		r2,.doDelete
0110DC 86 20 10 00 		cmp		r2,r1,#CTRLH	; backspace ?
0110E0 3D 01 6E 00 		beq		r2,.doBackspace
0110E4 86 20 14 00 		cmp		r2,r1,#'\n'	; line feed ?
0110E8 3D 01 92 00 		beq		r2,.doLinefeed
0110EC 82 20 00 1A 		mov		r2,r1
0110F0 39 EA FF FF 		bsr		CalcScreenLoc
0110F4 82 30 00 1A 		mov		r3,r1
0110F8 02 11 00 1A 		mov		r1,r2
0110FC B9 A3 FE FF 		bsr		AsciiToScreen
011100 82 20 00 1A 		mov		r2,r1
011104 B9 DD FF FF 		bsr		GetCurrAttr
011108 82 10 04 1A 		or		r1,r1,r2
01110C E2 11 00 00 		sh	    r1,[r3]
011110 B9 20 00 00 		bsr		IncCursorPos
                	.dcx4:
011114 57 4F 10 00 		pop		r4
011118 57 3F 10 00 	    pop     r3
01111C 57 2F 10 00 	    pop     r2
011120 57 1F 10 00 	    pop     r1
011124 57 FF 11 00 	    pop     lr
011128 37 FF 01 00 		rtl
.docr:
01112C 60 00 02 01 		sb		r0,CursorCol
011130 39 D9 FF FF 		bsr		UpdateCursorPos
011134 3A FC FF FF 		bra     .dcx4
                	.doCursorRight:
011138 41 10 02 01 		lbu		r1,CursorCol
01113C 84 10 02 00 		add		r1,r1,#1
011140 96 20 A8 00 		cmpu	r2,r1,#TXTCOLS
011144 3D 31 04 00 		bge		r2,.dcx7
011148 60 10 02 01 		sb		r1,CursorCol
                	.dcx7:
01114C B9 D5 FF FF 		bsr		UpdateCursorPos
011150 BA F8 FF FF 		bra     .dcx4
                	.doCursorUp:
011154 41 10 00 01 		lbu		r1,CursorRow
011158 BD 00 FA FF 		beq		r1,.dcx7
01115C 85 10 02 00 		sub		r1,r1,#1
011160 60 10 00 01 		sb		r1,CursorRow
011164 3A FD FF FF 		bra		.dcx7
                	.doCursorLeft:
011168 41 10 02 01 		lbu		r1,CursorCol
01116C BD 00 F0 FF 		beq		r1,.dcx7
011170 85 10 02 00 		sub		r1,r1,#1
011174 60 10 02 01 		sb		r1,CursorCol
011178 BA FA FF FF 		bra		.dcx7
                	.doCursorDown:
01117C 41 10 00 01 		lbu		r1,CursorRow
011180 84 10 02 00 		add		r1,r1,#1
011184 96 20 3E 00 		cmpu	r2,r1,#TXTROWS
011188 3D 31 E2 FF 		bge		r2,.dcx7
01118C 60 10 00 01 		sb		r1,CursorRow
011190 BA F7 FF FF 		bra		.dcx7
                	.doCursorHome:
011194 41 10 02 01 		lbu		r1,CursorCol
011198 BD 00 06 00 		beq		r1,.dcx12
01119C 60 00 02 01 		sb		r0,CursorCol
0111A0 BA F5 FF FF 		bra		.dcx7
                	.dcx12:
0111A4 60 00 00 01 		sb		r0,CursorRow
0111A8 BA F4 FF FF 		bra		.dcx7
                	.doDelete:
0111AC B9 D2 FF FF 		bsr		CalcScreenLoc
0111B0 82 30 00 1A 		mov		r3,r1
0111B4 41 10 02 01 		lbu		r1,CursorCol
0111B8 3A 04 00 00 		bra		.dcx5
                	.doBackspace:
0111BC 41 10 02 01 		lbu		r1,CursorCol
0111C0 BD 00 AA FF 		beq		r1,.dcx4
0111C4 85 10 02 00 		sub		r1,r1,#1
0111C8 60 10 02 01 		sb		r1,CursorCol
0111CC B9 CE FF FF 		bsr		CalcScreenLoc
0111D0 82 30 00 1A 		mov		r3,r1
0111D4 41 10 02 01 		lbu		r1,CursorCol
                	.dcx5:
0111D8 C5 21 08 00 		lhu	    r2,4[r3]
0111DC E2 21 00 00 		sh	    r2,[r3]
0111E0 84 31 08 00 		add		r3,r3,#4
0111E4 84 10 02 00 		add		r1,r1,#1
0111E8 96 20 A8 00 		cmpu	r2,r1,#TXTCOLS
0111EC 3D 41 F6 FF 		blt		r2,.dcx5
0111F0 0A 10 40 00 		ldi		r1,#' '
0111F4 B9 84 FE FF 		bsr		AsciiToScreen
0111F8 45 20 F0 00 		lhu		r2,NormAttr
0111FC 82 10 04 1A 		or		r1,r1,r2
011200 85 31 08 00 		sub		r3,r3,#4
011204 E2 11 00 00 		sh	    r1,[r3]
011208 BA E1 FF FF 		bra		.dcx4
                	.doLinefeed:
01120C B9 06 00 00 		bsr		IncCursorRow
011210 BA E0 FF FF 		bra		.dcx4
                	
                	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	IncCursorPos:
011214 E7 EF 01 00 	    push    lr
011218 E7 E0 01 00 		push	r1
01121C 67 E1 01 00 	    push    r2
011220 67 E2 01 00 	    push    r4
011224 41 10 02 01 		lbu		r1,CursorCol
011228 94 10 02 00 		addui	r1,r1,#1
01122C 60 10 02 01 		sb		r1,CursorCol
011230 96 20 A8 00 		cmpu	r2,r1,#TXTCOLS
011234 3D 41 1E 00 		blt		r2,icc1
011238 60 00 02 01 		sb		r0,CursorCol
01123C BA 02 00 00 		bra		icr1
                	IncCursorRow:
011240 E7 EF 01 00 	    push    lr
011244 E7 E0 01 00 		push	r1
011248 67 E1 01 00 	    push    r2
01124C 67 E2 01 00 	    push    r4
                	icr1:
011250 41 10 00 01 		lbu		r1,CursorRow
011254 94 10 02 00 		addui	r1,r1,#1
011258 60 10 00 01 		sb		r1,CursorRow
01125C 96 20 3E 00 		cmpu	r2,r1,#TXTROWS
011260 3D 41 08 00 		blt		r2,icc1
011264 0A 20 3C 00 		ldi		r2,#TXTROWS-1
011268 60 20 00 01 		sb		r2,CursorRow
01126C B9 04 00 00 		bsr		ScrollUp
                	icc1:
011270 3F 00 00 00 	    nop
011274 3F 00 00 00 	    nop
011278 39 B0 FF FF 		bsr		UpdateCursorPos
01127C 57 4F 10 00 		pop		r4
011280 57 2F 10 00 	    pop     r2
011284 57 1F 10 00 	    pop     r1
011288 57 FF 11 00 		pop     lr
01128C 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	ScrollUp:
011290 E7 EF 01 00 	    push    lr
011294 E7 E0 01 00 		push	r1
011298 67 E1 01 00 	    push    r2
01129C E7 E1 01 00 	    push    r3
0112A0 E7 E2 01 00 	    push    r5
0112A4 67 E3 01 00 		push	r6
0112A8 7C DA FF 00 		lbu	    r1,TEXTREG+TEXT_COLS+$FFD00000
0112AC 41 10 00 00 
0112B0 7C DA FF 00 		lbu	    r2,TEXTREG+TEXT_ROWS+$FFD00000
0112B4 41 20 08 00 
0112B8 15 21 02 00 		subui	r2,r2,#1
0112BC 82 60 04 2E 		mulu	r6,r1,r2
0112C0 7C D0 FF 00 		ldi		r1,#TEXTSCR+$FFD00000
0112C4 0A 10 00 00 
0112C8 7C D0 FF 00 		ldi		r2,#TEXTSCR+TXTCOLS*4+$FFD00000
0112CC 0A 20 A0 02 
0112D0 0A 30 00 00 		ldi		r3,#0
                	.0001:
0112D4 4C 51 86 00 		lh	    r5,[r2+r3*4]
0112D8 EA 50 86 00 		sh	    r5,[r1+r3*4]
0112DC 94 31 02 00 		addui	r3,r3,#1
0112E0 15 63 02 00 		subui   r6,r6,#1
0112E4 3D 13 F8 FF 		bne	    r6,.0001
0112E8 7C DA FF 00 		lbu	    r1,TEXTREG+TEXT_ROWS+$FFD00000
0112EC 41 10 08 00 
0112F0 95 10 02 00 		subui	r1,r1,#1
0112F4 39 04 00 00 		bsr		BlankLine
0112F8 57 6F 10 00 		pop		r6
0112FC 57 5F 10 00 		pop		r5
011300 57 3F 10 00 	    pop     r3
011304 57 2F 10 00 	    pop     r2
011308 57 1F 10 00 	    pop     r1
01130C 57 FF 11 00 		pop     lr
011310 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; Blank out a line on the screen.
                	;
                	; Parameters:
                	;	r1 = line number to blank out
                	;------------------------------------------------------------------------------
                	
                	BlankLine:
011314 E7 EF 01 00 	    push    lr
011318 E7 E0 01 00 		push	r1
01131C 67 E1 01 00 	    push    r2
011320 E7 E1 01 00 	    push    r3
011324 67 E2 01 00 	    push    r4
011328 7C DA FF 00 	    lbu     r2,TEXTREG+TEXT_COLS+$FFD00000
01132C 41 20 00 00 
011330 02 31 02 2E 		mulu	r3,r2,r1
                	;	subui	r2,r2,#1		; r2 = #chars to blank - 1
011334 82 31 04 70 		shl		r3,r3,#2
011338 7C D0 FF 00 		addui	r3,r3,#TEXTSCR+$FFD00000
01133C 94 31 00 00 
011340 0A 10 40 00 		ldi		r1,#' '
011344 B9 5A FE FF 		bsr		AsciiToScreen
011348 45 40 F0 00 		lhu		r4,NormAttr
01134C 82 10 08 1A 		or		r1,r1,r4
                	.0001:
011350 EA 11 84 00 		sh	    r1,[r3+r2*4]
011354 15 21 02 00 		subui   r2,r2,#1
011358 3D 11 FC FF 		bne	    r2,.0001
01135C 57 4F 10 00 		pop		r4
011360 57 3F 10 00 	    pop     r3
011364 57 2F 10 00 	    pop     r2
011368 57 1F 10 00 	    pop     r1
01136C 57 FF 11 00 		pop     lr
011370 37 FF 01 00 		rtl

011374 00          		db	0
                	msgStart:
011375 46 49 53 41 		db	"FISA64 test system starting.",0
011379 36 34 20 74 
01137D 65 73 74 20 
011381 73 79 73 74 
011385 65 6D 20 73 
011389 74 61 72 74 
01138D 69 6E 67 2E 
011391 00          
                	
                	
                	; ============================================================================
                	; Monitor Task
                	; ============================================================================
                	
                	Monitor:
011392 00 00 0A 10 		ldi		r1,#49
011396 62 00       
011398 7C DC FF 00 		sc		r1,LEDS
01139C 61 10 00 0C 
                	;	bsr		ClearScreen
                	;	bsr		HomeCursor
0113A0 7C 01 00 00 		ldi		r1,#msgMonitorStarted
0113A4 0A 10 C2 31 
0113A8 39 7C FE FF 		bsr		DisplayStringCRLF
0113AC 60 00 08 01 		sb		r0,KeybdEcho
                		;ldi		r1,#7
                		;ldi		r2,#0
                		;ldi		r3,#IdleTask
                		;ldi		r4,#0
                		;ldi		r5,#0
                		;bsr		StartTask
                	mon1:
0113B0 0A 10 64 00 		ldi		r1,#50
0113B4 7C DC FF 00 		sc		r1,LEDS
0113B8 61 10 00 0C 
                	;	ldi		sp,#TCBs+TCB_Size-8		; reload the stack pointer, it may have been trashed
0113BC 7C 00 00 00 		ldi		sp,#MON_STACK
0113C0 0A E0 01 C0 
0113C4 02 00 00 6E 		cli
                	.PromptLn:
0113C8 B9 79 FE FF 		bsr		CRLF
0113CC 0A 10 48 00 		ldi		r1,#'$'
0113D0 B9 3C 00 00 		bsr		OutChar
                	.Prompt3:
0113D4 39 F0 00 00 		bsr		KeybdGetCharNoWait		; KeybdGetCharDirectNB
0113D8 BD 40 FE FF 		blt	    r1,.Prompt3
0113DC 86 20 1A 00 		cmp		r2,r1,#CR
0113E0 3D 01 06 00 		beq		r2,.Prompt1
0113E4 39 3A 00 00 		bsr		OutChar
0113E8 BA FD FF FF 		bra		.Prompt3
                	.Prompt1:
0113EC 60 00 02 01 		sb		r0,CursorCol
0113F0 39 8A FF FF 		bsr		CalcScreenLoc
0113F4 82 30 00 1A 		mov		r3,r1
0113F8 B9 0F 00 00 		bsr		MonGetch
0113FC 86 20 48 00 		cmp		r2,r1,#'$'
011400 3D 11 04 00 		bne		r2,.Prompt2
011404 39 0E 00 00 		bsr		MonGetch
                	.Prompt2:
011408 86 20 7E 00 		cmp		r2,r1,#'?'
01140C 3D 01 2C 00 		beq		r2,.doHelp
011410 86 20 86 00 		cmp		r2,r1,#'C'
011414 3D 01 6E 02 		beq		r2,doCLS
011418 86 20 C6 00 		cmp     r2,r1,#'c'
01141C 3D 01 DE 76 		beq     r2,doCS
011420 86 20 9A 00 		cmp		r2,r1,#'M'
011424 3D 01 64 00 		beq		r2,doDumpmem
011428 86 20 8C 00 		cmp		r2,r1,#'F'
01142C 3D 01 70 00 		beq		r2,doFillmem
011430 86 20 DA 00 		cmp		r2,r1,#'m'
011434 3D 01 D2 76 		beq		r2,MRTest
011438 86 20 A6 00 		cmp		r2,r1,#'S'
01143C 3D 01 AA 00 		beq		r2,doSDBoot
011440 86 20 CE 00 		cmp		r2,r1,#'g'
011444 3D 01 CC 76 		beq		r2,doRand
011448 86 20 CA 00 		cmp		r2,r1,#'e'
01144C 3D 01 C8 76 		beq		r2,eval
011450 86 20 94 00 		cmp		r2,r1,#'J'
011454 3D 01 B2 00 		beq		r2,doJump
011458 86 20 88 00 		cmp		r2,r1,#'D'
01145C 3D 01 B8 00 		beq		r2,doDate
011460 3A EA FF FF 		bra     mon1
                	
                	.doHelp:
011464 7C 01 00 00 		ldi		r1,#msgHelp
011468 0A 10 B0 30 
01146C B9 5D FE FF 		bsr		DisplayString
011470 3A E8 FF FF 		bra     mon1
                	
                	MonGetch:
011474 E7 EF 01 00 	    push    lr
011478 C5 11 00 00 		lhu	    r1,[r3]
01147C 8C 10 FE 03 		andi	r1,r1,#$1FF
011480 84 31 08 00 		add		r3,r3,#4
011484 B9 37 FE FF 		bsr		ScreenToAscii
011488 57 FF 11 00 		pop     lr
01148C 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; Ignore blanks in the input
                	; r3 = text pointer
                	; r1 destroyed
                	;------------------------------------------------------------------------------
                	
                	ignBlanks:
011490 E7 EF 01 00 	    push    lr
011494 67 E1 01 00 	    push    r2
                	ignBlanks1:
011498 B9 FB FF FF 		bsr		MonGetch
01149C 86 20 40 00 		cmp		r2,r1,#' '
0114A0 3D 01 FC FF 		beq		r2,ignBlanks1
0114A4 85 31 08 00 		sub		r3,r3,#4
0114A8 57 2F 10 00 		pop     r2
0114AC 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	GetTwoParams:
0114B0 E7 EF 01 00 	    push    lr
0114B4 B9 FB FF FF 		bsr		ignBlanks
0114B8 B9 5B 00 00 		bsr		GetHexNumber	; get start address of dump
0114BC 82 20 00 1A 		mov		r2,r1
0114C0 39 FA FF FF 		bsr		ignBlanks
0114C4 39 5A 00 00 		bsr		GetHexNumber	; get end address of dump
0114C8 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; Get a range, the end must be greater or equal to the start.
                	;------------------------------------------------------------------------------
                	
                	GetRange:
0114CC E7 EF 01 00 	    push    lr
0114D0 67 E2 01 00 	    push    r4
0114D4 B9 FB FF FF 		bsr		GetTwoParams
0114D8 02 41 02 2C 		cmpu	r4,r2,r1
0114DC 3D 22 B2 01 		bgt		r4,DisplayErr
0114E0 57 4F 10 00 		pop     r4
0114E4 57 FF 11 00 		pop     lr
0114E8 37 FF 01 00 		rtl

                	doDumpmem:
0114EC 39 2E FE FF 		bsr		CursorOff
0114F0 B9 FB FF FF 		bsr		GetRange
0114F4 39 54 FE FF 		bsr		CRLF
                	;	bra     mon1
                	.001:
0114F8 39 45 00 00 		bsr		CheckKeys
0114FC B9 2C 00 00 		bsr		DisplayMemBytes
011500 02 41 02 2C 		cmpu	r4,r2,r1
011504 3D 52 FA FF 		ble		r4,.001
011508 3A D5 FF FF 		bra     mon1
                	
                	;------------------------------------------------------------------------------
                	; Fill memory
                	;
                	; FB FFD80000 FFD8FFFF r	; fill sprite memory with random bytes
                	;------------------------------------------------------------------------------
                	
                	doFillmem:
01150C 39 2A FE FF 		bsr		CursorOff
011510 B9 EC FF FF 		bsr		MonGetch		; skip over 'B' of "FB"
011514 86 20 84 00 		cmp		r2,r1,#'B'
011518 3D 01 04 00 		beq		r2,.0004
01151C 95 31 08 00 		subui	r3,r3,#4		; backup text pointer
                	.0004:
011520 B9 F5 FF FF 		bsr		GetRange
011524 E7 E0 01 00 		push	r1
011528 67 E1 01 00 	    push    r2
01152C B9 EC FF FF 		bsr		ignBlanks
011530 B9 E8 FF FF 		bsr		MonGetch		; check for random fill
011534 86 20 E4 00 		cmp		r2,r1,#'r'
011538 3D 01 18 00 		beq		r2,.0001
01153C 95 31 08 00 		subui   r3,r3,#4
011540 B9 4A 00 00 		bsr		GetHexNumber
011544 82 30 00 1A 		mov		r3,r1
011548 57 2F 10 00 		pop		r2
01154C 57 1F 10 00 	    pop     r1
                	.0002:
011550 39 3A 00 00 		bsr		CheckKeys
011554 60 31 00 00 		sb		r3,[r2]
011558 14 21 02 00 		addui	r2,r2,#1
01155C 02 51 02 2C 		cmpu	r5,r2,r1
011560 BD 42 F8 FF 		blt		r5,.0002
011564 BA C9 FF FF 		bra		mon1
                	.0001:
011568 57 2F 10 00 		pop		r2
01156C 57 1F 10 00 	    pop     r1
                	.0003:
011570 39 36 00 00 		bsr		CheckKeys
011574 7C DC FF 00 		lw	    r3,RANDOM_NUM
011578 46 30 00 18 
01157C 60 31 00 00 		sb		r3,[r2]
011580 14 21 02 00 		addui	r2,r2,#1
011584 02 51 02 2C 		cmpu	r5,r2,r1
011588 BD 42 F4 FF 		blt		r5,.0003
01158C BA C4 FF FF 		bra		mon1
                	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	doSDBoot:
                	;	sub		r3,r3,#4
011590 39 70 DD FF 		bsr		SDInit
011594 BD 10 0E FF 		bne	    r1,mon1
011598 39 6F DD FF 		bsr		SDReadPart
01159C BD 10 0A FF 		bne	    r1,mon1
0115A0 B9 89 DD FF 		bsr		SDReadBoot
0115A4 BD 10 06 FF 		bne	    r1,mon1
0115A8 39 89 DD FF 		bsr		loadBootFile
0115AC 7C 00 00 00 		jmp		mon1
0115B0 3C 00 D8 89 
                	
                	OutChar:
0115B4 3E 00 30 00 	    jmp     (OutputVec)
                	
                	;------------------------------------------------------------------------------
                	; Jump to subroutine
                	;
                	; J 10000     ; restart system
                	;------------------------------------------------------------------------------
                	
                	doJump:
0115B8 B9 D7 FF FF 		bsr		MonGetch		; skip over 'S'
0115BC B9 DA FF FF 		bsr		ignBlanks
0115C0 B9 3A 00 00 		bsr		GetHexNumber
0115C4 BC F0 01 00 		jsr		[r1]
0115C8 3A BD FF FF 		bra		mon1
                	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	doDate:
0115CC 39 D5 FF FF 		bsr		MonGetch		; skip over 'T'
0115D0 86 50 82 00 		cmp		r5,r1,#'A'		; look for DAY
0115D4 BD 02 38 00 		beq		r5,doDay
0115D8 39 D7 FF FF 		bsr		ignBlanks
0115DC 39 D3 FF FF 		bsr		MonGetch
0115E0 86 50 7E 00 		cmp		r5,r1,#'?'
0115E4 BD 02 14 00 		beq		r5,.0001
0115E8 95 31 08 00 		subui	r3,r3,#4
0115EC 39 35 00 00 		bsr		GetHexNumber
0115F0 60 10 4A 01 		sb		r1,RTCC_BUF+5	; update month
0115F4 39 34 00 00 		bsr		GetHexNumber
0115F8 60 10 48 01 		sb		r1,RTCC_BUF+4	; update day
0115FC 39 33 00 00 		bsr		GetHexNumber
011600 60 10 4C 01 		sb		r1,RTCC_BUF+6	; update year
011604 B9 90 01 00 		bsr		RTCCWritebuf
011608 3A B5 FF FF 		bra		mon1
                	.0001:
01160C B9 8A 01 00 		bsr		RTCCReadbuf
011610 B9 30 FE FF 		bsr		CRLF
011614 41 10 4A 01 		lbu		r1,RTCC_BUF+5
011618 B9 1F FE FF 		bsr		DisplayByte
01161C 0A 10 5E 00 		ldi		r1,#'/'
011620 B9 F2 FF FF 		bsr		OutChar
011624 41 10 48 01 		lbu		r1,RTCC_BUF+4
011628 B9 1D FE FF 		bsr		DisplayByte
01162C 0A 10 5E 00 		ldi		r1,#'/'
011630 B9 F0 FF FF 		bsr		OutChar
011634 41 10 4C 01 		lbu		r1,RTCC_BUF+6
011638 B9 1B FE FF 		bsr		DisplayByte
01163C 39 2B FE FF 		bsr		CRLF
011640 3A AE FF FF 		bra		mon1
                	
                	doDay:
011644 B9 C9 FF FF 		bsr		ignBlanks
011648 B9 29 00 00 		bsr		GetHexNumber
01164C 82 30 00 1A 		mov		r3,r1			; value to write
011650 0A 10 DE 00 		ldi		r1,#$6F			; device $6F
011654 0A 20 06 00 		ldi		r2,#$03			; register 3
011658 39 6F 01 00 		bsr		I2C_WRITE
01165C BA AA FF FF 		bra		mon1
                	
                	;------------------------------------------------------------------------------
                	; Display memory pointed to by r2.
                	; destroys r1,r3
                	;------------------------------------------------------------------------------
                	;
                	DisplayMemBytes:
011660 E7 EF 01 00 	    push    lr
011664 E7 E0 01 00 		push	r1
011668 E7 E1 01 00 	    push    r3
01166C 67 E2 01 00 	    push    r4
011670 0A 10 7C 00 		ldi		r1,#'>'
011674 39 E8 FF FF 		bsr		OutChar
011678 0A 10 84 00 		ldi		r1,#'B'
01167C 39 E7 FF FF 		bsr		OutChar
011680 0A 10 40 00 		ldi		r1,#' '
011684 39 E6 FF FF 		bsr		OutChar
011688 02 11 00 1A 		mov		r1,r2
01168C 39 0C FE FF 		bsr		DisplayHalf
011690 0A 30 10 00 		ldi		r3,#8
                	.001:
011694 0A 10 40 00 		ldi		r1,#' '
011698 B9 E3 FF FF 		bsr		OutChar
01169C 41 11 00 00 		lbu		r1,[r2]
0116A0 B9 0E FE FF 		bsr		DisplayByte
0116A4 14 21 02 00 		addui	r2,r2,#1
0116A8 95 31 02 00 		subui   r3,r3,#1
0116AC BD 11 F4 FF 		bne	    r3,.001
0116B0 0A 10 74 00 		ldi		r1,#':'
0116B4 39 E0 FF FF 		bsr		OutChar
0116B8 7C 70 0D 00 		ldi		r1,#%110101110_000000100_0000000000	; reverse video
0116BC 0A 10 00 20 
0116C0 62 10 F0 00 		sh		r1,NormAttr
0116C4 0A 30 10 00 		ldi		r3,#8
0116C8 15 21 10 00 		subui	r2,r2,#8
                	.002
0116CC 41 11 00 00 		lbu		r1,[r2]
0116D0 96 40 34 00 		cmpu	r4,r1,#26				; convert control characters to '.'
0116D4 3D 32 06 00 		bge		r4,.004
0116D8 0A 10 5C 00 		ldi		r1,#'.'
0116DC 3A 02 00 00 		bra     .003
                	.004:
0116E0 96 40 00 01 		cmpu	r4,r1,#$80				; convert other non-ascii to '.'
0116E4 3D 42 04 00 		blt		r4,.003
0116E8 0A 10 5C 00 		ldi		r1,#'.'
                	.003:
0116EC 39 D9 FF FF 		bsr		OutChar
0116F0 14 21 02 00 		addui	r2,r2,#1
0116F4 95 31 02 00 		subui   r3,r3,#1
0116F8 BD 11 EA FF 		bne	    r3,.002
0116FC FC 26 00 00 		ldi		r1,#%000000100_110101110_0000000000	; normal video
011700 0A 10 00 70 
011704 62 10 F0 00 		sh		r1,NormAttr
011708 B9 11 FE FF 		bsr		CRLF
01170C 57 4F 10 00 		pop     r4
011710 57 3F 10 00 		pop		r3
011714 57 1F 10 00 	    pop     r1
011718 57 FF 11 00 	    pop     lr
01171C 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; CheckKeys:
                	;	Checks for a CTRLC or a scroll lock during long running dumps.
                	;------------------------------------------------------------------------------
                	
                	CheckKeys:
011720 E7 EF 01 00 	    push    lr
011724 39 02 00 00 		bsr	    CTRLCCheck
011728 B9 07 00 00 		bsr     CheckScrollLock
01172C 57 FF 11 00 		pop     lr
011730 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; CTRLCCheck
                	;	Checks to see if CTRL-C is pressed. If so then the current routine is
                	; aborted and control is returned to the monitor.
                	;------------------------------------------------------------------------------
                	
                	CTRLCCheck:
011734 E7 EF 01 00 	    push    lr
011738 E7 E0 01 00 		push	r1
01173C 67 E1 01 00 		push    r2
011740 B9 82 00 00 		bsr		KeybdGetCharNoWait
011744 86 20 06 00 		cmp		r2,r1,#CTRLC
011748 3D 01 0A 00 		beq		r2,.0001
01174C 57 2F 10 00 		pop     r2
011750 57 1F 10 00 		pop		r1
011754 57 FF 11 00 		pop     lr
011758 37 FF 01 00 		rtl
.0001:
01175C 14 EF 31 00 		addui	sp,sp,#24
011760 3A 8A FF FF 		bra     mon1
                	
                	;------------------------------------------------------------------------------
                	; CheckScrollLock:
                	;	Check for a scroll lock by the user. If scroll lock is active then tasks
                	; are rescheduled while the scroll lock state is tested in a loop.
                	;------------------------------------------------------------------------------
                	
                	CheckScrollLock:
011764 E7 EF 01 00 	    push    lr
011768 E7 E0 01 00 		push	r1
01176C 67 E1 01 00 		push    r2
                	.0002:
011770 43 10 0C 01 		lcu		r1,KeybdLocks
011774 7C 00 00 00 		and		r2,r1,#$4000		; is scroll lock active ?
011778 8C 20 00 80 
01177C 3D 01 04 00 		beq		r2,.0001
                		brk		#2*16				; reschedule tasks
011780 3A FE FF FF 		bra     .0002
                	.0001:
011784 57 2F 10 00 	    pop     r2
011788 57 1F 10 00 		pop		r1
01178C 57 FF 11 00 		pop     lr
011790 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; Get a hexidecimal number. Maximum of eight digits.
                	; R3 = text pointer (updated)
                	; R1 = hex number
                	;------------------------------------------------------------------------------
                	;
                	GetHexNumber:
011794 E7 EF 01 00 	    push    lr
011798 67 E1 01 00 		push	r2
01179C 67 E2 01 00 	    push    r4
0117A0 0A 20 00 00 		ldi		r2,#0
0117A4 0A 40 20 00 		ldi		r4,#16
                	.gthxn2:
0117A8 B9 99 FF FF 		bsr		MonGetch
0117AC 39 05 00 00 		bsr		AsciiToHexNybble
0117B0 BD 40 0A 00 		bmi		r1,.gthxn1
0117B4 02 21 08 70 		asl		r2,r2,#4
0117B8 02 21 02 1A 		or		r2,r2,r1
0117BC 15 42 02 00 		subui   r4,r4,#1
0117C0 3D 12 F4 FF 	    bne	    r4,.gthxn2
                	.gthxn1:
0117C4 02 11 00 1A 		mov		r1,r2
0117C8 57 4F 10 00 		pop		r4
0117CC 57 2F 10 00 	    pop     r2
0117D0 3B FF 11 00 	    rts

                	;------------------------------------------------------------------------------
                	; Convert ASCII character in the range '0' to '9', 'a' to 'f' or 'A' to 'F'
                	; to a hex nybble.
                	;------------------------------------------------------------------------------
                	;
                	AsciiToHexNybble:
0117D4 67 E1 01 00 	    push    r2
0117D8 96 20 60 00 		cmpu	r2,r1,#'0'
0117DC 3D 41 2C 00 		blt		r2,.gthx3
0117E0 96 20 74 00 		cmpu	r2,r1,#'9'+1
0117E4 3D 31 08 00 		bge		r2,.gthx5
0117E8 95 10 60 00 		subui	r1,r1,#'0'
0117EC 57 2F 10 00 		pop     r2
0117F0 37 FF 01 00 		rtl
.gthx5:
0117F4 96 20 82 00 		cmpu	r2,r1,#'A'
0117F8 3D 41 1E 00 		blt		r2,.gthx3
0117FC 96 20 8E 00 		cmpu	r2,r1,#'F'+1
011800 3D 31 0A 00 		bge		r2,.gthx6
011804 95 10 82 00 		subui	r1,r1,#'A'
011808 94 10 14 00 		addui	r1,r1,#10
01180C 57 2F 10 00 		pop     r2
011810 37 FF 01 00 		rtl
.gthx6:
011814 96 20 C2 00 		cmpu	r2,r1,#'a'
011818 3D 41 0E 00 		blt		r2,.gthx3
01181C 96 20 F6 00 		cmpu	r2,r1,#'z'+1
011820 3D 31 0A 00 		bge		r2,.gthx3
011824 95 10 C2 00 		subui	r1,r1,#'a'
011828 94 10 14 00 		addui	r1,r1,#10
01182C 57 2F 10 00 		pop     r2
011830 37 FF 01 00 		rtl
.gthx3:
011834 57 2F 10 00 	    pop     r2
011838 0A 10 FE FF 		ldi		r1,#-1		; not a hex number
01183C 37 FF 01 00 		rtl

                	DisplayErr:
011840 7C 01 00 00 		ldi		r1,#msgErr
011844 0A 10 A0 30 
011848 39 E2 FD FF 		bsr		DisplayString
01184C BA 6C FF FF 		bra mon1
                	
                	msgErr:
011850 2A 2A 45 72 		db	"**Err",CR,LF,0
011854 72 0D 0A 00 
                	
                	msgHelp:
011858 3F 20 3D 20 		db		"? = Display Help",CR,LF
01185C 44 69 73 70 
011860 6C 61 79 20 
011864 48 65 6C 70 
011868 0D 0A       
01186A 43 4C 53 20 		db		"CLS = clear screen",CR,LF
01186E 3D 20 63 6C 
011872 65 61 72 20 
011876 73 63 72 65 
01187A 65 6E 0D 0A 
01187E 44 54 20 3D 		db		"DT = set/read date",CR,LF
011882 20 73 65 74 
011886 2F 72 65 61 
01188A 64 20 64 61 
01188E 74 65 0D 0A 
011892 46 42 20 3D 		db		"FB = fill memory",CR,LF
011896 20 66 69 6C 
01189A 6C 20 6D 65 
01189E 6D 6F 72 79 
0118A2 0D 0A       
0118A4 4D 42 20 3D 		db		"MB = dump memory",CR,LF
0118A8 20 64 75 6D 
0118AC 70 20 6D 65 
0118B0 6D 6F 72 79 
0118B4 0D 0A       
0118B6 4A 53 20 3D 		db		"JS = jump to code",CR,LF
0118BA 20 6A 75 6D 
0118BE 70 20 74 6F 
0118C2 20 63 6F 64 
0118C6 65 0D 0A    
0118C9 53 20 3D 20 		db		"S = boot from SD card",CR,LF
0118CD 62 6F 6F 74 
0118D1 20 66 72 6F 
0118D5 6D 20 53 44 
0118D9 20 63 61 72 
0118DD 64 0D 0A    
0118E0 00          		db		0
                	
                	msgMonitorStarted
0118E1 4D 6F 6E 69 		db		"Monitor started.",0
0118E5 74 6F 72 20 
0118E9 73 74 61 72 
0118ED 74 65 64 2E 
0118F1 00          
                	
                	doCLS:
0118F2 00 00 B9 B0 		bsr		ClearScreen
0118F6 FD FF       
0118F8 B9 AD FD FF 		bsr		HomeCursor
0118FC BA 56 FF FF 		bra     mon1
                	
                	;------------------------------------------------------------------------------
                	; Get a random number from peripheral device.
                	;------------------------------------------------------------------------------
                	
                	GetRandomNumber:
011900 7C DC FF 00 	    lw      r1,$FFDC0C00
011904 46 10 00 18 
011908 37 FF 01 00 	    rtl
                
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	; Keyboard processing routines follow.
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	KEYBD_DELAY		EQU		1000
                	
                	KeybdGetCharDirectNB:
01190C E7 EF 01 00 	    push    lr
011910 67 E1 01 00 		push	r2
011914 02 00 02 6E 		sei
011918 7C DC FF 00 		lcu		r1,KEYBD
01191C 43 10 00 00 
011920 FC 00 00 00 		and		r2,r1,#$8000
011924 8C 20 00 00 
011928 3D 01 22 00 		beq		r2,.0001
01192C 7C DC FF 00 		lbu		r0,KEYBD+4		; clear keyboard strobe
011930 41 00 08 00 
011934 02 00 00 6E 		cli
011938 8C 20 00 10 		and		r2,r1,#$800	; is it keydown ?
01193C 3D 11 18 00 		bne	    r2,.0001
011940 8C 10 FE 01 		and		r1,r1,#$FF
011944 41 20 08 01 		lbu		r2,KeybdEcho
011948 3D 01 0C 00 		beq		r2,.0002
01194C 86 20 1A 00 		cmp		r2,r1,#CR
011950 3D 11 06 00 		bne		r2,.0003
011954 39 C8 FD FF 		bsr		CRLF
011958 3A 01 00 00 		bra     .0002
                	.0003:
01195C 3E F0 31 00 		jsr		(OutputVec)
                	.0002:
011960 57 2F 10 00 		pop		r2
011964 57 FF 11 00 		pop     lr
011968 37 FF 01 00 		rtl
.0001:
01196C 02 00 00 6E 		cli
011970 0A 10 FE FF 		ldi		r1,#-1
011974 57 2F 10 00 		pop		r2
011978 57 FF 11 00 		pop     lr
01197C 37 FF 01 00 		rtl

                	KeybdGetCharDirect:
011980 E7 EF 01 00 	    push    lr
011984 67 E1 01 00 		push	r2
                	.0001:
011988 7C DC FF 00 		lc		r1,KEYBD
01198C 42 10 00 00 
011990 FC 00 00 00 		and		r2,r1,#$8000
011994 8C 20 00 00 
011998 3D 01 F8 FF 		beq		r2,.0001
01199C 7C DC FF 00 		lbu		r0,KEYBD+4		; clear keyboard strobe
0119A0 41 00 08 00 
0119A4 8C 20 00 10 		and		r2,r1,#$800	; is it keydown ?
0119A8 3D 11 F0 FF 		bne	    r2,.0001
0119AC 8C 10 FE 01 		and		r1,r1,#$FF
0119B0 41 20 08 01 		lbu		r2,KeybdEcho
0119B4 3D 01 0C 00 		beq		r2,.gk1
0119B8 86 20 1A 00 		cmp		r2,r1,#CR
0119BC 3D 11 06 00 		bne		r2,.gk2
0119C0 B9 BA FD FF 		bsr		CRLF
0119C4 3A 01 00 00 		bra     .gk1
                	.gk2:
0119C8 3E F0 31 00 		jsr		(OutputVec)
                	.gk1:
0119CC 57 2F 10 00 		pop		r2
0119D0 57 FF 11 00 		pop     lr
0119D4 37 FF 01 00 		rtl

                	;KeybdInit:
                	;	mfspr	r1,cr0		; turn off tmr mode
                	;	push	r1
                	;	mtspr	cr0,r0
                	;	ldi		r1,#33
                	;	sb		r1,LEDS
                	;	bsr		WaitForKeybdAck	; grab a byte from the keyboard
                	;	cmp		flg0,r1,#$AA	; did it send a ack ?
                	;	
                	;	ldi		r1,#$ff			; issue keyboard reset
                	;	bsr		SendByteToKeybd
                	;	ldi		r1,#38
                	;	sb		r1,LEDS
                	;	ldi		r1,#4
                	;	jsr		Sleep
                	;	ldi		r1,#KEYBD_DELAY	; delay a bit
                	kbdi5:
                	;	sub		r1,r1,#1
                	;	brnz	r1,kbdi5
                	;	ldi		r1,#34
                	;	sb		r1,LEDS
                	;	ldi		r1,#0xf0		; send scan code select
                	;	bsr		SendByteToKeybd
                	;	ldi		r1,#35
                	;	sb		r1,LEDS
                	;	ldi		r2,#0xFA
                	;	bsr		WaitForKeybdAck
                	;	cmp		fl0,r1,#$FA
                	;	bne		fl0,kbdi2
                	;	ldi		r1,#36
                	;	sb		r1,LEDS
                	;	ldi		r1,#2			; select scan code set#2
                	;	bsr		SendByteToKeybd
                	;	ldi		r1,#39
                	;	sb		r1,LEDS
                	;kbdi2:
                	;	ldi		r1,#45
                	;	sb		r1,LEDS
                	;	pop		r1				; turn back on tmr mode
                	;	mtspr	cr0,r1
                	;	rtl
                	
                	msgBadKeybd:
0119D8 4B 65 79 62 		db		"Keyboard not responding.",0
0119DC 6F 61 72 64 
0119E0 20 6E 6F 74 
0119E4 20 72 65 73 
0119E8 70 6F 6E 64 
0119EC 69 6E 67 2E 
0119F0 00          
                	
                	;SendByteToKeybd:
                	;	push	r2
                	;	sb		r1,KEYBD
                	;	ldi		r1,#40
                	;	sb		r1,LEDS
                	;	mfspr	r3,tick
                	;kbdi4:						; wait for transmit complete
                	;	mfspr	r4,tick
                	;	sub		r4,r4,r3
                	;	cmp		fl0,r4,#KEYBD_DELAY
                	;	bhi		fl0,kbdbad
                	;	ldi		r1,#41
                	;	sb		r1,LEDS
                	;	lbu		r1,KEYBD+1
                	;	and		fl0,r1,#64
                	;	brz		fl0,kbdi4
                	;	bra 	sbtk1
                	;kbdbad:
                	;	ldi		r1,#42
                	;	sb		r1,LEDS
                	;	lbu		r1,KeybdBad
                	;	brnz	r1,sbtk2
                	;	ldi		r1,#1
                	;	sb		r1,KeybdBad
                	;	ldi		r1,#43
                	;	sb		r1,LEDS
                	;	ldi		r1,#msgBadKeybd
                	;	bsr		DisplayStringCRLF
                	;sbtk1:
                	;	ldi		r1,#44
                	;	sb		r1,LEDS
                	;	pop		r2
                	;	rtl
                	;sbtk2:
                	;	bra sbtk1
                	
                	; Wait for keyboard to respond with an ACK (FA)
                	;
                	;WaitForKeybdAck:
                	;	ldi		r1,#64
                	;	sb		r1,LEDS
                	;	mfspr	r3,tick
                	;wkbdack1:
                	;	mfspr	r4,tick
                	;	sub		r4,r4,r3
                	;	cmp		fl0,r4,#KEYBD_DELAY
                	;	bhi		fl0,wkbdbad
                	;	ldi		r1,#65
                	;	sb		r1,LEDS
                	;	lb		r1,KEYBD+1				; check keyboard status for key
                	;	brpl	r1,wkbdack1				; no key available, go back
                	;	lbu		r1,KEYBD				; get the scan code
                	;	sb		r0,KEYBD+1				; clear recieve register
                	;wkbdbad:
                	;	rtl
                	
                	KeybdInit:
0119F1 00 00 00 E7 	    push    lr
0119F5 EF 01 00    
0119F8 0A 30 0A 00 		ldi		r3,#5
                	.0001:
0119FC 39 19 00 00 		bsr		KeybdRecvByte	; Look for $AA
011A00 BD 40 06 00 		bmi		r1,.0002
011A04 86 20 54 01 		cmp		r2,r1,#$AA		;
011A08 3D 01 20 00 		beq		r2,.config
                	.0002:
011A0C B9 76 00 00 		bsr		Wait10ms
011A10 0A 10 FE FF 		ldi		r1,#-1			; send reset code to keyboard
011A14 7C DC FF 00 		sb		r1,KEYBD+1		; write to status reg to clear TX state
011A18 60 10 02 00 
011A1C B9 74 00 00 		bsr		Wait10ms
011A20 0A 10 FE 01 		ldi		r1,#$FF
011A24 39 72 00 00 		bsr		KeybdSendByte	; now write to transmit register
011A28 B9 1B 00 00 		bsr		KeybdWaitTx		; wait until no longer busy
011A2C 39 13 00 00 		bsr		KeybdRecvByte	; look for an ACK ($FA)
011A30 86 20 F4 01 		cmp		r2,r1,#$FA
011A34 39 12 00 00 		bsr		KeybdRecvByte
011A38 86 20 F8 01 		cmp		r2,r1,#$FC		; reset error ?
011A3C 3D 01 1A 00 		beq		r2,.tryAgain
011A40 86 20 54 01 		cmp		r2,r1,#$AA		; reset complete okay ?
011A44 3D 11 16 00 		bne		r2,.tryAgain
                	.config:
011A48 0A 10 E0 01 		ldi		r1,#$F0			; send scan code select
011A4C 7C DC FF 00 		sc		r1,LEDS
011A50 61 10 00 0C 
011A54 39 6C 00 00 		bsr		KeybdSendByte
011A58 B9 15 00 00 		bsr		KeybdWaitTx
011A5C BD 40 0A 00 		bmi		r1,.tryAgain
011A60 B9 0C 00 00 		bsr		KeybdRecvByte	; wait for response from keyboard
011A64 BD 40 06 00 		bmi		r1,.tryAgain
011A68 86 20 F4 01 		cmp		r2,r1,#$FA
011A6C 3D 01 10 00 		beq		r2,.0004
                	.tryAgain:
011A70 95 31 02 00 	    subui   r3,r3,#1
011A74 BD 11 C4 FF 		bne	    r3,.0001
                	.keybdErr:
011A78 7C 01 00 00 		ldi		r1,#msgBadKeybd
011A7C 0A 10 B0 33 
011A80 39 9B FD FF 		bsr		DisplayString
011A84 57 FF 11 00 		pop     lr
011A88 37 FF 01 00 		rtl
.0004:
011A8C 0A 10 04 00 		ldi		r1,#2			; select scan code set #2
011A90 B9 64 00 00 		bsr		KeybdSendByte
011A94 39 0E 00 00 		bsr		KeybdWaitTx
011A98 BD 40 EC FF 		bmi		r1,.tryAgain
011A9C 57 FF 11 00 		pop     lr
011AA0 37 FF 01 00 		rtl

                	; Get the keyboard status
                	;
                	KeybdGetStatus:
011AA4 7C DC FF 00 		lb		r1,KEYBD+1
011AA8 40 10 02 00 
011AAC 37 FF 01 00 		rtl

                	; Get the scancode from the keyboard port
                	;
                	KeybdGetScancode:
011AB0 7C DC FF 00 		lbu		r1,KEYBD				; get the scan code
011AB4 41 10 00 00 
011AB8 7C DC FF 00 		sb		r0,KEYBD+1				; clear receive register
011ABC 60 00 02 00 
011AC0 37 FF 01 00 		rtl

                	; Recieve a byte from the keyboard, used after a command is sent to the
                	; keyboard in order to wait for a response.
                	;
                	KeybdRecvByte:
011AC4 E7 EF 01 00 	    push    lr
011AC8 E7 E1 01 00 		push	r3
011ACC 0A 30 C8 00 		ldi		r3,#100			; wait up to 1s
                	.0003:
011AD0 B9 FA FF FF 		bsr		KeybdGetStatus	; wait for response from keyboard
011AD4 BD 40 10 00 		bmi		r1,.0004		; is input buffer full ? yes, branch
011AD8 39 5D 00 00 		bsr		Wait10ms		; wait a bit
011ADC 95 31 02 00 		subui   r3,r3,#1
011AE0 BD 11 F8 FF 		bne     r3,.0003		; go back and try again
011AE4 57 3F 10 00 		pop		r3				; timeout
011AE8 0A 10 FE FF 		ldi		r1,#-1			; return -1
011AEC 57 FF 11 00 		pop     lr
011AF0 37 FF 01 00 		rtl
.0004:
011AF4 B9 F7 FF FF 		bsr		KeybdGetScancode
011AF8 57 3F 10 00 		pop		r3
011AFC 57 FF 11 00 		pop     lr
011B00 37 FF 01 00 		rtl

                	
                	; Wait until the keyboard transmit is complete
                	; Returns .CF = 1 if successful, .CF=0 timeout
                	;
                	KeybdWaitTx:
011B04 E7 EF 01 00 	    push    lr
011B08 67 E1 01 00 		push	r2
011B0C E7 E1 01 00 	    push    r3
011B10 0A 30 C8 00 		ldi		r3,#100			; wait a max of 1s
                	.0001:
011B14 39 F2 FF FF 		bsr		KeybdGetStatus
011B18 8C 10 80 00 		and		r1,r1,#$40		; check for transmit complete bit
011B1C BD 10 12 00 		bne	    r1,.0002		; branch if bit set
011B20 39 54 00 00 		bsr		Wait10ms		; delay a little bit
011B24 95 31 02 00 		subui   r3,r3,#1
011B28 BD 11 F6 FF 		bne	    r3,.0001		; go back and try again
011B2C 57 3F 10 00 		pop		r3
011B30 57 2F 10 00 	    pop     r2			    ; timed out
011B34 0A 10 FE FF 		ldi		r1,#-1			; return -1
011B38 57 FF 11 00 		pop     lr
011B3C 37 FF 01 00 		rtl
.0002:
011B40 57 3F 10 00 		pop		r3
011B44 57 2F 10 00 	    pop     r2			    ; wait complete, return 
011B48 0A 10 00 00 		ldi		r1,#0			; return 0
011B4C 57 FF 11 00 		pop     lr
011B50 37 FF 01 00 		rtl

                	KeybdGetCharNoWait:
011B54 60 00 14 01 		sb		r0,KeybdWaitFlag
011B58 BA 01 00 00 		bra		KeybdGetChar
                	
                	KeybdGetCharWait:
011B5C 0A 10 FE FF 		ldi		r1,#-1
011B60 60 10 14 01 		sb		r1,KeybdWaitFlag
                		
                	KeybdGetChar:
011B64 E7 EF 01 00 	    push    lr
011B68 67 E1 01 00 		push	r2
011B6C E7 E1 01 00 	    push    r3
                	.0003:
011B70 B9 E6 FF FF 		bsr		KeybdGetStatus			; check keyboard status for key available
011B74 BD 40 10 00 		bmi		r1,.0006				; yes, go process
011B78 40 10 14 01 		lb		r1,KeybdWaitFlag		; are we willing to wait for a key ?
011B7C BD 40 FA FF 		bmi		r1,.0003				; yes, branch back
011B80 0A 10 FE FF 		ldi		r1,#-1					; flag no char available
011B84 57 3F 10 00 		pop		r3
011B88 57 2F 10 00 	    pop     r2
011B8C 57 FF 11 00 	    pop     lr
011B90 37 FF 01 00 		rtl
.0006:
011B94 B9 E3 FF FF 		bsr		KeybdGetScancode
                	.0001:
011B98 0A 20 02 00 		ldi		r2,#1
011B9C 7C DC FF 00 		sb		r2,LEDS
011BA0 60 20 00 0C 
011BA4 86 20 E0 01 		cmp		r2,r1,#SC_KEYUP
011BA8 3D 01 68 00 		beq		r2,.doKeyup
011BAC 86 20 C0 01 		cmp		r2,r1,#SC_EXTEND
011BB0 3D 01 6A 00 		beq		r2,.doExtend
011BB4 86 20 28 00 		cmp		r2,r1,#$14				; code for CTRL
011BB8 3D 01 6E 00 		beq		r2,.doCtrl
011BBC 86 20 24 00 		cmp		r2,r1,#$12				; code for left shift
011BC0 3D 01 80 00 		beq		r2,.doShift
011BC4 86 20 B2 00 		cmp		r2,r1,#$59				; code for right-shift
011BC8 3D 01 7C 00 		beq		r2,.doShift
011BCC 86 20 EE 00 		cmp		r2,r1,#SC_NUMLOCK
011BD0 3D 01 8E 00 		beq		r2,.doNumLock
011BD4 86 20 B0 00 		cmp		r2,r1,#SC_CAPSLOCK
011BD8 3D 01 98 00 		beq		r2,.doCapsLock
011BDC 86 20 FC 00 		cmp		r2,r1,#SC_SCROLLLOCK
011BE0 3D 01 28 73 		beq		r2,.doScrolllock
011BE4 40 20 10 01 		lb		r2,KeyState1			; check key up/down
011BE8 60 00 10 01 		sb		r0,KeyState1			; clear keyup status
011BEC 3D 11 C2 FF 		bne	    r2,.0003				; ignore key up
011BF0 40 20 12 01 		lb		r2,KeyState2
011BF4 0C 31 00 01 		and		r3,r2,#$80				; is it extended code ?
011BF8 BD 01 0E 00 		beq		r3,.0010
011BFC 0C 31 FE 00 		and		r3,r2,#$7f				; clear extended bit
011C00 60 30 12 01 		sb		r3,KeyState2
011C04 60 00 10 01 		sb		r0,KeyState1			; clear keyup
011C08 7C 01 00 00 		lbu		r1,keybdExtendedCodes[r1]
011C0C C1 10 E0 40 
011C10 BA 09 00 00 		bra		.0008
                	.0010:
011C14 40 20 12 01 		lb		r2,KeyState2
011C18 0C 31 08 00 		and		r3,r2,#$04				; is it CTRL code ?
011C1C BD 01 0A 00 		beq		r3,.0009
011C20 8C 10 FE 00 		and		r1,r1,#$7F
011C24 7C 01 00 00 		lbu		r1,keybdControlCodes[r1]
011C28 C1 10 E0 3F 
011C2C 3A 06 00 00 		bra		.0008
                	.0009:
011C30 40 20 12 01 		lb		r2,KeyState2
011C34 0C 31 02 00 		and		r3,r2,#$01				; is it shift down ?
011C38 BD 01 08 00 		beq  	r3,.0007
011C3C 7C 01 00 00 		lbu		r1,shiftedScanCodes[r1]
011C40 C1 10 E0 3D 
011C44 3A 03 00 00 		bra		.0008
                	.0007:
011C48 7C 01 00 00 		lbu		r1,unshiftedScanCodes[r1]
011C4C C1 10 E0 3B 
011C50 0A 20 04 00 		ldi		r2,#2
011C54 7C DC FF 00 		sb		r2,LEDS
011C58 60 20 00 0C 
                	.0008:
011C5C 0A 20 06 00 		ldi		r2,#3
011C60 7C DC FF 00 		sb		r2,LEDS
011C64 60 20 00 0C 
011C68 57 3F 10 00 		pop		r3
011C6C 57 2F 10 00 	    pop     r2
011C70 57 FF 11 00 	    pop     lr
011C74 37 FF 01 00 		rtl
.doKeyup:
011C78 0A 10 FE FF 		ldi		r1,#-1
011C7C 60 10 10 01 		sb		r1,KeyState1
011C80 3A DE FF FF 		bra		.0003
                	.doExtend:
011C84 41 10 12 01 		lbu		r1,KeyState2
011C88 8D 10 00 01 		or		r1,r1,#$80
011C8C 60 10 12 01 		sb		r1,KeyState2
011C90 3A DC FF FF 		bra		.0003
                	.doCtrl:
011C94 40 10 10 01 		lb		r1,KeyState1
011C98 60 00 10 01 		sb		r0,KeyState1
011C9C BD 30 0A 00 		bpl		r1,.0004
011CA0 40 10 12 01 		lb		r1,KeyState2
011CA4 8C 10 F6 FF 		and		r1,r1,#-5
011CA8 60 10 12 01 		sb		r1,KeyState2
011CAC BA D8 FF FF 		bra		.0003
                	.0004:
011CB0 40 10 12 01 		lb		r1,KeyState2
011CB4 8D 10 08 00 		or		r1,r1,#4
011CB8 60 10 12 01 		sb		r1,KeyState2
011CBC BA D6 FF FF 		bra		.0003
                	.doShift:
011CC0 40 10 10 01 		lb		r1,KeyState1
011CC4 60 00 10 01 		sb		r0,KeyState1
011CC8 BD 30 0A 00 		bpl		r1,.0005
011CCC 40 10 12 01 		lb		r1,KeyState2
011CD0 8C 10 FC FF 		and		r1,r1,#-2
011CD4 60 10 12 01 		sb		r1,KeyState2
011CD8 3A D3 FF FF 		bra		.0003
                	.0005:
011CDC 40 10 12 01 		lb		r1,KeyState2
011CE0 8D 10 02 00 		or		r1,r1,#1
011CE4 60 10 12 01 		sb		r1,KeyState2
011CE8 3A D1 FF FF 		bra		.0003
                	.doNumLock:
011CEC 7C 00 00 00 		lb		r1,KeySTate2
011CF0 7C 00 00 00 
011CF4 40 10 7A 04 
011CF8 8E 10 20 00 		eor		r1,r1,#16
011CFC 60 10 12 01 		sb		r1,KeyState2
011D00 39 06 00 00 		bsr		KeybdSetLEDStatus
011D04 BA CD FF FF 		bra		.0003
                	.doCapsLock:
011D08 40 10 12 01 		lb		r1,KeyState2
011D0C 8E 10 40 00 		eor		r1,r1,#32
011D10 60 10 12 01 		sb		r1,KeyState2
011D14 B9 03 00 00 		bsr		KeybdSetLEDStatus
011D18 3A CB FF FF 		bra		.0003
                	.doScrollLock:
011D1C 40 10 12 01 		lb		r1,KeyState2
011D20 8E 10 80 00 		eor		r1,r1,#64
011D24 60 10 12 01 		sb		r1,KeyState2
011D28 39 01 00 00 		bsr		KeybdSetLEDStatus
011D2C BA C8 FF FF 		bra		.0003
                	
                	KeybdSetLEDStatus:
011D30 E7 EF 01 00 	    push    lr
011D34 67 E1 01 00 		push	r2
011D38 E7 E1 01 00 	    push    r3
011D3C 60 00 16 01 		sb		r0,KeybdLEDs
011D40 40 10 12 01 		lb		r1,KeyState2
011D44 8C 20 20 00 		and		r2,r1,#16
011D48 3D 01 06 00 		beq		r2,.0002
011D4C 0A 30 04 00 		ldi		r3,#2
011D50 60 30 16 01 		sb		r3,KeybdLEDs
                	.0002:
011D54 8C 20 40 00 		and		r2,r1,#32
011D58 3D 01 08 00 		beq		r2,.0003
011D5C 40 30 16 01 		lb		r3,KeybdLEDs
011D60 8D 31 08 00 		or		r3,r3,#4
011D64 60 30 16 01 		sb		r3,KeybdLEDs
                	.0003:
011D68 8C 20 80 00 		and		r2,r1,#64
011D6C 3D 01 08 00 		beq		r2,.0004
011D70 40 30 16 01 		lb		r3,KeybdLEDs
011D74 8D 31 02 00 		or		r3,r3,#1
011D78 60 30 16 01 		sb		r3,KeybdLEDs
                	.0004:
011D7C 0A 10 DA 01 		ldi		r1,#$ED
011D80 B9 06 00 00 		bsr		KeybdSendByte
011D84 39 B0 FF FF 		bsr		KeybdWaitTx
011D88 B9 A7 FF FF 		bsr		KeybdRecvByte
011D8C BD 40 0C 00 		bmi		r1,.0001
011D90 86 20 F4 01 		cmp		r2,r1,#$FA
011D94 40 10 16 01 		lb		r1,KeybdLEDs
011D98 B9 03 00 00 		bsr		KeybdSendByte
011D9C 39 AD FF FF 		bsr		KeybdWaitTx
011DA0 B9 A4 FF FF 		bsr		KeybdRecvByte
                	.0001:
011DA4 57 3F 10 00 		pop		r3
011DA8 57 2F 10 00 	    pop     r2
011DAC 57 FF 11 00 	    pop     lr
011DB0 37 FF 01 00 		rtl

                	KeybdSendByte:
011DB4 7C DC FF 00 		sb		r1,KEYBD
011DB8 60 10 00 00 
011DBC 37 FF 01 00 		rtl
	
                	Wait10ms:
011DC0 E7 E1 01 00 		push	r3
011DC4 67 E2 01 00 	    push    r4
011DC8 02 30 08 3E 		mfspr	r3,tick					; get orginal count
                	.0001:
011DCC 02 40 08 3E 		mfspr	r4,tick
011DD0 02 42 06 0A 		sub		r4,r4,r3
011DD4 3D 42 08 00 		blt  	r4,.0002				; shouldn't be -ve unless counter overflowed
011DD8 FC 03 00 00 		cmpu	r4,r4,#250000			; about 10ms at 25 MHz
011DDC 16 42 20 A1 
011DE0 3D 42 F6 FF 		blt		r4,.0001
                	.0002:
011DE4 57 4F 10 00 		pop		r4
011DE8 57 3F 10 00 	    pop     r3
011DEC 37 FF 01 00 		rtl

                		;--------------------------------------------------------------------------
                		; PS2 scan codes to ascii conversion tables.
                		;--------------------------------------------------------------------------
                		;
                		align	16                	
                	unshiftedScanCodes:
011DF0 2E A9 2E A5 		.byte	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
011DF4 A3 A1 A2 AC 
011DF8 2E AA A8 A6 		.byte	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
011DFC A4 09 60 2E 
011E00 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
011E04 2E 71 31 2E 
011E08 2E 2E 7A 73 		.byte	$2e,$2e,$7a,$73,$61,$77,$32,$2e
011E0C 61 77 32 2E 
011E10 2E 63 78 64 		.byte	$2e,$63,$78,$64,$65,$34,$33,$2e
011E14 65 34 33 2E 
011E18 2E 20 76 66 		.byte	$2e,$20,$76,$66,$74,$72,$35,$2e
011E1C 74 72 35 2E 
011E20 2E 6E 62 68 		.byte	$2e,$6e,$62,$68,$67,$79,$36,$2e
011E24 67 79 36 2E 
011E28 2E 2E 6D 6A 		.byte	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
011E2C 75 37 38 2E 
011E30 2E 2C 6B 69 		.byte	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
011E34 6F 30 39 2E 
011E38 2E 2E 2F 6C 		.byte	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
011E3C 3B 70 2D 2E 
011E40 2E 2E 27 2E 		.byte	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
011E44 5B 3D 2E 2E 
011E48 AD 2E 0D 5D 		.byte	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
011E4C 2E 5C 2E 2E 
011E50 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
011E54 2E 2E 08 2E 
011E58 2E 95 2E 93 		.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
011E5C 94 2E 2E 2E 
011E60 98 7F 92 2E 		.byte	$98,$7f,$92,$2e,$91,$90,$1b,$af
011E64 91 90 1B AF 
011E68 AB 2E 97 2E 		.byte	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
011E6C 2E 96 AE 2E 
                	
011E70 2E 2E 2E A7 		.byte	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
011E74 2E 2E 2E 2E 
011E78 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011E7C 2E 2E 2E 2E 
011E80 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011E84 2E 2E 2E 2E 
011E88 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011E8C 2E 2E 2E 2E 
011E90 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011E94 2E 2E 2E 2E 
011E98 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011E9C 2E 2E 2E 2E 
011EA0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011EA4 2E 2E 2E 2E 
011EA8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011EAC 2E 2E 2E 2E 
011EB0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011EB4 2E 2E 2E 2E 
011EB8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011EBC 2E 2E 2E 2E 
011EC0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011EC4 2E 2E 2E 2E 
011EC8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011ECC 2E 2E 2E 2E 
011ED0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011ED4 2E 2E 2E 2E 
011ED8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011EDC 2E 2E 2E 2E 
011EE0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011EE4 2E 2E 2E 2E 
011EE8 2E 2E FA 2E 		.byte	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
011EEC 2E 2E 2E 2E 
                	
                	shiftedScanCodes:
011EF0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011EF4 2E 2E 2E 2E 
011EF8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
011EFC 2E 09 7E 2E 
011F00 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
011F04 2E 51 21 2E 
011F08 2E 2E 5A 53 		.byte	$2e,$2e,$5a,$53,$41,$57,$40,$2e
011F0C 41 57 40 2E 
011F10 2E 43 58 44 		.byte	$2e,$43,$58,$44,$45,$24,$23,$2e
011F14 45 24 23 2E 
011F18 2E 20 56 46 		.byte	$2e,$20,$56,$46,$54,$52,$25,$2e
011F1C 54 52 25 2E 
011F20 2E 4E 42 48 		.byte	$2e,$4e,$42,$48,$47,$59,$5e,$2e
011F24 47 59 5E 2E 
011F28 2E 2E 4D 4A 		.byte	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
011F2C 55 26 2A 2E 
011F30 2E 3C 4B 49 		.byte	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
011F34 4F 29 28 2E 
011F38 2E 3E 3F 4C 		.byte	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
011F3C 3A 50 5F 2E 
011F40 2E 2E 22 2E 		.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
011F44 7B 2B 2E 2E 
011F48 2E 2E 0D 7D 		.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
011F4C 2E 7C 2E 2E 
011F50 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
011F54 2E 2E 08 2E 
011F58 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011F5C 2E 2E 2E 2E 
011F60 2E 7F 2E 2E 		.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
011F64 2E 2E 1B 2E 
011F68 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011F6C 2E 2E 2E 2E 
                	
011F70 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011F74 2E 2E 2E 2E 
011F78 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011F7C 2E 2E 2E 2E 
011F80 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011F84 2E 2E 2E 2E 
011F88 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011F8C 2E 2E 2E 2E 
011F90 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011F94 2E 2E 2E 2E 
011F98 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011F9C 2E 2E 2E 2E 
011FA0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011FA4 2E 2E 2E 2E 
011FA8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011FAC 2E 2E 2E 2E 
011FB0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011FB4 2E 2E 2E 2E 
011FB8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011FBC 2E 2E 2E 2E 
011FC0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011FC4 2E 2E 2E 2E 
011FC8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011FCC 2E 2E 2E 2E 
011FD0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011FD4 2E 2E 2E 2E 
011FD8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011FDC 2E 2E 2E 2E 
011FE0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011FE4 2E 2E 2E 2E 
011FE8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011FEC 2E 2E 2E 2E 
                	
                	; control
                	keybdControlCodes:
011FF0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011FF4 2E 2E 2E 2E 
011FF8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
011FFC 2E 09 7E 2E 
012000 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
012004 2E 11 21 2E 
012008 2E 2E 1A 13 		.byte	$2e,$2e,$1a,$13,$01,$17,$40,$2e
01200C 01 17 40 2E 
012010 2E 03 18 04 		.byte	$2e,$03,$18,$04,$05,$24,$23,$2e
012014 05 24 23 2E 
012018 2E 20 16 06 		.byte	$2e,$20,$16,$06,$14,$12,$25,$2e
01201C 14 12 25 2E 
012020 2E 0E 02 08 		.byte	$2e,$0e,$02,$08,$07,$19,$5e,$2e
012024 07 19 5E 2E 
012028 2E 2E 0D 0A 		.byte	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
01202C 15 26 2A 2E 
012030 2E 3C 0B 09 		.byte	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
012034 0F 29 28 2E 
012038 2E 3E 3F 0C 		.byte	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
01203C 3A 10 5F 2E 
012040 2E 2E 22 2E 		.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
012044 7B 2B 2E 2E 
012048 2E 2E 0D 7D 		.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
01204C 2E 7C 2E 2E 
012050 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
012054 2E 2E 08 2E 
012058 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
01205C 2E 2E 2E 2E 
012060 2E 7F 2E 2E 		.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
012064 2E 2E 1B 2E 
012068 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
01206C 2E 2E 2E 2E 
                	
                	keybdExtendedCodes:
012070 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
012074 A3 A1 A2 2E 
012078 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
01207C 2E 2E 2E 2E 
012080 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
012084 2E 2E 2E 2E 
012088 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
01208C 2E 2E 2E 2E 
012090 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
012094 2E 2E 2E 2E 
012098 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
01209C 2E 2E 2E 2E 
0120A0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
0120A4 2E 2E 2E 2E 
0120A8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
0120AC 2E 2E 2E 2E 
0120B0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
0120B4 2E 2E 2E 2E 
0120B8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
0120BC 2E 2E 2E 2E 
0120C0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
0120C4 2E 2E 2E 2E 
0120C8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
0120CC 2E 2E 2E 2E 
0120D0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
0120D4 2E 2E 2E 2E 
0120D8 2E 95 2E 93 		.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
0120DC 94 2E 2E 2E 
0120E0 98 99 92 2E 		.byte	$98,$99,$92,$2e,$91,$90,$2e,$2e
0120E4 91 90 2E 2E 
0120E8 2E 2E 97 2E 		.byte	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
0120EC 2E 96 2E 2E 
                	
                	
                	; ============================================================================
                	; I2C interface to RTCC
                	; ============================================================================
                	
                	I2C_INIT:
0120F0 E7 E0 01 00 	    push    r1
0120F4 67 E1 01 00 	    push    r2
0120F8 7C DC FF 00 		ldi		r2,#I2C_MASTER
0120FC 0A 20 00 1C 
012100 60 01 04 00 		sb		r0,I2C_CONTROL[r2]		; disable the contoller
012104 60 01 02 00 		sb		r0,I2C_PRESCALE_HI[r2]	; set clock divisor for 100kHz
012108 0A 10 C6 00 		ldi		r1,#99					; 24=400kHz, 99=100KHz
01210C 60 11 00 00 		sb		r1,I2C_PRESCALE_LO[r2]
012110 0A 10 00 01 		ldi		r1,#$80					; controller enable bit
012114 60 11 04 00 		sb		r1,I2C_CONTROL[r2]
012118 57 2F 10 00 		pop		r2
01211C 57 1F 10 00 	    pop     r1
012120 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; I2C Read
                	;
                	; Parameters:
                	; 	r1 = device ($6F for RTCC)
                	; 	r2 = register to read
                	; Returns
                	; 	r1 = register value $00 to $FF if successful, else r1 = -1 on error
                	;------------------------------------------------------------------------------
                	;
                	I2C_READ:
012124 E7 EF 01 00 	    push    lr
012128 67 E1 01 00 		push	r2
01212C E7 E1 01 00 	    push    r3
012130 67 E2 01 00 	    push    r4
012134 82 10 02 70 		asl		r1,r1,#1				; clear rw bit for write
                	;	or		r1,r1,#1				; set rw bit for a read
012138 82 40 00 1A 		mov		r4,r1					; save device address in r4
01213C 02 31 00 1A 		mov		r3,r2
                		; transmit device #
012140 7C DC FF 00 		ldi		r2,#I2C_MASTER
012144 0A 20 00 1C 
012148 60 11 06 00 		sb		r1,I2C_TX[r2]
01214C 0A 10 20 01 		ldi		r1,#$90					; STA($80) and WR($10) bits set
012150 60 11 08 00 		sb		r1,I2C_CMD[r2]
012154 B9 1F 00 00 		bsr		I2C_WAIT_TC				; wait for transmit to complete
                		; transmit register #
012158 40 11 08 00 		lb		r1,I2C_STAT[r2]
01215C 8C 10 00 01 		and		r1,r1,#$80				; test RxACK bit
012160 BD 10 30 00 		bne	    r1,I2C_ERR
012164 60 31 06 00 		sb		r3,I2C_TX[r2]			; select register r3
012168 0A 10 20 00 		ldi		r1,#$10					; set WR bit
01216C 60 11 08 00 		sb		r1,I2C_CMD[r2]
012170 39 1C 00 00 		bsr		I2C_WAIT_TC
                	
                		; transmit device #
012174 40 11 08 00 		lb		r1,I2C_STAT[r2]
012178 8C 10 00 01 		and		r1,r1,#$80				; test RxACK bit
01217C BD 10 22 00 		bne	    r1,I2C_ERR
012180 0D 42 02 00 		or		r4,r4,#1				; set read flag
012184 60 41 06 00 		sb		r4,I2C_TX[r2]
012188 0A 10 20 01 		ldi		r1,#$90					; STA($80) and WR($10) bits set
01218C 60 11 08 00 		sb		r1,I2C_CMD[r2]
012190 39 18 00 00 		bsr		I2C_WAIT_TC				; wait for transmit to complete
                	
                		; receive data byte
012194 40 11 08 00 		lb		r1,I2C_STAT[r2]
012198 8C 10 00 01 		and		r1,r1,#$80				; test RxACK bit
01219C BD 10 12 00 		bne	    r1,I2C_ERR
0121A0 0A 10 D0 00 		ldi		r1,#$68					; STO($40), RD($20), and NACK($08)
0121A4 60 11 08 00 		sb		r1,I2C_CMD[r2]
0121A8 39 15 00 00 		bsr		I2C_WAIT_TC
0121AC 41 11 06 00 		lbu		r1,I2C_RX[r2]			; $00 to $FF = byte read, -1=err
0121B0 57 4F 10 00 		pop		r4
0121B4 57 3F 10 00 	    pop     r3
0121B8 57 2F 10 00 	    pop     r2
0121BC 3B FF 11 00 		rts

                	I2C_ERR:
0121C0 0A 10 FE FF 		ldi		r1,#-1
0121C4 82 02 00 3C 		mtspr	cr0,r5					; restore TMR
0121C8 57 4F 10 00 		pop		r4/r3/r2/r5
0121CC 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; I2C Write
                	;
                	; Parameters:
                	; 	r1 = device ($6F)
                	; 	r2 = register to write
                	; 	r3 = value for register
                	; Returns
                	; 	r1 = 0 if successful, else r1 = -1 on error
                	;------------------------------------------------------------------------------
                	;
                	I2C_WRITE:
0121D0 E7 EF 01 00 		push	lr
0121D4 67 E1 01 00 	    push    r2
0121D8 E7 E1 01 00 	    push    r3
0121DC 67 E2 01 00 	    push    r4
0121E0 82 10 02 70 		asl		r1,r1,#1				; clear rw bit for write
0121E4 82 41 00 1A 		mov		r4,r3					; save value r4
0121E8 02 31 00 1A 		mov		r3,r2
                		; transmit device #
0121EC 7C DC FF 00 		ldi		r2,#I2C_MASTER			; r2 = I/O base address of controller
0121F0 0A 20 00 1C 
0121F4 60 11 06 00 		sb		r1,I2C_TX[r2]
0121F8 0A 10 20 01 		ldi		r1,#$90					; STA($80) and WR($10) bits set
0121FC 60 11 08 00 		sb		r1,I2C_CMD[r2]
012200 39 0A 00 00 		bsr		I2C_WAIT_TC				; wait for transmit to complete
                		; transmit register #
012204 40 11 08 00 		lb		r1,I2C_STAT[r2]
012208 8C 10 00 01 		and		r1,r1,#$80				; test RxACK bit
01220C BD 10 DA FF 		bne  	r1,I2C_ERR
012210 60 31 06 00 		sb		r3,I2C_TX[r2]			; select register r3
012214 0A 10 20 00 		ldi		r1,#$10					; set WR bit
012218 60 11 08 00 		sb		r1,I2C_CMD[r2]
01221C B9 06 00 00 		bsr		I2C_WAIT_TC
                		; transmit value
012220 40 11 08 00 		lb		r1,I2C_STAT[r2]
012224 8C 10 00 01 		and		r1,r1,#$80				; test RxACK bit
012228 BD 10 CC FF 		bne  	r1,I2C_ERR
01222C 60 41 06 00 		sb		r4,I2C_TX[r2]			; select value in r4
012230 0A 10 A0 00 		ldi		r1,#$50					; set STO, WR bit
012234 60 11 08 00 		sb		r1,I2C_CMD[r2]
012238 39 03 00 00 		bsr		I2C_WAIT_TC
01223C 0A 10 00 00 		ldi		r1,#0					; everything okay
012240 57 4F 10 00 		pop		r4
012244 57 3F 10 00 	    pop     r3
012248 57 2F 10 00 	    pop     r2
01224C 3B FF 11 00 		rts

                	; Wait for I2C controller transmit complete
                	
                	I2C_WAIT_TC:
                	.0001:
012250 40 11 08 00 		lb		r1,I2C_STAT[r2]
012254 8C 10 04 00 		and		r1,r1,#2
012258 BD 10 FC FF 		bne 	r1,.0001
01225C 37 FF 01 00 		rtl

                	; Read the entire contents of the RTCC including 64 SRAM bytes
                	
                	RTCCReadbuf:
012260 E7 EF 01 00 	    push    lr
012264 B9 D1 FF FF 		bsr		I2C_INIT
012268 0A 20 00 00 		ldi		r2,#$00
                	.0001:
01226C 0A 10 DE 00 		ldi		r1,#$6F
012270 B9 D6 FF FF 		bsr		I2C_READ
012274 60 11 40 01 		sb		r1,RTCC_BUF[r2]
012278 04 21 02 00 		add		r2,r2,#1
01227C 16 11 C0 00 		cmpu	r1,r2,#$60
012280 BD 40 F6 FF 		blt		r1,.0001
012284 3B FF 11 00 		rts

                	; Write the entire contents of the RTCC including 64 SRAM bytes
                	
                	RTCCWritebuf:
012288 E7 EF 01 00 	    push    lr
01228C B9 CC FF FF 		bsr		I2C_INIT
012290 0A 20 00 00 		ldi		r2,#$00
                	.0001:
012294 0A 10 DE 00 		ldi		r1,#$6F
012298 41 31 40 01 		lbu		r3,RTCC_BUF[r2]
01229C B9 E6 FF FF 		bsr		I2C_WRITE
0122A0 04 21 02 00 		add		r2,r2,#1
0122A4 16 11 C0 00 		cmpu	r1,r2,#$60
0122A8 BD 40 F6 FF 		blt		r1,.0001
0122AC 3B FF 11 00 		rts

                	RTCCOscOn:
0122B0 E7 EF 01 00 	    push    lr
0122B4 B9 C7 FF FF 		bsr		I2C_INIT
0122B8 0A 10 DE 00 		ldi		r1,#$6F
0122BC 0A 20 00 00 		ldi		r2,#$00			; register zero
0122C0 B9 CC FF FF 		bsr		I2C_READ		; read register zero
0122C4 8D 30 00 01 		or		r3,r1,#$80		; set start osc bit
0122C8 0A 10 DE 00 		ldi		r1,#$6F
0122CC B9 E0 FF FF 		bsr		I2C_WRITE
0122D0 3B FF 11 00 		rts

                	; ============================================================================
                	; SD/MMC Card interface
                	; ============================================================================
                	SD_INIT:
0122D4 E7 EF 01 00 	    push    lr
0122D8 7C DC FF 00 		ldi		r3,#SD_MASTER
0122DC 0A 30 00 16 
0122E0 7C 00 00 00 		ldi		r2,#25000
0122E4 0A 20 50 C3 
0122E8 E1 21 58 00 		sc		r2,0x2c[r3]		; timeout register
                		; Software reset should be held active for several cycles to allow
                		; reset to be detected on the sd_clk domain.
0122EC 0A 20 02 00 		ldi		r2,#1
0122F0 E0 21 50 00 		sb		r2,0x28[r3]		; software reset reg
0122F4 0A 20 04 00 		ldi		r2,#2
0122F8 E0 21 98 00 		sb		r2,0x4c[r3]		; prog /6 for clock divider
0122FC 0A 10 C8 00 		ldi		r1,#100			; software reset delay
012300 39 47 00 00 		bsr     MicroDelay
012304 E0 01 50 00 		sb		r0,0x28[r3]		; clear software reset
012308 E1 01 08 00 		sc		r0,0x04[r3]		; command 0
01230C E2 01 00 00 		sh		r0,0x00[r3]		; arg 0
012310 39 28 00 00 		bsr		SD_WAIT_RESP
012314 C4 11 18 00 		lh		r1,0x0C[r3]		; read response register
012318 B9 7A FC FF 		bsr		DisplayHalf
01231C 3B FF 11 00 		rts

                	SD_CMD8:
012320 E7 EF 01 00 	    push    lr
012324 7C DC FF 00 		ldi		r3,#SD_MASTER
012328 0A 30 00 16 
01232C 0A 20 34 10 		ldi		r2,#$81A
012330 E1 21 08 00 		sc		r2,0x04[r3]		; set command register
012334 0A 20 54 03 		ldi		r2,#$1AA
012338 E2 21 00 00 		sh		r2,0x00[r3]		; set command argument x1AA
01233C B9 22 00 00 		bsr		SD_WAIT_RESP
012340 7C 00 00 00 		sb		r1,SD_2_0
012344 7C 00 00 00 
012348 60 10 AC 04 
01234C C4 11 18 00 		lh		r1,0x0C[r3]		; read response register
012350 B9 73 FC FF 		bsr		DisplayHalf
                		; send command zero
012354 E1 01 08 00 		sc		r0,0x04[r3]
012358 E2 01 00 00 		sh		r0,0x00[r3]
01235C B9 1E 00 00 		bsr		SD_WAIT_RESP
012360 7C 00 00 00 		lbu		r1,SD_2_0
012364 7C 00 00 00 
012368 41 10 AC 04 
01236C BD 00 12 00 		beq		r1,.0001
012370 0A 10 64 00 		ldi		r1,#'2'
012374 39 48 FE FF 		bsr		OutChar
012378 0A 10 5C 00 		ldi		r1,#'.'
01237C 39 47 FE FF 		bsr		OutChar
012380 0A 10 60 00 		ldi		r1,#'0'
012384 39 46 FE FF 		bsr		OutChar
012388 B9 81 FC FF 		bsr		CRLF
01238C 3B FF 11 00 		rts
.0001:
012390 E1 01 08 00 		sc		r0,0x04[r3]		; send CMD0
012394 E2 01 00 00 		sh		r0,0x00[r3]
                	.0002:
012398 C3 11 10 00 		lcu		r1,0x08[r3]
01239C 8C 10 02 00 		and		r1,r1,#1
0123A0 BD 10 FC FF 		bne  	r1,.0002
0123A4 02 40 00 1A 		mov		r4,r0			; ret_reg = r4 = 0
                	.0004:
0123A8 02 52 00 1A 		mov		r5,r4
0123AC 7C 00 80 00 		and		r4,r4,#$80000000
0123B0 0C 42 00 00 
0123B4 3D 12 20 00 		bne  	r4,.0003
0123B8 0A 10 04 6E 		ldi		r1,#$3702		; CMD55|RSP48
0123BC E1 11 08 00 		sc		r1,0x04[r3]
0123C0 E2 01 00 00 		sh		r0,0x00[r3]
0123C4 B9 11 00 00 		bsr		SD_WAIT_RESP
0123C8 BD 10 38 00 		bne  	r1,.respOk
0123CC 0A 10 04 52 		ldi		r1,#$2902		; ACMD41|RSP48
0123D0 E1 11 08 00 		sc		r1,0x04[r3]
0123D4 E2 01 00 00 		sh		r0,0x00[r3]
0123D8 39 0F 00 00 		bsr		SD_WAIT_RESP
0123DC BD 10 2E 00 		bne  	r1,.respOk
0123E0 C4 41 18 00 		lh		r4,0x0c[r3]		; ret_reg = RESP1
0123E4 02 12 00 1A 		mov		r1,r4
0123E8 B9 60 FC FF 		bsr		DisplayHalf
0123EC 39 75 FC FF 		bsr		CRLF
0123F0 3A F7 FF FF 		bra		.0004
                	.0003:
0123F4 FC FF 00 00 		and		r1,r5,#$FFFFFF	; voltage mask
0123F8 8C 12 FE FF 
0123FC 39 5E FC FF 		bsr		DisplayHalf
012400 B9 72 FC FF 		bsr		CRLF
                		; GetCID
012404 0A 10 02 04 		ldi		r1,#$201		; CMD2 + RSP146
012408 E1 11 08 00 		sc		r1,0x04[r3]
01240C E2 01 00 00 		sh		r0,0x00[r3]
012410 39 08 00 00 		bsr		SD_WAIT_RESP
                		; GetRCA
012414 0A 10 34 06 		ldi		r1,#$31A		; CMD3 + CICE + CRCE + RSP48
012418 E1 11 08 00 		sc		r1,0x04[r3]
01241C E2 01 00 00 		sh		r0,0x00[r3]
012420 39 06 00 00 		bsr		SD_WAIT_RESP
012424 C4 41 18 00 		lh		r4,0x0c[r3]			; r4 = RESP1
012428 7C FF FF 00 		and		r1,r4,#$FFFF0000	; r4 & RCA_MASK
01242C 0C 12 00 00 
012430 B9 57 FC FF 		bsr		DisplayHalf
012434 39 6C FC FF 		bsr		CRLF
                	.respOk:
012438 0A 10 9E 00 		ldi		r1,#'O'
01243C 39 2F FE FF 		bsr		OutChar
012440 0A 10 D6 00 		ldi		r1,#'k'
012444 39 2E FE FF 		bsr		OutChar
012448 B9 69 FC FF 		bsr		CRLF
01244C 3B FF 11 00 		rts

                	SD_WAIT_RESP:
012450 E7 EF 01 00 	    push    lr
012454 67 E1 01 00 		push	r2
012458 E7 E1 01 00 	    push    r3
01245C 7C DC FF 00 		ldi		r2,#SD_MASTER
012460 0A 20 00 16 
                	.0001:
012464 42 31 68 00 		lc		r3,0x34[r2]		; read error interrupt status reg
012468 42 11 60 00 		lc		r1,0x30[r2]		; read normal interrupt status reg
01246C 8C 31 02 00 		and		r3,r3,#1		; get command timeout indicator
012470 BD 11 10 00 		bne  	r3,.0002
012474 8C 10 02 00 		and		r1,r1,#1		; wait for command complete bit to set
012478 BD 00 F6 FF 		beq		r1,.0001
01247C 0A 10 02 00 		ldi		r1,#1
012480 57 3F 10 00 		pop		r3
012484 57 2F 10 00 	    pop     r2
012488 57 FF 11 00 	    pop     lr
01248C 37 FF 01 00 		rtl
.0002:
012490 0A 10 A8 00 		ldi		r1,#'T'
012494 39 24 FE FF 		bsr		OutChar
012498 0A 10 9E 00 		ldi		r1,#'O'
01249C 39 23 FE FF 		bsr		OutChar
0124A0 B9 5E FC FF 		bsr		CRLF
0124A4 0A 10 00 00 		ldi		r1,#0
0124A8 57 3F 10 00 		pop		r3
0124AC 57 2F 10 00 	    pop     r2
0124B0 57 FF 11 00 	    pop     lr
0124B4 37 FF 01 00 		rtl

                	; ============================================================================
                	; ============================================================================
                	
0124B8 7C 01 00 00 	    ldi     r1,#brkpt1           ; set breakpoint address
0124BC 0A 10 F8 49 
0124C0 82 00 64 3C 	    mtspr   dbad0,r1
0124C4 0A 10 00 00 	    ldi     r1,#$0000000000000000   ; enable instruction breakpoint, turn on single step mode
0124C8 82 00 6C 3C 	    mtspr   dbctrl,r1
0124CC 02 00 54 3C 	    mtspr   lotgrp,r0            ; operating system is group #0
0124D0 B9 04 00 00 	    bsr     SetupMemtags
0124D4 0A 10 C8 00 	    ldi     r1,#100
0124D8 39 0C 00 00 	    bsr     MicroDelay
0124DC 3F 00 00 00 	    nop
0124E0 3F 00 00 00 	    nop
                	hangprg:
0124E4 3F 00 00 00 	    nop
0124E8 3F 00 00 00 	    nop
0124EC 3F 00 00 00 	    nop
0124F0 BA FE FF FF 	    bra     hangprg
                	
                	SetupMemtags:
0124F4 02 00 50 3C 	    mtspr   ea,r0                ; select tag for first 64kB
0124F8 0A 10 0C 00 	    ldi     r1,#$0006            ; system only: readable, writeable, not executable
                	brkpt1:
0124FC 82 00 52 3C 	    mtspr   tag,r1
012500 7C 01 00 00 	    ldi     r1,#$10000           ; select tag for second 64kB
012504 0A 10 00 00 
012508 82 00 50 3C 	    mtspr   ea,r1
01250C 0A 20 0A 00 	    ldi     r2,#$0005            ; system only: readable, executable, not writeable
012510 02 01 52 3C 	    mtspr   tag,r2
012514 0A 30 24 00 	    ldi     r3,#20-2             ; number of tags to setup
                	.0001:
012518 7C 01 00 00 	    addui   r1,r1,#$10000
01251C 94 10 00 00 
012520 82 00 50 3C 	    mtspr   ea,r1
012524 0A 20 0C 00 	    ldi     r2,#$0006            ; set them up as data
012528 02 01 52 3C 	    mtspr   tag,r2
01252C 95 31 02 00 	    subui   r3,r3,#1
012530 BD 11 F4 FF 	    bne     r3,.0001
012534 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	; MicroDelay
                	;     Delay for a short time for at least the specified number of clock cycles
                	;
                	; Parameters:
                	;     r1 = required delay in clock ticks
                	;------------------------------------------------------------------------------
                	;
                	MicroDelay:
012538 67 E1 01 00 	    push    r2
01253C E7 E1 01 00 	    push    r3
012540 02 30 08 3E 	    mfspr   r3,tick             ; get starting tick
                	.0001:
012544 02 20 08 3E 	    mfspr   r2,tick
012548 02 21 06 2A 	    subu    r2,r2,r3
01254C 02 21 02 0C 	    cmp     r2,r2,r1
012550 3D 41 FA FF 	    blt     r2,.0001
012554 57 3F 10 00 	    pop     r3
012558 57 2F 10 00 	    pop     r2
01255C 37 FF 01 00 	    rtl
;
012560 3F 00 00 00 	    nop
012564 3F 00 00 00 	    nop
                	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	LoadFromSerial:
012568 E7 EF 01 00 	    push    lr
01256C 7C 00 00 00 	    ldi     r3,#16384
012570 0A 30 00 80 
012574 7C 02 00 00 	    ldi     r2,#$20000          ; target store address
012578 0A 20 00 00 
                	.0001:
01257C 39 AA FB FF 	    bsr     SerialGetCharDirect
012580 60 11 00 00 	    sb      r1,[r2]
012584 14 21 02 00 	    addui   r2,r2,#1
012588 95 31 02 00 	    subui   r3,r3,#1
01258C BD 11 F8 FF 	    bne     r3,.0001
012590 3B FF 11 00 	    rts

                	;------------------------------------------------------------------------------
                	; Execution fault. Occurs when an attempt is made to execute code from a
                	; page marked as non-executable.
                	;------------------------------------------------------------------------------
                	
                	exf_rout:
012594 0A 10 76 01 		ldi		r1,#$bb
012598 7C DC FF 00 		sc		r1,LEDS
01259C 61 10 00 0C 
0125A0 7C 01 00 00 		ldi		r1,#msgexf
0125A4 0A 10 08 4C 
0125A8 39 3C FC FF 		bsr		DisplayStringCRLF
                	.0001:
0125AC 3A 00 00 00 		bra .0001
                	
                	;------------------------------------------------------------------------------
                	; Data read fault. Occurs when an attempt is made to read from a page marked
                	; as non-readble.
                	;------------------------------------------------------------------------------
                	
                	drf_rout:
0125B0 0A 10 76 01 		ldi		r1,#$bb
0125B4 7C DC FF 00 		sc		r1,LEDS
0125B8 61 10 00 0C 
0125BC 7C 01 00 00 		ldi		r1,#msgdrf
0125C0 0A 10 12 4C 
0125C4 B9 38 FC FF 		bsr		DisplayStringCRLF
                	.0001:
0125C8 3A 00 00 00 		bra .0001
                	
                	;------------------------------------------------------------------------------
                	; Data write fault. Occurs when an attempt is made to write to a page marked
                	; as non-writeable.
                	;------------------------------------------------------------------------------
                	
                	dwf_rout:
0125CC 0A 10 76 01 		ldi		r1,#$bb
0125D0 7C DC FF 00 		sc		r1,LEDS
0125D4 61 10 00 0C 
0125D8 7C 01 00 00 		ldi		r1,#msgdwf
0125DC 0A 10 1C 4C 
0125E0 39 35 FC FF 		bsr		DisplayStringCRLF
                	.0001:
0125E4 3A 00 00 00 		bra .0001
                	
                	;------------------------------------------------------------------------------
                	; Privilege violation fault. Occurs when the current privilege level isn't
                	; sufficient to allow access.
                	;------------------------------------------------------------------------------
                	
                	priv_rout:
0125E8 0A 10 78 01 		ldi		r1,#$bc
0125EC 7C DC FF 00 		sc		r1,LEDS
0125F0 61 10 00 0C 
0125F4 7C 01 00 00 		ldi		r1,#msgPriv
0125F8 0A 10 26 4C 
0125FC B9 31 FC FF 		bsr		DisplayStringCRLF
                	.0001:
012600 3A 00 00 00 		bra .0001
                	
                	;------------------------------------------------------------------------------
                	; Message strings for the faults.
                	;------------------------------------------------------------------------------
                	
                	msgexf:
012604 65 78 66 20 		db	"exf ",0
012608 00          
                	msgdrf:
012609 64 72 66 20 		db	"drf ",0
01260D 00          
                	msgdwf:
01260E 64 77 66 20 		db	"dwf ",0
012612 00          
                	msgPriv:
012613 70 72 69 76 		db	"priv fault",0
012617 20 66 61 75 
01261B 6C 74 00    
                	msgUninit:
01261E 75 6E 69 6E 		db	"uninit int.",0
012622 69 74 20 69 
012626 6E 74 2E 00 
                	msgBusErr:
01262A 0D 0A 42 75 	    db  CR,LF,"Bus error PC=",0
01262E 73 20 65 72 
012632 72 6F 72 20 
012636 50 43 3D 00 
                	msgEA:
01263A 20 45 41 3D 	    db  " EA=",0
01263E 00          
                	
                	;------------------------------------------------------------------------------
                	; Bus error routine.
                	;------------------------------------------------------------------------------
                	
                	berr_rout:
01263F 00 7C 00 00 	    ldi     sp,#$7800
012643 00 0A E0 01 
012647 F0          
012648 FC 00 00 00 		ldi		r1,#$bebe
01264C 0A 10 7C 7D 
012650 7C DC FF 00 		sc		r1,LEDS
012654 61 10 00 0C 
012658 7C 01 00 00 		ldi     r1,#msgBusErr
01265C 0A 10 54 4C 
012660 39 1F FC FF 		bsr     DisplayString
012664 02 10 10 3E 		mfspr   r1,ipc
012668 39 0E FC FF 		bsr		DisplayWord
01266C 7C 01 00 00 		ldi     r1,#msgEA
012670 0A 10 74 4C 
012674 B9 1C FC FF 		bsr     DisplayString
012678 02 10 16 3E 	    mfspr   r1,bear
01267C B9 0B FC FF 		bsr     DisplayWord
012680 B9 22 FC FF 		bsr     CRLF
012684 39 9B FE FF 		bsr		KeybdGetCharWait
                	
                		; In order to return an RTI must be used to exit the routine (or interrupts
                		; will permanently disabled). The RTI instruction clears an internal
                		; processor flag used to prevent nested interrupts.
                		; Since this is a serious error the system is just restarted. So the IPC
                		; is set to point to the restart address.
                	
012688 7C 01 00 00 		ldi     r1,#start
01268C 0A 10 00 01 
012690 82 00 10 3C 		mtspr   ipc,r1
                		
                		; Allow pipeline time for IPC to update before RTI (there's no results
                		; forwarding on SPR's).
012694 3F 00 00 00 		nop     
012698 3F 00 00 00 		nop
01269C 02 E0 3F 6E 		rti
                	
                	
                	SSM_ISR:
0126A0 02 E0 3B 6E 	    rtd
                	
                	IBPT_ISR:
0126A4 02 E0 3B 6E 	    rtd
                	.0001:
0126A8 3A 00 00 00 	    bra     .0001
                	
                		code
0126AC 00 00 00 00 		align	1
                	
                	get_datetime:
0126B0 15 EF 21 00 		      	subui	sp,sp,#16
0126B4 E7 ED 01 00 		      	push 	bp
0126B8 02 BF 01 1A 		      	mov  	bp,sp
0126BC 15 EF 11 00 		      	subui	sp,sp,#8
0126C0 E7 E5 01 00 		      	push 	r11
0126C4 67 E6 01 00 		      	push 	r12
0126C8 E7 E6 01 00 		      	push 	r13
0126CC 67 E7 01 00 		      	push 	r14
0126D0 E7 E7 01 00 		      	push 	r15
0126D4 67 E8 01 00 		      	push 	r16
0126D8 E7 E8 01 00 		      	push 	r17
0126DC 0A B0 40 01 		      	ldi  	r11,#RTCC_BUF
0126E0 C6 CD A0 00 		      	lw   	r12,80[bp]
0126E4 C6 DD 90 00 		      	lw   	r13,72[bp]
0126E8 C6 ED 80 00 		      	lw   	r14,64[bp]
0126EC C6 FD 70 00 		      	lw   	r15,56[bp]
0126F0 C6 0D 61 00 		      	lw   	r16,48[bp]
0126F4 C6 1D 51 00 		      	lw   	r17,40[bp]
0126F8 BD 08 20 00 		      	beq  	r17,set_time_serial_2
0126FC C1 35 0C 00 		      	lbu  	r3,6[r11]
012700 82 31 00 20 		      	sxb  	r3,r3
012704 E3 3D F0 FF 		      	sw   	r3,-8[bp]
012708 0A 30 A0 0F 		      	ldi  	r3,#2000
01270C C6 4D F0 FF 		      	lw   	r4,-8[bp]
012710 0C 42 1E 00 		      	and  	r4,r4,#15
012714 C6 5D F0 FF 		      	lw   	r5,-8[bp]
012718 8C 52 E0 01 		      	and  	r5,r5,#240
01271C 82 52 08 78 		      	asri 	r5,r5,#4
012720 87 52 14 00 		      	mul  	r5,r5,#10
012724 02 42 0A 28 		      	addu 	r4,r4,r5
012728 82 31 08 28 		      	addu 	r3,r3,r4
01272C E3 3D F0 FF 		      	sw   	r3,-8[bp]
012730 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012734 E3 38 00 00 		      	sw   	r3,[r17]
                	set_time_serial_2:
012738 3D 08 1C 00 		      	beq  	r16,set_time_serial_4
01273C C1 35 08 00 		      	lbu  	r3,4[r11]
012740 82 31 00 20 		      	sxb  	r3,r3
012744 E3 3D F0 FF 		      	sw   	r3,-8[bp]
012748 C6 3D F0 FF 		      	lw   	r3,-8[bp]
01274C 8C 31 1E 00 		      	and  	r3,r3,#15
012750 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012754 0C 42 20 00 		      	and  	r4,r4,#16
012758 02 42 08 78 		      	asri 	r4,r4,#4
01275C 07 42 14 00 		      	mul  	r4,r4,#10
012760 82 31 08 28 		      	addu 	r3,r3,r4
012764 E3 3D F0 FF 		      	sw   	r3,-8[bp]
012768 C6 3D F0 FF 		      	lw   	r3,-8[bp]
01276C 63 38 00 00 		      	sw   	r3,[r16]
                	set_time_serial_4:
012770 BD 07 1C 00 		      	beq  	r15,set_time_serial_6
012774 C1 35 0A 00 		      	lbu  	r3,5[r11]
012778 82 31 00 20 		      	sxb  	r3,r3
01277C E3 3D F0 FF 		      	sw   	r3,-8[bp]
012780 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012784 8C 31 1E 00 		      	and  	r3,r3,#15
012788 C6 4D F0 FF 		      	lw   	r4,-8[bp]
01278C 0C 42 60 00 		      	and  	r4,r4,#48
012790 02 42 08 78 		      	asri 	r4,r4,#4
012794 07 42 14 00 		      	mul  	r4,r4,#10
012798 82 31 08 28 		      	addu 	r3,r3,r4
01279C E3 3D F0 FF 		      	sw   	r3,-8[bp]
0127A0 C6 3D F0 FF 		      	lw   	r3,-8[bp]
0127A4 E3 37 00 00 		      	sw   	r3,[r15]
                	set_time_serial_6:
0127A8 3D 07 22 00 		      	beq  	r14,set_time_serial_8
0127AC C1 35 04 00 		      	lbu  	r3,2[r11]
0127B0 82 31 00 20 		      	sxb  	r3,r3
0127B4 E3 3D F0 FF 		      	sw   	r3,-8[bp]
0127B8 C6 3D F0 FF 		      	lw   	r3,-8[bp]
0127BC 8C 31 1E 00 		      	and  	r3,r3,#15
0127C0 C6 4D F0 FF 		      	lw   	r4,-8[bp]
0127C4 0C 42 60 00 		      	and  	r4,r4,#48
0127C8 02 42 08 78 		      	asri 	r4,r4,#4
0127CC 07 42 14 00 		      	mul  	r4,r4,#10
0127D0 82 31 08 28 		      	addu 	r3,r3,r4
0127D4 E3 3D F0 FF 		      	sw   	r3,-8[bp]
0127D8 C6 3D F0 FF 		      	lw   	r3,-8[bp]
0127DC 8C 31 7E 00 		      	and  	r3,r3,#63
0127E0 E3 3D F0 FF 		      	sw   	r3,-8[bp]
0127E4 C6 3D F0 FF 		      	lw   	r3,-8[bp]
0127E8 63 37 00 00 		      	sw   	r3,[r14]
                	set_time_serial_8:
0127EC BD 06 1C 00 		      	beq  	r13,set_time_serial_10
0127F0 C1 35 02 00 		      	lbu  	r3,1[r11]
0127F4 82 31 00 20 		      	sxb  	r3,r3
0127F8 E3 3D F0 FF 		      	sw   	r3,-8[bp]
0127FC C6 3D F0 FF 		      	lw   	r3,-8[bp]
012800 8C 31 1E 00 		      	and  	r3,r3,#15
012804 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012808 0C 42 E0 00 		      	and  	r4,r4,#112
01280C 02 42 08 78 		      	asri 	r4,r4,#4
012810 07 42 14 00 		      	mul  	r4,r4,#10
012814 82 31 08 28 		      	addu 	r3,r3,r4
012818 E3 3D F0 FF 		      	sw   	r3,-8[bp]
01281C C6 3D F0 FF 		      	lw   	r3,-8[bp]
012820 E3 36 00 00 		      	sw   	r3,[r13]
                	set_time_serial_10:
012824 3D 06 1C 00 		      	beq  	r12,set_time_serial_12
012828 C1 35 00 00 		      	lbu  	r3,[r11]
01282C 82 31 00 20 		      	sxb  	r3,r3
012830 E3 3D F0 FF 		      	sw   	r3,-8[bp]
012834 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012838 8C 31 1E 00 		      	and  	r3,r3,#15
01283C C6 4D F0 FF 		      	lw   	r4,-8[bp]
012840 0C 42 E0 00 		      	and  	r4,r4,#112
012844 02 42 08 78 		      	asri 	r4,r4,#4
012848 07 42 14 00 		      	mul  	r4,r4,#10
01284C 82 31 08 28 		      	addu 	r3,r3,r4
012850 E3 3D F0 FF 		      	sw   	r3,-8[bp]
012854 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012858 63 36 00 00 		      	sw   	r3,[r12]
                	set_time_serial_12:
                	set_time_serial_14:
01285C 57 1F 11 00 		      	pop  	r17
012860 57 0F 11 00 		      	pop  	r16
012864 57 FF 10 00 		      	pop  	r15
012868 57 EF 10 00 		      	pop  	r14
01286C 57 DF 10 00 		      	pop  	r13
012870 57 CF 10 00 		      	pop  	r12
012874 57 BF 10 00 		      	pop  	r11
012878 82 ED 01 1A 		      	mov  	sp,bp
01287C 57 BF 11 00 		      	pop  	bp
012880 37 FF 21 00 		      	rtl  	#16
                	ToJul:
012884 15 EF 21 00 		      	subui	sp,sp,#16
012888 E7 ED 01 00 		      	push 	bp
01288C 02 BF 01 1A 		      	mov  	bp,sp
012890 15 EF 41 00 		      	subui	sp,sp,#32
012894 C6 3D 50 00 		      	lw   	r3,40[bp]
012898 E3 3D E0 FF 		      	sw   	r3,-16[bp]
01289C C6 3D 60 00 		      	lw   	r3,48[bp]
0128A0 E3 3D D0 FF 		      	sw   	r3,-24[bp]
0128A4 C6 3D 70 00 		      	lw   	r3,56[bp]
0128A8 E3 3D C0 FF 		      	sw   	r3,-32[bp]
0128AC FC FF FF FF 		      	ldi  	r3,#-32075
0128B0 0A 30 6A 05 
0128B4 C6 4D C0 FF 		      	lw   	r4,-32[bp]
0128B8 7C 6B 00 00 		      	ldi  	r5,#7012800
0128BC 0A 50 80 03 
0128C0 C6 6D E0 FF 		      	lw   	r6,-16[bp]
0128C4 C6 7D D0 FF 		      	lw   	r7,-24[bp]
0128C8 95 73 1C 00 		      	subu 	r7,r7,#14
0128CC 88 73 18 00 		      	divs 	r7,r7,#12
0128D0 02 63 0E 28 		      	addu 	r6,r6,r7
0128D4 07 63 6A 0B 		      	mul  	r6,r6,#1461
0128D8 82 52 0C 28 		      	addu 	r5,r5,r6
0128DC 82 52 04 78 		      	asri 	r5,r5,#2
0128E0 02 42 0A 28 		      	addu 	r4,r4,r5
0128E4 0A 50 44 FA 		      	ldi  	r5,#-734
0128E8 C6 6D D0 FF 		      	lw   	r6,-24[bp]
0128EC C6 7D D0 FF 		      	lw   	r7,-24[bp]
0128F0 95 73 1C 00 		      	subu 	r7,r7,#14
0128F4 88 73 18 00 		      	divs 	r7,r7,#12
0128F8 87 73 18 00 		      	mul  	r7,r7,#12
0128FC 02 63 0E 2A 		      	subu 	r6,r6,r7
012900 07 63 DE 02 		      	mul  	r6,r6,#367
012904 82 52 0C 28 		      	addu 	r5,r5,r6
012908 88 52 18 00 		      	divs 	r5,r5,#12
01290C 02 42 0A 28 		      	addu 	r4,r4,r5
012910 0A 50 48 26 		      	ldi  	r5,#4900
012914 C6 6D E0 FF 		      	lw   	r6,-16[bp]
012918 C6 7D D0 FF 		      	lw   	r7,-24[bp]
01291C 95 73 1C 00 		      	subu 	r7,r7,#14
012920 88 73 18 00 		      	divs 	r7,r7,#12
012924 02 63 0E 28 		      	addu 	r6,r6,r7
012928 82 52 0C 28 		      	addu 	r5,r5,r6
01292C 88 52 C8 00 		      	divs 	r5,r5,#100
012930 87 52 06 00 		      	mul  	r5,r5,#3
012934 82 52 04 78 		      	asri 	r5,r5,#2
012938 02 42 0A 2A 		      	subu 	r4,r4,r5
01293C 82 31 08 28 		      	addu 	r3,r3,r4
012940 E3 3D F0 FF 		      	sw   	r3,-8[bp]
012944 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012948 82 11 00 1A 		      	mov  	r1,r3
                	set_time_serial_17:
01294C 82 ED 01 1A 		      	mov  	sp,bp
012950 57 BF 11 00 		      	pop  	bp
012954 37 FF 21 00 		      	rtl  	#16
                	set_time_serial:
012958 E7 EF 01 00 		      	push 	lr
01295C 67 EE 01 00 		      	push 	xlr
012960 E7 ED 01 00 		      	push 	bp
012964 7C 01 00 00 		      	ldi  	xlr,#set_time_serial_19
012968 0A C0 11 54 
01296C 02 BF 01 1A 		      	mov  	bp,sp
012970 15 EF 91 00 		      	subui	sp,sp,#72
012974 E5 ED 81 FF 		      	pea  	-64[bp]
012978 E5 ED 91 FF 		      	pea  	-56[bp]
01297C E5 ED A1 FF 		      	pea  	-48[bp]
012980 E5 ED B1 FF 		      	pea  	-40[bp]
012984 E5 ED C1 FF 		      	pea  	-32[bp]
012988 E5 ED D1 FF 		      	pea  	-24[bp]
01298C B9 A4 FF FF 		      	bsr  	get_datetime
012990 14 EF 61 00 		      	addui	sp,sp,#48
012994 C6 3D 80 FF 		      	lw   	r3,-64[bp]
012998 82 31 14 70 		      	asli 	r3,r3,#10
01299C C6 4D 90 FF 		      	lw   	r4,-56[bp]
0129A0 FC 00 00 00 		      	mul  	r4,r4,#61440
0129A4 07 42 00 E0 
0129A8 82 31 08 28 		      	addu 	r3,r3,r4
0129AC C6 4D A0 FF 		      	lw   	r4,-48[bp]
0129B0 7C 38 00 00 		      	mul  	r4,r4,#3686400
0129B4 07 42 00 80 
0129B8 82 31 08 28 		      	addu 	r3,r3,r4
0129BC E7 E1 01 00 		      	push 	r3
0129C0 E6 ED B1 FF 		      	push 	-40[bp]
0129C4 E6 ED C1 FF 		      	push 	-32[bp]
0129C8 E6 ED D1 FF 		      	push 	-24[bp]
0129CC 39 D7 FF FF 		      	bsr  	ToJul
0129D0 14 EF 31 00 		      	addui	sp,sp,#24
0129D4 57 3F 10 00 		      	pop  	r3
0129D8 82 40 00 1A 		      	mov  	r4,r1
0129DC 7C 46 05 00 		      	mul  	r4,r4,#88473600
0129E0 07 42 00 00 
0129E4 82 31 08 28 		      	addu 	r3,r3,r4
0129E8 63 30 20 00 		      	sw   	r3,Milliseconds
0129EC C6 3D E0 FF 		      	lw   	r3,-16[bp]
0129F0 82 11 00 1A 		      	mov  	r1,r3
                	set_time_serial_20:
0129F4 82 ED 01 1A 		      	mov  	sp,bp
0129F8 57 BF 11 00 		      	pop  	bp
0129FC 57 CF 11 00 		      	pop  	xlr
012A00 57 FF 11 00 		      	pop  	lr
012A04 37 FF 01 00 		      	rtl  	#0
                	set_time_serial_19:
012A08 C6 FD 11 00 		      	lw   	lr,8[bp]
012A0C E3 FD 21 00 		      	sw   	lr,16[bp]
012A10 BA FC FF FF 		      	bra  	set_time_serial_20
                	        code
                	
                	pSpriteController:
012A14 00 D0 DA FF 		dw	-2437120
012A18 FF FF FF FF 
                	
                	sprite_demo:
012A1C 15 EF 21 00 		      	subui	sp,sp,#16
012A20 E7 ED 01 00 		      	push 	bp
012A24 02 BF 01 1A 		      	mov  	bp,sp
012A28 15 EF 31 00 		      	subui	sp,sp,#24
012A2C E7 E5 01 00 		      	push 	r11
012A30 67 E6 01 00 		      	push 	r12
012A34 E7 E6 01 00 		      	push 	r13
012A38 7C 05 00 00 		      	ldi  	r11,#sprites
012A3C 0A B0 00 E0 
012A40 7C DC FF FF 		      	ldi  	r12,#-2356224
012A44 0A C0 00 18 
012A48 7C D8 FF FF 		      	ldi  	r13,#-2621440
012A4C 0A D0 00 00 
012A50 E3 0D F0 FF 		      	sw   	r0,-8[bp]
                	sprite_demo_4:
012A54 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012A58 86 31 40 00 		      	cmp  	r3,r3,#32
012A5C BD 31 18 00 		      	bge  	r3,sprite_demo_5
012A60 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012A64 82 31 04 70 		      	asli 	r3,r3,#2
012A68 82 31 04 70 		      	asli 	r3,r3,#2
012A6C 7C 01 00 00 		      	lw   	r4,pSpriteController
012A70 46 40 28 54 
012A74 82 31 08 28 		      	addu 	r3,r3,r4
012A78 C5 41 08 00 		      	lhu  	r4,4[r3]
012A7C 0D 42 98 01 		      	ori  	r4,r4,#204
012A80 E2 41 08 00 		      	sh   	r4,4[r3]
                	sprite_demo_6:
012A84 E4 1D F0 FF 		      	inc  	-8[bp],#1
012A88 BA F9 FF FF 		      	bra  	sprite_demo_4
                	sprite_demo_5:
012A8C E3 0D F0 FF 		      	sw   	r0,-8[bp]
                	sprite_demo_7:
012A90 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012A94 7C 00 00 00 		      	cmp  	r3,r3,#16384
012A98 86 31 00 80 
012A9C BD 31 0E 00 		      	bge  	r3,sprite_demo_8
012AA0 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012AA4 82 31 04 70 		      	asli 	r3,r3,#2
012AA8 45 46 00 00 		      	lhu  	r4,[r12]
012AAC EA 46 06 00 		      	sh   	r4,0[r13+r3]
                	sprite_demo_9:
012AB0 E4 1D F0 FF 		      	inc  	-8[bp],#1
012AB4 BA FB FF FF 		      	bra  	sprite_demo_7
                	sprite_demo_8:
012AB8 E3 0D F0 FF 		      	sw   	r0,-8[bp]
                	sprite_demo_10:
012ABC C6 3D F0 FF 		      	lw   	r3,-8[bp]
012AC0 86 31 40 00 		      	cmp  	r3,r3,#32
012AC4 BD 31 38 00 		      	bge  	r3,sprite_demo_11
012AC8 46 36 00 00 		      	lw   	r3,[r12]
012ACC 89 31 A8 0A 		      	mod  	r3,r3,#1364
012AD0 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012AD4 02 42 0A 70 		      	asli 	r4,r4,#5
012AD8 EB 35 08 00 		      	sw   	r3,0[r11+r4]
012ADC 46 36 00 00 		      	lw   	r3,[r12]
012AE0 89 31 00 06 		      	mod  	r3,r3,#768
012AE4 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012AE8 02 42 0A 70 		      	asli 	r4,r4,#5
012AEC 02 42 16 28 		      	addu 	r4,r4,r11
012AF0 63 32 10 00 		      	sw   	r3,8[r4]
012AF4 46 36 00 00 		      	lw   	r3,[r12]
012AF8 8C 31 0E 00 		      	and  	r3,r3,#7
012AFC 95 31 08 00 		      	subu 	r3,r3,#4
012B00 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012B04 02 42 0A 70 		      	asli 	r4,r4,#5
012B08 02 42 16 28 		      	addu 	r4,r4,r11
012B0C 63 32 20 00 		      	sw   	r3,16[r4]
012B10 46 36 00 00 		      	lw   	r3,[r12]
012B14 8C 31 0E 00 		      	and  	r3,r3,#7
012B18 95 31 08 00 		      	subu 	r3,r3,#4
012B1C C6 4D F0 FF 		      	lw   	r4,-8[bp]
012B20 02 42 0A 70 		      	asli 	r4,r4,#5
012B24 02 42 16 28 		      	addu 	r4,r4,r11
012B28 63 32 30 00 		      	sw   	r3,24[r4]
                	sprite_demo_12:
012B2C E4 1D F0 FF 		      	inc  	-8[bp],#1
012B30 BA F1 FF FF 		      	bra  	sprite_demo_10
                	sprite_demo_11:
                	sprite_demo_13:
012B34 0A 30 02 00 		      	ldi  	r3,#1
012B38 BD 01 68 00 		      	beq  	r3,sprite_demo_14
012B3C E3 0D F0 FF 		      	sw   	r0,-8[bp]
                	sprite_demo_15:
012B40 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012B44 86 31 40 00 		      	cmp  	r3,r3,#32
012B48 BD 31 58 00 		      	bge  	r3,sprite_demo_16
012B4C C6 3D F0 FF 		      	lw   	r3,-8[bp]
012B50 82 31 0A 70 		      	asli 	r3,r3,#5
012B54 CE 35 06 00 		      	lw   	r3,0[r11+r3]
012B58 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012B5C 02 42 0A 70 		      	asli 	r4,r4,#5
012B60 02 42 16 28 		      	addu 	r4,r4,r11
012B64 46 42 20 00 		      	lw   	r4,16[r4]
012B68 82 31 08 28 		      	addu 	r3,r3,r4
012B6C 8C 31 FE 07 		      	and  	r3,r3,#1023
012B70 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012B74 02 42 0A 70 		      	asli 	r4,r4,#5
012B78 EB 35 08 00 		      	sw   	r3,0[r11+r4]
012B7C C6 3D F0 FF 		      	lw   	r3,-8[bp]
012B80 82 31 0A 70 		      	asli 	r3,r3,#5
012B84 82 31 16 28 		      	addu 	r3,r3,r11
012B88 C6 31 10 00 		      	lw   	r3,8[r3]
012B8C C6 4D F0 FF 		      	lw   	r4,-8[bp]
012B90 02 42 0A 70 		      	asli 	r4,r4,#5
012B94 02 42 16 28 		      	addu 	r4,r4,r11
012B98 46 42 30 00 		      	lw   	r4,24[r4]
012B9C 82 31 08 28 		      	addu 	r3,r3,r4
012BA0 8C 31 FE 03 		      	and  	r3,r3,#511
012BA4 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012BA8 02 42 0A 70 		      	asli 	r4,r4,#5
012BAC 02 42 16 28 		      	addu 	r4,r4,r11
012BB0 63 32 10 00 		      	sw   	r3,8[r4]
012BB4 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012BB8 82 31 0A 70 		      	asli 	r3,r3,#5
012BBC CE 35 06 00 		      	lw   	r3,0[r11+r3]
012BC0 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012BC4 02 42 0A 70 		      	asli 	r4,r4,#5
012BC8 02 42 16 28 		      	addu 	r4,r4,r11
012BCC 46 42 10 00 		      	lw   	r4,8[r4]
012BD0 02 42 20 70 		      	asli 	r4,r4,#16
012BD4 82 31 08 28 		      	addu 	r3,r3,r4
012BD8 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012BDC 02 42 04 70 		      	asli 	r4,r4,#2
012BE0 02 42 04 70 		      	asli 	r4,r4,#2
012BE4 7C 01 00 00 		      	lw   	r5,pSpriteController
012BE8 46 50 28 54 
012BEC EA 32 08 00 		      	sh   	r3,0[r5+r4]
                	sprite_demo_17:
012BF0 E4 1D F0 FF 		      	inc  	-8[bp],#1
012BF4 BA E9 FF FF 		      	bra  	sprite_demo_15
                	sprite_demo_16:
012BF8 7C 0F 00 00 		      	     	            ldi  r1,#1000000
012BFC 0A 10 80 84 
012C00 39 27 FF FF 	            bsr  MicroDelay
                	        
012C04 3A E6 FF FF 		      	bra  	sprite_demo_13
                	sprite_demo_14:
                	sprite_demo_18:
012C08 57 DF 10 00 		      	pop  	r13
012C0C 57 CF 10 00 		      	pop  	r12
012C10 57 BF 10 00 		      	pop  	r11
012C14 82 ED 01 1A 		      	mov  	sp,bp
012C18 57 BF 11 00 		      	pop  	bp
012C1C 37 FF 21 00 		      	rtl  	#16
                	         
012C20 3F 00 00 00 	    nop
012C24 3F 00 00 00 	    nop
                	
                	
                		rodata
                		align	16                	
                		align	8                	
                		extern	RTCC_BUF
                		extern	Milliseconds
                		extern	Milliseconds
687 symbols
  Symbol Name                              seg     address
  API_AREA                                    bss  000100
  API_head                                    bss  0000a6
  API_sema                                    bss  0000b0
  API_tail                                    bss  0000a8
  AddTaskToReadyList                         code  010860
  AddToTimeoutList                           code  010954
  AsciiToHexNybble                           code  0117d4
  AsciiToHexNybble.gthx3                     code  011834
  AsciiToHexNybble.gthx5                     code  0117f4
  AsciiToHexNybble.gthx6                     code  011814
  AsciiToScreen                              code  010618
  AsciiToScreen.00001                        code  010638
  BIOS_AREA                                  code  80000000000001a0
  BIOS_Call                                  code  010c44
  BIOS_Call.0001                             code  010c58
  BIOS_Call.0002                             code  010cf0
  BIOS_DONE                                 const  000001
  BIOS_Dispatcher                            code  010cf8
  BIOS_Dispatcher.0001                       code  010d1c
  BIOS_Dispatcher.0002                       code  010da4
  BIOS_Dispatcher.advanceHead                code  80000000000001a9
  BIOS_Dispatcher.sleep                      code  010da4
  BIOS_FREE                                 const  000000
  BIOS_INSERVICE                            const  000002
  BIOS_STACK                                const  006800
  BIOS_WAIT_SVC                              code  80000000000001a6
  BIOS_arg1                                 const  000008
  BIOS_arg2                                 const  000010
  BIOS_arg3                                 const  000018
  BIOS_arg4                                 const  000020
  BIOS_arg5                                 const  000028
  BIOS_dx                                    code  010dac
  BIOS_dx.advanceHead                        code  010dac
  BIOS_dx.x1                                 code  010dc0
  BIOS_head                                  code  800000000000019f
  BIOS_op                                   const  000000
  BIOS_resp                                 const  000030
  BIOS_sema                                   bss  0000b8
  BIOS_stat                                 const  000038
  BIOS_tail                                  code  800000000000019e
  BMP_CLUT                                  const  0c5800
  BSI_BootSig                               const  000026
  BSI_DriveNum                              const  000024
  BSI_FATS                                  const  000010
  BSI_FileSysType                           const  000036
  BSI_Heads                                 const  00001a
  BSI_HiddenSecs                            const  00001c
  BSI_HugeSecs                              const  00001e
  BSI_JMP                                   const  000000
  BSI_Media                                 const  000015
  BSI_OEMName                               const  000003
  BSI_ResSectors                            const  00000e
  BSI_RootDirEnts                           const  000011
  BSI_Rsvd1                                 const  000025
  BSI_SecPerCluster                         const  00000d
  BSI_SecPerFAT                             const  000016
  BSI_SecPerTrack                           const  000018
  BSI_Sectors                               const  000013
  BSI_VolID                                 const  000027
  BSI_VolLabel                              const  00002b
  BSI_bps                                   const  00000b
  BYTE_SECTOR_BUF                           const  052000
  BlankLine                                  code  011314
  BlankLine.0001                             code  011350
  BranchToSelf                               code  0107e8
  CPU1_IRQ_STACK                            const  020800
  CPUIdleTick                                 bss  0000d0
  CR                                        const  00000d
  CRLF                                       code  010794
  CRLF1                                      code  010798
  CTRLC                                     const  000003
  CTRLCCheck                                 code  011734
  CTRLCCheck.0001                            code  01175c
  CTRLH                                     const  000008
  CTRLI                                     const  000009
  CTRLJ                                     const  00000a
  CTRLK                                     const  00000b
  CTRLM                                     const  00000d
  CTRLS                                     const  000013
  CTRLX                                     const  000018
  CalcScreenLoc                              code  011040
  CharsInRxBuf                               code  010400
  CheckKeys                                  code  011720
  CheckScrollLock                            code  011764
  CheckScrollLock.0001                       code  011784
  CheckScrollLock.0002                       code  011770
  ClearBmpScreen                             code  800000000000010e
  ClearScreen                                code  010678
  ClearScreen.cs1                            code  0106b8
  CursorCol                                   bss  000081
  CursorOff                                  code  01065c
  CursorOn                                   code  010660
  CursorRow                                   bss  000080
  DBG_STACK                                 const  007000
  DispCharQ                                  code  0107b4
  DispStartMsg                               code  0107c8
  DisplayByte                                code  010714
  DisplayChar                                code  01108c
  DisplayChar.dcx12                          code  0111a4
  DisplayChar.dcx4                           code  011114
  DisplayChar.dcx5                           code  0111d8
  DisplayChar.dcx7                           code  01114c
  DisplayChar.doBackspace                    code  0111bc
  DisplayChar.doCursorDown                   code  01117c
  DisplayChar.doCursorHome                   code  011194
  DisplayChar.doCursorLeft                   code  011168
  DisplayChar.doCursorRight                  code  011138
  DisplayChar.doCursorUp                     code  011154
  DisplayChar.doDelete                       code  0111ac
  DisplayChar.doLinefeed                     code  01120c
  DisplayChar.docr                           code  01112c
  DisplayCharHex                             code  010700
  DisplayErr                                 code  011840
  DisplayHalf                                code  0106ec
  DisplayMemBytes                            code  011660
  DisplayMemBytes.001                        code  011694
  DisplayMemBytes.002                        code  0116cc
  DisplayMemBytes.003                        code  0116ec
  DisplayMemBytes.004                        code  0116e0
  DisplayNybble                              code  010728
  DisplayNybble.0001                         code  010748
  DisplayString                              code  010758
  DisplayString.dm1                          code  01077c
  DisplayString.dm2                          code  010768
  DisplayStringCRLF                          code  010788
  DisplayWord                                code  0106d8
  Dummy1                                      bss  000082
  E_Arg                                     const  000001
  E_BadAlarm                                const  000011
  E_BadBlockNum                             const  000025
  E_BadDevNum                               const  000020
  E_BadDevOp                                const  000022
  E_BadMbx                                  const  000004
  E_DCBInUse                                const  000019
  E_NoDev                                   const  000021
  E_NoMem                                   const  00000c
  E_NoMoreAlarmBlks                         const  000044
  E_NoMoreMbx                               const  000040
  E_NoMoreMsgBlks                           const  000041
  E_NoMoreTCBs                              const  000045
  E_NoMsg                                   const  00000b
  E_NoThread                                const  000006
  E_NotAlloc                                const  000009
  E_NotOwner                                const  000012
  E_Ok                                      const  000000
  E_QueFull                                 const  000005
  E_QueStrategy                             const  000013
  E_ReadError                               const  000023
  E_Timeout                                 const  000010
  E_TooManyBlocks                           const  000026
  E_WriteError                              const  000024
  EndStaticAllocations                        bss  057400
  FMTKInitialize                             code  8000000000000130
  FreeTCB                                     bss  000030
  GDTBaseAddress                              bss  012000
  GetCurrAttr                                code  010ff0
  GetHexNumber                               code  011794
  GetHexNumber.gthxn1                        code  0117c4
  GetHexNumber.gthxn2                        code  0117a8
  GetRandomNumber                            code  011900
  GetRange                                   code  0114cc
  GetScreenLocation                          code  010fe4
  GetSystemTime                              code  010fd8
  GetTwoParams                               code  0114b0
  HomeCursor                                 code  010664
  I2C_CMD                                   const  000004
  I2C_CONTROL                               const  000002
  I2C_ERR                                    code  0121c0
  I2C_INIT                                   code  0120f0
  I2C_MASTER                                const  ffdc0e00
  I2C_PRESCALE_HI                           const  000001
  I2C_PRESCALE_LO                           const  000000
  I2C_READ                                   code  012124
  I2C_RX                                    const  000003
  I2C_STAT                                  const  000004
  I2C_TX                                    const  000003
  I2C_WAIT_TC                                code  012250
  I2C_WAIT_TC.0001                           code  012250
  I2C_WRITE                                  code  0121d0
  IBPT_ISR                                   code  0126a4
  IBPT_ISR.0001                              code  0126a8
  IOPgTbl                                     bss  04c000
  IRQ_STACK                                 const  008000
  IVTBaseAddress                              bss  010000
  IncCursorPos                               code  011214
  IncCursorRow                               code  011240
  InitFMTK                                   code  0107ec
  InitFMTK.0001                              code  010834
  InitFMTK.nextTCB                           code  0107f4
  InitPIC                                    code  010244
  InitUart                                   code  010260
  KEYBD                                     const  ffdc0000
  KEYBDCLR                                  const  ffdc0004
  KEYBD_DELAY                               const  0003e8
  KeySTate2                                  code  800000000000023d
  KeyState1                                   bss  000088
  KeyState2                                   bss  000089
  KeybdBad                                    bss  000085
  KeybdEcho                                   bss  000084
  KeybdGetChar                               code  011b64
  KeybdGetChar.0001                          code  011b98
  KeybdGetChar.0003                          code  011b70
  KeybdGetChar.0004                          code  011cb0
  KeybdGetChar.0005                          code  011cdc
  KeybdGetChar.0006                          code  011b94
  KeybdGetChar.0007                          code  011c48
  KeybdGetChar.0008                          code  011c5c
  KeybdGetChar.0009                          code  011c30
  KeybdGetChar.0010                          code  011c14
  KeybdGetChar.doCapsLock                    code  011d08
  KeybdGetChar.doCtrl                        code  011c94
  KeybdGetChar.doExtend                      code  011c84
  KeybdGetChar.doKeyup                       code  011c78
  KeybdGetChar.doNumLock                     code  011cec
  KeybdGetChar.doScrollLock                  code  011d1c
  KeybdGetChar.doScrolllock                  code  8000000000000230
  KeybdGetChar.doShift                       code  011cc0
  KeybdGetCharDirect                         code  011980
  KeybdGetCharDirect.0001                    code  011988
  KeybdGetCharDirect.gk1                     code  0119cc
  KeybdGetCharDirect.gk2                     code  0119c8
  KeybdGetCharDirectNB                       code  01190c
  KeybdGetCharDirectNB.0001                  code  01196c
  KeybdGetCharDirectNB.0002                  code  011960
  KeybdGetCharDirectNB.0003                  code  01195c
  KeybdGetCharNoWait                         code  011b54
  KeybdGetCharWait                           code  011b5c
  KeybdGetScancode                           code  011ab0
  KeybdGetStatus                             code  011aa4
  KeybdIRQ                                   code  0107dc
  KeybdInit                                  code  0119f1
  KeybdInit.0001                             code  0119fc
  KeybdInit.0002                             code  011a0c
  KeybdInit.0004                             code  011a8c
  KeybdInit.config                           code  011a48
  KeybdInit.keybdErr                         code  011a78
  KeybdInit.tryAgain                         code  011a70
  KeybdLEDs                                   bss  00008b
  KeybdLocks                                  bss  000086
  KeybdRecvByte                              code  011ac4
  KeybdRecvByte.0003                         code  011ad0
  KeybdRecvByte.0004                         code  011af4
  KeybdSendByte                              code  011db4
  KeybdSetLEDStatus                          code  011d30
  KeybdSetLEDStatus.0001                     code  011da4
  KeybdSetLEDStatus.0002                     code  011d54
  KeybdSetLEDStatus.0003                     code  011d68
  KeybdSetLEDStatus.0004                     code  011d7c
  KeybdWaitFlag                               bss  00008a
  KeybdWaitTx                                code  011b04
  KeybdWaitTx.0001                           code  011b14
  KeybdWaitTx.0002                           code  011b40
  LEDS                                      const  ffdc0600
  LF                                        const  00000a
  LoadFromSerial                             code  012568
  LoadFromSerial.0001                        code  01257c
  MON_STACK                                 const  006000
  MRTest                                     code  80000000000001db
  MicroDelay                                 code  012538
  MicroDelay.0001                            code  012544
  Milliseconds                                bss  000010
  MonGetch                                   code  011474
  Monitor                                    code  011392
  NR_PTBL                                   const  000020
  NR_TCB                                    const  000010
  NormAttr                                    bss  000078
  OutCRLF                                    code  010794
  OutChar                                    code  0115b4
  OutputVec                                   bss  000018
  PAM1                                        bss  022000
  PAM2                                        bss  023000
  PIC                                       const  ffdc0fc0
  PIC_ES                                    const  ffdc0fd0
  PIC_IE                                    const  ffdc0fc4
  PIC_RSTE                                  const  ffdc0fd4
  PRI_LOWEST                                 code  8000000000000184
  PROG_LOAD_AREA                            const  053000
  PgSD0                                       bss  044000
  PgSD3                                       bss  045000
  PgTbl0                                      bss  046000
  PgTbl1                                      bss  047000
  PgTbl2                                      bss  048000
  PgTbl3                                      bss  049000
  PgTbl4                                      bss  04a000
  PgTbl5                                      bss  04b000
  PopTimeoutList                             code  010b24
  QNdx0                                       bss  000038
  RANDOM_NUM                                const  ffdc0c00
  ROOTDIR_BUF                                 bss  053000
  RTCCOscOn                                  code  0122b0
  RTCCReadbuf                                code  012260
  RTCCReadbuf.0001                           code  01226c
  RTCCWritebuf                               code  012288
  RTCCWritebuf.0001                          code  012294
  RTCC_BUF                                    bss  0000a0
  RW_READ_SD_BLOCK                          const  000002
  RW_WRITE_SD_BLOCK                         const  000003
  RemoveFromTimeoutList                      code  010a50
  RemoveTaskFromReadyList                    code  0108e0
  RootPageTbl                                 bss  024000
  RunningTCB                                  bss  000028
  SC_ALT                                    const  000011
  SC_CAPSLOCK                               const  000058
  SC_CTRL                                   const  000014
  SC_DEL                                    const  000071
  SC_EXTEND                                 const  0000e0
  SC_KEYUP                                  const  0000f0
  SC_LCTRL                                  const  000058
  SC_LSHIFT                                 const  000012
  SC_NUMLOCK                                const  000077
  SC_RSHIFT                                 const  000059
  SC_SCROLLLOCK                             const  00007e
  SDDiskSize                                 code  8000000000000114
  SDInit                                     code  8000000000000110
  SDReadBoot                                 code  80000000000001ef
  SDReadMultiple                             code  8000000000000111
  SDReadPart                                 code  8000000000000113
  SDWriteMultiple                            code  8000000000000112
  SD_2_0                                     code  8000000000000256
  SD_CMD8                                    code  012320
  SD_CMD8.0001                               code  012390
  SD_CMD8.0002                               code  012398
  SD_CMD8.0003                               code  0123f4
  SD_CMD8.0004                               code  0123a8
  SD_CMD8.respOk                             code  012438
  SD_INIT                                    code  0122d4
  SD_MASTER                                 const  ffdc0b00
  SD_WAIT_RESP                               code  012450
  SD_WAIT_RESP.0001                          code  012464
  SD_WAIT_RESP.0002                          code  012490
  SECTOR_BUF                                  bss  052000
  SPIMASTER                                 const  ffdc0500
  SPI_DIRECT_ACCESS_DATA_REG                const  000018
  SPI_INIT_NO_ERROR                         const  000000
  SPI_INIT_SD                               const  000001
  SPI_MASTER_CONTROL_REG                    const  000004
  SPI_MASTER_VERSION_REG                    const  000000
  SPI_READ_NO_ERROR                         const  000000
  SPI_RESP_BYTE1                            const  0000c0
  SPI_RESP_BYTE2                            const  0000c4
  SPI_RESP_BYTE3                            const  0000c8
  SPI_RESP_BYTE4                            const  0000cc
  SPI_RX_FIFO_CTRL_REG                      const  000050
  SPI_RX_FIFO_DATA_COUNT_LSB                const  00004c
  SPI_RX_FIFO_DATA_COUNT_MSB                const  000048
  SPI_RX_FIFO_DATA_REG                      const  000040
  SPI_SD_SECT_15_8_REG                      const  000020
  SPI_SD_SECT_23_16_REG                     const  000024
  SPI_SD_SECT_31_24_REG                     const  000028
  SPI_SD_SECT_7_0_REG                       const  00001c
  SPI_TRANS_BUSY                            const  000001
  SPI_TRANS_CTRL_REG                        const  00000c
  SPI_TRANS_ERROR_REG                       const  000014
  SPI_TRANS_START                           const  000001
  SPI_TRANS_STATUS_REG                      const  000010
  SPI_TRANS_TYPE_REG                        const  000008
  SPI_TX_FIFO_CTRL_REG                      const  000090
  SPI_TX_FIFO_DATA_REG                      const  000080
  SPI_WRITE_NO_ERROR                        const  000000
  SSM_ISR                                    code  0126a0
  ScreenToAscii                              code  010640
  ScreenToAscii.stasc1                       code  010654
  ScrollUp                                   code  011290
  ScrollUp.0001                              code  0112d4
  SelectTaskToRun                            code  010f94
  SelectTaskToRun.0001                       code  010fc4
  SerialCheckForCharDirect                   code  0102e8
  SerialGetChar                              code  010424
  SerialGetCharDirect                        code  0102cc
  SerialIRQ                                  code  0104f0
  SerialPutChar                              code  010300
  SerialStartMsg                             code  010150
  ServiceRequestIRQ                          code  010dec
  ServiceRequestIRQ.0001                     code  010dec
  SetupIntVectors                            code  01017c
  SetupMemtags                               code  0124f4
  Sleep                                      code  010b54
  StartCPU1Addr                               bss  0000c8
  StartCPU1Flag                               bss  0000c0
  Sync_BIOS_Call                             code  010b84
  Sync_BIOS_Call.0001                        code  010b98
  Sync_BIOS_Call.0002                        code  010c30
  Sync_BIOS_Call.0003                        code  010c24
  TAB                                       const  000009
  TCB_BASE                                  const  c00000
  TCB_BackLink                              const  000000
  TCB_IPC                                   const  000100
  TCB_Next                                  const  000a00
  TCB_NextFree                              const  000218
  TCB_NextRdy                               const  000200
  TCB_NextTo                                const  000228
  TCB_PCSave                                const  000980
  TCB_Prev                                  const  000a08
  TCB_PrevFree                              const  000220
  TCB_PrevRdy                               const  000208
  TCB_PrevTo                                const  000230
  TCB_Priority                              const  000212
  TCB_Regs                                  const  000008
  TCB_SP0Save                               const  000800
  TCB_SP10Save                              const  0008a0
  TCB_SP11Save                              const  0008b0
  TCB_SP12Save                              const  0008c0
  TCB_SP13Save                              const  0008d0
  TCB_SP14Save                              const  0008e0
  TCB_SP15Save                              const  0008f0
  TCB_SP1Save                               const  000810
  TCB_SP2Save                               const  000820
  TCB_SP3Save                               const  000830
  TCB_SP4Save                               const  000840
  TCB_SP5Save                               const  000850
  TCB_SP6Save                               const  000860
  TCB_SP7Save                               const  000870
  TCB_SP8Save                               const  000880
  TCB_SP9Save                               const  000890
  TCB_SPSave                                const  000988
  TCB_SS0Save                               const  000808
  TCB_SS10Save                              const  0008a8
  TCB_SS11Save                              const  0008b8
  TCB_SS12Save                              const  0008c8
  TCB_SS13Save                              const  0008d8
  TCB_SS14Save                              const  0008e8
  TCB_SS15Save                              const  0008f8
  TCB_SS1Save                               const  000818
  TCB_SS2Save                               const  000828
  TCB_SS3Save                               const  000838
  TCB_SS4Save                               const  000848
  TCB_SS5Save                               const  000858
  TCB_SS6Save                               const  000868
  TCB_SS7Save                               const  000878
  TCB_SS8Save                               const  000888
  TCB_SS9Save                               const  000898
  TCB_Seg0Save                              const  000900
  TCB_Seg10Save                             const  000950
  TCB_Seg11Save                             const  000958
  TCB_Seg12Save                             const  000960
  TCB_Seg13Save                             const  000968
  TCB_Seg14Save                             const  000970
  TCB_Seg15Save                             const  000978
  TCB_Seg1Save                              const  000908
  TCB_Seg2Save                              const  000910
  TCB_Seg3Save                              const  000918
  TCB_Seg4Save                              const  000920
  TCB_Seg5Save                              const  000928
  TCB_Seg6Save                              const  000930
  TCB_Seg7Save                              const  000938
  TCB_Seg8Save                              const  000940
  TCB_Seg9Save                              const  000948
  TCB_Size                                  const  000400
  TCB_Status                                const  000210
  TCB_TOP                                   const  1c00000
  TCB_Timeout                                code  800000000000018d
  TCB_hJCB                                  const  000214
  TCB_r1                                    const  000008
  TCB_r10                                   const  000050
  TCB_r11                                   const  000058
  TCB_r12                                   const  000060
  TCB_r13                                   const  000068
  TCB_r14                                   const  000070
  TCB_r15                                   const  000078
  TCB_r16                                   const  000080
  TCB_r17                                   const  000088
  TCB_r18                                   const  000090
  TCB_r19                                   const  000098
  TCB_r2                                    const  000010
  TCB_r20                                   const  0000a0
  TCB_r21                                   const  0000a8
  TCB_r22                                   const  0000b0
  TCB_r23                                   const  0000b8
  TCB_r24                                   const  0000c0
  TCB_r25                                   const  0000c8
  TCB_r26                                   const  0000d0
  TCB_r27                                   const  0000d8
  TCB_r28                                   const  0000e0
  TCB_r29                                   const  0000e8
  TCB_r3                                    const  000018
  TCB_r30                                   const  0000f0
  TCB_r31                                   const  0000f8
  TCB_r4                                    const  000020
  TCB_r5                                    const  000028
  TCB_r6                                    const  000030
  TCB_r7                                    const  000038
  TCB_r8                                    const  000040
  TCB_r9                                    const  000048
  TCBs                                        bss  04e000
  TEXTREG                                   const  0a0000
  TEXTSCR                                   const  000000
  TEXT_COLS                                 const  000000
  TEXT_CURCTL                               const  000020
  TEXT_CURPOS                               const  00002c
  TEXT_ROWS                                 const  000004
  TSSBaseAddress                              bss  04e000
  TS_NONE                                   const  000000
  TS_PREEMPT                                const  000004
  TS_READY                                  const  000010
  TS_READY_BIT                              const  000004
  TS_RUNNING                                const  000008
  TS_RUNNING_BIT                            const  000003
  TS_SLEEP                                  const  000020
  TS_TIMEOUT                                const  000001
  TS_TIMEOUT_BIT                            const  000000
  TS_WAITMSG                                const  000002
  TS_WAITMSG_BIT                            const  000001
  TXTCOLS                                   const  000054
  TXTROWS                                   const  00001f
  TempTCB                                     bss  04d000
  Tick1024Rout                               code  010f64
  Tick1024Rout.0001                          code  010f70
  TickRout                                   code  010dec
  TickRout.SaveContext                       code  010dfc
  TickRout.acknowledgeInterrupt              code  010f20
  TickVec                                     bss  000020
  Ticks                                       bss  000008
  TimeoutList                                code  010a70
  ToJul                                      code  012884
  UART                                      const  ffdc0a00
  UART_CM0                                  const  000008
  UART_CM1                                  const  000009
  UART_CM2                                  const  00000a
  UART_CM3                                  const  00000b
  UART_CTRL                                 const  000007
  UART_FF                                   const  000005
  UART_IE                                   const  000004
  UART_IS                                   const  000003
  UART_LS                                   const  000001
  UART_MC                                   const  000006
  UART_MS                                   const  000002
  UART_RX                                   const  000000
  UART_SPR                                  const  00000f
  UART_TX                                   const  000000
  Uart_foff                                   bss  00009e
  Uart_fon                                    bss  0000a0
  Uart_ms                                     bss  000094
  Uart_rxdtr                                  bss  00009c
  Uart_rxfifo                                code  800000000000015a
  Uart_rxflow                                 bss  00009a
  Uart_rxhead                                 bss  000096
  Uart_rxrts                                  bss  00009b
  Uart_rxtail                                 bss  000098
  Uart_rxxon                                  bss  00009d
  Uart_txdtr                                  bss  0000a3
  Uart_txrts                                  bss  0000a2
  Uart_txxon                                  bss  0000a4
  Uart_txxonoff                               bss  000095
  UpdateCursorPos                            code  010ff8
  Wait10ms                                   code  011dc0
  Wait10ms.0001                              code  011dcc
  Wait10ms.0002                              code  011de4
  XOFF                                      const  000013
  XON                                       const  000011
  arl1                                       code  010894
  arl5                                       code  0108c4
  attl_add_at_end                            code  01099c
  attl_add_at_head                           code  010a14
  attl_adjust_timeout                        code  0109e4
  attl_check_next                            code  01097c
  attl_exit                                  code  010a30
  attl_insert_before                         code  0109b8
  attl_insert_before_head                    code  0109d0
  berr_rout                                  code  01263f
  brkpt1                                     code  0124fc
  brkpt1.0001                                code  012518
  cirxb1                                     code  010420
  disk_size                                   bss  000090
  doCLS                                      code  0118f2
  doCS                                       code  80000000000001d8
  doDate                                     code  0115cc
  doDate.0001                                code  01160c
  doDay                                      code  011644
  doDumpmem                                  code  0114ec
  doDumpmem.001                              code  0114f8
  doFillmem                                  code  01150c
  doFillmem.0001                             code  011568
  doFillmem.0002                             code  011550
  doFillmem.0003                             code  011570
  doFillmem.0004                             code  011520
  doJump                                     code  0115b8
  doRand                                     code  80000000000001dd
  doSDBoot                                   code  011590
  drf_rout                                   code  0125b0
  drf_rout.0001                              code  0125c8
  dwf_rout                                   code  0125cc
  dwf_rout.0001                              code  0125e4
  eval                                       code  80000000000001de
  exf_rout                                   code  012594
  exf_rout.0001                              code  0125ac
  get_datetime                               code  0126b0
  hangprg                                    code  0124e4
  icc1                                       code  011270
  icr1                                       code  011250
  ignBlanks                                  code  011490
  ignBlanks1                                 code  011498
  kbdi5                                      code  0119d8
  keybdControlCodes                          code  011ff0
  keybdExtendedCodes                         code  012070
  loadBootFile                               code  80000000000001f0
  mon1                                       code  0113b0
  mon1.Prompt1                               code  0113ec
  mon1.Prompt2                               code  011408
  mon1.Prompt3                               code  0113d4
  mon1.PromptLn                              code  0113c8
  mon1.doHelp                                code  011464
  msgBadKeybd                                code  0119d8
  msgBusErr                                  code  01262a
  msgEA                                      code  01263a
  msgErr                                     code  011850
  msgHelp                                    code  011858
  msgMonitorStarted                          code  0118e1
  msgPriv                                    code  012613
  msgStart                                   code  011375
  msgUninit                                  code  01261e
  msgdrf                                     code  012609
  msgdwf                                     code  01260e
  msgexf                                     code  012604
  pSpriteController                          code  012a14
  priv_rout                                  code  0125e8
  priv_rout.0001                             code  012600
  ptl1                                       code  010b38
  r2                                         code  0121cc
  r3                                         code  0121cc
  r5                                         code  0121cc
  rfr2                                       code  010940
  rftl_empty_list                            code  010af4
  rftl_not_on_list                           code  010b10
  rftl_not_on_list2                          code  010b20
  rftl_remove_from_head                      code  010ab8
  rxfull                                     code  800000000000014b
  set_time_serial                            code  012958
  set_time_serial_10                         code  012824
  set_time_serial_12                         code  01285c
  set_time_serial_14                         code  01285c
  set_time_serial_17                         code  01294c
  set_time_serial_19                         code  012a08
  set_time_serial_2                          code  012738
  set_time_serial_20                         code  0129f4
  set_time_serial_4                          code  012770
  set_time_serial_6                          code  0127a8
  set_time_serial_8                          code  0127ec
  sgc1                                       code  0102cc
  sgcfifo1                                   code  0104d8
  sgcfifo2                                   code  0104c4
  sgcfifo3                                   code  01049c
  sgcfifo4                                   code  0104b0
  sgcfifo5                                   code  0104c4
  shiftedScanCodes                           code  011ef0
  sirq1                                      code  010534
  smsirq                                     code  010548
  spcabort                                   code  0103e8
  spcb1                                      code  010360
  spcb2                                      code  010398
  spcb3                                      code  010338
  spcb4                                      code  010370
  spcb5                                      code  0103b4
  spcb6                                      code  0103a0
  spcb7                                      code  0103e4
  spcb8                                      code  0103bc
  sprite_demo                                code  012a1c
  sprite_demo_10                             code  012abc
  sprite_demo_11                             code  012b34
  sprite_demo_12                             code  012b2c
  sprite_demo_13                             code  012b34
  sprite_demo_14                             code  012c08
  sprite_demo_15                             code  012b40
  sprite_demo_16                             code  012bf8
  sprite_demo_17                             code  012bf0
  sprite_demo_18                             code  012c08
  sprite_demo_4                              code  012a54
  sprite_demo_5                              code  012a8c
  sprite_demo_6                              code  012a84
  sprite_demo_7                              code  012a90
  sprite_demo_8                              code  012ab8
  sprite_demo_9                              code  012ab0
  sprites                                     bss  057000
  srxirq                                     code  010558
  srxirq1                                    code  010558
  srxirq2                                    code  010578
  srxirq3                                    code  010588
  srxirq5                                    code  0105a8
  srxirq6                                    code  0105f0
  srxirq7                                    code  010604
  srxirq8                                    code  010614
  start                                      code  010080
  start.0001                                 code  0100c8
  start.0002                                 code  0100b0
  start.0003                                 code  010094
  startSector                                 bss  00008c
  stxirq                                     code  010554
  unshiftedScanCodes                         code  011df0
