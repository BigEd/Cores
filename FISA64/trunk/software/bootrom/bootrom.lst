                	; ============================================================================
                	; bootrom.s
                	;        __
                	;   \\__/ o\    (C) 2014  Robert Finch, Stratford
                	;    \  __ /    All rights reserved.
                	;     \/_//     robfinch<remove>@finitron.ca
                	;       ||
                	;  
                	;
                	; This source file is free software: you can redistribute it and/or modify 
                	; it under the terms of the GNU Lesser General Public License as published 
                	; by the Free Software Foundation, either version 3 of the License, or     
                	; (at your option) any later version.                                      
                	;                                                                          
                	; This source file is distributed in the hope that it will be useful,      
                	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                	; GNU General Public License for more details.                             
                	;                                                                          
                	; You should have received a copy of the GNU General Public License        
                	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                	;                                                                          
                	; ============================================================================
                	;
                	TXTCOLS		EQU		84
                	TXTROWS		EQU		31
                	
                	CR	EQU	0x0D		;ASCII equates
                	LF	EQU	0x0A
                	TAB	EQU	0x09
                	CTRLC	EQU	0x03
                	CTRLH	EQU	0x08
                	CTRLI	EQU	0x09
                	CTRLJ	EQU	0x0A
                	CTRLK	EQU	0x0B
                	CTRLM   EQU 0x0D
                	CTRLS	EQU	0x13
                	CTRLX	EQU	0x18
                	XON		EQU	0x11
                	XOFF	EQU	0x13
                	
                	SC_LSHIFT	EQU		$12
                	SC_RSHIFT	EQU		$59
                	SC_KEYUP	EQU		$F0
                	SC_EXTEND	EQU		$E0
                	SC_CTRL		EQU		$14
                	SC_ALT		EQU		$11
                	SC_DEL		EQU		$71		; extend
                	SC_LCTRL	EQU		$58
                	SC_NUMLOCK	EQU		$77
                	SC_SCROLLLOCK	EQU	$7E
                	SC_CAPSLOCK	EQU		$58
                	SC_TAB      EQU     $0D
                	
                	; Boot sector info (62 byte structure) */
                	BSI_JMP		= 0x00
                	BSI_OEMName	= 0x03
                	BSI_bps		= 0x0B
                	BSI_SecPerCluster	= 0x0D
                	BSI_ResSectors	= 0x0E
                	BSI_FATS	= 0x10
                	BSI_RootDirEnts	= 0x11
                	BSI_Sectors	= 0x13
                	BSI_Media	= 0x15
                	BSI_SecPerFAT	= 0x16
                	BSI_SecPerTrack	= 0x18
                	BSI_Heads	= 0x1A
                	BSI_HiddenSecs	= 0x1C
                	BSI_HugeSecs	= 0x1E
                	
                	BSI_DriveNum	= 0x24
                	BSI_Rsvd1		= 0x25
                	BSI_BootSig		= 0x26
                	BSI_VolID		= 0x27
                	BSI_VolLabel	= 0x2B
                	BSI_FileSysType = 0x36
                	
                	IRQ_STACK   EQU     $8000
                	DBG_STACK   EQU     $7000
                	CPU0_BIOS_STACK  EQU     $6800
                	MON_STACK   EQU     $6000
                	; CPU1 Ram allocations must be to the dram area.
                	CPU1_IRQ_STACK  EQU     $20800
                	CPU1_SYS_STACK      EQU  $21000
                	CPU1_BIOS_STACK     EQU  $21800
                	CPU0_SYS_STACK      EQU  $5000
                	
                	LEDS	equ		$FFDC0600
                	
                	BIOS_FREE      EQU       0
                	BIOS_DONE      EQU       1
                	BIOS_INSERVICE EQU       2
                	
                	MAX_BIOS_CALL  EQU       100
                	E_BadFuncno    EQU       1
                	
                	; The following offsets in the I/O segment
                	TEXTSCR	equ		$00000
                	TEXTREG		EQU		$A0000
                	TEXT_COLS	EQU		0x00
                	TEXT_ROWS	EQU		0x04
                	TEXT_CURPOS	EQU		0x2C
                	TEXT_CURCTL	EQU		0x20
                	
                	BMP_CLUT	EQU		$C5800
                	
                	PIC			EQU		0xFFDC0FC0
                	PIC_IE		EQU		0xFFDC0FC4
                	PIC_ES		EQU		0xFFDC0FD0
                	PIC_RSTE	EQU		0xFFDC0FD4
                	
                	KEYBD		EQU		0xFFDC0000
                	KEYBDCLR	EQU		0xFFDC0004
                	
                	SPIMASTER	EQU		0xFFDC0500
                	SPI_MASTER_VERSION_REG	EQU	0x00
                	SPI_MASTER_CONTROL_REG	EQU	0x04
                	SPI_TRANS_TYPE_REG	EQU		0x08
                	SPI_TRANS_CTRL_REG	EQU		0x0C
                	SPI_TRANS_STATUS_REG	EQU	0x10
                	SPI_TRANS_ERROR_REG		EQU	0x14
                	SPI_DIRECT_ACCESS_DATA_REG		EQU	0x18
                	SPI_SD_SECT_7_0_REG		EQU	0x1C
                	SPI_SD_SECT_15_8_REG	EQU	0x20
                	SPI_SD_SECT_23_16_REG	EQU	0x24
                	SPI_SD_SECT_31_24_REG	EQU	0x28
                	SPI_RX_FIFO_DATA_REG	EQU	0x40
                	SPI_RX_FIFO_DATA_COUNT_MSB	EQU	0x48
                	SPI_RX_FIFO_DATA_COUNT_LSB  EQU 0x4C
                	SPI_RX_FIFO_CTRL_REG		EQU	0x50
                	SPI_TX_FIFO_DATA_REG	EQU	0x80
                	SPI_TX_FIFO_CTRL_REG	EQU	0x90
                	SPI_RESP_BYTE1			EQU	0xC0
                	SPI_RESP_BYTE2			EQU	0xC4
                	SPI_RESP_BYTE3			EQU	0xC8
                	SPI_RESP_BYTE4			EQU	0xCC
                	
                	SPI_INIT_SD			EQU		0x01
                	SPI_TRANS_START		EQU		0x01
                	SPI_TRANS_BUSY		EQU		0x01
                	SPI_INIT_NO_ERROR	EQU		0x00
                	SPI_READ_NO_ERROR	EQU		0x00
                	SPI_WRITE_NO_ERROR	EQU		0x00
                	RW_READ_SD_BLOCK	EQU		0x02
                	RW_WRITE_SD_BLOCK	EQU		0x03
                	
                	I2C_MASTER		EQU		0xFFDC0E00
                	I2C_PRESCALE_LO	EQU		0x00
                	I2C_PRESCALE_HI	EQU		0x01
                	I2C_CONTROL		EQU		0x02
                	I2C_TX			EQU		0x03
                	I2C_RX			EQU		0x03
                	I2C_CMD			EQU		0x04
                	I2C_STAT		EQU		0x04
                	
                	SD_MASTER		EQU		0xFFDC0B00
                	
                	RANDOM_NUM      EQU     0xFFDC0C00
                	
                	UART            EQU     0xFFDC0A00
                	UART_TX         EQU     0
                	UART_RX         EQU     0
                	UART_LS         EQU     1
                	UART_MS         EQU     2
                	UART_IS         EQU     3
                	UART_IE         EQU     4
                	UART_FF         EQU     5
                	UART_MC         EQU     6
                	UART_CTRL       EQU     7
                	UART_CM0        EQU     8
                	UART_CM1        EQU     9
                	UART_CM2        EQU     10
                	UART_CM3        EQU     11
                	UART_SPR        EQU     15
                	
                	TCB_BASE       EQU     $0C00000
                	TCB_TOP        EQU     $1C00000
                	
                	; BIOS request structure
                	BIOS_op        EQU     $00
                	BIOS_arg1      EQU     $08
                	BIOS_arg2      EQU     $10
                	BIOS_arg3      EQU     $18
                	BIOS_arg4      EQU     $20
                	BIOS_arg5      EQU     $28
                	BIOS_resp      EQU     $30
                	BIOS_stat      EQU     $38
                	
                	;include "FMTK_Equates.inc"
                	
                		code
                		org		$00010000
010000 3A 10 00 00 		bra     start
                	BIOS_FuncTable:
010004 00 00 00 00 		align   
                	
010008 74 06 01 00 		dw		ClearScreen		; $8000
01000C 00 00 00 00 
010010 60 06 01 00 		dw		HomeCursor		; $8008
010014 00 00 00 00 
010018 54 07 01 00 		dw		DisplayString	; $8010
01001C 00 00 00 00 
010020 D4 17 01 00 		dw		KeybdGetCharNoWait; $8018
010024 00 00 00 00 
010028 91 00 00 00 		dw		ClearBmpScreen	; $8020
01002C 00 00 00 80 
010030 F0 0B 01 00 		dw		DisplayChar		; $8028
010034 00 00 00 00 
010038 93 00 00 00 		dw		SDInit			; $8030
01003C 00 00 00 80 
010040 94 00 00 00 		dw		SDReadMultiple	; $8038
010044 00 00 00 80 
010048 95 00 00 00 		dw		SDWriteMultiple	; $8040
01004C 00 00 00 80 
010050 96 00 00 00 		dw		SDReadPart		; $8048
010054 00 00 00 80 
010058 97 00 00 00 		dw		SDDiskSize		; $8050
01005C 00 00 00 80 
010060 D4 06 01 00 		dw		DisplayWord		; $8058
010064 00 00 00 00 
010068 E8 06 01 00 		dw		DisplayHalf		; $8060
01006C 00 00 00 00 
010070 FC 06 01 00 		dw		DisplayCharHex	; $8068
010074 00 00 00 00 
010078 10 07 01 00 		dw		DisplayByte		; $8070
01007C 00 00 00 00 
                	message "start"
                	start:
010080 02 00 02 6E 	    sei     ; interrupts off
010084 02 10 00 6C 	    cpuid   r1,r0,#0
010088 BD 00 14 00 	    beq     r1,.0002
01008C 7C C1 00 00 	    ldi     tr,#$C10000          ; IDLE task for CPU #1
010090 0A 80 01 00 
                	.0003:
010094 7C 02 00 00 	    inc     $20000
010098 64 10 00 00 
01009C 46 10 30 07 	    lw      r1,StartCPU1Flag
0100A0 7C 34 12 00 	    cmp     r1,r1,#$12345678
0100A4 86 10 F0 AC 
0100A8 BD 10 F6 FF 	    bne     r1,.0003
0100AC 3E 00 40 07 	    jmp     (StartCPU1Addr)
                	.0002:
0100B0 7C 00 00 00 	    ldi     sp,#MON_STACK        ; set stack pointer to top of 32k Area
0100B4 0A E0 01 C0 
0100B8 7C C1 00 00 		ldi     tr,#$C10000          ; load task register with IDLE task
0100BC 0A 80 01 00 
0100C0 0A 50 00 00 	    ldi     r5,#$0000
0100C4 0A 10 28 00 	    ldi     r1,#20
                	.0001:
0100C8 7C DC FF 00 	    sc      r5,LEDS
0100CC 61 50 00 0C 
0100D0 94 52 02 00 	    addui   r5,r5,#1
0100D4 63 00 10 02 		sw		r0,Milliseconds
0100D8 0A 10 FE FF 		ldi     r1,#-1
0100DC 63 10 10 07 		sw      r1,API_sema
0100E0 63 00 20 07 		sw      r0,BIOS_sema
0100E4 FC 26 00 00 		ldi		r1,#%000000100_110101110_0000000000
0100E8 0A 10 00 70 
0100EC 60 10 78 02 		sb		r1,KeybdEcho
0100F0 60 00 7A 02 		sb		r0,KeybdBad
0100F4 62 10 60 02 		sh		r1,NormAttr
0100F8 60 00 70 02 		sb		r0,CursorRow
0100FC 60 00 72 02 		sb		r0,CursorCol
010100 7C 01 00 00 		ldi		r1,#DisplayChar
010104 0A 10 E0 17 
010108 63 10 20 02 		sw		r1,OutputVec
01010C 39 AD 00 00 		bsr		ClearScreen
010110 39 AA 00 00 		bsr		HomeCursor
010114 7C 01 00 00 		ldi     r1,#msgStart
010118 0A 10 B2 1D 
01011C 39 CD 00 00 		bsr     DisplayStringCRLF
010120 0A 10 10 00 		ldi     r1,#8
010124 7C DC FF 00 		sb      r1,LEDS
010128 60 10 00 0C 
01012C 39 0C 00 00 		bsr		SetupIntVectors
                	;	bsr		KeybdInit
010130 B9 DD 07 00 	    bsr     FMTKInitialize
010134 7C 01 00 00 	    ldi     r1,#UserTickRout     ; set user tick vector
010138 0A 10 30 15 
01013C 7C C0 00 00 	    sw      r1,$C00000
010140 63 10 00 00 
010144 B9 22 00 00 		bsr		InitPIC
010148 B9 25 00 00 		bsr     InitUart
01014C B9 BE 03 00 		bsr     RTCCReadbuf          ; read the real-time clock
010150 39 9D 04 00 		bsr     set_time_serial      ; set the system time serial
010154 3A B4 01 00 		bra		Monitor
010158 B9 D8 07 00 		bsr		FMTKInitialize
01015C 02 00 00 6E 		cli
                	
                	SerialStartMsg:
010160 E7 EF 01 00 	    push    lr
010164 7C 01 00 00 		ldi     r1,#SerialPutChar
010168 0A 10 18 06 
01016C 63 10 20 02 		sw      r1,OutputVec
010170 7C 01 00 00 		ldi     r1,#msgStart
010174 0A 10 B2 1D 
010178 B9 C1 00 00 		bsr     DisplayStringCRLF
01017C 7C 01 00 00 		ldi		r1,#DisplayChar
010180 0A 10 E0 17 
010184 63 10 20 02 		sw		r1,OutputVec
010188 3B FF 11 00 	    rts
 
                	SetupIntVectors:
01018C 0A 10 4E 01 		ldi     r1,#$00A7
010190 7C DC FF 00 		sc      r1,LEDS
010194 61 10 00 0C 
010198 02 00 14 3C 		mtspr   vbr,r0               ; place vector table at $0000
01019C 3F 00 00 00 		nop
0101A0 3F 00 00 00 		nop
0101A4 02 20 14 3E 		mfspr   r2,vbr
0101A8 7C 01 00 00 		ldi		r1,#Tick1024Rout
0101AC 0A 10 90 15 
0101B0 63 11 20 1C 		sw		r1,450*8[r2]
0101B4 7C 01 00 00 		ldi		r1,#TickRout         ; This vector will be taken over by FMTK
0101B8 0A 10 40 12 
0101BC 63 11 30 1C 		sw		r1,451*8[r2]
0101C0 7C 01 00 00 		ldi     r1,#SerialIRQ
0101C4 0A 10 E8 09 
0101C8 63 11 80 1C 		sw      r1,456*8[r2]
0101CC 7C 00 00 00 		ldi     r1,#ServiceRequestIRQ
0101D0 7C 00 00 00 
0101D4 0A 10 72 01 
0101D8 63 11 90 1C 		sw      r1,457*8[r2]
0101DC 7C 01 00 00 		ldi		r1,#KeybdIRQ
0101E0 0A 10 B0 0F 
0101E4 63 11 F0 1C 		sw		r1,463*8[r2]
0101E8 7C 01 00 00 	    ldi     r1,#SSM_ISR          ; set ISR vector for single step routine
0101EC 0A 10 00 47 
0101F0 63 11 F0 1E 	    sw      r1,495*8[r2]
0101F4 7C 01 00 00 	    ldi     r1,#IBPT_ISR         ; set ISR vector for instruction breakpoint routine
0101F8 0A 10 08 47 
0101FC 63 11 00 1F 	    sw      r1,496*8[r2]
010200 7C 01 00 00 		ldi		r1,#exf_rout
010204 0A 10 E8 44 
010208 63 11 10 1F 		sw		r1,497*8[r2]
01020C 7C 01 00 00 		ldi		r1,#dwf_rout
010210 0A 10 58 45 
010214 63 11 20 1F 		sw		r1,498*8[r2]
010218 7C 01 00 00 		ldi		r1,#drf_rout
01021C 0A 10 20 45 
010220 63 11 30 1F 		sw		r1,499*8[r2]
010224 7C 01 00 00 		ldi		r1,#priv_rout
010228 0A 10 90 45 
01022C 63 11 50 1F 		sw		r1,501*8[r2]
010230 7C 01 00 00 		ldi		r1,#berr_rout
010234 0A 10 3E 46 
010238 63 11 C0 1F 		sw		r1,508*8[r2]
01023C 7C 01 00 00 		ldi		r1,#berr_rout
010240 0A 10 3E 46 
010244 63 11 D0 1F 		sw		r1,509*8[r2]
010248 0A 10 54 01 		ldi     r1,#$00AA
01024C 7C DC FF 00 		sc      r1,LEDS
010250 61 10 00 0C 
010254 37 FF 01 00 	    rtl
 
                	;------------------------------------------------------------------------------
                	; Initialize the interrupt controller.
                	;------------------------------------------------------------------------------
                	
                	InitPIC:
010258 0A 10 18 04 		ldi		r1,#$020C		; timer interrupt(s) are edge sensitive
01025C 7C DC FF 00 		sh		r1,PIC_ES
010260 62 10 A0 1F 
010264 0A 10 1E 04 		ldi		r1,#$020F		; enable keyboard reset, timer interrupts
010268 7C DC FF 00 		sh		r1,PIC_IE
01026C 62 10 88 1F 
010270 37 FF 01 00 		rtl

                	
                	;==============================================================================
                	; Serial port
                	;==============================================================================
                		code
                	;------------------------------------------------------------------------------
                	; Initialize UART
                	;------------------------------------------------------------------------------
                	
                	InitUart:
010274 7C DC FF 00 	    ldi     r2,#UART
010278 0A 20 00 14 
                	;    ldi     r1,#$025BF7BA   ; constant for clock multiplier with 16.667MHz clock for 9600 baud
01027C FC 27 0E 00 	    ldi     r1,#$0E27CE61   ; constant for clock multiplier with 16.667MHz clock for 57600 baud
010280 0A 10 C2 9C 
010284 82 10 10 72 	    lsr     r1,r1,#8          ; drop the LSB (not used)
010288 60 11 12 00 	    sb      r1,UART_CM1[r2]
01028C 82 10 10 72 	    lsr     r1,r1,#8
010290 60 11 14 00 	    sb      r1,UART_CM2[r2]
010294 82 10 10 72 	    lsr     r1,r1,#8
010298 60 11 16 00 	    sb      r1,UART_CM3[r2]
01029C 60 01 0E 00 	    sb      r0,UART_CTRL[r2]           ; no hardware flow control
0102A0 61 00 DC 02 		sc		r0,Uart_rxhead			; reset buffer indexes
0102A4 61 00 E0 02 		sc		r0,Uart_rxtail
0102A8 0A 10 E0 03 		ldi		r1,#0x1f0
0102AC 61 10 EC 02 		sc		r1,Uart_foff		; set threshold for XOFF
0102B0 0A 10 20 00 		ldi		r1,#0x010
0102B4 61 10 F0 02 		sc		r1,Uart_fon			; set threshold for XON
0102B8 0A 10 02 00 		ldi		r1,#1
0102BC 60 11 08 00 		sb		r1,UART_IE[r2]		; enable receive interrupt only
0102C0 60 00 E6 02 		sb		r0,Uart_rxrts		; no RTS/CTS signals available
0102C4 60 00 F4 02 		sb		r0,Uart_txrts		; no RTS/CTS signals available
0102C8 60 00 F6 02 		sb		r0,Uart_txdtr		; no DTR signals available
0102CC 60 00 E8 02 		sb		r0,Uart_rxdtr		; no DTR signals available
0102D0 0A 10 02 00 		ldi		r1,#1
0102D4 60 10 F8 02 		sb		r1,Uart_txxon		; for now
0102D8 0A 10 02 00 		ldi		r1,#1
                	;	sb		r1,SERIAL_SEMA
0102DC 37 FF 01 00 	    rtl

                	;---------------------------------------------------------------------------------
                	; Get character directly from serial port. Blocks until a character is available.
                	;---------------------------------------------------------------------------------
                	;
                	SerialGetCharDirect:
                	sgc1:
0102E0 7C DC FF 00 		lb		r1,UART+UART_LS	; uart status
0102E4 40 10 02 14 
0102E8 8C 10 02 00 		and		r1,r1,#1		; is there a char available ?
0102EC BD 00 FA FF 		beq		r1,sgc1
0102F0 7C DC FF 00 		lb		r1,UART+UART_RX
0102F4 40 10 00 14 
0102F8 37 FF 01 00 		rtl

                	;------------------------------------------------
                	; Check for a character at the serial port
                	; returns r1 = 1 if char available, 0 otherwise
                	;------------------------------------------------
                	;
                	SerialCheckForCharDirect:
0102FC 7C DC FF 00 		lb		r1,UART+UART_LS			; uart status
010300 40 10 02 14 
010304 8C 10 02 00 		and		r1,r1,#rxfull			; is there a char available ?
010308 37 FF 01 00 		rtl

                	;-----------------------------------------
                	; Put character to serial port
                	; r1 = char to put
                	;-----------------------------------------
                	;
                	SerialPutChar:
01030C 67 E1 01 00 	    push    r2
010310 E7 E1 01 00 	    push    r3
010314 67 E2 01 00 		push	r4
010318 E7 E2 01 00 		push	r5
01031C 67 E3 01 00 	    push    r6
010320 7C DC FF 00 	    ldi     r6,#UART
010324 0A 60 00 14 
010328 40 23 0C 00 		lb		r2,UART_MC[r6]
01032C 0D 21 06 00 		or		r2,r2,#3		; assert DTR / RTS
010330 60 23 0C 00 		sb		r2,UART_MC[r6]
010334 40 20 F4 02 		lb		r2,Uart_txrts
010338 3D 01 1A 00 		beq		r2,spcb1
01033C 46 40 10 02 		lw		r4,Milliseconds
010340 0A 30 00 08 		ldi		r3,#1024		; delay count (1 s)
                	spcb3:
010344 40 23 04 00 		lb		r2,UART_MS[r6]
010348 0C 21 20 00 		and		r2,r2,#$10		; is CTS asserted ?
01034C 3D 11 10 00 		bne		r2,spcb1
010350 46 50 10 02 		lw		r5,Milliseconds
010354 02 22 0A 0C 		cmp		r2,r4,r5
010358 3D 01 F6 FF 		beq		r2,spcb3
01035C 82 42 00 1A 		mov		r4,r5
010360 95 31 02 00 		subui   r3,r3,#1
010364 BD 11 F0 FF 		bne		r3,spcb3
010368 BA 11 00 00 		bra		spcabort
                	spcb1:
01036C 40 20 F6 02 		lb		r2,Uart_txdtr
010370 3D 01 1A 00 		beq		r2,spcb2
010374 46 40 10 02 		lw		r4,Milliseconds
010378 0A 30 00 08 		ldi		r3,#1024		; delay count
                	spcb4:
01037C 40 23 04 00 		lb		r2,UART_MS[r6]
010380 0C 21 40 00 		and		r2,r2,#$20		; is DSR asserted ?
010384 3D 11 10 00 		bne		r2,spcb2
010388 46 50 10 02 		lw		r5,Milliseconds
01038C 02 22 0A 0C 		cmp		r2,r4,r5
010390 3D 01 F6 FF 		beq		r2,spcb4
010394 82 42 00 1A 		mov		r4,r5
010398 95 31 02 00 		subui   r3,r3,#1
01039C BD 11 F0 FF 		bne		r3,spcb4
0103A0 BA 0A 00 00 		bra		spcabort
                	spcb2:	
0103A4 40 20 F8 02 		lb		r2,Uart_txxon
0103A8 3D 01 0C 00 		beq		r2,spcb5
                	spcb6:
0103AC 40 20 DA 02 		lb		r2,Uart_txxonoff
0103B0 3D 01 08 00 		beq		r2,spcb5
0103B4 40 43 04 00 		lb		r4,UART_MS[r6]
0103B8 0C 42 00 01 		and		r4,r4,#0x80			; DCD ?
0103BC 3D 12 F8 FF 		bne		r4,spcb6
                	spcb5:
0103C0 46 40 10 02 		lw		r4,Milliseconds
0103C4 0A 30 00 08 		ldi		r3,#1024			; wait up to 1s
                	spcb8:
0103C8 40 23 02 00 		lb		r2,UART_LS[r6]
0103CC 0C 21 40 00 		and		r2,r2,#0x20			; tx not full ?
0103D0 3D 11 10 00 		bne		r2,spcb7
0103D4 46 50 10 02 		lw		r5,Milliseconds
0103D8 02 22 0A 0C 		cmp		r2,r4,r5
0103DC 3D 01 F6 FF 		beq		r2,spcb8
0103E0 82 42 00 1A 		mov		r4,r5
0103E4 95 31 02 00 		subui   r3,r3,#1
0103E8 BD 11 F0 FF 		bne		r3,spcb8
0103EC 3A 01 00 00 		bra		spcabort
                	spcb7:
0103F0 60 13 00 00 		sb		r1,UART_TX[r6]
                	spcabort:
0103F4 57 6F 10 00 	    pop     r6
0103F8 57 5F 10 00 		pop		r5
0103FC 57 4F 10 00 		pop		r4
010400 57 3F 10 00 		pop     r3
010404 57 2F 10 00 		pop     r2
010408 37 FF 01 00 		rtl

                	
                	;-------------------------------------------------
                	; Compute number of characters in recieve buffer.
                	; r4 = number of chars
                	;-------------------------------------------------
                	CharsInRxBuf:
01040C 43 40 DC 02 		lcu		r4,Uart_rxhead
010410 43 30 E0 02 		lcu		r3,Uart_rxtail
010414 02 42 06 2A 		subu	r4,r4,r3
010418 3D 22 0A 00 		bgt		r4,cirxb1
01041C 0A 40 00 04 		ldi		r4,#0x200
010420 02 42 06 28 		addu	r4,r4,r3
010424 43 30 DC 02 		lcu		r3,Uart_rxhead
010428 02 42 06 2A 		subu	r4,r4,r3
                	cirxb1:
01042C 37 FF 01 00 		rtl

                	;----------------------------------------------
                	; Get character from rx fifo
                	; If the fifo is empty enough then send an XON
                	;----------------------------------------------
                	;
                	SerialGetChar:
010430 67 E1 01 00 	    push    r2
010434 E7 E1 01 00 	    push    r3
010438 67 E2 01 00 		push	r4
01043C E7 E2 01 00 	    push    r5
010440 7C DC FF 00 	    ldi     r5,#UART
010444 0A 50 00 14 
010448 43 30 DC 02 		lcu		r3,Uart_rxhead
01044C 43 20 E0 02 		lcu		r2,Uart_rxtail
010450 02 31 06 0C 		cmp		r3,r2,r3
010454 BD 01 44 00 		beq		r3,sgcfifo1		    ; is there a char available ?
010458 41 11 FA 02 		lbu		r1,Uart_rxfifo[r2]	; get the char from the fifo into r1
01045C 14 21 02 00 		addui   r2,r2,#1    		; increment the fifo pointer
010460 0C 21 FE 03 		and		r2,r2,#$1ff
010464 61 20 E0 02 		sc		r2,Uart_rxtail
010468 40 20 E4 02 		lb		r2,Uart_rxflow		; using flow control ?
01046C 3D 01 2E 00 		beq		r2,sgcfifo2
010470 43 30 F0 02 		lcu		r3,Uart_fon		; enough space in Rx buffer ?
010474 E7 EF 01 00 		push    lr
010478 B9 F2 FF FF 		bsr		CharsInRxBuf
01047C 57 FF 11 00 		pop     lr
010480 02 42 06 0C 		cmp		r4,r4,r3
010484 3D 22 22 00 		bgt		r4,sgcfifo2
010488 60 00 E4 02 		sb		r0,Uart_rxflow		; flow off
01048C 40 40 E6 02 		lb		r4,Uart_rxrts
010490 3D 02 08 00 		beq		r4,sgcfifo3
010494 C0 42 0C 00 		lb		r4,UART_MC[r5]		; set rts bit in MC
010498 0D 42 04 00 		or		r4,r4,#2
01049C E0 42 0C 00 		sb		r4,UART_MC[r5]
                	sgcfifo3:
0104A0 40 40 E8 02 		lb		r4,Uart_rxdtr
0104A4 3D 02 08 00 		beq		r4,sgcfifo4
0104A8 C0 42 0C 00 		lb		r4,UART_MC[r5]		; set DTR
0104AC 0D 42 02 00 		or		r4,r4,#1
0104B0 E0 42 0C 00 		sb		r4,UART_MC[r5]
                	sgcfifo4:
0104B4 40 40 EA 02 		lb		r4,Uart_rxxon
0104B8 3D 02 08 00 		beq		r4,sgcfifo5
0104BC 0A 40 22 00 		ldi		r4,#XON
0104C0 7C DC FF 00 		sb		r4,UART[r5]
0104C4 E0 42 00 14 
                	sgcfifo5:
                	sgcfifo2:					; return with char in r1
0104C8 57 5F 10 00 	    pop     r5
0104CC 57 4F 10 00 		pop		r4
0104D0 57 3F 10 00 		pop     r3
0104D4 57 2F 10 00 		pop     r2
0104D8 37 FF 01 00 		rtl
sgcfifo1:
0104DC 0A 10 FE FF 		ldi		r1,#-1				; no char available
0104E0 57 5F 10 00 		pop     r5
0104E4 57 4F 10 00 		pop		r4
0104E8 57 3F 10 00 		pop     r3
0104EC 57 2F 10 00 		pop     r2
0104F0 3B FF 11 00 		rts

                	
                	;-----------------------------------------
                	; Serial port IRQ
                	;-----------------------------------------
                	;
                	SerialIRQ:
0104F4 FC 00 00 00 	    ldi     sp,#$8000
0104F8 0A E0 01 00 
0104FC E7 E0 01 00 		push    r1
010500 67 E1 01 00 		push    r2
010504 E7 E1 01 00 		push    r3
010508 67 E2 01 00 		push	r4
                	
01050C 7C DC FF 00 	    ldi     r2,#UART
010510 0A 20 00 14 
010514 40 11 06 00 	    lb      r1,UART_IS[r2]  ; get interrupt status
010518 BD 20 10 00 		bgt		r1,sirq1		; no interrupt
01051C 8C 10 FE 00 		and		r1,r1,#0x7f  	; switch on interrupt type
010520 86 30 08 00 		cmp		r3,r1,#4
010524 BD 01 1C 00 		beq		r3,srxirq
010528 86 30 18 00 		cmp		r3,r1,#$0C
01052C BD 01 16 00 		beq		r3,stxirq
010530 86 30 20 00 		cmp		r3,r1,#$10
010534 BD 01 0C 00 		beq		r3,smsirq
                		; unknown IRQ type
                	sirq1:
010538 57 4F 10 00 		pop		r4
01053C 57 3F 10 00 		pop     r3
010540 57 2F 10 00 		pop     r2
010544 57 1F 10 00 		pop     r1
010548 02 E0 3F 6E 		rti
                	
                	; Get the modem status and record it
                	smsirq:
01054C 41 11 04 00 	    lbu     r1,UART_MS[r2]
010550 60 10 D8 02 		sb      r1,Uart_ms
010554 BA FC FF FF 		bra		sirq1
                	
                	stxirq:
010558 3A FC FF FF 		bra		sirq1
                	
                	; Get a character from the uart and store it in the rx fifo
                	srxirq:
                	srxirq1:
01055C 41 11 00 00 	    lbu     r1,UART_RX[r2]      ; get the char (clears interrupt)
010560 41 30 F8 02 	    lbu     r3,Uart_txxon
010564 BD 01 14 00 		beq		r3,srxirq3
010568 86 40 26 00 		cmp		r4,r1,#XOFF
01056C 3D 12 08 00 		bne		r4,srxirq2
010570 0A 10 02 00 		ldi     r1,#1
010574 60 10 DA 02 		sb		r1,Uart_txxonoff
010578 BA 05 00 00 		bra		srxirq5
                	srxirq2:
01057C 86 40 22 00 		cmp		r4,r1,#XON
010580 3D 12 06 00 		bne		r4,srxirq3
010584 60 00 DA 02 		sb		r0,Uart_txxonoff
010588 BA 03 00 00 		bra		srxirq5
                	srxirq3:
01058C 60 00 DA 02 		sb		r0,Uart_txxonoff
010590 43 40 DC 02 		lcu		r4,Uart_rxhead
010594 60 12 FA 02 		sb		r1,Uart_rxfifo[r4]  ; store in buffer
010598 14 42 02 00 		addui   r4,r4,#1
01059C 0C 42 FE 03 		and		r4,r4,#$1ff
0105A0 61 40 DC 02 		sc		r4,Uart_rxhead
                	srxirq5:
0105A4 40 11 02 00 	    lb      r1,UART_LS[r2]      ; check for another ready character
0105A8 8C 10 02 00 		and		r1,r1,#1            ; check rxfull bit
0105AC BD 10 D8 FF 		bne		r1,srxirq1          ; loop back for another character
0105B0 40 10 E4 02 		lb		r1,Uart_rxflow		; are we using flow controls?
0105B4 BD 10 2E 00 		bne		r1,srxirq8
0105B8 E7 EF 01 00 		push    lr
0105BC 39 CA FF FF 		bsr		CharsInRxBuf
0105C0 57 FF 11 00 		pop     lr
0105C4 40 10 EC 02 		lb		r1,Uart_foff
0105C8 02 12 02 0C 		cmp		r1,r4,r1
0105CC BD 40 22 00 		blt		r1,srxirq8
0105D0 0A 10 02 00 		ldi		r1,#1
0105D4 60 10 E4 02 		sb		r1,Uart_rxflow
0105D8 40 10 E6 02 		lb		r1,Uart_rxrts
0105DC BD 00 08 00 		beq		r1,srxirq6
0105E0 40 11 0C 00 		lb		r1,UART_MC[r2]
0105E4 8C 10 FA 01 		and		r1,r1,#$FD		; turn off RTS
0105E8 60 11 0C 00 		sb		r1,UART_MC[r2]
                	srxirq6:
0105EC 40 10 E8 02 		lb		r1,Uart_rxdtr
0105F0 BD 00 08 00 		beq		r1,srxirq7
0105F4 40 11 0C 00 		lb		r1,UART_MC[r2]
0105F8 8C 10 FC 01 		and		r1,r1,#$FE		; turn off DTR
0105FC 60 11 0C 00 		sb		r1,UART_MC[r2]
                	srxirq7:
010600 40 10 EA 02 		lb		r1,Uart_rxxon
010604 BD 00 06 00 		beq		r1,srxirq8
010608 0A 10 26 00 		ldi		r1,#XOFF
01060C 60 11 00 00 		sb		r1,UART_TX[r2]
                	srxirq8:
010610 3A E5 FF FF 		bra		sirq1
                	
                	
                	
                	;------------------------------------------------------------------------------
                	; Convert ASCII character to screen display character.
                	;------------------------------------------------------------------------------
                	
                	AsciiToScreen:
010614 67 E1 01 00 	    push    r2
010618 8C 10 FE 01 		and		r1,r1,#$FF
01061C 8D 10 00 02 		or		r1,r1,#$100
010620 8C 20 40 00 		and		r2,r1,#%00100000	; if bit 5 or 6 isn't set
010624 3D 01 08 00 		beq		r2,.00001
010628 8C 20 80 00 		and		r2,r1,#%01000000
01062C 3D 01 04 00 		beq		r2,.00001
010630 8C 10 3E 03 		and		r1,r1,#%110011111
                	.00001:
010634 57 2F 10 00 	    pop     r2
010638 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; Convert screen display character to ascii.
                	;------------------------------------------------------------------------------
                	
                	ScreenToAscii:
01063C 67 E1 01 00 	    push    r2
010640 8C 10 FE 01 		and		r1,r1,#$FF
010644 96 20 36 00 		cmpu	r2,r1,#26+1
010648 3D 31 04 00 		bge		r2,.stasc1
01064C 84 10 C0 00 		add		r1,r1,#$60
                	.stasc1:
010650 57 2F 10 00 	    pop     r2
010654 37 FF 01 00 		rtl

                	CursorOff:
010658 37 FF 01 00 		rtl
CursorOn:
01065C 37 FF 01 00 		rtl
HomeCursor:
010660 60 00 70 02 		sb		r0,CursorRow
010664 60 00 72 02 		sb		r0,CursorCol
010668 7C DA FF 00 		sc	    r0,TEXTREG+TEXT_CURPOS+$FFD00000
01066C 61 00 58 00 
010670 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	                                                                               
                	ClearScreen:
010674 E7 EF 01 00 	    push    lr
010678 E7 E0 01 00 	    push	r1
01067C 67 E1 01 00 	    push    r2
010680 E7 E1 01 00 	    push    r3
010684 67 E2 01 00 	    push    r4
010688 7C DA FF 00 		lbu	    r1,TEXTREG+TEXT_COLS+$FFD00000
01068C 41 10 00 00 
010690 7C DA FF 00 		lbu	    r2,TEXTREG+TEXT_ROWS+$FFD00000
010694 41 20 08 00 
010698 02 41 02 2E 		mulu	r4,r2,r1
01069C 7C D0 FF 00 		ldi		r3,#TEXTSCR+$FFD00000
0106A0 0A 30 00 00 
0106A4 0A 10 40 00 		ldi		r1,#' '
0106A8 B9 ED FF FF 		bsr		AsciiToScreen
0106AC 45 20 60 02 		lhu		r2,NormAttr
0106B0 82 10 04 1A 		or		r1,r1,r2
                	.cs1:
0106B4 EA 11 88 00 	    sh	    r1,[r3+r4*4]
0106B8 15 42 02 00 	    subui   r4,r4,#1
0106BC 3D 12 FC FF 		bne	    r4,.cs1
0106C0 57 4F 10 00 		pop     r4
0106C4 57 3F 10 00 		pop     r3
0106C8 57 2F 10 00 		pop     r2
0106CC 57 1F 10 00 		pop     r1
0106D0 3B FF 11 00 	    rts

                	;------------------------------------------------------------------------------
                	; Display the word in r1
                	;------------------------------------------------------------------------------
                	
                	DisplayWord:
0106D4 E7 EF 01 00 	    push    lr
0106D8 82 10 40 74 		rol	    r1,r1,#32
0106DC B9 01 00 00 		bsr		DisplayHalf
0106E0 82 10 40 74 		rol	    r1,r1,#32
0106E4 57 FF 11 00 	    pop     lr
                	
                	;------------------------------------------------------------------------------
                	; Display the half-word in r1
                	;------------------------------------------------------------------------------
                	
                	DisplayHalf:
0106E8 E7 EF 01 00 	    push    lr
0106EC 82 10 20 76 		ror		r1,r1,#16
0106F0 B9 01 00 00 		bsr		DisplayCharHex
0106F4 82 10 20 74 		rol		r1,r1,#16
0106F8 57 FF 11 00 	    pop     lr
                	
                	;------------------------------------------------------------------------------
                	; Display the char in r1
                	;------------------------------------------------------------------------------
                	
                	DisplayCharHex:
0106FC E7 EF 01 00 	    push    lr
010700 82 10 10 76 		ror		r1,r1,#8
010704 B9 01 00 00 		bsr		DisplayByte
010708 82 10 10 74 		rol		r1,r1,#8
01070C 57 FF 11 00 	    pop     lr
                	
                	;------------------------------------------------------------------------------
                	; Display the byte in r1
                	;------------------------------------------------------------------------------
                	
                	DisplayByte:
010710 E7 EF 01 00 	    push    lr
010714 82 10 08 76 		ror		r1,r1,#4
010718 B9 01 00 00 		bsr		DisplayNybble
01071C 82 10 08 74 		rol		r1,r1,#4
010720 57 FF 11 00 		pop     lr
                	 
                	;------------------------------------------------------------------------------
                	; Display nybble in r1
                	;------------------------------------------------------------------------------
                	
                	DisplayNybble:
010724 E7 EF 01 00 	    push    lr
010728 E7 E0 01 00 		push	r1
01072C 67 E1 01 00 		push    r2
010730 8C 10 1E 00 		and		r1,r1,#$0F
010734 94 10 60 00 		addui	r1,r1,#'0'
010738 96 20 74 00 		cmpu	r2,r1,#'9'+1
01073C 3D 41 04 00 		blt		r2,.0001
010740 94 10 0E 00 		addui	r1,r1,#7
                	.0001:
010744 B9 3C 01 00 		bsr		OutChar
010748 57 2F 10 00 		pop     r2
01074C 57 1F 10 00 		pop		r1
010750 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; Display a string pointer to string in r1.
                	;------------------------------------------------------------------------------
                	
                	DisplayString:
010754 E7 EF 01 00 	    push    lr
010758 E7 E0 01 00 		push	r1
01075C 67 E1 01 00 		push    r2
010760 82 20 00 1A 		mov		r2,r1
                	.dm2:
010764 41 11 00 00 		lbu		r1,[r2]
010768 14 21 02 00 		addui   r2,r2,#1	; increment text pointer
01076C BD 00 06 00 		beq		r1,.dm1
010770 39 37 01 00 		bsr		OutChar
010774 3A FE FF FF 		bra		.dm2
                	.dm1:
010778 57 2F 10 00 		pop		r2
01077C 57 1F 10 00 	    pop     r1
010780 3B FF 11 00 		rts

                	DisplayStringCRLF:
010784 E7 EF 01 00 	    push    lr
010788 B9 F9 FF FF 		bsr		DisplayString
01078C 3A 01 00 00 		bra     CRLF1
                	OutCRLF:
                	CRLF:
010790 E7 EF 01 00 	    push    lr
                	CRLF1:
010794 E7 E0 01 00 		push	r1
010798 0A 10 1A 00 		ldi		r1,#CR
01079C B9 31 01 00 		bsr		OutChar
0107A0 0A 10 14 00 		ldi		r1,#LF
0107A4 B9 30 01 00 		bsr		OutChar
0107A8 57 1F 10 00 		pop		r1
0107AC 3B FF 11 00 		rts

                	
                	DispCharQ:
0107B0 E7 EF 01 00 	    push    lr
0107B4 39 CC FF FF 		bsr		AsciiToScreen
0107B8 E1 11 00 00 		sc		r1,[r3]
0107BC 84 31 08 00 		add		r3,r3,#4
0107C0 3B FF 11 00 	    rts

                	DispStartMsg:
0107C4 E7 EF 01 00 	    push    lr
0107C8 7C 01 00 00 		ldi		r1,#msgStart
0107CC 0A 10 B2 1D 
0107D0 B9 F0 FF FF 		bsr		DisplayString
0107D4 3B FF 11 00 	    rts

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	KeybdIRQ:
0107D8 7C DC FF 00 		sb		r0,KEYBD+1
0107DC 60 00 02 00 
0107E0 02 E0 3F 6E 		rti
                	
                	BranchToSelf2:
0107E4 3A 00 00 00 	    bra      BranchToSelf2
                	
                	;------------------------------------------------------------------------------
                	; Display a space on the output device.
                	;------------------------------------------------------------------------------
                	
                	DisplaySpace:
0107E8 E7 EF 01 00 	    push     lr
0107EC E7 E0 01 00 	    push     r1
0107F0 0A 10 40 00 	    ldi      r1,#' '
0107F4 B9 26 01 00 	    bsr      OutChar
0107F8 57 1F 10 00 	    pop      r1
0107FC 3B FF 11 00 	    rts

                	;------------------------------------------------------------------------------
                	; 'PRTNUM' prints the 64 bit number in r1, leading blanks are added if
                	; needed to pad the number of spaces to the number in r2.
                	; However, if the number of digits is larger than the no. in
                	; r2, all digits are printed anyway. Negative sign is also
                	; printed and counted in, positive sign is not.
                	;
                	; r1 = number to print
                	; r2 = number of digits
                	; Register Usage
                	;	r5 = number of padding spaces
                	;------------------------------------------------------------------------------
                	PRTNUM:
010800 E7 EF 01 00 	    push    lr
010804 E7 E1 01 00 		push	r3
010808 E7 E2 01 00 		push	r5
01080C 67 E3 01 00 		push	r6
010810 E7 E3 01 00 		push	r7
010814 0A 70 88 02 		ldi		r7,#NUMWKA	; r7 = pointer to numeric work area
010818 82 60 00 1A 		mov		r6,r1		; save number for later
01081C 02 51 00 1A 		mov		r5,r2		; r5 = min number of chars
010820 BD 30 06 00 		bge		r1,PN2			; is it negative? if not
010824 02 10 02 2A 		subu	r1,r0,r1	; else make it positive
010828 95 52 02 00 		subui   r5,r5,#1	; one less for width count
                	PN2:
                	;	ldi		r3,#10
                	PN1:
01082C 89 20 14 00 		mod		r2,r1,#10	; r2 = r1 mod 10
010830 88 10 14 00 		div		r1,r1,#10	; r1 /= 10 divide by 10
010834 04 21 60 00 		add		r2,r2,#'0'	; convert remainder to ascii
010838 E0 23 00 00 		sb		r2,[r7]		; and store in buffer
01083C 94 73 02 00 		addui   r7,r7,#1
010840 95 52 02 00 		subui   r5,r5,#1	; decrement width
010844 BD 10 F4 FF 		bne		r1,PN1
                	PN6:
010848 BD 52 08 00 		ble		r5,PN4		; test pad count, skip padding if not needed
                	PN3:
01084C B9 F3 FF FF 		bsr     DisplaySpace	; display the required leading spaces
010850 95 52 02 00 		subui   r5,r5,#1
010854 BD 12 FC FF 		bne		r5,PN3
                	PN4:
010858 3D 33 06 00 		bge		r6,PN5		; is number negative?
01085C 0A 10 5A 00 		ldi		r1,#'-'		; if so, display the sign
010860 39 19 01 00 		bsr		OutChar
                	PN5:
010864 95 73 02 00 	    subui   r7,r7,#1
010868 C0 13 00 00 		lb		r1,[r7]		; now unstack the digits and display
01086C B9 17 01 00 		bsr		OutChar
010870 86 13 88 02 		cmp		r1,r7,#NUMWKA
010874 BD 20 F8 FF 		bgt		r1,PN5
                	PNRET:
010878 57 7F 10 00 		pop		r7
01087C 57 6F 10 00 		pop		r6
010880 57 5F 10 00 		pop		r5
010884 57 3F 10 00 		pop		r3
010888 3B FF 11 00 		rts

                	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	BIOSCall:
01088C 02 E0 01 6C 	    cpuid   sp,r0,#0
010890 3D 0F 18 00 	    beq     sp,.0005
010894 7C 02 00 00 	    ldi     sp,#CPU1_BIOS_STACK
010898 0A E0 01 30 
01089C 67 E5 01 00 	    push    r10
0108A0 E7 E5 01 00 	    push    r11
0108A4 67 E6 01 00 	    push    r12
0108A8 0A C0 02 00 	    ldi     r12,#1             ; remember the original affinity
                	.0002:
0108AC 61 0C 00 05 	    sc      r0,TCB_Affinity[tr]
                	    ; Now wait for an interrupt. After the task switch interrupt, CPU#0 is
                	    ; the one that would be returning here because of the affinity setting.
                	    ; The BIOS call can be completed then.
0108B0 02 00 06 6E 	    wai
                	
                	    ; Some other interrupt besides a task switch might have happened, so
                	    ; we check if the CPU switched.
0108B4 02 A0 00 6C 	    cpuid   r10,r0,#0
0108B8 3D 15 FA FF 	    bne     r10,.0002
0108BC BA 03 00 00 	    bra     .0006
                	.0005:
0108C0 7C 00 00 00 	    ldi     sp,#CPU0_BIOS_STACK
0108C4 0A E0 01 D0 
0108C8 67 E5 01 00 	    push    r10
0108CC E7 E5 01 00 	    push    r11
0108D0 67 E6 01 00 	    push    r12
0108D4 0A C0 00 00 	    ldi     r12,#0
                	.0006:
0108D8 02 A0 12 3E 	    mfspr   r10,epc             ;
0108DC 44 B5 08 00 	    lh      r11,4[r10]           ; get the function #
0108E0 14 A5 10 00 	    addui   r10,r10,#8
0108E4 02 05 12 3C 	    mtspr   epc,r10
0108E8 86 A5 C8 00 	    cmp     r10,r11,#MAX_BIOS_CALL
0108EC 3D 25 12 7C 	    bgt     r10,.0003
0108F0 82 B5 06 70 	    asl     r11,r11,#3
0108F4 E7 EF 01 00 	    push    lr
0108F8 7C 01 00 00 	    jsr     (BIOS_FuncTable[r11])
0108FC 3E F0 09 00 
010900 57 FF 11 00 	    pop     lr
                	.0004:
010904 61 CC 00 05 	    sc      r12,TCB_Affinity[tr]
010908 57 CF 10 00 	    pop     r12
01090C 57 BF 10 00 	    pop     r11
010910 57 AF 10 00 	    pop     r10
010914 02 E0 3D 6E 	    rte
                	.0003:
010918 0A 10 02 00 	    ldi     r1,#E_BadFuncno
01091C 3A FD FF FF 	    bra     .0004
                	
                	
                	;------------------------------------------------------------------------------
                	; 60 Hz interrupt routine.
                	; Both cpu's will execute this interrupt (necessary for multi-tasking).
                	; Only cpu#0 needs to reset the I/O hardware.
                	;------------------------------------------------------------------------------
                	
                	TickRout:
010920 02 E0 01 6C 	    cpuid   sp,r0,#0
010924 3D 0F 98 00 	    beq     sp,.acknowledgeInterrupt
                	    ; The stacks for the CPUs' must not overlap
010928 7C 02 00 00 	    ldi     sp,#CPU1_IRQ_STACK
01092C 0A E0 01 10 
                	.SaveContext:
                	    ; Do something here that takes a few cycles in order to allow cpu#0 to
                	    ; reset the PIC. Otherwise the IRQ line going high will cause a bounce back
                	    ; to here.
010930 63 1C 10 00 	    sw      r1,TCB_r1[tr]
010934 63 2C 20 00 	    sw      r2,TCB_r2[tr]
010938 63 3C 30 00 	    sw      r3,TCB_r3[tr]
01093C 63 4C 40 00 	    sw      r4,TCB_r4[tr]
010940 63 5C 50 00 	    sw      r5,TCB_r5[tr]
010944 63 6C 60 00 	    sw      r6,TCB_r6[tr]
010948 63 7C 70 00 	    sw      r7,TCB_r7[tr]
01094C 63 8C 80 00 	    sw      r8,TCB_r8[tr]
010950 63 9C 90 00 	    sw      r9,TCB_r9[tr]
010954 63 AC A0 00 	    sw      r10,TCB_r10[tr]
010958 63 BC B0 00 	    sw      r11,TCB_r11[tr]
01095C 63 CC C0 00 	    sw      r12,TCB_r12[tr]
010960 63 DC D0 00 	    sw      r13,TCB_r13[tr]
010964 63 EC E0 00 	    sw      r14,TCB_r14[tr]
010968 63 FC F0 00 	    sw      r15,TCB_r15[tr]
01096C 63 0C 01 01 	    sw      r16,TCB_r16[tr]
010970 63 1C 11 01 	    sw      r17,TCB_r17[tr]
010974 63 2C 21 01 	    sw      r18,TCB_r18[tr]
010978 63 3C 31 01 	    sw      r19,TCB_r19[tr]
01097C 63 4C 41 01 	    sw      r20,TCB_r20[tr]
010980 63 5C 51 01 	    sw      r21,TCB_r21[tr]
010984 63 6C 61 01 	    sw      r22,TCB_r22[tr]
010988 63 7C 71 01 	    sw      r23,TCB_r23[tr]
01098C 63 8C 81 01 	    sw      r24,TCB_r24[tr]
010990 63 9C 91 01 	    sw      r25,TCB_r25[tr]
010994 63 AC A1 01 	    sw      r26,TCB_r26[tr]
010998 63 BC B1 01 	    sw      r27,TCB_r27[tr]
01099C 63 CC C1 01 	    sw      r28,TCB_r28[tr]
0109A0 63 DC D1 01 	    sw      r29,TCB_r29[tr]
0109A4 02 10 1E 3E 	    mfspr   r1,isp
0109A8 63 1C E0 01 	    sw      r1,TCB_r30[tr]
0109AC 63 FC F1 01 	    sw      r31,TCB_r31[tr]
0109B0 02 10 10 3E 	    mfspr   r1,ipc
0109B4 63 1C 00 03 	    sw      r1,TCB_IPC[tr]
0109B8 46 1C 10 00 	    lw      r1,TCB_r1[tr]
                	
0109BC B9 27 00 00 	    bsr     SelectTaskToRun2
0109C0 82 80 01 1A 	    mov     tr,r1
                	
                	    ; Restore the context of the selected task
0109C4 46 1C 00 03 	    lw      r1,TCB_IPC[tr]
0109C8 82 00 10 3C 	    mtspr   ipc,r1
0109CC 46 FC F1 01 	    lw      r31,TCB_r31[tr]
0109D0 46 1C E0 01 	    lw      r1,TCB_r30[tr]
0109D4 82 00 1E 3C 	    mtspr   isp,r1
0109D8 46 DC D1 01 	    lw      r29,TCB_r29[tr]
0109DC 46 CC C1 01 	    lw      r28,TCB_r28[tr]
0109E0 46 BC B1 01 	    lw      r27,TCB_r27[tr]
0109E4 46 AC A1 01 	    lw      r26,TCB_r26[tr]
0109E8 46 9C 91 01 	    lw      r25,TCB_r25[tr]
                	;   lw      r24,TCB_r24[tr]    ; r24 is the task register - no need to load
0109EC 46 7C 71 01 	    lw      r23,TCB_r23[tr]
0109F0 46 6C 61 01 	    lw      r22,TCB_r22[tr]
0109F4 46 5C 51 01 	    lw      r21,TCB_r21[tr]
0109F8 46 4C 41 01 	    lw      r20,TCB_r20[tr]
0109FC 46 3C 31 01 	    lw      r19,TCB_r19[tr]
010A00 46 2C 21 01 	    lw      r18,TCB_r18[tr]
010A04 46 1C 11 01 	    lw      r17,TCB_r17[tr]
010A08 46 0C 01 01 	    lw      r16,TCB_r16[tr]
010A0C 46 FC F0 00 	    lw      r15,TCB_r15[tr]
010A10 46 EC E0 00 	    lw      r14,TCB_r14[tr]
010A14 46 DC D0 00 	    lw      r13,TCB_r13[tr]
010A18 46 CC C0 00 	    lw      r12,TCB_r12[tr]
010A1C 46 BC B0 00 	    lw      r11,TCB_r11[tr]
010A20 46 AC A0 00 	    lw      r10,TCB_r10[tr]
010A24 46 9C 90 00 	    lw      r9,TCB_r9[tr]
010A28 46 8C 80 00 	    lw      r8,TCB_r8[tr]
010A2C 46 7C 70 00 	    lw      r7,TCB_r7[tr]
010A30 46 6C 60 00 	    lw      r6,TCB_r6[tr]
010A34 46 5C 50 00 	    lw      r5,TCB_r5[tr]
010A38 46 4C 40 00 	    lw      r4,TCB_r4[tr]
010A3C 46 3C 30 00 	    lw      r3,TCB_r3[tr]
010A40 46 2C 20 00 	    lw      r2,TCB_r2[tr]
010A44 46 1C 10 00 	    lw      r1,TCB_r1[tr]
010A48 02 E0 3F 6E 	    rti
010A4C 3F 00 00 00 	    nop
010A50 3F 00 00 00 	    nop
                	    
                	.acknowledgeInterrupt:
010A54 FC 00 00 00 	    ldi     sp,#IRQ_STACK       ; set stack pointer to interrupt processing stack
010A58 0A E0 01 00 
010A5C E7 E0 01 00 	    push    r1
010A60 0A 10 06 00 		ldi		r1,#3				; reset the edge sense circuit
010A64 7C DC FF 00 		sh		r1,PIC_RSTE
010A68 62 10 A8 1F 
010A6C 7C D0 FF 00 		lh	    r1,TEXTSCR+220+$FFD00000
010A70 44 10 B8 01 
010A74 94 10 02 00 		addui	r1,r1,#1
010A78 7C D0 FF 00 		sh	    r1,TEXTSCR+220+$FFD00000
010A7C 62 10 B8 01 
010A80 7C 02 00 00 		lw      r1,$20000
010A84 46 10 00 00 
010A88 7C D0 FF 00 		sh      r1,TEXTSCR+224+$FFD00000
010A8C 62 10 C0 01 
010A90 57 1F 10 00 		pop     r1
010A94 BA D3 FF FF 		bra     .SaveContext
                	
                	UserTickRout:
010A98 E7 E0 01 00 	    push    r1
010A9C 7C D0 FF 00 		lh	    r1,TEXTSCR+220+$FFD00000
010AA0 44 10 B8 01 
010AA4 94 10 02 00 		addui	r1,r1,#1
010AA8 7C D0 FF 00 		sh	    r1,TEXTSCR+220+$FFD00000
010AAC 62 10 B8 01 
010AB0 7C 02 00 00 		lw      r1,$20000
010AB4 46 10 00 00 
010AB8 7C D0 FF 00 		sh      r1,TEXTSCR+224+$FFD00000
010ABC 62 10 C0 01 
010AC0 57 1F 10 00 		pop     r1
010AC4 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	; 1024Hz interupt routine. This must be fast. Allows the system time to be
                	; gotten by right shifting by 10 bits.
                	;------------------------------------------------------------------------------
                	
                	Tick1024Rout:
010AC8 02 E0 01 6C 	    cpuid   sp,r0,#0
010ACC 3D 0F 04 00 	    beq     sp,.0001
010AD0 02 E0 3F 6E 	    rti                         ; nothing for cpu >0 to do here
                	.0001:
010AD4 FC 00 00 00 	    ldi     sp,#$8000           ; set stack pointer to interrupt processing stack
010AD8 0A E0 01 00 
010ADC E7 E0 01 00 		push	r1
010AE0 0A 10 04 00 		ldi		r1,#2				; reset the edge sense circuit
010AE4 7C DC FF 00 		sh		r1,PIC_RSTE
010AE8 62 10 A8 1F 
010AEC 64 10 10 02 		inc     Milliseconds
010AF0 57 1F 10 00 		pop		r1
010AF4 02 E0 3F 6E 		rti                         ; restore stack pointer and return
                	
                	;------------------------------------------------------------------------------
                	; For now, just pick one at random.
                	;------------------------------------------------------------------------------
                	SelectTaskToRun2:
010AF8 02 1C 00 1A 	    mov     r1,tr             ; stay in the same task for now
010AFC 37 FF 01 00 	    rtl
    lw      r1,RANDOM_NUM
010B00 7C DC FF 00 
010B04 46 10 00 18 
010B08 02 20 00 6C 	    cpuid   r2,r0,#0
010B0C 3D 01 0E 00 	    beq     r2,.0001
010B10 8C 10 3E 00 	    and     r1,r1,#$1F
010B14 8D 10 02 00 	    or      r1,r1,#1         ; make sure it's an odd task for CPU1
010B18 82 10 20 70 	    asl     r1,r1,#16
010B1C 7C C0 00 00 	    addui   r1,r1,#$C00000
010B20 94 10 00 00 
010B24 37 FF 01 00 	    rtl    
.0001:
010B28 8C 10 3C 00 	    and     r1,r1,#$1E       ; make sure it's an even task for CPU0
010B2C 82 10 20 70 	    asl     r1,r1,#16
010B30 7C C0 00 00 	    addui   r1,r1,#$C00000
010B34 94 10 00 00 
010B38 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	; GetSystemTime
                	;
                	; Returns 
                	;    r1 = the system time in seconds.
                	;------------------------------------------------------------------------------
                	
                	GetSystemTime:
010B3C 46 10 10 02 	    lw      r1,Milliseconds
010B40 82 10 14 72 	    lsr     r1,r1,#10
010B44 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	GetScreenLocation:
010B48 7C D0 FF 00 		ldi		r1,#TEXTSCR+$FFD00000
010B4C 0A 10 00 00 
010B50 37 FF 01 00 		rtl
GetCurrAttr:
010B54 45 10 60 02 		lhu		r1,NormAttr
010B58 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	UpdateCursorPos:
010B5C E7 EF 01 00 	    push    lr
010B60 E7 E0 01 00 		push	r1
010B64 67 E1 01 00 		push    r2
010B68 67 E2 01 00 		push    r4
010B6C 41 10 70 02 		lbu		r1,CursorRow
010B70 8C 10 7E 00 		and		r1,r1,#$3f
010B74 7C DA FF 00 		lbu	    r2,TEXTREG+TEXT_COLS+$FFD00000
010B78 41 20 00 00 
010B7C 02 21 02 2E 		mulu	r2,r2,r1
010B80 41 10 72 02 		lbu		r1,CursorCol
010B84 8C 10 FE 00 		and		r1,r1,#$7f
010B88 02 21 02 28 		addu	r2,r2,r1
010B8C 7C DA FF 00 		sc	    r2,TEXTREG+TEXT_CURPOS+$FFD00000
010B90 61 20 58 00 
010B94 57 4F 10 00 		pop		r4
010B98 57 2F 10 00 	    pop     r2
010B9C 57 1F 10 00 	    pop     r1
010BA0 3B FF 11 00 	    rts
	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	CalcScreenLoc:
010BA4 E7 EF 01 00 	    push    lr
010BA8 67 E1 01 00 		push	r2
010BAC 67 E2 01 00 		push    r4
010BB0 41 10 70 02 		lbu		r1,CursorRow
010BB4 8C 10 7E 00 		and		r1,r1,#$3f
010BB8 7C DA FF 00 		lbu	    r2,TEXTREG+TEXT_COLS+$FFD00000
010BBC 41 20 00 00 
010BC0 02 21 02 2E 		mulu	r2,r2,r1
010BC4 41 10 72 02 		lbu		r1,CursorCol
010BC8 8C 10 FE 00 		and		r1,r1,#$7f
010BCC 02 21 02 28 		addu	r2,r2,r1
010BD0 7C DA FF 00 		sc	    r2,TEXTREG+TEXT_CURPOS+$FFD00000
010BD4 61 20 58 00 
010BD8 39 EE FF FF 		bsr		GetScreenLocation
010BDC 02 21 04 70 		shl		r2,r2,#2
010BE0 82 10 04 28 		addu	r1,r1,r2
010BE4 57 4F 10 00 		pop		r4
010BE8 57 2F 10 00 	    pop     r2
010BEC 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	DisplayChar:
010BF0 E7 EF 01 00 	    push    lr
010BF4 E7 E0 01 00 		push	r1
010BF8 67 E1 01 00 	    push    r2
010BFC E7 E1 01 00 	    push    r3
010C00 67 E2 01 00 	    push    r4
010C04 8C 10 FE 01 		and		r1,r1,#$FF
010C08 86 20 1A 00 		cmp		r2,r1,#'\r'
010C0C 3D 01 42 00 		beq		r2,.docr
010C10 86 20 22 01 		cmp		r2,r1,#$91		; cursor right ?
010C14 3D 01 44 00 		beq		r2,.doCursorRight
010C18 86 20 20 01 		cmp		r2,r1,#$90		; cursor up ?
010C1C 3D 01 4E 00 		beq		r2,.doCursorUp
010C20 86 20 26 01 		cmp		r2,r1,#$93		; cursor left ?
010C24 3D 01 54 00 		beq		r2,.doCursorLeft
010C28 86 20 24 01 		cmp		r2,r1,#$92		; cursor down ?
010C2C 3D 01 5A 00 		beq		r2,.doCursorDown
010C30 86 20 28 01 		cmp		r2,r1,#$94		; cursor home ?
010C34 3D 01 62 00 		beq		r2,.doCursorHome
010C38 86 20 32 01 		cmp		r2,r1,#$99		; delete ?
010C3C 3D 01 6A 00 		beq		r2,.doDelete
010C40 86 20 10 00 		cmp		r2,r1,#CTRLH	; backspace ?
010C44 3D 01 6E 00 		beq		r2,.doBackspace
010C48 86 20 14 00 		cmp		r2,r1,#'\n'	; line feed ?
010C4C 3D 01 92 00 		beq		r2,.doLinefeed
010C50 82 20 00 1A 		mov		r2,r1
010C54 39 EA FF FF 		bsr		CalcScreenLoc
010C58 82 30 00 1A 		mov		r3,r1
010C5C 02 11 00 1A 		mov		r1,r2
010C60 B9 36 FF FF 		bsr		AsciiToScreen
010C64 82 20 00 1A 		mov		r2,r1
010C68 B9 DD FF FF 		bsr		GetCurrAttr
010C6C 82 10 04 1A 		or		r1,r1,r2
010C70 E2 11 00 00 		sh	    r1,[r3]
010C74 B9 20 00 00 		bsr		IncCursorPos
                	.dcx4:
010C78 57 4F 10 00 		pop		r4
010C7C 57 3F 10 00 	    pop     r3
010C80 57 2F 10 00 	    pop     r2
010C84 57 1F 10 00 	    pop     r1
010C88 57 FF 11 00 	    pop     lr
010C8C 37 FF 01 00 		rtl
.docr:
010C90 60 00 72 02 		sb		r0,CursorCol
010C94 39 D9 FF FF 		bsr		UpdateCursorPos
010C98 3A FC FF FF 		bra     .dcx4
                	.doCursorRight:
010C9C 41 10 72 02 		lbu		r1,CursorCol
010CA0 84 10 02 00 		add		r1,r1,#1
010CA4 96 20 A8 00 		cmpu	r2,r1,#TXTCOLS
010CA8 3D 31 04 00 		bge		r2,.dcx7
010CAC 60 10 72 02 		sb		r1,CursorCol
                	.dcx7:
010CB0 B9 D5 FF FF 		bsr		UpdateCursorPos
010CB4 BA F8 FF FF 		bra     .dcx4
                	.doCursorUp:
010CB8 41 10 70 02 		lbu		r1,CursorRow
010CBC BD 00 FA FF 		beq		r1,.dcx7
010CC0 85 10 02 00 		sub		r1,r1,#1
010CC4 60 10 70 02 		sb		r1,CursorRow
010CC8 3A FD FF FF 		bra		.dcx7
                	.doCursorLeft:
010CCC 41 10 72 02 		lbu		r1,CursorCol
010CD0 BD 00 F0 FF 		beq		r1,.dcx7
010CD4 85 10 02 00 		sub		r1,r1,#1
010CD8 60 10 72 02 		sb		r1,CursorCol
010CDC BA FA FF FF 		bra		.dcx7
                	.doCursorDown:
010CE0 41 10 70 02 		lbu		r1,CursorRow
010CE4 84 10 02 00 		add		r1,r1,#1
010CE8 96 20 3E 00 		cmpu	r2,r1,#TXTROWS
010CEC 3D 31 E2 FF 		bge		r2,.dcx7
010CF0 60 10 70 02 		sb		r1,CursorRow
010CF4 BA F7 FF FF 		bra		.dcx7
                	.doCursorHome:
010CF8 41 10 72 02 		lbu		r1,CursorCol
010CFC BD 00 06 00 		beq		r1,.dcx12
010D00 60 00 72 02 		sb		r0,CursorCol
010D04 BA F5 FF FF 		bra		.dcx7
                	.dcx12:
010D08 60 00 70 02 		sb		r0,CursorRow
010D0C BA F4 FF FF 		bra		.dcx7
                	.doDelete:
010D10 B9 D2 FF FF 		bsr		CalcScreenLoc
010D14 82 30 00 1A 		mov		r3,r1
010D18 41 10 72 02 		lbu		r1,CursorCol
010D1C 3A 04 00 00 		bra		.dcx5
                	.doBackspace:
010D20 41 10 72 02 		lbu		r1,CursorCol
010D24 BD 00 AA FF 		beq		r1,.dcx4
010D28 85 10 02 00 		sub		r1,r1,#1
010D2C 60 10 72 02 		sb		r1,CursorCol
010D30 B9 CE FF FF 		bsr		CalcScreenLoc
010D34 82 30 00 1A 		mov		r3,r1
010D38 41 10 72 02 		lbu		r1,CursorCol
                	.dcx5:
010D3C C5 21 08 00 		lhu	    r2,4[r3]
010D40 E2 21 00 00 		sh	    r2,[r3]
010D44 84 31 08 00 		add		r3,r3,#4
010D48 84 10 02 00 		add		r1,r1,#1
010D4C 96 20 A8 00 		cmpu	r2,r1,#TXTCOLS
010D50 3D 41 F6 FF 		blt		r2,.dcx5
010D54 0A 10 40 00 		ldi		r1,#' '
010D58 B9 17 FF FF 		bsr		AsciiToScreen
010D5C 45 20 60 02 		lhu		r2,NormAttr
010D60 82 10 04 1A 		or		r1,r1,r2
010D64 85 31 08 00 		sub		r3,r3,#4
010D68 E2 11 00 00 		sh	    r1,[r3]
010D6C BA E1 FF FF 		bra		.dcx4
                	.doLinefeed:
010D70 B9 06 00 00 		bsr		IncCursorRow
010D74 BA E0 FF FF 		bra		.dcx4
                	
                	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	IncCursorPos:
010D78 E7 EF 01 00 	    push    lr
010D7C E7 E0 01 00 		push	r1
010D80 67 E1 01 00 	    push    r2
010D84 67 E2 01 00 	    push    r4
010D88 41 10 72 02 		lbu		r1,CursorCol
010D8C 94 10 02 00 		addui	r1,r1,#1
010D90 60 10 72 02 		sb		r1,CursorCol
010D94 96 20 A8 00 		cmpu	r2,r1,#TXTCOLS
010D98 3D 41 1E 00 		blt		r2,icc1
010D9C 60 00 72 02 		sb		r0,CursorCol
010DA0 BA 02 00 00 		bra		icr1
                	IncCursorRow:
010DA4 E7 EF 01 00 	    push    lr
010DA8 E7 E0 01 00 		push	r1
010DAC 67 E1 01 00 	    push    r2
010DB0 67 E2 01 00 	    push    r4
                	icr1:
010DB4 41 10 70 02 		lbu		r1,CursorRow
010DB8 94 10 02 00 		addui	r1,r1,#1
010DBC 60 10 70 02 		sb		r1,CursorRow
010DC0 96 20 3E 00 		cmpu	r2,r1,#TXTROWS
010DC4 3D 41 08 00 		blt		r2,icc1
010DC8 0A 20 3C 00 		ldi		r2,#TXTROWS-1
010DCC 60 20 70 02 		sb		r2,CursorRow
010DD0 B9 04 00 00 		bsr		ScrollUp
                	icc1:
010DD4 3F 00 00 00 	    nop
010DD8 3F 00 00 00 	    nop
010DDC 39 B0 FF FF 		bsr		UpdateCursorPos
010DE0 57 4F 10 00 		pop		r4
010DE4 57 2F 10 00 	    pop     r2
010DE8 57 1F 10 00 	    pop     r1
010DEC 57 FF 11 00 		pop     lr
010DF0 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	ScrollUp:
010DF4 E7 EF 01 00 	    push    lr
010DF8 E7 E0 01 00 		push	r1
010DFC 67 E1 01 00 	    push    r2
010E00 E7 E1 01 00 	    push    r3
010E04 E7 E2 01 00 	    push    r5
010E08 67 E3 01 00 		push	r6
010E0C 7C DA FF 00 		lbu	    r1,TEXTREG+TEXT_COLS+$FFD00000
010E10 41 10 00 00 
010E14 7C DA FF 00 		lbu	    r2,TEXTREG+TEXT_ROWS+$FFD00000
010E18 41 20 08 00 
010E1C 15 21 02 00 		subui	r2,r2,#1
010E20 82 60 04 2E 		mulu	r6,r1,r2
010E24 7C D0 FF 00 		ldi		r1,#TEXTSCR+$FFD00000
010E28 0A 10 00 00 
010E2C 7C D0 FF 00 		ldi		r2,#TEXTSCR+TXTCOLS*4+$FFD00000
010E30 0A 20 A0 02 
010E34 0A 30 00 00 		ldi		r3,#0
                	.0001:
010E38 4C 51 86 00 		lh	    r5,[r2+r3*4]
010E3C EA 50 86 00 		sh	    r5,[r1+r3*4]
010E40 94 31 02 00 		addui	r3,r3,#1
010E44 15 63 02 00 		subui   r6,r6,#1
010E48 3D 13 F8 FF 		bne	    r6,.0001
010E4C 7C DA FF 00 		lbu	    r1,TEXTREG+TEXT_ROWS+$FFD00000
010E50 41 10 08 00 
010E54 95 10 02 00 		subui	r1,r1,#1
010E58 39 04 00 00 		bsr		BlankLine
010E5C 57 6F 10 00 		pop		r6
010E60 57 5F 10 00 		pop		r5
010E64 57 3F 10 00 	    pop     r3
010E68 57 2F 10 00 	    pop     r2
010E6C 57 1F 10 00 	    pop     r1
010E70 57 FF 11 00 		pop     lr
010E74 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; Blank out a line on the screen.
                	;
                	; Parameters:
                	;	r1 = line number to blank out
                	;------------------------------------------------------------------------------
                	
                	BlankLine:
010E78 E7 EF 01 00 	    push    lr
010E7C E7 E0 01 00 		push	r1
010E80 67 E1 01 00 	    push    r2
010E84 E7 E1 01 00 	    push    r3
010E88 67 E2 01 00 	    push    r4
010E8C 7C DA FF 00 	    lbu     r2,TEXTREG+TEXT_COLS+$FFD00000
010E90 41 20 00 00 
010E94 02 31 02 2E 		mulu	r3,r2,r1
                	;	subui	r2,r2,#1		; r2 = #chars to blank - 1
010E98 82 31 04 70 		shl		r3,r3,#2
010E9C 7C D0 FF 00 		addui	r3,r3,#TEXTSCR+$FFD00000
010EA0 94 31 00 00 
010EA4 0A 10 40 00 		ldi		r1,#' '
010EA8 B9 ED FE FF 		bsr		AsciiToScreen
010EAC 45 40 60 02 		lhu		r4,NormAttr
010EB0 82 10 08 1A 		or		r1,r1,r4
                	.0001:
010EB4 EA 11 84 00 		sh	    r1,[r3+r2*4]
010EB8 15 21 02 00 		subui   r2,r2,#1
010EBC 3D 11 FC FF 		bne	    r2,.0001
010EC0 57 4F 10 00 		pop		r4
010EC4 57 3F 10 00 	    pop     r3
010EC8 57 2F 10 00 	    pop     r2
010ECC 57 1F 10 00 	    pop     r1
010ED0 57 FF 11 00 		pop     lr
010ED4 37 FF 01 00 		rtl

010ED8 00          		db	0
                	msgStart:
010ED9 46 49 53 41 		db	"FISA64 test system starting.",0
010EDD 36 34 20 74 
010EE1 65 73 74 20 
010EE5 73 79 73 74 
010EE9 65 6D 20 73 
010EED 74 61 72 74 
010EF1 69 6E 67 2E 
010EF5 00          
                	
                	
                	; ============================================================================
                	; Monitor Task
                	; ============================================================================
                	
                	Monitor:
010EF6 00 00 0A 10 		ldi		r1,#49
010EFA 62 00       
010EFC 7C DC FF 00 		sc		r1,LEDS
010F00 61 10 00 0C 
                	;	bsr		ClearScreen
                	;	bsr		HomeCursor
010F04 7C 01 00 00 		ldi		r1,#msgMonitorStarted
010F08 0A 10 C2 2A 
010F0C 39 0F FF FF 		bsr		DisplayStringCRLF
010F10 60 00 78 02 		sb		r0,KeybdEcho
                		;ldi		r1,#7
                		;ldi		r2,#0
                		;ldi		r3,#IdleTask
                		;ldi		r4,#0
                		;ldi		r5,#0
                		;bsr		StartTask
                	mon1:
010F14 0A 10 64 00 		ldi		r1,#50
010F18 7C DC FF 00 		sc		r1,LEDS
010F1C 61 10 00 0C 
                	;	ldi		sp,#TCBs+TCB_Size-8		; reload the stack pointer, it may have been trashed
010F20 7C 00 00 00 		ldi		sp,#MON_STACK
010F24 0A E0 01 C0 
010F28 02 00 00 6E 		cli
                	.PromptLn:
010F2C B9 0C FF FF 		bsr		CRLF
010F30 0A 10 48 00 		ldi		r1,#'$'
010F34 B9 3E 00 00 		bsr		OutChar
                	.Prompt3:
010F38 B9 13 01 00 		bsr		KeybdGetCharNoWait		; KeybdGetCharDirectNB
010F3C BD 40 FE FF 		blt	    r1,.Prompt3
010F40 86 20 1A 00 		cmp		r2,r1,#CR
010F44 3D 01 06 00 		beq		r2,.Prompt1
010F48 39 3C 00 00 		bsr		OutChar
010F4C BA FD FF FF 		bra		.Prompt3
                	.Prompt1:
010F50 60 00 72 02 		sb		r0,CursorCol
010F54 39 8A FF FF 		bsr		CalcScreenLoc
010F58 82 30 00 1A 		mov		r3,r1
010F5C B9 10 00 00 		bsr		MonGetch
010F60 86 20 48 00 		cmp		r2,r1,#'$'
010F64 3D 11 04 00 		bne		r2,.Prompt2
010F68 39 0F 00 00 		bsr		MonGetch
                	.Prompt2:
010F6C 86 20 7E 00 		cmp		r2,r1,#'?'
010F70 3D 01 30 00 		beq		r2,.doHelp
010F74 86 20 86 00 		cmp		r2,r1,#'C'
010F78 3D 01 FC 02 		beq		r2,doCLS
010F7C 86 20 C6 00 		cmp     r2,r1,#'c'
010F80 3D 01 EE 78 		beq     r2,doCS
010F84 86 20 9A 00 		cmp		r2,r1,#'M'
010F88 3D 01 68 00 		beq		r2,doDumpmem
010F8C 86 20 8C 00 		cmp		r2,r1,#'F'
010F90 3D 01 78 00 		beq		r2,doFillmem
010F94 86 20 DA 00 		cmp		r2,r1,#'m'
010F98 3D 01 E4 78 		beq		r2,MRTest
010F9C 86 20 A6 00 		cmp		r2,r1,#'S'
010FA0 3D 01 B2 00 		beq		r2,doSDBoot
010FA4 86 20 CE 00 		cmp		r2,r1,#'g'
010FA8 3D 01 DC 78 		beq		r2,doRand
010FAC 86 20 CA 00 		cmp		r2,r1,#'e'
010FB0 3D 01 D8 78 		beq		r2,eval
010FB4 86 20 94 00 		cmp		r2,r1,#'J'
010FB8 3D 01 BA 00 		beq		r2,doJump
010FBC 86 20 88 00 		cmp		r2,r1,#'D'
010FC0 3D 01 3C 01 		beq		r2,doDate
010FC4 86 20 A8 00 		cmp     r2,r1,#'T'
010FC8 3D 01 58 00 		beq     r2,doDumpTL
010FCC 3A E9 FF FF 		bra     mon1
                	
                	.doHelp:
010FD0 7C 01 00 00 		ldi		r1,#msgHelp
010FD4 0A 10 88 29 
010FD8 B9 EF FE FF 		bsr		DisplayString
010FDC 3A E7 FF FF 		bra     mon1
                	
                	MonGetch:
010FE0 E7 EF 01 00 	    push    lr
010FE4 C5 11 00 00 		lhu	    r1,[r3]
010FE8 8C 10 FE 03 		andi	r1,r1,#$1FF
010FEC 84 31 08 00 		add		r3,r3,#4
010FF0 B9 C9 FE FF 		bsr		ScreenToAscii
010FF4 57 FF 11 00 		pop     lr
010FF8 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; Ignore blanks in the input
                	; r3 = text pointer
                	; r1 destroyed
                	;------------------------------------------------------------------------------
                	
                	ignBlanks:
010FFC E7 EF 01 00 	    push    lr
011000 67 E1 01 00 	    push    r2
                	ignBlanks1:
011004 B9 FB FF FF 		bsr		MonGetch
011008 86 20 40 00 		cmp		r2,r1,#' '
01100C 3D 01 FC FF 		beq		r2,ignBlanks1
011010 85 31 08 00 		sub		r3,r3,#4
011014 57 2F 10 00 		pop     r2
011018 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	GetTwoParams:
01101C E7 EF 01 00 	    push    lr
011020 B9 FB FF FF 		bsr		ignBlanks
011024 B9 7B 00 00 		bsr		GetHexNumber	; get start address of dump
011028 82 20 00 1A 		mov		r2,r1
01102C 39 FA FF FF 		bsr		ignBlanks
011030 39 7A 00 00 		bsr		GetHexNumber	; get end address of dump
011034 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; Get a range, the end must be greater or equal to the start.
                	;------------------------------------------------------------------------------
                	
                	GetRange:
011038 E7 EF 01 00 	    push    lr
01103C 67 E2 01 00 	    push    r4
011040 B9 FB FF FF 		bsr		GetTwoParams
011044 02 41 02 2C 		cmpu	r4,r2,r1
011048 3D 22 32 02 		bgt		r4,DisplayErr
01104C 57 4F 10 00 		pop     r4
011050 57 FF 11 00 		pop     lr
011054 37 FF 01 00 		rtl

                	doDumpmem:
011058 39 C0 FE FF 		bsr		CursorOff
01105C B9 FB FF FF 		bsr		GetRange
011060 39 E6 FE FF 		bsr		CRLF
                	;	bra     mon1
                	.001:
011064 39 65 00 00 		bsr		CheckKeys
011068 B9 4C 00 00 		bsr		DisplayMemBytes
01106C 02 41 02 2C 		cmpu	r4,r2,r1
011070 3D 52 FA FF 		ble		r4,.001
011074 3A D4 FF FF 		bra     mon1
                	
                	doDumpTL:
011078 39 DE 06 00 	    bsr     DumpTaskList
01107C 3A D3 FF FF 	    bra     mon1
                	
                	;------------------------------------------------------------------------------
                	; Fill memory
                	;
                	; FB FFD80000 FFD8FFFF r	; fill sprite memory with random bytes
                	;------------------------------------------------------------------------------
                	
                	doFillmem:
011080 39 BB FE FF 		bsr		CursorOff
011084 B9 EB FF FF 		bsr		MonGetch		; skip over 'B' of "FB"
011088 86 20 84 00 		cmp		r2,r1,#'B'
01108C 3D 01 04 00 		beq		r2,.0004
011090 95 31 08 00 		subui	r3,r3,#4		; backup text pointer
                	.0004:
011094 B9 F4 FF FF 		bsr		GetRange
011098 E7 E0 01 00 		push	r1
01109C 67 E1 01 00 	    push    r2
0110A0 B9 EB FF FF 		bsr		ignBlanks
0110A4 B9 E7 FF FF 		bsr		MonGetch		; check for random fill
0110A8 86 20 E4 00 		cmp		r2,r1,#'r'
0110AC 3D 01 18 00 		beq		r2,.0001
0110B0 95 31 08 00 		subui   r3,r3,#4
0110B4 B9 69 00 00 		bsr		GetHexNumber
0110B8 82 30 00 1A 		mov		r3,r1
0110BC 57 2F 10 00 		pop		r2
0110C0 57 1F 10 00 	    pop     r1
                	.0002:
0110C4 39 59 00 00 		bsr		CheckKeys
0110C8 60 31 00 00 		sb		r3,[r2]
0110CC 14 21 02 00 		addui	r2,r2,#1
0110D0 02 51 02 2C 		cmpu	r5,r2,r1
0110D4 BD 42 F8 FF 		blt		r5,.0002
0110D8 BA C7 FF FF 		bra		mon1
                	.0001:
0110DC 57 2F 10 00 		pop		r2
0110E0 57 1F 10 00 	    pop     r1
                	.0003:
0110E4 39 55 00 00 		bsr		CheckKeys
0110E8 7C DC FF 00 		lw	    r3,RANDOM_NUM
0110EC 46 30 00 18 
0110F0 60 31 00 00 		sb		r3,[r2]
0110F4 14 21 02 00 		addui	r2,r2,#1
0110F8 02 51 02 2C 		cmpu	r5,r2,r1
0110FC BD 42 F4 FF 		blt		r5,.0003
011100 BA C2 FF FF 		bra		mon1
                	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	doSDBoot:
                	;	sub		r3,r3,#4
011104 B9 F1 DD FF 		bsr		SDInit
011108 BD 10 06 FF 		bne	    r1,mon1
01110C 39 F1 DD FF 		bsr		SDReadPart
011110 BD 10 02 FF 		bne	    r1,mon1
011114 39 0C DE FF 		bsr		SDReadBoot
011118 BD 10 FE FE 		bne	    r1,mon1
01111C 39 0B DE FF 		bsr		loadBootFile
011120 7C 00 00 00 		jmp		mon1
011124 3C 00 8A 87 
                	
                	OutChar:
011128 3E 00 20 02 	    jmp     (OutputVec)
                	
                	;------------------------------------------------------------------------------
                	; Jump to subroutine
                	;
                	; J 10000     ; restart system
                	;------------------------------------------------------------------------------
                	
                	doJump:
01112C B9 D6 FF FF 		bsr		MonGetch		; skip over 'S'
011130 B9 D9 FF FF 		bsr		ignBlanks
011134 B9 59 00 00 		bsr		GetHexNumber
011138 63 10 40 02 		sw      r1,jmp_vector
01113C 46 F0 01 02 	    lw      r31,MON_r31
011140 46 E0 F1 01 	    lw      r30,MON_r30
011144 46 D0 E1 01 	    lw      r29,MON_r29
011148 46 C0 D1 01 	    lw      r28,MON_r28
01114C 46 B0 C1 01 	    lw      r27,MON_r27
011150 46 A0 B1 01 	    lw      r26,MON_r26
011154 46 90 A1 01 	    lw      r25,MON_r25
                	;   lw      r24,MON_r24    ; r24 is the task register - no need to load
011158 46 70 81 01 	    lw      r23,MON_r23
01115C 46 60 71 01 	    lw      r22,MON_r22
011160 46 50 61 01 	    lw      r21,MON_r21
011164 46 40 51 01 	    lw      r20,MON_r20
011168 46 30 41 01 	    lw      r19,MON_r19
01116C 46 20 31 01 	    lw      r18,MON_r18
011170 46 10 21 01 	    lw      r17,MON_r17
011174 46 00 11 01 	    lw      r16,MON_r16
011178 46 F0 00 01 	    lw      r15,MON_r15
01117C 46 E0 F0 00 	    lw      r14,MON_r14
011180 46 D0 E0 00 	    lw      r13,MON_r13
011184 46 C0 D0 00 	    lw      r12,MON_r12
011188 46 B0 C0 00 	    lw      r11,MON_r11
01118C 46 A0 B0 00 	    lw      r10,MON_r10
011190 46 90 A0 00 	    lw      r9,MON_r9
011194 46 80 90 00 	    lw      r8,MON_r8
011198 46 70 80 00 	    lw      r7,MON_r7
01119C 46 60 70 00 	    lw      r6,MON_r6
0111A0 46 50 60 00 	    lw      r5,MON_r5
0111A4 46 40 50 00 	    lw      r4,MON_r4
0111A8 46 30 40 00 	    lw      r3,MON_r3
0111AC 46 20 30 00 	    lw      r2,MON_r2
0111B0 46 10 20 00 	    lw      r1,MON_r1
0111B4 3E F0 41 02 	    jsr		(jmp_vector)
0111B8 63 10 20 00 	    sw      r1,MON_r1
0111BC 63 20 30 00 	    sw      r2,MON_r2
0111C0 63 30 40 00 	    sw      r3,MON_r3
0111C4 63 40 50 00 	    sw      r4,MON_r4
0111C8 63 50 60 00 	    sw      r5,MON_r5
0111CC 63 60 70 00 	    sw      r6,MON_r6
0111D0 63 70 80 00 	    sw      r7,MON_r7
0111D4 63 80 90 00 	    sw      r8,MON_r8
0111D8 63 90 A0 00 	    sw      r9,MON_r9
0111DC 63 A0 B0 00 	    sw      r10,MON_r10
0111E0 63 B0 C0 00 	    sw      r11,MON_r11
0111E4 63 C0 D0 00 	    sw      r12,MON_r12
0111E8 63 D0 E0 00 	    sw      r13,MON_r13
0111EC 63 E0 F0 00 	    sw      r14,MON_r14
0111F0 63 F0 00 01 	    sw      r15,MON_r15
0111F4 63 00 11 01 	    sw      r16,MON_r16
0111F8 63 10 21 01 	    sw      r17,MON_r17
0111FC 63 20 31 01 	    sw      r18,MON_r18
011200 63 30 41 01 	    sw      r19,MON_r19
011204 63 40 51 01 	    sw      r20,MON_r20
011208 63 50 61 01 	    sw      r21,MON_r21
01120C 63 60 71 01 	    sw      r22,MON_r22
011210 63 70 81 01 	    sw      r23,MON_r23
011214 63 80 91 01 	    sw      r24,MON_r24
011218 63 90 A1 01 	    sw      r25,MON_r25
01121C 63 A0 B1 01 	    sw      r26,MON_r26
011220 63 B0 C1 01 	    sw      r27,MON_r27
011224 63 C0 D1 01 	    sw      r28,MON_r28
011228 63 D0 E1 01 	    sw      r29,MON_r29
01122C 63 E0 F1 01 	    sw      r30,MON_r30
011230 63 F0 01 02 	    sw      r31,MON_r31
011234 3A 9C FF FF 		bra		mon1
                	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	doDate:
011238 39 B5 FF FF 		bsr		MonGetch		; skip over 'T'
01123C 86 50 82 00 		cmp		r5,r1,#'A'		; look for DAY
011240 BD 02 38 00 		beq		r5,doDay
011244 39 B7 FF FF 		bsr		ignBlanks
011248 39 B3 FF FF 		bsr		MonGetch
01124C 86 50 7E 00 		cmp		r5,r1,#'?'
011250 BD 02 14 00 		beq		r5,.0001
011254 95 31 08 00 		subui	r3,r3,#4
011258 39 35 00 00 		bsr		GetHexNumber
01125C 60 10 AA 07 		sb		r1,RTCC_BUF+5	; update month
011260 39 34 00 00 		bsr		GetHexNumber
011264 60 10 A8 07 		sb		r1,RTCC_BUF+4	; update day
011268 39 33 00 00 		bsr		GetHexNumber
01126C 60 10 AC 07 		sb		r1,RTCC_BUF+6	; update year
011270 39 9F 01 00 		bsr		RTCCWritebuf
011274 3A 94 FF FF 		bra		mon1
                	.0001:
011278 39 99 01 00 		bsr		RTCCReadbuf
01127C B9 A2 FE FF 		bsr		CRLF
011280 41 10 AA 07 		lbu		r1,RTCC_BUF+5
011284 B9 91 FE FF 		bsr		DisplayByte
011288 0A 10 5E 00 		ldi		r1,#'/'
01128C B9 D3 FF FF 		bsr		OutChar
011290 41 10 A8 07 		lbu		r1,RTCC_BUF+4
011294 B9 8F FE FF 		bsr		DisplayByte
011298 0A 10 5E 00 		ldi		r1,#'/'
01129C B9 D1 FF FF 		bsr		OutChar
0112A0 41 10 AC 07 		lbu		r1,RTCC_BUF+6
0112A4 B9 8D FE FF 		bsr		DisplayByte
0112A8 39 9D FE FF 		bsr		CRLF
0112AC 3A 8D FF FF 		bra		mon1
                	
                	doDay:
0112B0 B9 A9 FF FF 		bsr		ignBlanks
0112B4 B9 29 00 00 		bsr		GetHexNumber
0112B8 82 30 00 1A 		mov		r3,r1			; value to write
0112BC 0A 10 DE 00 		ldi		r1,#$6F			; device $6F
0112C0 0A 20 06 00 		ldi		r2,#$03			; register 3
0112C4 B9 7D 01 00 		bsr		I2C_WRITE
0112C8 BA 89 FF FF 		bra		mon1
                	
                	;------------------------------------------------------------------------------
                	; Display memory pointed to by r2.
                	; destroys r1,r3
                	;------------------------------------------------------------------------------
                	;
                	DisplayMemBytes:
0112CC E7 EF 01 00 	    push    lr
0112D0 E7 E0 01 00 		push	r1
0112D4 E7 E1 01 00 	    push    r3
0112D8 67 E2 01 00 	    push    r4
0112DC 0A 10 7C 00 		ldi		r1,#'>'
0112E0 39 C9 FF FF 		bsr		OutChar
0112E4 0A 10 84 00 		ldi		r1,#'B'
0112E8 39 C8 FF FF 		bsr		OutChar
0112EC 0A 10 40 00 		ldi		r1,#' '
0112F0 39 C7 FF FF 		bsr		OutChar
0112F4 02 11 00 1A 		mov		r1,r2
0112F8 39 7E FE FF 		bsr		DisplayHalf
0112FC 0A 30 10 00 		ldi		r3,#8
                	.001:
011300 0A 10 40 00 		ldi		r1,#' '
011304 B9 C4 FF FF 		bsr		OutChar
011308 41 11 00 00 		lbu		r1,[r2]
01130C B9 80 FE FF 		bsr		DisplayByte
011310 14 21 02 00 		addui	r2,r2,#1
011314 95 31 02 00 		subui   r3,r3,#1
011318 BD 11 F4 FF 		bne	    r3,.001
01131C 0A 10 74 00 		ldi		r1,#':'
011320 39 C1 FF FF 		bsr		OutChar
011324 7C 70 0D 00 		ldi		r1,#%110101110_000000100_0000000000	; reverse video
011328 0A 10 00 20 
01132C 62 10 60 02 		sh		r1,NormAttr
011330 0A 30 10 00 		ldi		r3,#8
011334 15 21 10 00 		subui	r2,r2,#8
                	.002
011338 41 11 00 00 		lbu		r1,[r2]
01133C 96 40 34 00 		cmpu	r4,r1,#26				; convert control characters to '.'
011340 3D 32 06 00 		bge		r4,.004
011344 0A 10 5C 00 		ldi		r1,#'.'
011348 3A 02 00 00 		bra     .003
                	.004:
01134C 96 40 00 01 		cmpu	r4,r1,#$80				; convert other non-ascii to '.'
011350 3D 42 04 00 		blt		r4,.003
011354 0A 10 5C 00 		ldi		r1,#'.'
                	.003:
011358 39 BA FF FF 		bsr		OutChar
01135C 14 21 02 00 		addui	r2,r2,#1
011360 95 31 02 00 		subui   r3,r3,#1
011364 BD 11 EA FF 		bne	    r3,.002
011368 FC 26 00 00 		ldi		r1,#%000000100_110101110_0000000000	; normal video
01136C 0A 10 00 70 
011370 62 10 60 02 		sh		r1,NormAttr
011374 B9 83 FE FF 		bsr		CRLF
011378 57 4F 10 00 		pop     r4
01137C 57 3F 10 00 		pop		r3
011380 57 1F 10 00 	    pop     r1
011384 57 FF 11 00 	    pop     lr
011388 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; CheckKeys:
                	;	Checks for a CTRLC or a scroll lock during long running dumps.
                	;------------------------------------------------------------------------------
                	
                	CheckKeys:
01138C E7 EF 01 00 	    push    lr
011390 39 02 00 00 		bsr	    CTRLCCheck
011394 B9 07 00 00 		bsr     CheckScrollLock
011398 57 FF 11 00 		pop     lr
01139C 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; CTRLCCheck
                	;	Checks to see if CTRL-C is pressed. If so then the current routine is
                	; aborted and control is returned to the monitor.
                	;------------------------------------------------------------------------------
                	
                	CTRLCCheck:
0113A0 E7 EF 01 00 	    push    lr
0113A4 E7 E0 01 00 		push	r1
0113A8 67 E1 01 00 		push    r2
0113AC 39 85 00 00 		bsr		KeybdGetCharNoWait
0113B0 86 20 06 00 		cmp		r2,r1,#CTRLC
0113B4 3D 01 0A 00 		beq		r2,.0001
0113B8 57 2F 10 00 		pop     r2
0113BC 57 1F 10 00 		pop		r1
0113C0 57 FF 11 00 		pop     lr
0113C4 37 FF 01 00 		rtl
.0001:
0113C8 14 EF 31 00 		addui	sp,sp,#24
0113CC 3A 69 FF FF 		bra     mon1
                	
                	;------------------------------------------------------------------------------
                	; CheckScrollLock:
                	;	Check for a scroll lock by the user. If scroll lock is active then tasks
                	; are rescheduled while the scroll lock state is tested in a loop.
                	;------------------------------------------------------------------------------
                	
                	CheckScrollLock:
0113D0 E7 EF 01 00 	    push    lr
0113D4 E7 E0 01 00 		push	r1
0113D8 67 E1 01 00 		push    r2
                	.0002:
0113DC 43 10 7C 02 		lcu		r1,KeybdLocks
0113E0 7C 00 00 00 		and		r2,r1,#$4000		; is scroll lock active ?
0113E4 8C 20 00 80 
0113E8 3D 01 04 00 		beq		r2,.0001
                	;	brk		#2*16				; reschedule tasks
0113EC 3A FE FF FF 		bra     .0002
                	.0001:
0113F0 57 2F 10 00 	    pop     r2
0113F4 57 1F 10 00 		pop		r1
0113F8 57 FF 11 00 		pop     lr
0113FC 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; Get a hexidecimal number. Maximum of eight digits.
                	; R3 = text pointer (updated)
                	; R1 = hex number
                	;------------------------------------------------------------------------------
                	;
                	GetHexNumber:
011400 E7 EF 01 00 	    push    lr
011404 67 E1 01 00 		push	r2
011408 67 E2 01 00 	    push    r4
01140C 0A 20 00 00 		ldi		r2,#0
011410 0A 40 20 00 		ldi		r4,#16
                	.gthxn2:
011414 B9 79 FF FF 		bsr		MonGetch
011418 39 05 00 00 		bsr		AsciiToHexNybble
01141C BD 40 0A 00 		bmi		r1,.gthxn1
011420 02 21 08 70 		asl		r2,r2,#4
011424 02 21 02 1A 		or		r2,r2,r1
011428 15 42 02 00 		subui   r4,r4,#1
01142C 3D 12 F4 FF 	    bne	    r4,.gthxn2
                	.gthxn1:
011430 02 11 00 1A 		mov		r1,r2
011434 57 4F 10 00 		pop		r4
011438 57 2F 10 00 	    pop     r2
01143C 3B FF 11 00 	    rts

                	;------------------------------------------------------------------------------
                	; Convert ASCII character in the range '0' to '9', 'a' to 'f' or 'A' to 'F'
                	; to a hex nybble.
                	;------------------------------------------------------------------------------
                	;
                	AsciiToHexNybble:
011440 67 E1 01 00 	    push    r2
011444 96 20 60 00 		cmpu	r2,r1,#'0'
011448 3D 41 2C 00 		blt		r2,.gthx3
01144C 96 20 74 00 		cmpu	r2,r1,#'9'+1
011450 3D 31 08 00 		bge		r2,.gthx5
011454 95 10 60 00 		subui	r1,r1,#'0'
011458 57 2F 10 00 		pop     r2
01145C 37 FF 01 00 		rtl
.gthx5:
011460 96 20 82 00 		cmpu	r2,r1,#'A'
011464 3D 41 1E 00 		blt		r2,.gthx3
011468 96 20 8E 00 		cmpu	r2,r1,#'F'+1
01146C 3D 31 0A 00 		bge		r2,.gthx6
011470 95 10 82 00 		subui	r1,r1,#'A'
011474 94 10 14 00 		addui	r1,r1,#10
011478 57 2F 10 00 		pop     r2
01147C 37 FF 01 00 		rtl
.gthx6:
011480 96 20 C2 00 		cmpu	r2,r1,#'a'
011484 3D 41 0E 00 		blt		r2,.gthx3
011488 96 20 F6 00 		cmpu	r2,r1,#'z'+1
01148C 3D 31 0A 00 		bge		r2,.gthx3
011490 95 10 C2 00 		subui	r1,r1,#'a'
011494 94 10 14 00 		addui	r1,r1,#10
011498 57 2F 10 00 		pop     r2
01149C 37 FF 01 00 		rtl
.gthx3:
0114A0 57 2F 10 00 	    pop     r2
0114A4 0A 10 FE FF 		ldi		r1,#-1		; not a hex number
0114A8 37 FF 01 00 		rtl

                	DisplayErr:
0114AC 7C 01 00 00 		ldi		r1,#msgErr
0114B0 0A 10 78 29 
0114B4 39 54 FE FF 		bsr		DisplayString
0114B8 BA 4B FF FF 		bra mon1
                	
                	msgErr:
0114BC 2A 2A 45 72 		db	"**Err",CR,LF,0
0114C0 72 0D 0A 00 
                	
                	msgHelp:
0114C4 3F 20 3D 20 		db		"? = Display Help",CR,LF
0114C8 44 69 73 70 
0114CC 6C 61 79 20 
0114D0 48 65 6C 70 
0114D4 0D 0A       
0114D6 43 4C 53 20 		db		"CLS = clear screen",CR,LF
0114DA 3D 20 63 6C 
0114DE 65 61 72 20 
0114E2 73 63 72 65 
0114E6 65 6E 0D 0A 
0114EA 44 54 20 3D 		db		"DT = set/read date",CR,LF
0114EE 20 73 65 74 
0114F2 2F 72 65 61 
0114F6 64 20 64 61 
0114FA 74 65 0D 0A 
0114FE 46 42 20 3D 		db		"FB = fill memory",CR,LF
011502 20 66 69 6C 
011506 6C 20 6D 65 
01150A 6D 6F 72 79 
01150E 0D 0A       
011510 4D 42 20 3D 		db		"MB = dump memory",CR,LF
011514 20 64 75 6D 
011518 70 20 6D 65 
01151C 6D 6F 72 79 
011520 0D 0A       
011522 4A 53 20 3D 		db		"JS = jump to code",CR,LF
011526 20 6A 75 6D 
01152A 70 20 74 6F 
01152E 20 63 6F 64 
011532 65 0D 0A    
011535 54 20 3D 20 		db	    "T = Dump task list",CR,LF
011539 44 75 6D 70 
01153D 20 74 61 73 
011541 6B 20 6C 69 
011545 73 74 0D 0A 
011549 53 20 3D 20 		db		"S = boot from SD card",CR,LF
01154D 62 6F 6F 74 
011551 20 66 72 6F 
011555 6D 20 53 44 
011559 20 63 61 72 
01155D 64 0D 0A    
011560 00          		db		0
                	
                	msgMonitorStarted
011561 4D 6F 6E 69 		db		"Monitor started.",0
011565 74 6F 72 20 
011569 73 74 61 72 
01156D 74 65 64 2E 
011571 00          
                	
                	doCLS:
011572 00 00 39 20 		bsr		ClearScreen
011576 FE FF       
011578 39 1D FE FF 		bsr		HomeCursor
01157C 3A 33 FF FF 		bra     mon1
                	
                	;------------------------------------------------------------------------------
                	; Get a random number from peripheral device.
                	;------------------------------------------------------------------------------
                	
                	GetRandomNumber:
011580 7C DC FF 00 	    lw      r1,$FFDC0C00
011584 46 10 00 18 
011588 37 FF 01 00 	    rtl
                
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	; Keyboard processing routines follow.
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	KEYBD_DELAY		EQU		1000
                	
                	KeybdGetCharDirectNB:
01158C E7 EF 01 00 	    push    lr
011590 67 E1 01 00 		push	r2
011594 02 00 02 6E 		sei
011598 7C DC FF 00 		lcu		r1,KEYBD
01159C 43 10 00 00 
0115A0 FC 00 00 00 		and		r2,r1,#$8000
0115A4 8C 20 00 00 
0115A8 3D 01 22 00 		beq		r2,.0001
0115AC 7C DC FF 00 		lbu		r0,KEYBD+4		; clear keyboard strobe
0115B0 41 00 08 00 
0115B4 02 00 00 6E 		cli
0115B8 8C 20 00 10 		and		r2,r1,#$800	; is it keydown ?
0115BC 3D 11 18 00 		bne	    r2,.0001
0115C0 8C 10 FE 01 		and		r1,r1,#$FF
0115C4 41 20 78 02 		lbu		r2,KeybdEcho
0115C8 3D 01 0C 00 		beq		r2,.0002
0115CC 86 20 1A 00 		cmp		r2,r1,#CR
0115D0 3D 11 06 00 		bne		r2,.0003
0115D4 B9 37 FE FF 		bsr		CRLF
0115D8 3A 01 00 00 		bra     .0002
                	.0003:
0115DC 3E F0 21 02 		jsr		(OutputVec)
                	.0002:
0115E0 57 2F 10 00 		pop		r2
0115E4 57 FF 11 00 		pop     lr
0115E8 37 FF 01 00 		rtl
.0001:
0115EC 02 00 00 6E 		cli
0115F0 0A 10 FE FF 		ldi		r1,#-1
0115F4 57 2F 10 00 		pop		r2
0115F8 57 FF 11 00 		pop     lr
0115FC 37 FF 01 00 		rtl

                	KeybdGetCharDirect:
011600 E7 EF 01 00 	    push    lr
011604 67 E1 01 00 		push	r2
                	.0001:
011608 7C DC FF 00 		lc		r1,KEYBD
01160C 42 10 00 00 
011610 FC 00 00 00 		and		r2,r1,#$8000
011614 8C 20 00 00 
011618 3D 01 F8 FF 		beq		r2,.0001
01161C 7C DC FF 00 		lbu		r0,KEYBD+4		; clear keyboard strobe
011620 41 00 08 00 
011624 8C 20 00 10 		and		r2,r1,#$800	; is it keydown ?
011628 3D 11 F0 FF 		bne	    r2,.0001
01162C 8C 10 FE 01 		and		r1,r1,#$FF
011630 41 20 78 02 		lbu		r2,KeybdEcho
011634 3D 01 0C 00 		beq		r2,.gk1
011638 86 20 1A 00 		cmp		r2,r1,#CR
01163C 3D 11 06 00 		bne		r2,.gk2
011640 39 2A FE FF 		bsr		CRLF
011644 3A 01 00 00 		bra     .gk1
                	.gk2:
011648 3E F0 21 02 		jsr		(OutputVec)
                	.gk1:
01164C 57 2F 10 00 		pop		r2
011650 57 FF 11 00 		pop     lr
011654 37 FF 01 00 		rtl

                	;KeybdInit:
                	;	mfspr	r1,cr0		; turn off tmr mode
                	;	push	r1
                	;	mtspr	cr0,r0
                	;	ldi		r1,#33
                	;	sb		r1,LEDS
                	;	bsr		WaitForKeybdAck	; grab a byte from the keyboard
                	;	cmp		flg0,r1,#$AA	; did it send a ack ?
                	;	
                	;	ldi		r1,#$ff			; issue keyboard reset
                	;	bsr		SendByteToKeybd
                	;	ldi		r1,#38
                	;	sb		r1,LEDS
                	;	ldi		r1,#4
                	;	jsr		Sleep
                	;	ldi		r1,#KEYBD_DELAY	; delay a bit
                	kbdi5:
                	;	sub		r1,r1,#1
                	;	brnz	r1,kbdi5
                	;	ldi		r1,#34
                	;	sb		r1,LEDS
                	;	ldi		r1,#0xf0		; send scan code select
                	;	bsr		SendByteToKeybd
                	;	ldi		r1,#35
                	;	sb		r1,LEDS
                	;	ldi		r2,#0xFA
                	;	bsr		WaitForKeybdAck
                	;	cmp		fl0,r1,#$FA
                	;	bne		fl0,kbdi2
                	;	ldi		r1,#36
                	;	sb		r1,LEDS
                	;	ldi		r1,#2			; select scan code set#2
                	;	bsr		SendByteToKeybd
                	;	ldi		r1,#39
                	;	sb		r1,LEDS
                	;kbdi2:
                	;	ldi		r1,#45
                	;	sb		r1,LEDS
                	;	pop		r1				; turn back on tmr mode
                	;	mtspr	cr0,r1
                	;	rtl
                	
                	msgBadKeybd:
011658 4B 65 79 62 		db		"Keyboard not responding.",0
01165C 6F 61 72 64 
011660 20 6E 6F 74 
011664 20 72 65 73 
011668 70 6F 6E 64 
01166C 69 6E 67 2E 
011670 00          
                	
                	;SendByteToKeybd:
                	;	push	r2
                	;	sb		r1,KEYBD
                	;	ldi		r1,#40
                	;	sb		r1,LEDS
                	;	mfspr	r3,tick
                	;kbdi4:						; wait for transmit complete
                	;	mfspr	r4,tick
                	;	sub		r4,r4,r3
                	;	cmp		fl0,r4,#KEYBD_DELAY
                	;	bhi		fl0,kbdbad
                	;	ldi		r1,#41
                	;	sb		r1,LEDS
                	;	lbu		r1,KEYBD+1
                	;	and		fl0,r1,#64
                	;	brz		fl0,kbdi4
                	;	bra 	sbtk1
                	;kbdbad:
                	;	ldi		r1,#42
                	;	sb		r1,LEDS
                	;	lbu		r1,KeybdBad
                	;	brnz	r1,sbtk2
                	;	ldi		r1,#1
                	;	sb		r1,KeybdBad
                	;	ldi		r1,#43
                	;	sb		r1,LEDS
                	;	ldi		r1,#msgBadKeybd
                	;	bsr		DisplayStringCRLF
                	;sbtk1:
                	;	ldi		r1,#44
                	;	sb		r1,LEDS
                	;	pop		r2
                	;	rtl
                	;sbtk2:
                	;	bra sbtk1
                	
                	; Wait for keyboard to respond with an ACK (FA)
                	;
                	;WaitForKeybdAck:
                	;	ldi		r1,#64
                	;	sb		r1,LEDS
                	;	mfspr	r3,tick
                	;wkbdack1:
                	;	mfspr	r4,tick
                	;	sub		r4,r4,r3
                	;	cmp		fl0,r4,#KEYBD_DELAY
                	;	bhi		fl0,wkbdbad
                	;	ldi		r1,#65
                	;	sb		r1,LEDS
                	;	lb		r1,KEYBD+1				; check keyboard status for key
                	;	brpl	r1,wkbdack1				; no key available, go back
                	;	lbu		r1,KEYBD				; get the scan code
                	;	sb		r0,KEYBD+1				; clear recieve register
                	;wkbdbad:
                	;	rtl
                	
                	KeybdInit:
011671 00 00 00 E7 	    push    lr
011675 EF 01 00    
011678 0A 30 0A 00 		ldi		r3,#5
                	.0001:
01167C 39 19 00 00 		bsr		KeybdRecvByte	; Look for $AA
011680 BD 40 06 00 		bmi		r1,.0002
011684 86 20 54 01 		cmp		r2,r1,#$AA		;
011688 3D 01 20 00 		beq		r2,.config
                	.0002:
01168C B9 82 00 00 		bsr		Wait10ms
011690 0A 10 FE FF 		ldi		r1,#-1			; send reset code to keyboard
011694 7C DC FF 00 		sb		r1,KEYBD+1		; write to status reg to clear TX state
011698 60 10 02 00 
01169C B9 80 00 00 		bsr		Wait10ms
0116A0 0A 10 FE 01 		ldi		r1,#$FF
0116A4 39 7E 00 00 		bsr		KeybdSendByte	; now write to transmit register
0116A8 B9 1B 00 00 		bsr		KeybdWaitTx		; wait until no longer busy
0116AC 39 13 00 00 		bsr		KeybdRecvByte	; look for an ACK ($FA)
0116B0 86 20 F4 01 		cmp		r2,r1,#$FA
0116B4 39 12 00 00 		bsr		KeybdRecvByte
0116B8 86 20 F8 01 		cmp		r2,r1,#$FC		; reset error ?
0116BC 3D 01 1A 00 		beq		r2,.tryAgain
0116C0 86 20 54 01 		cmp		r2,r1,#$AA		; reset complete okay ?
0116C4 3D 11 16 00 		bne		r2,.tryAgain
                	.config:
0116C8 0A 10 E0 01 		ldi		r1,#$F0			; send scan code select
0116CC 7C DC FF 00 		sc		r1,LEDS
0116D0 61 10 00 0C 
0116D4 39 78 00 00 		bsr		KeybdSendByte
0116D8 B9 15 00 00 		bsr		KeybdWaitTx
0116DC BD 40 0A 00 		bmi		r1,.tryAgain
0116E0 B9 0C 00 00 		bsr		KeybdRecvByte	; wait for response from keyboard
0116E4 BD 40 06 00 		bmi		r1,.tryAgain
0116E8 86 20 F4 01 		cmp		r2,r1,#$FA
0116EC 3D 01 10 00 		beq		r2,.0004
                	.tryAgain:
0116F0 95 31 02 00 	    subui   r3,r3,#1
0116F4 BD 11 C4 FF 		bne	    r3,.0001
                	.keybdErr:
0116F8 7C 01 00 00 		ldi		r1,#msgBadKeybd
0116FC 0A 10 B0 2C 
011700 B9 0A FE FF 		bsr		DisplayString
011704 57 FF 11 00 		pop     lr
011708 37 FF 01 00 		rtl
.0004:
01170C 0A 10 04 00 		ldi		r1,#2			; select scan code set #2
011710 B9 70 00 00 		bsr		KeybdSendByte
011714 39 0E 00 00 		bsr		KeybdWaitTx
011718 BD 40 EC FF 		bmi		r1,.tryAgain
01171C 57 FF 11 00 		pop     lr
011720 37 FF 01 00 		rtl

                	; Get the keyboard status
                	;
                	KeybdGetStatus:
011724 7C DC FF 00 		lb		r1,KEYBD+1
011728 40 10 02 00 
01172C 37 FF 01 00 		rtl

                	; Get the scancode from the keyboard port
                	;
                	KeybdGetScancode:
011730 7C DC FF 00 		lbu		r1,KEYBD				; get the scan code
011734 41 10 00 00 
011738 7C DC FF 00 		sb		r0,KEYBD+1				; clear receive register
01173C 60 00 02 00 
011740 37 FF 01 00 		rtl

                	; Recieve a byte from the keyboard, used after a command is sent to the
                	; keyboard in order to wait for a response.
                	;
                	KeybdRecvByte:
011744 E7 EF 01 00 	    push    lr
011748 E7 E1 01 00 		push	r3
01174C 0A 30 C8 00 		ldi		r3,#100			; wait up to 1s
                	.0003:
011750 B9 FA FF FF 		bsr		KeybdGetStatus	; wait for response from keyboard
011754 BD 40 10 00 		bmi		r1,.0004		; is input buffer full ? yes, branch
011758 39 69 00 00 		bsr		Wait10ms		; wait a bit
01175C 95 31 02 00 		subui   r3,r3,#1
011760 BD 11 F8 FF 		bne     r3,.0003		; go back and try again
011764 57 3F 10 00 		pop		r3				; timeout
011768 0A 10 FE FF 		ldi		r1,#-1			; return -1
01176C 57 FF 11 00 		pop     lr
011770 37 FF 01 00 		rtl
.0004:
011774 B9 F7 FF FF 		bsr		KeybdGetScancode
011778 57 3F 10 00 		pop		r3
01177C 57 FF 11 00 		pop     lr
011780 37 FF 01 00 		rtl

                	
                	; Wait until the keyboard transmit is complete
                	; Returns .CF = 1 if successful, .CF=0 timeout
                	;
                	KeybdWaitTx:
011784 E7 EF 01 00 	    push    lr
011788 67 E1 01 00 		push	r2
01178C E7 E1 01 00 	    push    r3
011790 0A 30 C8 00 		ldi		r3,#100			; wait a max of 1s
                	.0001:
011794 39 F2 FF FF 		bsr		KeybdGetStatus
011798 8C 10 80 00 		and		r1,r1,#$40		; check for transmit complete bit
01179C BD 10 12 00 		bne	    r1,.0002		; branch if bit set
0117A0 39 60 00 00 		bsr		Wait10ms		; delay a little bit
0117A4 95 31 02 00 		subui   r3,r3,#1
0117A8 BD 11 F6 FF 		bne	    r3,.0001		; go back and try again
0117AC 57 3F 10 00 		pop		r3
0117B0 57 2F 10 00 	    pop     r2			    ; timed out
0117B4 0A 10 FE FF 		ldi		r1,#-1			; return -1
0117B8 57 FF 11 00 		pop     lr
0117BC 37 FF 01 00 		rtl
.0002:
0117C0 57 3F 10 00 		pop		r3
0117C4 57 2F 10 00 	    pop     r2			    ; wait complete, return 
0117C8 0A 10 00 00 		ldi		r1,#0			; return 0
0117CC 57 FF 11 00 		pop     lr
0117D0 37 FF 01 00 		rtl

                	KeybdGetCharNoWait:
0117D4 60 00 84 02 		sb		r0,KeybdWaitFlag
0117D8 BA 01 00 00 		bra		KeybdGetChar
                	
                	KeybdGetCharWait:
0117DC 0A 10 FE FF 		ldi		r1,#-1
0117E0 60 10 84 02 		sb		r1,KeybdWaitFlag
                	
                	;
                	; Keystate2
                	; 876543210
                	; ||||||||+ = alt
                	; |||||||+- =
                	; ||||||+-- = control
                	; |||||+--- = numlock
                	; ||||+---- = capslock
                	; |||+----- = scrolllock
                	; ||+------ =
                	; |+------- = 
                	; +-------- = extended
                	;
                	KeybdGetChar:
0117E4 E7 EF 01 00 	    push    lr
0117E8 67 E1 01 00 		push	r2
0117EC E7 E1 01 00 	    push    r3
                	.0003:
0117F0 B9 E6 FF FF 		bsr		KeybdGetStatus			; check keyboard status for key available
0117F4 BD 40 10 00 		bmi		r1,.0006				; yes, go process
0117F8 40 10 84 02 		lb		r1,KeybdWaitFlag		; are we willing to wait for a key ?
0117FC BD 40 FA FF 		bmi		r1,.0003				; yes, branch back
011800 0A 10 FE FF 		ldi		r1,#-1					; flag no char available
011804 57 3F 10 00 		pop		r3
011808 57 2F 10 00 	    pop     r2
01180C 57 FF 11 00 	    pop     lr
011810 37 FF 01 00 		rtl
.0006:
011814 B9 E3 FF FF 		bsr		KeybdGetScancode
                	.0001:
011818 0A 20 02 00 		ldi		r2,#1
01181C 7C DC FF 00 		sb		r2,LEDS
011820 60 20 00 0C 
011824 86 20 E0 01 		cmp		r2,r1,#SC_KEYUP
011828 3D 01 70 00 		beq		r2,.doKeyup
01182C 86 20 C0 01 		cmp		r2,r1,#SC_EXTEND
011830 3D 01 72 00 		beq		r2,.doExtend
011834 86 20 28 00 		cmp		r2,r1,#$14				; code for CTRL
011838 3D 01 76 00 		beq		r2,.doCtrl
01183C 86 20 24 00 		cmp		r2,r1,#$12				; code for left shift
011840 3D 01 B4 00 		beq		r2,.doShift
011844 86 20 B2 00 		cmp		r2,r1,#$59				; code for right-shift
011848 3D 01 B0 00 		beq		r2,.doShift
01184C 86 20 EE 00 		cmp		r2,r1,#SC_NUMLOCK
011850 3D 01 C2 00 		beq		r2,.doNumLock
011854 86 20 B0 00 		cmp		r2,r1,#SC_CAPSLOCK
011858 3D 01 C8 00 		beq		r2,.doCapsLock
01185C 86 20 FC 00 		cmp		r2,r1,#SC_SCROLLLOCK
011860 3D 01 CE 00 		beq		r2,.doScrollLock
011864 86 20 22 00 		cmp     r2,r1,#SC_ALT
011868 3D 01 74 00 		beq     r2,.doAlt
01186C 40 20 80 02 		lb		r2,KeyState1			; check key up/down
011870 60 00 80 02 		sb		r0,KeyState1			; clear keyup status
011874 3D 11 BE FF 		bne	    r2,.0003				; ignore key up
011878 86 20 1A 00 		cmp     r2,r1,#SC_TAB
01187C 3D 01 82 00 		beq     r2,.doTab
                	.0013:
011880 40 20 82 02 		lb		r2,KeyState2
011884 0C 31 00 01 		and		r3,r2,#$80				; is it extended code ?
011888 BD 01 0E 00 		beq		r3,.0010
01188C 0C 31 FE 00 		and		r3,r2,#$7f				; clear extended bit
011890 60 30 82 02 		sb		r3,KeyState2
011894 60 00 80 02 		sb		r0,KeyState1			; clear keyup
011898 7C 01 00 00 		lbu		r1,keybdExtendedCodes[r1]
01189C C1 10 A0 3A 
0118A0 BA 09 00 00 		bra		.0008
                	.0010:
0118A4 40 20 82 02 		lb		r2,KeyState2
0118A8 0C 31 08 00 		and		r3,r2,#$04				; is it CTRL code ?
0118AC BD 01 0A 00 		beq		r3,.0009
0118B0 8C 10 FE 00 		and		r1,r1,#$7F
0118B4 7C 01 00 00 		lbu		r1,keybdControlCodes[r1]
0118B8 C1 10 A0 39 
0118BC 3A 06 00 00 		bra		.0008
                	.0009:
0118C0 40 20 82 02 		lb		r2,KeyState2
0118C4 0C 31 02 00 		and		r3,r2,#$01				; is it shift down ?
0118C8 BD 01 08 00 		beq  	r3,.0007
0118CC 7C 01 00 00 		lbu		r1,shiftedScanCodes[r1]
0118D0 C1 10 A0 37 
0118D4 3A 03 00 00 		bra		.0008
                	.0007:
0118D8 7C 01 00 00 		lbu		r1,unshiftedScanCodes[r1]
0118DC C1 10 A0 35 
0118E0 0A 20 04 00 		ldi		r2,#2
0118E4 7C DC FF 00 		sb		r2,LEDS
0118E8 60 20 00 0C 
                	.0008:
0118EC 0A 20 06 00 		ldi		r2,#3
0118F0 7C DC FF 00 		sb		r2,LEDS
0118F4 60 20 00 0C 
0118F8 57 3F 10 00 		pop		r3
0118FC 57 2F 10 00 	    pop     r2
011900 57 FF 11 00 	    pop     lr
011904 37 FF 01 00 		rtl
.doKeyup:
011908 0A 10 FE FF 		ldi		r1,#-1
01190C 60 10 80 02 		sb		r1,KeyState1
011910 3A DC FF FF 		bra		.0003
                	.doExtend:
011914 41 10 82 02 		lbu		r1,KeyState2
011918 8D 10 00 01 		or		r1,r1,#$80
01191C 60 10 82 02 		sb		r1,KeyState2
011920 3A DA FF FF 		bra		.0003
                	.doCtrl:
011924 40 10 80 02 		lb		r1,KeyState1
011928 60 00 80 02 		sb		r0,KeyState1
01192C BD 30 0A 00 		bpl		r1,.0004
011930 40 10 82 02 		lb		r1,KeyState2
011934 8C 10 F6 FF 		and		r1,r1,#-5
011938 60 10 82 02 		sb		r1,KeyState2
01193C BA D6 FF FF 		bra		.0003
                	.0004:
011940 40 10 82 02 		lb		r1,KeyState2
011944 8D 10 08 00 		or		r1,r1,#4
011948 60 10 82 02 		sb		r1,KeyState2
01194C BA D4 FF FF 		bra		.0003
                	.doAlt:
011950 40 10 80 02 		lb		r1,KeyState1
011954 60 00 80 02 		sb		r0,KeyState1
011958 BD 30 0C 00 		bpl		r1,.0011
01195C 40 10 82 02 	    lb      r1,KeyState2
011960 40 10 82 02 		lb		r1,KeyState2
011964 8C 10 FC FF 		and		r1,r1,#-2
011968 60 10 82 02 		sb		r1,KeyState2
01196C BA D0 FF FF 		bra		.0003
                	.0011:
011970 40 10 82 02 		lb		r1,KeyState2
011974 8D 10 02 00 		or		r1,r1,#1
011978 60 10 82 02 		sb		r1,KeyState2
01197C BA CE FF FF 		bra		.0003
                	.doTab:
011980 E7 E0 01 00 	    push    r1
011984 40 10 82 02 	    lb      r1,KeyState2
011988 8C 10 02 00 	    and     r1,r1,#1                 ; is ALT down ?
01198C BD 00 0A 00 	    beq     r1,.0012
011990 7C C0 00 00 	    inc     iof_switch
011994 64 10 F0 01 
011998 57 1F 10 00 	    pop     r1
01199C BA CA FF FF 	    bra     .0003
                	.0012:
0119A0 57 1F 10 00 	    pop     r1
0119A4 BA DB FF FF 	    bra     .0013
                	.doShift:
0119A8 40 10 80 02 		lb		r1,KeyState1
0119AC 60 00 80 02 		sb		r0,KeyState1
0119B0 BD 30 0A 00 		bpl		r1,.0005
0119B4 40 10 82 02 		lb		r1,KeyState2
0119B8 8C 10 FC FF 		and		r1,r1,#-2
0119BC 60 10 82 02 		sb		r1,KeyState2
0119C0 3A C6 FF FF 		bra		.0003
                	.0005:
0119C4 40 10 82 02 		lb		r1,KeyState2
0119C8 8D 10 02 00 		or		r1,r1,#1
0119CC 60 10 82 02 		sb		r1,KeyState2
0119D0 3A C4 FF FF 		bra		.0003
                	.doNumLock:
0119D4 40 10 82 02 		lb		r1,KeyState2
0119D8 8E 10 20 00 		eor		r1,r1,#16
0119DC 60 10 82 02 		sb		r1,KeyState2
0119E0 39 06 00 00 		bsr		KeybdSetLEDStatus
0119E4 BA C1 FF FF 		bra		.0003
                	.doCapsLock:
0119E8 40 10 82 02 		lb		r1,KeyState2
0119EC 8E 10 40 00 		eor		r1,r1,#32
0119F0 60 10 82 02 		sb		r1,KeyState2
0119F4 B9 03 00 00 		bsr		KeybdSetLEDStatus
0119F8 3A BF FF FF 		bra		.0003
                	.doScrollLock:
0119FC 40 10 82 02 		lb		r1,KeyState2
011A00 8E 10 80 00 		eor		r1,r1,#64
011A04 60 10 82 02 		sb		r1,KeyState2
011A08 39 01 00 00 		bsr		KeybdSetLEDStatus
011A0C BA BC FF FF 		bra		.0003
                	
                	KeybdSetLEDStatus:
011A10 E7 EF 01 00 	    push    lr
011A14 67 E1 01 00 		push	r2
011A18 E7 E1 01 00 	    push    r3
011A1C 60 00 86 02 		sb		r0,KeybdLEDs
011A20 40 10 82 02 		lb		r1,KeyState2
011A24 8C 20 20 00 		and		r2,r1,#16
011A28 3D 01 06 00 		beq		r2,.0002
011A2C 0A 30 04 00 		ldi		r3,#2
011A30 60 30 86 02 		sb		r3,KeybdLEDs
                	.0002:
011A34 8C 20 40 00 		and		r2,r1,#32
011A38 3D 01 08 00 		beq		r2,.0003
011A3C 40 30 86 02 		lb		r3,KeybdLEDs
011A40 8D 31 08 00 		or		r3,r3,#4
011A44 60 30 86 02 		sb		r3,KeybdLEDs
                	.0003:
011A48 8C 20 80 00 		and		r2,r1,#64
011A4C 3D 01 08 00 		beq		r2,.0004
011A50 40 30 86 02 		lb		r3,KeybdLEDs
011A54 8D 31 02 00 		or		r3,r3,#1
011A58 60 30 86 02 		sb		r3,KeybdLEDs
                	.0004:
011A5C 0A 10 DA 01 		ldi		r1,#$ED
011A60 B9 06 00 00 		bsr		KeybdSendByte
011A64 39 A4 FF FF 		bsr		KeybdWaitTx
011A68 B9 9B FF FF 		bsr		KeybdRecvByte
011A6C BD 40 0C 00 		bmi		r1,.0001
011A70 86 20 F4 01 		cmp		r2,r1,#$FA
011A74 40 10 86 02 		lb		r1,KeybdLEDs
011A78 B9 03 00 00 		bsr		KeybdSendByte
011A7C 39 A1 FF FF 		bsr		KeybdWaitTx
011A80 B9 98 FF FF 		bsr		KeybdRecvByte
                	.0001:
011A84 57 3F 10 00 		pop		r3
011A88 57 2F 10 00 	    pop     r2
011A8C 57 FF 11 00 	    pop     lr
011A90 37 FF 01 00 		rtl

                	KeybdSendByte:
011A94 7C DC FF 00 		sb		r1,KEYBD
011A98 60 10 00 00 
011A9C 37 FF 01 00 		rtl
	
                	Wait10ms:
011AA0 E7 E1 01 00 		push	r3
011AA4 67 E2 01 00 	    push    r4
011AA8 02 30 08 3E 		mfspr	r3,tick					; get orginal count
                	.0001:
011AAC 02 40 08 3E 		mfspr	r4,tick
011AB0 02 42 06 0A 		sub		r4,r4,r3
011AB4 3D 42 08 00 		blt  	r4,.0002				; shouldn't be -ve unless counter overflowed
011AB8 FC 03 00 00 		cmpu	r4,r4,#250000			; about 10ms at 25 MHz
011ABC 16 42 20 A1 
011AC0 3D 42 F6 FF 		blt		r4,.0001
                	.0002:
011AC4 57 4F 10 00 		pop		r4
011AC8 57 3F 10 00 	    pop     r3
011ACC 37 FF 01 00 		rtl

                		;--------------------------------------------------------------------------
                		; PS2 scan codes to ascii conversion tables.
                		;--------------------------------------------------------------------------
                		;
                		align	16                	
                	unshiftedScanCodes:
011AD0 2E A9 2E A5 		.byte	$2e,$a9,$2e,$a5,$a3,$a1,$a2,$ac
011AD4 A3 A1 A2 AC 
011AD8 2E AA A8 A6 		.byte	$2e,$aa,$a8,$a6,$a4,$09,$60,$2e
011ADC A4 09 60 2E 
011AE0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$71,$31,$2e
011AE4 2E 71 31 2E 
011AE8 2E 2E 7A 73 		.byte	$2e,$2e,$7a,$73,$61,$77,$32,$2e
011AEC 61 77 32 2E 
011AF0 2E 63 78 64 		.byte	$2e,$63,$78,$64,$65,$34,$33,$2e
011AF4 65 34 33 2E 
011AF8 2E 20 76 66 		.byte	$2e,$20,$76,$66,$74,$72,$35,$2e
011AFC 74 72 35 2E 
011B00 2E 6E 62 68 		.byte	$2e,$6e,$62,$68,$67,$79,$36,$2e
011B04 67 79 36 2E 
011B08 2E 2E 6D 6A 		.byte	$2e,$2e,$6d,$6a,$75,$37,$38,$2e
011B0C 75 37 38 2E 
011B10 2E 2C 6B 69 		.byte	$2e,$2c,$6b,$69,$6f,$30,$39,$2e
011B14 6F 30 39 2E 
011B18 2E 2E 2F 6C 		.byte	$2e,$2e,$2f,$6c,$3b,$70,$2d,$2e
011B1C 3B 70 2D 2E 
011B20 2E 2E 27 2E 		.byte	$2e,$2e,$27,$2e,$5b,$3d,$2e,$2e
011B24 5B 3D 2E 2E 
011B28 AD 2E 0D 5D 		.byte	$ad,$2e,$0d,$5d,$2e,$5c,$2e,$2e
011B2C 2E 5C 2E 2E 
011B30 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
011B34 2E 2E 08 2E 
011B38 2E 95 2E 93 		.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
011B3C 94 2E 2E 2E 
011B40 98 7F 92 2E 		.byte	$98,$7f,$92,$2e,$91,$90,$1b,$af
011B44 91 90 1B AF 
011B48 AB 2E 97 2E 		.byte	$ab,$2e,$97,$2e,$2e,$96,$ae,$2e
011B4C 2E 96 AE 2E 
                	
011B50 2E 2E 2E A7 		.byte	$2e,$2e,$2e,$a7,$2e,$2e,$2e,$2e
011B54 2E 2E 2E 2E 
011B58 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B5C 2E 2E 2E 2E 
011B60 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B64 2E 2E 2E 2E 
011B68 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B6C 2E 2E 2E 2E 
011B70 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B74 2E 2E 2E 2E 
011B78 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B7C 2E 2E 2E 2E 
011B80 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B84 2E 2E 2E 2E 
011B88 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B8C 2E 2E 2E 2E 
011B90 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B94 2E 2E 2E 2E 
011B98 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011B9C 2E 2E 2E 2E 
011BA0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011BA4 2E 2E 2E 2E 
011BA8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011BAC 2E 2E 2E 2E 
011BB0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011BB4 2E 2E 2E 2E 
011BB8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011BBC 2E 2E 2E 2E 
011BC0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011BC4 2E 2E 2E 2E 
011BC8 2E 2E FA 2E 		.byte	$2e,$2e,$fa,$2e,$2e,$2e,$2e,$2e
011BCC 2E 2E 2E 2E 
                	
                	shiftedScanCodes:
011BD0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011BD4 2E 2E 2E 2E 
011BD8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
011BDC 2E 09 7E 2E 
011BE0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$51,$21,$2e
011BE4 2E 51 21 2E 
011BE8 2E 2E 5A 53 		.byte	$2e,$2e,$5a,$53,$41,$57,$40,$2e
011BEC 41 57 40 2E 
011BF0 2E 43 58 44 		.byte	$2e,$43,$58,$44,$45,$24,$23,$2e
011BF4 45 24 23 2E 
011BF8 2E 20 56 46 		.byte	$2e,$20,$56,$46,$54,$52,$25,$2e
011BFC 54 52 25 2E 
011C00 2E 4E 42 48 		.byte	$2e,$4e,$42,$48,$47,$59,$5e,$2e
011C04 47 59 5E 2E 
011C08 2E 2E 4D 4A 		.byte	$2e,$2e,$4d,$4a,$55,$26,$2a,$2e
011C0C 55 26 2A 2E 
011C10 2E 3C 4B 49 		.byte	$2e,$3c,$4b,$49,$4f,$29,$28,$2e
011C14 4F 29 28 2E 
011C18 2E 3E 3F 4C 		.byte	$2e,$3e,$3f,$4c,$3a,$50,$5f,$2e
011C1C 3A 50 5F 2E 
011C20 2E 2E 22 2E 		.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
011C24 7B 2B 2E 2E 
011C28 2E 2E 0D 7D 		.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
011C2C 2E 7C 2E 2E 
011C30 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
011C34 2E 2E 08 2E 
011C38 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C3C 2E 2E 2E 2E 
011C40 2E 7F 2E 2E 		.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
011C44 2E 2E 1B 2E 
011C48 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C4C 2E 2E 2E 2E 
                	
011C50 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C54 2E 2E 2E 2E 
011C58 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C5C 2E 2E 2E 2E 
011C60 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C64 2E 2E 2E 2E 
011C68 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C6C 2E 2E 2E 2E 
011C70 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C74 2E 2E 2E 2E 
011C78 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C7C 2E 2E 2E 2E 
011C80 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C84 2E 2E 2E 2E 
011C88 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C8C 2E 2E 2E 2E 
011C90 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C94 2E 2E 2E 2E 
011C98 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011C9C 2E 2E 2E 2E 
011CA0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011CA4 2E 2E 2E 2E 
011CA8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011CAC 2E 2E 2E 2E 
011CB0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011CB4 2E 2E 2E 2E 
011CB8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011CBC 2E 2E 2E 2E 
011CC0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011CC4 2E 2E 2E 2E 
011CC8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011CCC 2E 2E 2E 2E 
                	
                	; control
                	keybdControlCodes:
011CD0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011CD4 2E 2E 2E 2E 
011CD8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$09,$7e,$2e
011CDC 2E 09 7E 2E 
011CE0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$11,$21,$2e
011CE4 2E 11 21 2E 
011CE8 2E 2E 1A 13 		.byte	$2e,$2e,$1a,$13,$01,$17,$40,$2e
011CEC 01 17 40 2E 
011CF0 2E 03 18 04 		.byte	$2e,$03,$18,$04,$05,$24,$23,$2e
011CF4 05 24 23 2E 
011CF8 2E 20 16 06 		.byte	$2e,$20,$16,$06,$14,$12,$25,$2e
011CFC 14 12 25 2E 
011D00 2E 0E 02 08 		.byte	$2e,$0e,$02,$08,$07,$19,$5e,$2e
011D04 07 19 5E 2E 
011D08 2E 2E 0D 0A 		.byte	$2e,$2e,$0d,$0a,$15,$26,$2a,$2e
011D0C 15 26 2A 2E 
011D10 2E 3C 0B 09 		.byte	$2e,$3c,$0b,$09,$0f,$29,$28,$2e
011D14 0F 29 28 2E 
011D18 2E 3E 3F 0C 		.byte	$2e,$3e,$3f,$0c,$3a,$10,$5f,$2e
011D1C 3A 10 5F 2E 
011D20 2E 2E 22 2E 		.byte	$2e,$2e,$22,$2e,$7b,$2b,$2e,$2e
011D24 7B 2B 2E 2E 
011D28 2E 2E 0D 7D 		.byte	$2e,$2e,$0d,$7d,$2e,$7c,$2e,$2e
011D2C 2E 7C 2E 2E 
011D30 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$08,$2e
011D34 2E 2E 08 2E 
011D38 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D3C 2E 2E 2E 2E 
011D40 2E 7F 2E 2E 		.byte	$2e,$7f,$2e,$2e,$2e,$2e,$1b,$2e
011D44 2E 2E 1B 2E 
011D48 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D4C 2E 2E 2E 2E 
                	
                	keybdExtendedCodes:
011D50 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$a3,$a1,$a2,$2e
011D54 A3 A1 A2 2E 
011D58 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D5C 2E 2E 2E 2E 
011D60 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D64 2E 2E 2E 2E 
011D68 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D6C 2E 2E 2E 2E 
011D70 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D74 2E 2E 2E 2E 
011D78 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D7C 2E 2E 2E 2E 
011D80 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D84 2E 2E 2E 2E 
011D88 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D8C 2E 2E 2E 2E 
011D90 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D94 2E 2E 2E 2E 
011D98 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011D9C 2E 2E 2E 2E 
011DA0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011DA4 2E 2E 2E 2E 
011DA8 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011DAC 2E 2E 2E 2E 
011DB0 2E 2E 2E 2E 		.byte	$2e,$2e,$2e,$2e,$2e,$2e,$2e,$2e
011DB4 2E 2E 2E 2E 
011DB8 2E 95 2E 93 		.byte	$2e,$95,$2e,$93,$94,$2e,$2e,$2e
011DBC 94 2E 2E 2E 
011DC0 98 99 92 2E 		.byte	$98,$99,$92,$2e,$91,$90,$2e,$2e
011DC4 91 90 2E 2E 
011DC8 2E 2E 97 2E 		.byte	$2e,$2e,$97,$2e,$2e,$96,$2e,$2e
011DCC 2E 96 2E 2E 
                	
                	
                	; ============================================================================
                	; I2C interface to RTCC
                	; ============================================================================
                	
                	I2C_INIT:
011DD0 E7 E0 01 00 	    push    r1
011DD4 67 E1 01 00 	    push    r2
011DD8 7C DC FF 00 		ldi		r2,#I2C_MASTER
011DDC 0A 20 00 1C 
011DE0 60 01 04 00 		sb		r0,I2C_CONTROL[r2]		; disable the contoller
011DE4 60 01 02 00 		sb		r0,I2C_PRESCALE_HI[r2]	; set clock divisor for 100kHz
011DE8 0A 10 C6 00 		ldi		r1,#99					; 24=400kHz, 99=100KHz
011DEC 60 11 00 00 		sb		r1,I2C_PRESCALE_LO[r2]
011DF0 0A 10 00 01 		ldi		r1,#$80					; controller enable bit
011DF4 60 11 04 00 		sb		r1,I2C_CONTROL[r2]
011DF8 57 2F 10 00 		pop		r2
011DFC 57 1F 10 00 	    pop     r1
011E00 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; I2C Read
                	;
                	; Parameters:
                	; 	r1 = device ($6F for RTCC)
                	; 	r2 = register to read
                	; Returns
                	; 	r1 = register value $00 to $FF if successful, else r1 = -1 on error
                	;------------------------------------------------------------------------------
                	;
                	I2C_READ:
011E04 E7 EF 01 00 	    push    lr
011E08 67 E1 01 00 		push	r2
011E0C E7 E1 01 00 	    push    r3
011E10 67 E2 01 00 	    push    r4
011E14 82 10 02 70 		asl		r1,r1,#1				; clear rw bit for write
                	;	or		r1,r1,#1				; set rw bit for a read
011E18 82 40 00 1A 		mov		r4,r1					; save device address in r4
011E1C 02 31 00 1A 		mov		r3,r2
                		; transmit device #
011E20 7C DC FF 00 		ldi		r2,#I2C_MASTER
011E24 0A 20 00 1C 
011E28 60 11 06 00 		sb		r1,I2C_TX[r2]
011E2C 0A 10 20 01 		ldi		r1,#$90					; STA($80) and WR($10) bits set
011E30 60 11 08 00 		sb		r1,I2C_CMD[r2]
011E34 B9 1F 00 00 		bsr		I2C_WAIT_TC				; wait for transmit to complete
                		; transmit register #
011E38 40 11 08 00 		lb		r1,I2C_STAT[r2]
011E3C 8C 10 00 01 		and		r1,r1,#$80				; test RxACK bit
011E40 BD 10 30 00 		bne	    r1,I2C_ERR
011E44 60 31 06 00 		sb		r3,I2C_TX[r2]			; select register r3
011E48 0A 10 20 00 		ldi		r1,#$10					; set WR bit
011E4C 60 11 08 00 		sb		r1,I2C_CMD[r2]
011E50 39 1C 00 00 		bsr		I2C_WAIT_TC
                	
                		; transmit device #
011E54 40 11 08 00 		lb		r1,I2C_STAT[r2]
011E58 8C 10 00 01 		and		r1,r1,#$80				; test RxACK bit
011E5C BD 10 22 00 		bne	    r1,I2C_ERR
011E60 0D 42 02 00 		or		r4,r4,#1				; set read flag
011E64 60 41 06 00 		sb		r4,I2C_TX[r2]
011E68 0A 10 20 01 		ldi		r1,#$90					; STA($80) and WR($10) bits set
011E6C 60 11 08 00 		sb		r1,I2C_CMD[r2]
011E70 39 18 00 00 		bsr		I2C_WAIT_TC				; wait for transmit to complete
                	
                		; receive data byte
011E74 40 11 08 00 		lb		r1,I2C_STAT[r2]
011E78 8C 10 00 01 		and		r1,r1,#$80				; test RxACK bit
011E7C BD 10 12 00 		bne	    r1,I2C_ERR
011E80 0A 10 D0 00 		ldi		r1,#$68					; STO($40), RD($20), and NACK($08)
011E84 60 11 08 00 		sb		r1,I2C_CMD[r2]
011E88 39 15 00 00 		bsr		I2C_WAIT_TC
011E8C 41 11 06 00 		lbu		r1,I2C_RX[r2]			; $00 to $FF = byte read, -1=err
011E90 57 4F 10 00 		pop		r4
011E94 57 3F 10 00 	    pop     r3
011E98 57 2F 10 00 	    pop     r2
011E9C 3B FF 11 00 		rts

                	I2C_ERR:
011EA0 0A 10 FE FF 		ldi		r1,#-1
011EA4 82 02 00 3C 		mtspr	cr0,r5					; restore TMR
011EA8 57 4F 10 00 		pop		r4/r3/r2/r5
011EAC 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; I2C Write
                	;
                	; Parameters:
                	; 	r1 = device ($6F)
                	; 	r2 = register to write
                	; 	r3 = value for register
                	; Returns
                	; 	r1 = 0 if successful, else r1 = -1 on error
                	;------------------------------------------------------------------------------
                	;
                	I2C_WRITE:
011EB0 E7 EF 01 00 		push	lr
011EB4 67 E1 01 00 	    push    r2
011EB8 E7 E1 01 00 	    push    r3
011EBC 67 E2 01 00 	    push    r4
011EC0 82 10 02 70 		asl		r1,r1,#1				; clear rw bit for write
011EC4 82 41 00 1A 		mov		r4,r3					; save value r4
011EC8 02 31 00 1A 		mov		r3,r2
                		; transmit device #
011ECC 7C DC FF 00 		ldi		r2,#I2C_MASTER			; r2 = I/O base address of controller
011ED0 0A 20 00 1C 
011ED4 60 11 06 00 		sb		r1,I2C_TX[r2]
011ED8 0A 10 20 01 		ldi		r1,#$90					; STA($80) and WR($10) bits set
011EDC 60 11 08 00 		sb		r1,I2C_CMD[r2]
011EE0 39 0A 00 00 		bsr		I2C_WAIT_TC				; wait for transmit to complete
                		; transmit register #
011EE4 40 11 08 00 		lb		r1,I2C_STAT[r2]
011EE8 8C 10 00 01 		and		r1,r1,#$80				; test RxACK bit
011EEC BD 10 DA FF 		bne  	r1,I2C_ERR
011EF0 60 31 06 00 		sb		r3,I2C_TX[r2]			; select register r3
011EF4 0A 10 20 00 		ldi		r1,#$10					; set WR bit
011EF8 60 11 08 00 		sb		r1,I2C_CMD[r2]
011EFC B9 06 00 00 		bsr		I2C_WAIT_TC
                		; transmit value
011F00 40 11 08 00 		lb		r1,I2C_STAT[r2]
011F04 8C 10 00 01 		and		r1,r1,#$80				; test RxACK bit
011F08 BD 10 CC FF 		bne  	r1,I2C_ERR
011F0C 60 41 06 00 		sb		r4,I2C_TX[r2]			; select value in r4
011F10 0A 10 A0 00 		ldi		r1,#$50					; set STO, WR bit
011F14 60 11 08 00 		sb		r1,I2C_CMD[r2]
011F18 39 03 00 00 		bsr		I2C_WAIT_TC
011F1C 0A 10 00 00 		ldi		r1,#0					; everything okay
011F20 57 4F 10 00 		pop		r4
011F24 57 3F 10 00 	    pop     r3
011F28 57 2F 10 00 	    pop     r2
011F2C 3B FF 11 00 		rts

                	; Wait for I2C controller transmit complete
                	
                	I2C_WAIT_TC:
                	.0001:
011F30 40 11 08 00 		lb		r1,I2C_STAT[r2]
011F34 8C 10 04 00 		and		r1,r1,#2
011F38 BD 10 FC FF 		bne 	r1,.0001
011F3C 37 FF 01 00 		rtl

                	; Read the entire contents of the RTCC including 64 SRAM bytes
                	
                	RTCCReadbuf:
011F40 E7 EF 01 00 	    push    lr
011F44 B9 D1 FF FF 		bsr		I2C_INIT
011F48 0A 20 00 00 		ldi		r2,#$00
                	.0001:
011F4C 0A 10 DE 00 		ldi		r1,#$6F
011F50 B9 D6 FF FF 		bsr		I2C_READ
011F54 60 11 A0 07 		sb		r1,RTCC_BUF[r2]
011F58 04 21 02 00 		add		r2,r2,#1
011F5C 16 11 C0 00 		cmpu	r1,r2,#$60
011F60 BD 40 F6 FF 		blt		r1,.0001
011F64 3B FF 11 00 		rts

                	; Write the entire contents of the RTCC including 64 SRAM bytes
                	
                	RTCCWritebuf:
011F68 E7 EF 01 00 	    push    lr
011F6C B9 CC FF FF 		bsr		I2C_INIT
011F70 0A 20 00 00 		ldi		r2,#$00
                	.0001:
011F74 0A 10 DE 00 		ldi		r1,#$6F
011F78 41 31 A0 07 		lbu		r3,RTCC_BUF[r2]
011F7C B9 E6 FF FF 		bsr		I2C_WRITE
011F80 04 21 02 00 		add		r2,r2,#1
011F84 16 11 C0 00 		cmpu	r1,r2,#$60
011F88 BD 40 F6 FF 		blt		r1,.0001
011F8C 3B FF 11 00 		rts

                	RTCCOscOn:
011F90 E7 EF 01 00 	    push    lr
011F94 B9 C7 FF FF 		bsr		I2C_INIT
011F98 0A 10 DE 00 		ldi		r1,#$6F
011F9C 0A 20 00 00 		ldi		r2,#$00			; register zero
011FA0 B9 CC FF FF 		bsr		I2C_READ		; read register zero
011FA4 8D 30 00 01 		or		r3,r1,#$80		; set start osc bit
011FA8 0A 10 DE 00 		ldi		r1,#$6F
011FAC B9 E0 FF FF 		bsr		I2C_WRITE
011FB0 3B FF 11 00 		rts

                	; ============================================================================
                	; SD/MMC Card interface
                	; ============================================================================
                	SD_INIT:
011FB4 E7 EF 01 00 	    push    lr
011FB8 7C DC FF 00 		ldi		r3,#SD_MASTER
011FBC 0A 30 00 16 
011FC0 7C 00 00 00 		ldi		r2,#25000
011FC4 0A 20 50 C3 
011FC8 E1 21 58 00 		sc		r2,0x2c[r3]		; timeout register
                		; Software reset should be held active for several cycles to allow
                		; reset to be detected on the sd_clk domain.
011FCC 0A 20 02 00 		ldi		r2,#1
011FD0 E0 21 50 00 		sb		r2,0x28[r3]		; software reset reg
011FD4 0A 20 04 00 		ldi		r2,#2
011FD8 E0 21 98 00 		sb		r2,0x4c[r3]		; prog /6 for clock divider
011FDC 0A 10 C8 00 		ldi		r1,#100			; software reset delay
011FE0 39 47 00 00 		bsr     MicroDelay
011FE4 E0 01 50 00 		sb		r0,0x28[r3]		; clear software reset
011FE8 E1 01 08 00 		sc		r0,0x04[r3]		; command 0
011FEC E2 01 00 00 		sh		r0,0x00[r3]		; arg 0
011FF0 39 28 00 00 		bsr		SD_WAIT_RESP
011FF4 C4 11 18 00 		lh		r1,0x0C[r3]		; read response register
011FF8 39 DE FC FF 		bsr		DisplayHalf
011FFC 3B FF 11 00 		rts

                	SD_CMD8:
012000 E7 EF 01 00 	    push    lr
012004 7C DC FF 00 		ldi		r3,#SD_MASTER
012008 0A 30 00 16 
01200C 0A 20 34 10 		ldi		r2,#$81A
012010 E1 21 08 00 		sc		r2,0x04[r3]		; set command register
012014 0A 20 54 03 		ldi		r2,#$1AA
012018 E2 21 00 00 		sh		r2,0x00[r3]		; set command argument x1AA
01201C B9 22 00 00 		bsr		SD_WAIT_RESP
012020 7C 00 00 00 		sb		r1,SD_2_0
012024 7C 00 00 00 
012028 60 10 02 04 
01202C C4 11 18 00 		lh		r1,0x0C[r3]		; read response register
012030 39 D7 FC FF 		bsr		DisplayHalf
                		; send command zero
012034 E1 01 08 00 		sc		r0,0x04[r3]
012038 E2 01 00 00 		sh		r0,0x00[r3]
01203C B9 1E 00 00 		bsr		SD_WAIT_RESP
012040 7C 00 00 00 		lbu		r1,SD_2_0
012044 7C 00 00 00 
012048 41 10 02 04 
01204C BD 00 12 00 		beq		r1,.0001
012050 0A 10 64 00 		ldi		r1,#'2'
012054 B9 1A FE FF 		bsr		OutChar
012058 0A 10 5C 00 		ldi		r1,#'.'
01205C B9 19 FE FF 		bsr		OutChar
012060 0A 10 60 00 		ldi		r1,#'0'
012064 B9 18 FE FF 		bsr		OutChar
012068 39 E5 FC FF 		bsr		CRLF
01206C 3B FF 11 00 		rts
.0001:
012070 E1 01 08 00 		sc		r0,0x04[r3]		; send CMD0
012074 E2 01 00 00 		sh		r0,0x00[r3]
                	.0002:
012078 C3 11 10 00 		lcu		r1,0x08[r3]
01207C 8C 10 02 00 		and		r1,r1,#1
012080 BD 10 FC FF 		bne  	r1,.0002
012084 02 40 00 1A 		mov		r4,r0			; ret_reg = r4 = 0
                	.0004:
012088 02 52 00 1A 		mov		r5,r4
01208C 7C 00 80 00 		and		r4,r4,#$80000000
012090 0C 42 00 00 
012094 3D 12 20 00 		bne  	r4,.0003
012098 0A 10 04 6E 		ldi		r1,#$3702		; CMD55|RSP48
01209C E1 11 08 00 		sc		r1,0x04[r3]
0120A0 E2 01 00 00 		sh		r0,0x00[r3]
0120A4 B9 11 00 00 		bsr		SD_WAIT_RESP
0120A8 BD 10 38 00 		bne  	r1,.respOk
0120AC 0A 10 04 52 		ldi		r1,#$2902		; ACMD41|RSP48
0120B0 E1 11 08 00 		sc		r1,0x04[r3]
0120B4 E2 01 00 00 		sh		r0,0x00[r3]
0120B8 39 0F 00 00 		bsr		SD_WAIT_RESP
0120BC BD 10 2E 00 		bne  	r1,.respOk
0120C0 C4 41 18 00 		lh		r4,0x0c[r3]		; ret_reg = RESP1
0120C4 02 12 00 1A 		mov		r1,r4
0120C8 39 C4 FC FF 		bsr		DisplayHalf
0120CC B9 D8 FC FF 		bsr		CRLF
0120D0 3A F7 FF FF 		bra		.0004
                	.0003:
0120D4 FC FF 00 00 		and		r1,r5,#$FFFFFF	; voltage mask
0120D8 8C 12 FE FF 
0120DC B9 C1 FC FF 		bsr		DisplayHalf
0120E0 39 D6 FC FF 		bsr		CRLF
                		; GetCID
0120E4 0A 10 02 04 		ldi		r1,#$201		; CMD2 + RSP146
0120E8 E1 11 08 00 		sc		r1,0x04[r3]
0120EC E2 01 00 00 		sh		r0,0x00[r3]
0120F0 39 08 00 00 		bsr		SD_WAIT_RESP
                		; GetRCA
0120F4 0A 10 34 06 		ldi		r1,#$31A		; CMD3 + CICE + CRCE + RSP48
0120F8 E1 11 08 00 		sc		r1,0x04[r3]
0120FC E2 01 00 00 		sh		r0,0x00[r3]
012100 39 06 00 00 		bsr		SD_WAIT_RESP
012104 C4 41 18 00 		lh		r4,0x0c[r3]			; r4 = RESP1
012108 7C FF FF 00 		and		r1,r4,#$FFFF0000	; r4 & RCA_MASK
01210C 0C 12 00 00 
012110 39 BB FC FF 		bsr		DisplayHalf
012114 B9 CF FC FF 		bsr		CRLF
                	.respOk:
012118 0A 10 9E 00 		ldi		r1,#'O'
01211C B9 01 FE FF 		bsr		OutChar
012120 0A 10 D6 00 		ldi		r1,#'k'
012124 B9 00 FE FF 		bsr		OutChar
012128 39 CD FC FF 		bsr		CRLF
01212C 3B FF 11 00 		rts

                	SD_WAIT_RESP:
012130 E7 EF 01 00 	    push    lr
012134 67 E1 01 00 		push	r2
012138 E7 E1 01 00 	    push    r3
01213C 7C DC FF 00 		ldi		r2,#SD_MASTER
012140 0A 20 00 16 
                	.0001:
012144 42 31 68 00 		lc		r3,0x34[r2]		; read error interrupt status reg
012148 42 11 60 00 		lc		r1,0x30[r2]		; read normal interrupt status reg
01214C 8C 31 02 00 		and		r3,r3,#1		; get command timeout indicator
012150 BD 11 10 00 		bne  	r3,.0002
012154 8C 10 02 00 		and		r1,r1,#1		; wait for command complete bit to set
012158 BD 00 F6 FF 		beq		r1,.0001
01215C 0A 10 02 00 		ldi		r1,#1
012160 57 3F 10 00 		pop		r3
012164 57 2F 10 00 	    pop     r2
012168 57 FF 11 00 	    pop     lr
01216C 37 FF 01 00 		rtl
.0002:
012170 0A 10 A8 00 		ldi		r1,#'T'
012174 B9 F6 FD FF 		bsr		OutChar
012178 0A 10 9E 00 		ldi		r1,#'O'
01217C B9 F5 FD FF 		bsr		OutChar
012180 39 C2 FC FF 		bsr		CRLF
012184 0A 10 00 00 		ldi		r1,#0
012188 57 3F 10 00 		pop		r3
01218C 57 2F 10 00 	    pop     r2
012190 57 FF 11 00 	    pop     lr
012194 37 FF 01 00 		rtl

                	; ============================================================================
                	; ============================================================================
                	
012198 7C 01 00 00 	    ldi     r1,#brkpt1           ; set breakpoint address
01219C 0A 10 B8 43 
0121A0 82 00 64 3C 	    mtspr   dbad0,r1
0121A4 0A 10 00 00 	    ldi     r1,#$0000000000000000   ; enable instruction breakpoint, turn on single step mode
0121A8 82 00 6C 3C 	    mtspr   dbctrl,r1
0121AC 02 00 54 3C 	    mtspr   lotgrp,r0            ; operating system is group #0
0121B0 B9 04 00 00 	    bsr     SetupMemtags
0121B4 0A 10 C8 00 	    ldi     r1,#100
0121B8 39 0C 00 00 	    bsr     MicroDelay
0121BC 3F 00 00 00 	    nop
0121C0 3F 00 00 00 	    nop
                	hangprg:
0121C4 3F 00 00 00 	    nop
0121C8 3F 00 00 00 	    nop
0121CC 3F 00 00 00 	    nop
0121D0 BA FE FF FF 	    bra     hangprg
                	
                	SetupMemtags:
0121D4 02 00 50 3C 	    mtspr   ea,r0                ; select tag for first 64kB
0121D8 0A 10 0C 00 	    ldi     r1,#$0006            ; system only: readable, writeable, not executable
                	brkpt1:
0121DC 82 00 52 3C 	    mtspr   tag,r1
0121E0 7C 01 00 00 	    ldi     r1,#$10000           ; select tag for second 64kB
0121E4 0A 10 00 00 
0121E8 82 00 50 3C 	    mtspr   ea,r1
0121EC 0A 20 0A 00 	    ldi     r2,#$0005            ; system only: readable, executable, not writeable
0121F0 02 01 52 3C 	    mtspr   tag,r2
0121F4 0A 30 24 00 	    ldi     r3,#20-2             ; number of tags to setup
                	.0001:
0121F8 7C 01 00 00 	    addui   r1,r1,#$10000
0121FC 94 10 00 00 
012200 82 00 50 3C 	    mtspr   ea,r1
012204 0A 20 0C 00 	    ldi     r2,#$0006            ; set them up as data
012208 02 01 52 3C 	    mtspr   tag,r2
01220C 95 31 02 00 	    subui   r3,r3,#1
012210 BD 11 F4 FF 	    bne     r3,.0001
012214 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	; MicroDelay
                	;     Delay for a short time for at least the specified number of clock cycles
                	;
                	; Parameters:
                	;     r1 = required delay in clock ticks
                	;------------------------------------------------------------------------------
                	;
                	MicroDelay:
012218 67 E1 01 00 	    push    r2
01221C E7 E1 01 00 	    push    r3
012220 02 30 08 3E 	    mfspr   r3,tick             ; get starting tick
                	.0001:
012224 02 20 08 3E 	    mfspr   r2,tick
012228 02 21 06 2A 	    subu    r2,r2,r3
01222C 02 21 02 0C 	    cmp     r2,r2,r1
012230 3D 41 FA FF 	    blt     r2,.0001
012234 57 3F 10 00 	    pop     r3
012238 57 2F 10 00 	    pop     r2
01223C 37 FF 01 00 	    rtl
;
012240 3F 00 00 00 	    nop
012244 3F 00 00 00 	    nop
                	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	LoadFromSerial:
012248 E7 EF 01 00 	    push    lr
01224C 7C 00 00 00 	    ldi     r3,#16384
012250 0A 30 00 80 
012254 7C 02 00 00 	    ldi     r2,#$24000          ; target store address
012258 0A 20 00 80 
                	.0001:
01225C B9 10 FC FF 	    bsr     SerialGetCharDirect
012260 60 11 00 00 	    sb      r1,[r2]
012264 14 21 02 00 	    addui   r2,r2,#1
012268 95 31 02 00 	    subui   r3,r3,#1
01226C BD 11 F8 FF 	    bne     r3,.0001
012270 3B FF 11 00 	    rts

                	;------------------------------------------------------------------------------
                	; Execution fault. Occurs when an attempt is made to execute code from a
                	; page marked as non-executable.
                	;------------------------------------------------------------------------------
                	
                	exf_rout:
012274 0A 10 76 01 		ldi		r1,#$bb
012278 7C DC FF 00 		sc		r1,LEDS
01227C 61 10 00 0C 
012280 7C 01 00 00 		ldi		r1,#msgexf
012284 0A 10 C8 45 
012288 B9 9F FC FF 		bsr		DisplayStringCRLF
                	.0001:
01228C 3A 00 00 00 		bra .0001
                	
                	;------------------------------------------------------------------------------
                	; Data read fault. Occurs when an attempt is made to read from a page marked
                	; as non-readble.
                	;------------------------------------------------------------------------------
                	
                	drf_rout:
012290 0A 10 76 01 		ldi		r1,#$bb
012294 7C DC FF 00 		sc		r1,LEDS
012298 61 10 00 0C 
01229C 7C 01 00 00 		ldi		r1,#msgdrf
0122A0 0A 10 D2 45 
0122A4 39 9C FC FF 		bsr		DisplayStringCRLF
                	.0001:
0122A8 3A 00 00 00 		bra .0001
                	
                	;------------------------------------------------------------------------------
                	; Data write fault. Occurs when an attempt is made to write to a page marked
                	; as non-writeable.
                	;------------------------------------------------------------------------------
                	
                	dwf_rout:
0122AC 0A 10 76 01 		ldi		r1,#$bb
0122B0 7C DC FF 00 		sc		r1,LEDS
0122B4 61 10 00 0C 
0122B8 7C 01 00 00 		ldi		r1,#msgdwf
0122BC 0A 10 DC 45 
0122C0 B9 98 FC FF 		bsr		DisplayStringCRLF
                	.0001:
0122C4 3A 00 00 00 		bra .0001
                	
                	;------------------------------------------------------------------------------
                	; Privilege violation fault. Occurs when the current privilege level isn't
                	; sufficient to allow access.
                	;------------------------------------------------------------------------------
                	
                	priv_rout:
0122C8 0A 10 78 01 		ldi		r1,#$bc
0122CC 7C DC FF 00 		sc		r1,LEDS
0122D0 61 10 00 0C 
0122D4 7C 01 00 00 		ldi		r1,#msgPriv
0122D8 0A 10 E6 45 
0122DC 39 95 FC FF 		bsr		DisplayStringCRLF
                	.0001:
0122E0 3A 00 00 00 		bra .0001
                	
                	;------------------------------------------------------------------------------
                	; Message strings for the faults.
                	;------------------------------------------------------------------------------
                	
                	msgexf:
0122E4 65 78 66 20 		db	"exf ",0
0122E8 00          
                	msgdrf:
0122E9 64 72 66 20 		db	"drf ",0
0122ED 00          
                	msgdwf:
0122EE 64 77 66 20 		db	"dwf ",0
0122F2 00          
                	msgPriv:
0122F3 70 72 69 76 		db	"priv fault",0
0122F7 20 66 61 75 
0122FB 6C 74 00    
                	msgUninit:
0122FE 75 6E 69 6E 		db	"uninit int.",0
012302 69 74 20 69 
012306 6E 74 2E 00 
                	msgBusErr:
01230A 0D 0A 42 75 	    db  CR,LF,"Bus error PC=",0
01230E 73 20 65 72 
012312 72 6F 72 20 
012316 50 43 3D 00 
                	msgEA:
01231A 20 45 41 3D 	    db  " EA=",0
01231E 00          
                	
                	;------------------------------------------------------------------------------
                	; Bus error routine.
                	;------------------------------------------------------------------------------
                	
                	berr_rout:
01231F 00 7C 00 00 	    ldi     sp,#$7800
012323 00 0A E0 01 
012327 F0          
012328 FC 00 00 00 		ldi		r1,#$bebe
01232C 0A 10 7C 7D 
012330 7C DC FF 00 		sc		r1,LEDS
012334 61 10 00 0C 
012338 7C 01 00 00 		ldi     r1,#msgBusErr
01233C 0A 10 14 46 
012340 B9 82 FC FF 		bsr     DisplayString
012344 02 10 10 3E 		mfspr   r1,ipc
012348 B9 71 FC FF 		bsr		DisplayWord
01234C 7C 01 00 00 		ldi     r1,#msgEA
012350 0A 10 34 46 
012354 39 80 FC FF 		bsr     DisplayString
012358 02 10 16 3E 	    mfspr   r1,bear
01235C 39 6F FC FF 		bsr     DisplayWord
012360 39 86 FC FF 		bsr     CRLF
012364 39 8F FE FF 		bsr		KeybdGetCharWait
                	
                		; In order to return an RTI must be used to exit the routine (or interrupts
                		; will permanently disabled). The RTI instruction clears an internal
                		; processor flag used to prevent nested interrupts.
                		; Since this is a serious error the system is just restarted. So the IPC
                		; is set to point to the restart address.
                	
012368 7C 01 00 00 		ldi     r1,#start
01236C 0A 10 00 01 
012370 82 00 10 3C 		mtspr   ipc,r1
                		
                		; Allow pipeline time for IPC to update before RTI (there's no results
                		; forwarding on SPR's).
012374 3F 00 00 00 		nop     
012378 3F 00 00 00 		nop
01237C 02 E0 3F 6E 		rti
                	
                	
                	SSM_ISR:
012380 02 E0 3B 6E 	    rtd
                	
                	IBPT_ISR:
012384 02 E0 3B 6E 	    rtd
                	.0001:
012388 3A 00 00 00 	    bra     .0001
                	
                		code
01238C 00 00 00 00 		align	1
                	
                	get_datetime:
012390 15 EF 21 00 		      	subui	sp,sp,#16
012394 E7 ED 01 00 		      	push 	bp
012398 02 BF 01 1A 		      	mov  	bp,sp
01239C 15 EF 11 00 		      	subui	sp,sp,#8
0123A0 E7 E5 01 00 		      	push 	r11
0123A4 67 E6 01 00 		      	push 	r12
0123A8 E7 E6 01 00 		      	push 	r13
0123AC 67 E7 01 00 		      	push 	r14
0123B0 E7 E7 01 00 		      	push 	r15
0123B4 67 E8 01 00 		      	push 	r16
0123B8 E7 E8 01 00 		      	push 	r17
0123BC 0A B0 A0 07 		      	ldi  	r11,#RTCC_BUF
0123C0 C6 CD A0 00 		      	lw   	r12,80[bp]
0123C4 C6 DD 90 00 		      	lw   	r13,72[bp]
0123C8 C6 ED 80 00 		      	lw   	r14,64[bp]
0123CC C6 FD 70 00 		      	lw   	r15,56[bp]
0123D0 C6 0D 61 00 		      	lw   	r16,48[bp]
0123D4 C6 1D 51 00 		      	lw   	r17,40[bp]
0123D8 BD 08 20 00 		      	beq  	r17,set_time_serial_2
0123DC C1 35 0C 00 		      	lbu  	r3,6[r11]
0123E0 82 31 00 20 		      	sxb  	r3,r3
0123E4 E3 3D F0 FF 		      	sw   	r3,-8[bp]
0123E8 0A 30 A0 0F 		      	ldi  	r3,#2000
0123EC C6 4D F0 FF 		      	lw   	r4,-8[bp]
0123F0 0C 42 1E 00 		      	and  	r4,r4,#15
0123F4 C6 5D F0 FF 		      	lw   	r5,-8[bp]
0123F8 8C 52 E0 01 		      	and  	r5,r5,#240
0123FC 82 52 08 78 		      	asri 	r5,r5,#4
012400 87 52 14 00 		      	mul  	r5,r5,#10
012404 02 42 0A 28 		      	addu 	r4,r4,r5
012408 82 31 08 28 		      	addu 	r3,r3,r4
01240C E3 3D F0 FF 		      	sw   	r3,-8[bp]
012410 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012414 E3 38 00 00 		      	sw   	r3,[r17]
                	set_time_serial_2:
012418 3D 08 1C 00 		      	beq  	r16,set_time_serial_4
01241C C1 35 08 00 		      	lbu  	r3,4[r11]
012420 82 31 00 20 		      	sxb  	r3,r3
012424 E3 3D F0 FF 		      	sw   	r3,-8[bp]
012428 C6 3D F0 FF 		      	lw   	r3,-8[bp]
01242C 8C 31 1E 00 		      	and  	r3,r3,#15
012430 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012434 0C 42 20 00 		      	and  	r4,r4,#16
012438 02 42 08 78 		      	asri 	r4,r4,#4
01243C 07 42 14 00 		      	mul  	r4,r4,#10
012440 82 31 08 28 		      	addu 	r3,r3,r4
012444 E3 3D F0 FF 		      	sw   	r3,-8[bp]
012448 C6 3D F0 FF 		      	lw   	r3,-8[bp]
01244C 63 38 00 00 		      	sw   	r3,[r16]
                	set_time_serial_4:
012450 BD 07 1C 00 		      	beq  	r15,set_time_serial_6
012454 C1 35 0A 00 		      	lbu  	r3,5[r11]
012458 82 31 00 20 		      	sxb  	r3,r3
01245C E3 3D F0 FF 		      	sw   	r3,-8[bp]
012460 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012464 8C 31 1E 00 		      	and  	r3,r3,#15
012468 C6 4D F0 FF 		      	lw   	r4,-8[bp]
01246C 0C 42 60 00 		      	and  	r4,r4,#48
012470 02 42 08 78 		      	asri 	r4,r4,#4
012474 07 42 14 00 		      	mul  	r4,r4,#10
012478 82 31 08 28 		      	addu 	r3,r3,r4
01247C E3 3D F0 FF 		      	sw   	r3,-8[bp]
012480 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012484 E3 37 00 00 		      	sw   	r3,[r15]
                	set_time_serial_6:
012488 3D 07 22 00 		      	beq  	r14,set_time_serial_8
01248C C1 35 04 00 		      	lbu  	r3,2[r11]
012490 82 31 00 20 		      	sxb  	r3,r3
012494 E3 3D F0 FF 		      	sw   	r3,-8[bp]
012498 C6 3D F0 FF 		      	lw   	r3,-8[bp]
01249C 8C 31 1E 00 		      	and  	r3,r3,#15
0124A0 C6 4D F0 FF 		      	lw   	r4,-8[bp]
0124A4 0C 42 60 00 		      	and  	r4,r4,#48
0124A8 02 42 08 78 		      	asri 	r4,r4,#4
0124AC 07 42 14 00 		      	mul  	r4,r4,#10
0124B0 82 31 08 28 		      	addu 	r3,r3,r4
0124B4 E3 3D F0 FF 		      	sw   	r3,-8[bp]
0124B8 C6 3D F0 FF 		      	lw   	r3,-8[bp]
0124BC 8C 31 7E 00 		      	and  	r3,r3,#63
0124C0 E3 3D F0 FF 		      	sw   	r3,-8[bp]
0124C4 C6 3D F0 FF 		      	lw   	r3,-8[bp]
0124C8 63 37 00 00 		      	sw   	r3,[r14]
                	set_time_serial_8:
0124CC BD 06 1C 00 		      	beq  	r13,set_time_serial_10
0124D0 C1 35 02 00 		      	lbu  	r3,1[r11]
0124D4 82 31 00 20 		      	sxb  	r3,r3
0124D8 E3 3D F0 FF 		      	sw   	r3,-8[bp]
0124DC C6 3D F0 FF 		      	lw   	r3,-8[bp]
0124E0 8C 31 1E 00 		      	and  	r3,r3,#15
0124E4 C6 4D F0 FF 		      	lw   	r4,-8[bp]
0124E8 0C 42 E0 00 		      	and  	r4,r4,#112
0124EC 02 42 08 78 		      	asri 	r4,r4,#4
0124F0 07 42 14 00 		      	mul  	r4,r4,#10
0124F4 82 31 08 28 		      	addu 	r3,r3,r4
0124F8 E3 3D F0 FF 		      	sw   	r3,-8[bp]
0124FC C6 3D F0 FF 		      	lw   	r3,-8[bp]
012500 E3 36 00 00 		      	sw   	r3,[r13]
                	set_time_serial_10:
012504 3D 06 1C 00 		      	beq  	r12,set_time_serial_12
012508 C1 35 00 00 		      	lbu  	r3,[r11]
01250C 82 31 00 20 		      	sxb  	r3,r3
012510 E3 3D F0 FF 		      	sw   	r3,-8[bp]
012514 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012518 8C 31 1E 00 		      	and  	r3,r3,#15
01251C C6 4D F0 FF 		      	lw   	r4,-8[bp]
012520 0C 42 E0 00 		      	and  	r4,r4,#112
012524 02 42 08 78 		      	asri 	r4,r4,#4
012528 07 42 14 00 		      	mul  	r4,r4,#10
01252C 82 31 08 28 		      	addu 	r3,r3,r4
012530 E3 3D F0 FF 		      	sw   	r3,-8[bp]
012534 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012538 63 36 00 00 		      	sw   	r3,[r12]
                	set_time_serial_12:
                	set_time_serial_14:
01253C 57 1F 11 00 		      	pop  	r17
012540 57 0F 11 00 		      	pop  	r16
012544 57 FF 10 00 		      	pop  	r15
012548 57 EF 10 00 		      	pop  	r14
01254C 57 DF 10 00 		      	pop  	r13
012550 57 CF 10 00 		      	pop  	r12
012554 57 BF 10 00 		      	pop  	r11
012558 82 ED 01 1A 		      	mov  	sp,bp
01255C 57 BF 11 00 		      	pop  	bp
012560 37 FF 21 00 		      	rtl  	#16
                	ToJul:
012564 15 EF 21 00 		      	subui	sp,sp,#16
012568 E7 ED 01 00 		      	push 	bp
01256C 02 BF 01 1A 		      	mov  	bp,sp
012570 15 EF 41 00 		      	subui	sp,sp,#32
012574 C6 3D 50 00 		      	lw   	r3,40[bp]
012578 E3 3D E0 FF 		      	sw   	r3,-16[bp]
01257C C6 3D 60 00 		      	lw   	r3,48[bp]
012580 E3 3D D0 FF 		      	sw   	r3,-24[bp]
012584 C6 3D 70 00 		      	lw   	r3,56[bp]
012588 E3 3D C0 FF 		      	sw   	r3,-32[bp]
01258C FC FF FF FF 		      	ldi  	r3,#-32075
012590 0A 30 6A 05 
012594 C6 4D C0 FF 		      	lw   	r4,-32[bp]
012598 7C 6B 00 00 		      	ldi  	r5,#7012800
01259C 0A 50 80 03 
0125A0 C6 6D E0 FF 		      	lw   	r6,-16[bp]
0125A4 C6 7D D0 FF 		      	lw   	r7,-24[bp]
0125A8 95 73 1C 00 		      	subu 	r7,r7,#14
0125AC 88 73 18 00 		      	divs 	r7,r7,#12
0125B0 02 63 0E 28 		      	addu 	r6,r6,r7
0125B4 07 63 6A 0B 		      	mul  	r6,r6,#1461
0125B8 82 52 0C 28 		      	addu 	r5,r5,r6
0125BC 82 52 04 78 		      	asri 	r5,r5,#2
0125C0 02 42 0A 28 		      	addu 	r4,r4,r5
0125C4 0A 50 44 FA 		      	ldi  	r5,#-734
0125C8 C6 6D D0 FF 		      	lw   	r6,-24[bp]
0125CC C6 7D D0 FF 		      	lw   	r7,-24[bp]
0125D0 95 73 1C 00 		      	subu 	r7,r7,#14
0125D4 88 73 18 00 		      	divs 	r7,r7,#12
0125D8 87 73 18 00 		      	mul  	r7,r7,#12
0125DC 02 63 0E 2A 		      	subu 	r6,r6,r7
0125E0 07 63 DE 02 		      	mul  	r6,r6,#367
0125E4 82 52 0C 28 		      	addu 	r5,r5,r6
0125E8 88 52 18 00 		      	divs 	r5,r5,#12
0125EC 02 42 0A 28 		      	addu 	r4,r4,r5
0125F0 0A 50 48 26 		      	ldi  	r5,#4900
0125F4 C6 6D E0 FF 		      	lw   	r6,-16[bp]
0125F8 C6 7D D0 FF 		      	lw   	r7,-24[bp]
0125FC 95 73 1C 00 		      	subu 	r7,r7,#14
012600 88 73 18 00 		      	divs 	r7,r7,#12
012604 02 63 0E 28 		      	addu 	r6,r6,r7
012608 82 52 0C 28 		      	addu 	r5,r5,r6
01260C 88 52 C8 00 		      	divs 	r5,r5,#100
012610 87 52 06 00 		      	mul  	r5,r5,#3
012614 82 52 04 78 		      	asri 	r5,r5,#2
012618 02 42 0A 2A 		      	subu 	r4,r4,r5
01261C 82 31 08 28 		      	addu 	r3,r3,r4
012620 E3 3D F0 FF 		      	sw   	r3,-8[bp]
012624 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012628 82 11 00 1A 		      	mov  	r1,r3
                	set_time_serial_17:
01262C 82 ED 01 1A 		      	mov  	sp,bp
012630 57 BF 11 00 		      	pop  	bp
012634 37 FF 21 00 		      	rtl  	#16
                	set_time_serial:
012638 E7 EF 01 00 		      	push 	lr
01263C 67 EE 01 00 		      	push 	xlr
012640 E7 ED 01 00 		      	push 	bp
012644 7C 01 00 00 		      	ldi  	xlr,#set_time_serial_19
012648 0A C0 D1 4D 
01264C 02 BF 01 1A 		      	mov  	bp,sp
012650 15 EF 91 00 		      	subui	sp,sp,#72
012654 E5 ED 81 FF 		      	pea  	-64[bp]
012658 E5 ED 91 FF 		      	pea  	-56[bp]
01265C E5 ED A1 FF 		      	pea  	-48[bp]
012660 E5 ED B1 FF 		      	pea  	-40[bp]
012664 E5 ED C1 FF 		      	pea  	-32[bp]
012668 E5 ED D1 FF 		      	pea  	-24[bp]
01266C B9 A4 FF FF 		      	bsr  	get_datetime
012670 14 EF 61 00 		      	addui	sp,sp,#48
012674 C6 3D 80 FF 		      	lw   	r3,-64[bp]
012678 82 31 14 70 		      	asli 	r3,r3,#10
01267C C6 4D 90 FF 		      	lw   	r4,-56[bp]
012680 FC 00 00 00 		      	mul  	r4,r4,#61440
012684 07 42 00 E0 
012688 82 31 08 28 		      	addu 	r3,r3,r4
01268C C6 4D A0 FF 		      	lw   	r4,-48[bp]
012690 7C 38 00 00 		      	mul  	r4,r4,#3686400
012694 07 42 00 80 
012698 82 31 08 28 		      	addu 	r3,r3,r4
01269C E7 E1 01 00 		      	push 	r3
0126A0 E6 ED B1 FF 		      	push 	-40[bp]
0126A4 E6 ED C1 FF 		      	push 	-32[bp]
0126A8 E6 ED D1 FF 		      	push 	-24[bp]
0126AC 39 D7 FF FF 		      	bsr  	ToJul
0126B0 14 EF 31 00 		      	addui	sp,sp,#24
0126B4 57 3F 10 00 		      	pop  	r3
0126B8 82 40 00 1A 		      	mov  	r4,r1
0126BC 7C 46 05 00 		      	mul  	r4,r4,#88473600
0126C0 07 42 00 00 
0126C4 82 31 08 28 		      	addu 	r3,r3,r4
0126C8 63 30 10 02 		      	sw   	r3,Milliseconds
0126CC C6 3D E0 FF 		      	lw   	r3,-16[bp]
0126D0 82 11 00 1A 		      	mov  	r1,r3
                	set_time_serial_20:
0126D4 82 ED 01 1A 		      	mov  	sp,bp
0126D8 57 BF 11 00 		      	pop  	bp
0126DC 57 CF 11 00 		      	pop  	xlr
0126E0 57 FF 11 00 		      	pop  	lr
0126E4 37 FF 01 00 		      	rtl  	#0
                	set_time_serial_19:
0126E8 C6 FD 11 00 		      	lw   	lr,8[bp]
0126EC E3 FD 21 00 		      	sw   	lr,16[bp]
0126F0 BA FC FF FF 		      	bra  	set_time_serial_20
                	        code
                	
                	pSpriteController:
0126F4 00 D0 DA FF 		dw	-2437120
0126F8 FF FF FF FF 
                	
                	sprite_demo:
0126FC 15 EF 21 00 		      	subui	sp,sp,#16
012700 E7 ED 01 00 		      	push 	bp
012704 02 BF 01 1A 		      	mov  	bp,sp
012708 15 EF 31 00 		      	subui	sp,sp,#24
01270C E7 E5 01 00 		      	push 	r11
012710 67 E6 01 00 		      	push 	r12
012714 E7 E6 01 00 		      	push 	r13
012718 FC 03 00 00 		      	ldi  	r11,#sprites
01271C 0A B0 00 E0 
012720 7C DC FF FF 		      	ldi  	r12,#-2356224
012724 0A C0 00 18 
012728 7C D8 FF FF 		      	ldi  	r13,#-2621440
01272C 0A D0 00 00 
012730 E3 0D F0 FF 		      	sw   	r0,-8[bp]
                	sprite_demo_4:
012734 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012738 86 31 40 00 		      	cmp  	r3,r3,#32
01273C BD 31 18 00 		      	bge  	r3,sprite_demo_5
012740 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012744 82 31 04 70 		      	asli 	r3,r3,#2
012748 82 31 04 70 		      	asli 	r3,r3,#2
01274C 7C 01 00 00 		      	lw   	r4,pSpriteController
012750 46 40 E8 4D 
012754 82 31 08 28 		      	addu 	r3,r3,r4
012758 C5 41 08 00 		      	lhu  	r4,4[r3]
01275C 0D 42 98 01 		      	ori  	r4,r4,#204
012760 E2 41 08 00 		      	sh   	r4,4[r3]
                	sprite_demo_6:
012764 E4 1D F0 FF 		      	inc  	-8[bp],#1
012768 BA F9 FF FF 		      	bra  	sprite_demo_4
                	sprite_demo_5:
01276C E3 0D F0 FF 		      	sw   	r0,-8[bp]
                	sprite_demo_7:
012770 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012774 7C 00 00 00 		      	cmp  	r3,r3,#16384
012778 86 31 00 80 
01277C BD 31 0E 00 		      	bge  	r3,sprite_demo_8
012780 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012784 82 31 04 70 		      	asli 	r3,r3,#2
012788 45 46 00 00 		      	lhu  	r4,[r12]
01278C EA 46 06 00 		      	sh   	r4,0[r13+r3]
                	sprite_demo_9:
012790 E4 1D F0 FF 		      	inc  	-8[bp],#1
012794 BA FB FF FF 		      	bra  	sprite_demo_7
                	sprite_demo_8:
012798 E3 0D F0 FF 		      	sw   	r0,-8[bp]
                	sprite_demo_10:
01279C C6 3D F0 FF 		      	lw   	r3,-8[bp]
0127A0 86 31 40 00 		      	cmp  	r3,r3,#32
0127A4 BD 31 38 00 		      	bge  	r3,sprite_demo_11
0127A8 46 36 00 00 		      	lw   	r3,[r12]
0127AC 89 31 A8 0A 		      	mod  	r3,r3,#1364
0127B0 C6 4D F0 FF 		      	lw   	r4,-8[bp]
0127B4 02 42 0A 70 		      	asli 	r4,r4,#5
0127B8 EB 35 08 00 		      	sw   	r3,0[r11+r4]
0127BC 46 36 00 00 		      	lw   	r3,[r12]
0127C0 89 31 00 06 		      	mod  	r3,r3,#768
0127C4 C6 4D F0 FF 		      	lw   	r4,-8[bp]
0127C8 02 42 0A 70 		      	asli 	r4,r4,#5
0127CC 02 42 16 28 		      	addu 	r4,r4,r11
0127D0 63 32 10 00 		      	sw   	r3,8[r4]
0127D4 46 36 00 00 		      	lw   	r3,[r12]
0127D8 8C 31 0E 00 		      	and  	r3,r3,#7
0127DC 95 31 08 00 		      	subu 	r3,r3,#4
0127E0 C6 4D F0 FF 		      	lw   	r4,-8[bp]
0127E4 02 42 0A 70 		      	asli 	r4,r4,#5
0127E8 02 42 16 28 		      	addu 	r4,r4,r11
0127EC 63 32 20 00 		      	sw   	r3,16[r4]
0127F0 46 36 00 00 		      	lw   	r3,[r12]
0127F4 8C 31 0E 00 		      	and  	r3,r3,#7
0127F8 95 31 08 00 		      	subu 	r3,r3,#4
0127FC C6 4D F0 FF 		      	lw   	r4,-8[bp]
012800 02 42 0A 70 		      	asli 	r4,r4,#5
012804 02 42 16 28 		      	addu 	r4,r4,r11
012808 63 32 30 00 		      	sw   	r3,24[r4]
                	sprite_demo_12:
01280C E4 1D F0 FF 		      	inc  	-8[bp],#1
012810 BA F1 FF FF 		      	bra  	sprite_demo_10
                	sprite_demo_11:
                	sprite_demo_13:
012814 0A 30 02 00 		      	ldi  	r3,#1
012818 BD 01 68 00 		      	beq  	r3,sprite_demo_14
01281C E3 0D F0 FF 		      	sw   	r0,-8[bp]
                	sprite_demo_15:
012820 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012824 86 31 40 00 		      	cmp  	r3,r3,#32
012828 BD 31 58 00 		      	bge  	r3,sprite_demo_16
01282C C6 3D F0 FF 		      	lw   	r3,-8[bp]
012830 82 31 0A 70 		      	asli 	r3,r3,#5
012834 CE 35 06 00 		      	lw   	r3,0[r11+r3]
012838 C6 4D F0 FF 		      	lw   	r4,-8[bp]
01283C 02 42 0A 70 		      	asli 	r4,r4,#5
012840 02 42 16 28 		      	addu 	r4,r4,r11
012844 46 42 20 00 		      	lw   	r4,16[r4]
012848 82 31 08 28 		      	addu 	r3,r3,r4
01284C 8C 31 FE 07 		      	and  	r3,r3,#1023
012850 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012854 02 42 0A 70 		      	asli 	r4,r4,#5
012858 EB 35 08 00 		      	sw   	r3,0[r11+r4]
01285C C6 3D F0 FF 		      	lw   	r3,-8[bp]
012860 82 31 0A 70 		      	asli 	r3,r3,#5
012864 82 31 16 28 		      	addu 	r3,r3,r11
012868 C6 31 10 00 		      	lw   	r3,8[r3]
01286C C6 4D F0 FF 		      	lw   	r4,-8[bp]
012870 02 42 0A 70 		      	asli 	r4,r4,#5
012874 02 42 16 28 		      	addu 	r4,r4,r11
012878 46 42 30 00 		      	lw   	r4,24[r4]
01287C 82 31 08 28 		      	addu 	r3,r3,r4
012880 8C 31 FE 03 		      	and  	r3,r3,#511
012884 C6 4D F0 FF 		      	lw   	r4,-8[bp]
012888 02 42 0A 70 		      	asli 	r4,r4,#5
01288C 02 42 16 28 		      	addu 	r4,r4,r11
012890 63 32 10 00 		      	sw   	r3,8[r4]
012894 C6 3D F0 FF 		      	lw   	r3,-8[bp]
012898 82 31 0A 70 		      	asli 	r3,r3,#5
01289C CE 35 06 00 		      	lw   	r3,0[r11+r3]
0128A0 C6 4D F0 FF 		      	lw   	r4,-8[bp]
0128A4 02 42 0A 70 		      	asli 	r4,r4,#5
0128A8 02 42 16 28 		      	addu 	r4,r4,r11
0128AC 46 42 10 00 		      	lw   	r4,8[r4]
0128B0 02 42 20 70 		      	asli 	r4,r4,#16
0128B4 82 31 08 28 		      	addu 	r3,r3,r4
0128B8 C6 4D F0 FF 		      	lw   	r4,-8[bp]
0128BC 02 42 04 70 		      	asli 	r4,r4,#2
0128C0 02 42 04 70 		      	asli 	r4,r4,#2
0128C4 7C 01 00 00 		      	lw   	r5,pSpriteController
0128C8 46 50 E8 4D 
0128CC EA 32 08 00 		      	sh   	r3,0[r5+r4]
                	sprite_demo_17:
0128D0 E4 1D F0 FF 		      	inc  	-8[bp],#1
0128D4 BA E9 FF FF 		      	bra  	sprite_demo_15
                	sprite_demo_16:
0128D8 7C 0F 00 00 		      	     	            ldi  r1,#1000000
0128DC 0A 10 80 84 
0128E0 39 27 FF FF 	            bsr  MicroDelay
                	        
0128E4 3A E6 FF FF 		      	bra  	sprite_demo_13
                	sprite_demo_14:
                	sprite_demo_18:
0128E8 57 DF 10 00 		      	pop  	r13
0128EC 57 CF 10 00 		      	pop  	r12
0128F0 57 BF 10 00 		      	pop  	r11
0128F4 82 ED 01 1A 		      	mov  	sp,bp
0128F8 57 BF 11 00 		      	pop  	bp
0128FC 37 FF 21 00 		      	rtl  	#16
                	
                	; error codes
                	E_Ok		=		0x00
                	E_Arg		=		0x01
                	E_BadMbx	=		0x04
                	E_QueFull	=		0x05
                	E_NoThread	=		0x06
                	E_NotAlloc	=		0x09
                	E_NoMsg		=		0x0b
                	E_Timeout	=		0x10
                	E_BadAlarm	=		0x11
                	E_NotOwner	=		0x12
                	E_QueStrategy =		0x13
                	E_BadDevNum	=		0x18
                	E_DCBInUse	=		0x19
                	; Device driver errors
                	E_BadDevNum	=		0x20
                	E_NoDev		=		0x21
                	E_BadDevOp	=		0x22
                	E_ReadError	=		0x23
                	E_WriteError =		0x24
                	E_BadBlockNum	=	0x25
                	E_TooManyBlocks	=	0x26
                	
                	; resource errors
                	E_NoMoreMbx	=		0x40
                	E_NoMoreMsgBlks	=	0x41
                	E_NoMoreAlarmBlks	=0x44
                	E_NoMoreTCBs	=	0x45
                	E_NoMem		= 12
                	
                	; task status
                	TS_NONE     =0
                	TS_TIMEOUT	=1
                	TS_WAITMSG	=2
                	TS_PREEMPT	=4
                	TS_RUNNING	=8
                	TS_READY	=16
                	TS_SLEEP	=32
                	
                	TS_TIMEOUT_BIT	=0
                	TS_WAITMSG_BIT	=1
                	TS_RUNNING_BIT	=3
                	TS_READY_BIT	=4
                	
                	PRI_HIGHEST	=0
                	PRI_HIGH	=1
                	PRI_NORMAL	=3
                	PRI_LOW		=5
                	PRI_LOWEST	=7
                	
                	
                	NR_TCB		EQU		256
                	TCB_BackLink    EQU     0
                	TCB_r1          EQU     8
                	TCB_r2          EQU     $10
                	TCB_r3          EQU     $18
                	TCB_r4          EQU     $20
                	TCB_r5          EQU     $28
                	TCB_r6          EQU     $30
                	TCB_r7          EQU     $38
                	TCB_r8          EQU     $40
                	TCB_r9          EQU     $48
                	TCB_r10         EQU     $50
                	TCB_r11         EQU     $58
                	TCB_r12         EQU     $60
                	TCB_r13         EQU     $68
                	TCB_r14         EQU     $70
                	TCB_r15         EQU     $78
                	TCB_r16         EQU     $80
                	TCB_r17         EQU     $88
                	TCB_r18         EQU     $90
                	TCB_r19         EQU     $98
                	TCB_r20         EQU     $A0
                	TCB_r21         EQU     $A8
                	TCB_r22         EQU     $B0
                	TCB_r23         EQU     $B8
                	TCB_r24         EQU     $C0
                	TCB_r25         EQU     $C8
                	TCB_r26         EQU     $D0
                	TCB_r27         EQU     $D8
                	TCB_r28         EQU     $E0
                	TCB_r29         EQU     $E8
                	TCB_r30         EQU     $F0
                	TCB_r31         EQU     $F8
                	
                	TCB_SP0Save		EQU		0x100
                	TCB_SP1Save		EQU		0x108
                	TCB_SP2Save		EQU		0x110
                	TCB_SP3Save		EQU		0x118
                	TCB_SP4Save		EQU		0x120
                	TCB_SP5Save		EQU		0x128
                	TCB_SP6Save		EQU		0x130
                	TCB_SP7Save		EQU		0x138
                	TCB_SP8Save		EQU		0x140
                	TCB_SP9Save		EQU		0x148
                	TCB_SP10Save	EQU		0x150
                	TCB_SP11Save	EQU		0x158
                	TCB_SP12Save	EQU		0x160
                	TCB_SP13Save	EQU		0x168
                	TCB_SP14Save	EQU		0x170
                	TCB_SP15Save	EQU		0x178
                	
                	TCB_IPC         EQU     0x180
                	TCB_DPC         EQU     0x188
                	TCB_EPC         EQU     0x190
                	
                	TCB_NextRdy     EQU     $200
                	TCB_PrevRdy     EQU     $208
                	TCB_Status      EQU     $210
                	TCB_Priority    EQU     $212
                	TCB_hJCB        EQU     $214
                	TCB_NextFree    EQU     $218
                	TCB_PrevFree    EQU     $220
                	TCB_NextTo      EQU     $228
                	TCB_PrevTo      EQU     $230
                	TCB_mbq_next    EQU     $238
                	TCB_mbq_prev    EQU     $240
                	TCB_MSG_D1      EQU     $248
                	TCB_MSG_D2      EQU     $250
                	TCB_hWaitMbx    EQU     $258
                	TCB_MbxList     EQU     $260
                	TCB_StackTop    EQU     $268
                	TCB_errno       EQU     $270
                	TCB_Timeout     EQU     $278
                	TCB_Affinity    EQU     $280
                	TCB_Size	    EQU	    $300
                	
                	; Mailboxes, room for 2048
                	;			.bss
                	;			.org		0x07E40000
                	NR_MBX		EQU		2048
                	MBX_LINK		EQU     $00       ; link to next mailbox in list (free list)
                	MBX_TQ_HEAD		EQU     $08       ; head of task queue
                	MBX_TQ_TAIL		EQU     $18
                	MBX_MQ_HEAD		EQU     $20	      ; head of message queue
                	MBX_MQ_TAIL		EQU     $28
                	MBX_TQ_COUNT	EQU     $30	      ; count of queued threads
                	MBX_MQ_SIZE		EQU     $38       ; number of messages that may be queued
                	MBX_MQ_COUNT	EQU     $40       ; count of messages that are queued
                	MBX_MQ_MISSED	EQU     $48	      ; number of messages dropped from queue
                	MBX_OWNER		EQU     $50	      ; job handle of mailbox owner
                	MBX_MQ_STRATEGY	EQU     $58	      ; message queueing strategy
                	MBX_Size        EQU     $60
                	
                	MQ_UNLIMITED    EQU     0
                	MQ_OLDEST       EQU     1
                	MQ_NEWEST       EQU     2
                	
                	; Messages, room for 64kW (16,384) messages
                	;			.bss
                	;			.org		0x07E80000
                	NR_MSG		EQU		32768
                	MSG_LINK	EQU     $00	        ; link to next message in queue or free list
                	MSG_D1		EQU     $08         ; message data 1
                	MSG_D2		EQU     $10	        ; message data 2
                	MSG_TYPE	EQU     $18	        ; message type
                	MSG_Size    EQU     $20
                	
                	MT_SEMA		EQU		-1
                	MT_IRQ		EQU		-16
                	MT_GETCHAR	EQU		-17
                	
                	
                	NR_JCB			EQU		51
                	JCB_Number		EQU		0
                	JCB_Name		EQU		4		; 32 bytes (1 len + 31)
                	JCB_MemGroup0	EQU		0x24	; memory map number associated with job
                	JCB_MemGroup1   EQU     0x26
                	JCB_MemGroup2   EQU     0x28
                	JCB_MemGroup3   EQU     0x2A
                	JCB_MemGroup4   EQU     0x2C
                	JCB_MemGroup5   EQU     0x2E
                	JCB_pCode		EQU		0x30
                	JCB_nCode		EQU		0x38	; size of code
                	JCB_pData		EQU		0x40
                	JCB_nData		EQU		0x48	; size of data
                	JCB_pStack		EQU		0x50
                	JCB_nStack		EQU		0x58
                	JCB_UserName	EQU		0x60	; 32 bytes
                	JCB_Path		EQU		0x80	; 256 bytes
                	JCB_ExitRF		EQU		0x180	; 256 bytes
                	JCB_CmdLine		EQU		0x280	; 256 bytes		
                	JCB_SysIn		EQU		0x380	; 48 chars
                	JCB_SysOut		EQU		0x3B0	; 48 chars
                	JCB_ExitError	EQU		0x3E0
                	JCB_pVidMem		EQU		0x3E8		; pointer to video memory
                	JCB_pVidMemAttr	EQU		0x3F0
                	JCB_pVirtVid	EQU		0x3F8		; pointer to virtual video buffer
                	JCB_pVirtVidAttr	EQU		0x400
                	JCB_VideoMode	EQU		0x408
                	JCB_VideoRows	EQU		0x40A
                	JCB_VideoCols	EQU		0x40B
                	JCB_CursorRow	EQU		0x40C
                	JCB_CursorCol	EQU		0x40D
                	JCB_CursorOn	EQU		0x40E
                	JCB_CursorFlash	EQU		0x40F
                	JCB_CursorType	EQU		0x410
                	JCB_NormAttr	EQU		0x414
                	JCB_CurrAttr	EQU		0x418
                	JCB_ScrlCnt		EQU		0x41C
                	JCB_fVidPause	EQU		0x41E
                	JCB_Next		EQU		0x420
                	JCB_iof_next	EQU		0x428		; I/O focus list
                	JCB_iof_prev	EQU		0x430
                	JCB_KeybdHead	EQU		0x438
                	JCB_KeybdTail	EQU		0x440
                	JCB_KeybdEcho	EQU		0x448
                	JCB_KeybdBad	EQU		0x449
                	JCB_KeybdAck	EQU		0x44A
                	JCB_KeybdLocks	EQU		0x44C
                	JCB_KeybdBuffer	EQU		0x450		; buffer is 16 words (chars = words)
                	JCB_esc			EQU		0x470		; escape flag for DisplayChar processing
                	JCB_Size		EQU		0x500
                	JCB_LogSize		EQU		10
                	
                	BITMAP_SCREEN1  EQU     $400000     ; bitmap graphics screen area (4MB)
                	BITMAP_SCREEN2  EQU     $800000     ; bitmap graphics screen area (4MB)
                	VAR_Area        EQU     $C00000     ; 64k block for OS vars
                	TCB_Array       EQU     $C10000     ; room for 256 TCB's (192kB)
                	TCB_ArrayEnd    EQU     $C40000
                	JCB_Array       EQU     $C40000
                	JCB_ArrayEnd    EQU     $C50000     ; room for 51 JCB's  (64kB)
                	MBX_Array       EQU     $C60000     ; room for 2048 mailboxes (192kB)
                	MBX_ArrayEnd    EQU     $C90000
                	MSG_Array       EQU     $C90000     ; room for 32,768 messages (1MB)
                	MSG_ArrayEnd    EQU     $D90000
                	SCREEN_Array    EQU     $D90000     ; room for 51 16kB screens
                	SCREEN_ArrayEnd EQU     $E90000
                	STACKS_Array    EQU    $7F00000     ; room for 256 TCB stacks of 4kB each
                	STACKS_ArrayEnd EQU    $8000000
                	MEM_END         EQU    $8000000
                	
                	    code
012900 00 00 00 00 		org		$14000
012904 00 00 00 00 
012908 00 00 00 00 
01290C 00 00 00 00 
012910 00 00 00 00 
012914 00 00 00 00 
012918 00 00 00 00 
01291C 00 00 00 00 
012920 00 00 00 00 
012924 00 00 00 00 
012928 00 00 00 00 
01292C 00 00 00 00 
012930 00 00 00 00 
012934 00 00 00 00 
012938 00 00 00 00 
01293C 00 00 00 00 
012940 00 00 00 00 
012944 00 00 00 00 
012948 00 00 00 00 
01294C 00 00 00 00 
012950 00 00 00 00 
012954 00 00 00 00 
012958 00 00 00 00 
01295C 00 00 00 00 
012960 00 00 00 00 
012964 00 00 00 00 
012968 00 00 00 00 
01296C 00 00 00 00 
012970 00 00 00 00 
012974 00 00 00 00 
012978 00 00 00 00 
01297C 00 00 00 00 
012980 00 00 00 00 
012984 00 00 00 00 
012988 00 00 00 00 
01298C 00 00 00 00 
012990 00 00 00 00 
012994 00 00 00 00 
012998 00 00 00 00 
01299C 00 00 00 00 
0129A0 00 00 00 00 
0129A4 00 00 00 00 
0129A8 00 00 00 00 
0129AC 00 00 00 00 
0129B0 00 00 00 00 
0129B4 00 00 00 00 
0129B8 00 00 00 00 
0129BC 00 00 00 00 
0129C0 00 00 00 00 
0129C4 00 00 00 00 
0129C8 00 00 00 00 
0129CC 00 00 00 00 
0129D0 00 00 00 00 
0129D4 00 00 00 00 
0129D8 00 00 00 00 
0129DC 00 00 00 00 
0129E0 00 00 00 00 
0129E4 00 00 00 00 
0129E8 00 00 00 00 
0129EC 00 00 00 00 
0129F0 00 00 00 00 
0129F4 00 00 00 00 
0129F8 00 00 00 00 
0129FC 00 00 00 00 
012A00 00 00 00 00 
012A04 00 00 00 00 
012A08 00 00 00 00 
012A0C 00 00 00 00 
012A10 00 00 00 00 
012A14 00 00 00 00 
012A18 00 00 00 00 
012A1C 00 00 00 00 
012A20 00 00 00 00 
012A24 00 00 00 00 
012A28 00 00 00 00 
012A2C 00 00 00 00 
012A30 00 00 00 00 
012A34 00 00 00 00 
012A38 00 00 00 00 
012A3C 00 00 00 00 
012A40 00 00 00 00 
012A44 00 00 00 00 
012A48 00 00 00 00 
012A4C 00 00 00 00 
012A50 00 00 00 00 
012A54 00 00 00 00 
012A58 00 00 00 00 
012A5C 00 00 00 00 
012A60 00 00 00 00 
012A64 00 00 00 00 
012A68 00 00 00 00 
012A6C 00 00 00 00 
012A70 00 00 00 00 
012A74 00 00 00 00 
012A78 00 00 00 00 
012A7C 00 00 00 00 
012A80 00 00 00 00 
012A84 00 00 00 00 
012A88 00 00 00 00 
012A8C 00 00 00 00 
012A90 00 00 00 00 
012A94 00 00 00 00 
012A98 00 00 00 00 
012A9C 00 00 00 00 
012AA0 00 00 00 00 
012AA4 00 00 00 00 
012AA8 00 00 00 00 
012AAC 00 00 00 00 
012AB0 00 00 00 00 
012AB4 00 00 00 00 
012AB8 00 00 00 00 
012ABC 00 00 00 00 
012AC0 00 00 00 00 
012AC4 00 00 00 00 
012AC8 00 00 00 00 
012ACC 00 00 00 00 
012AD0 00 00 00 00 
012AD4 00 00 00 00 
012AD8 00 00 00 00 
012ADC 00 00 00 00 
012AE0 00 00 00 00 
012AE4 00 00 00 00 
012AE8 00 00 00 00 
012AEC 00 00 00 00 
012AF0 00 00 00 00 
012AF4 00 00 00 00 
012AF8 00 00 00 00 
012AFC 00 00 00 00 
012B00 00 00 00 00 
012B04 00 00 00 00 
012B08 00 00 00 00 
012B0C 00 00 00 00 
012B10 00 00 00 00 
012B14 00 00 00 00 
012B18 00 00 00 00 
012B1C 00 00 00 00 
012B20 00 00 00 00 
012B24 00 00 00 00 
012B28 00 00 00 00 
012B2C 00 00 00 00 
012B30 00 00 00 00 
012B34 00 00 00 00 
012B38 00 00 00 00 
012B3C 00 00 00 00 
012B40 00 00 00 00 
012B44 00 00 00 00 
012B48 00 00 00 00 
012B4C 00 00 00 00 
012B50 00 00 00 00 
012B54 00 00 00 00 
012B58 00 00 00 00 
012B5C 00 00 00 00 
012B60 00 00 00 00 
012B64 00 00 00 00 
012B68 00 00 00 00 
012B6C 00 00 00 00 
012B70 00 00 00 00 
012B74 00 00 00 00 
012B78 00 00 00 00 
012B7C 00 00 00 00 
012B80 00 00 00 00 
012B84 00 00 00 00 
012B88 00 00 00 00 
012B8C 00 00 00 00 
012B90 00 00 00 00 
012B94 00 00 00 00 
012B98 00 00 00 00 
012B9C 00 00 00 00 
012BA0 00 00 00 00 
012BA4 00 00 00 00 
012BA8 00 00 00 00 
012BAC 00 00 00 00 
012BB0 00 00 00 00 
012BB4 00 00 00 00 
012BB8 00 00 00 00 
012BBC 00 00 00 00 
012BC0 00 00 00 00 
012BC4 00 00 00 00 
012BC8 00 00 00 00 
012BCC 00 00 00 00 
012BD0 00 00 00 00 
012BD4 00 00 00 00 
012BD8 00 00 00 00 
012BDC 00 00 00 00 
012BE0 00 00 00 00 
012BE4 00 00 00 00 
012BE8 00 00 00 00 
012BEC 00 00 00 00 
012BF0 00 00 00 00 
012BF4 00 00 00 00 
012BF8 00 00 00 00 
012BFC 00 00 00 00 
012C00 00 00 00 00 
012C04 00 00 00 00 
012C08 00 00 00 00 
012C0C 00 00 00 00 
012C10 00 00 00 00 
012C14 00 00 00 00 
012C18 00 00 00 00 
012C1C 00 00 00 00 
012C20 00 00 00 00 
012C24 00 00 00 00 
012C28 00 00 00 00 
012C2C 00 00 00 00 
012C30 00 00 00 00 
012C34 00 00 00 00 
012C38 00 00 00 00 
012C3C 00 00 00 00 
012C40 00 00 00 00 
012C44 00 00 00 00 
012C48 00 00 00 00 
012C4C 00 00 00 00 
012C50 00 00 00 00 
012C54 00 00 00 00 
012C58 00 00 00 00 
012C5C 00 00 00 00 
012C60 00 00 00 00 
012C64 00 00 00 00 
012C68 00 00 00 00 
012C6C 00 00 00 00 
012C70 00 00 00 00 
012C74 00 00 00 00 
012C78 00 00 00 00 
012C7C 00 00 00 00 
012C80 00 00 00 00 
012C84 00 00 00 00 
012C88 00 00 00 00 
012C8C 00 00 00 00 
012C90 00 00 00 00 
012C94 00 00 00 00 
012C98 00 00 00 00 
012C9C 00 00 00 00 
012CA0 00 00 00 00 
012CA4 00 00 00 00 
012CA8 00 00 00 00 
012CAC 00 00 00 00 
012CB0 00 00 00 00 
012CB4 00 00 00 00 
012CB8 00 00 00 00 
012CBC 00 00 00 00 
012CC0 00 00 00 00 
012CC4 00 00 00 00 
012CC8 00 00 00 00 
012CCC 00 00 00 00 
012CD0 00 00 00 00 
012CD4 00 00 00 00 
012CD8 00 00 00 00 
012CDC 00 00 00 00 
012CE0 00 00 00 00 
012CE4 00 00 00 00 
012CE8 00 00 00 00 
012CEC 00 00 00 00 
012CF0 00 00 00 00 
012CF4 00 00 00 00 
012CF8 00 00 00 00 
012CFC 00 00 00 00 
012D00 00 00 00 00 
012D04 00 00 00 00 
012D08 00 00 00 00 
012D0C 00 00 00 00 
012D10 00 00 00 00 
012D14 00 00 00 00 
012D18 00 00 00 00 
012D1C 00 00 00 00 
012D20 00 00 00 00 
012D24 00 00 00 00 
012D28 00 00 00 00 
012D2C 00 00 00 00 
012D30 00 00 00 00 
012D34 00 00 00 00 
012D38 00 00 00 00 
012D3C 00 00 00 00 
012D40 00 00 00 00 
012D44 00 00 00 00 
012D48 00 00 00 00 
012D4C 00 00 00 00 
012D50 00 00 00 00 
012D54 00 00 00 00 
012D58 00 00 00 00 
012D5C 00 00 00 00 
012D60 00 00 00 00 
012D64 00 00 00 00 
012D68 00 00 00 00 
012D6C 00 00 00 00 
012D70 00 00 00 00 
012D74 00 00 00 00 
012D78 00 00 00 00 
012D7C 00 00 00 00 
012D80 00 00 00 00 
012D84 00 00 00 00 
012D88 00 00 00 00 
012D8C 00 00 00 00 
012D90 00 00 00 00 
012D94 00 00 00 00 
012D98 00 00 00 00 
012D9C 00 00 00 00 
012DA0 00 00 00 00 
012DA4 00 00 00 00 
012DA8 00 00 00 00 
012DAC 00 00 00 00 
012DB0 00 00 00 00 
012DB4 00 00 00 00 
012DB8 00 00 00 00 
012DBC 00 00 00 00 
012DC0 00 00 00 00 
012DC4 00 00 00 00 
012DC8 00 00 00 00 
012DCC 00 00 00 00 
012DD0 00 00 00 00 
012DD4 00 00 00 00 
012DD8 00 00 00 00 
012DDC 00 00 00 00 
012DE0 00 00 00 00 
012DE4 00 00 00 00 
012DE8 00 00 00 00 
012DEC 00 00 00 00 
012DF0 00 00 00 00 
012DF4 00 00 00 00 
012DF8 00 00 00 00 
012DFC 00 00 00 00 
012E00 00 00 00 00 
012E04 00 00 00 00 
012E08 00 00 00 00 
012E0C 00 00 00 00 
012E10 00 00 00 00 
012E14 00 00 00 00 
012E18 00 00 00 00 
012E1C 00 00 00 00 
012E20 00 00 00 00 
012E24 00 00 00 00 
012E28 00 00 00 00 
012E2C 00 00 00 00 
012E30 00 00 00 00 
012E34 00 00 00 00 
012E38 00 00 00 00 
012E3C 00 00 00 00 
012E40 00 00 00 00 
012E44 00 00 00 00 
012E48 00 00 00 00 
012E4C 00 00 00 00 
012E50 00 00 00 00 
012E54 00 00 00 00 
012E58 00 00 00 00 
012E5C 00 00 00 00 
012E60 00 00 00 00 
012E64 00 00 00 00 
012E68 00 00 00 00 
012E6C 00 00 00 00 
012E70 00 00 00 00 
012E74 00 00 00 00 
012E78 00 00 00 00 
012E7C 00 00 00 00 
012E80 00 00 00 00 
012E84 00 00 00 00 
012E88 00 00 00 00 
012E8C 00 00 00 00 
012E90 00 00 00 00 
012E94 00 00 00 00 
012E98 00 00 00 00 
012E9C 00 00 00 00 
012EA0 00 00 00 00 
012EA4 00 00 00 00 
012EA8 00 00 00 00 
012EAC 00 00 00 00 
012EB0 00 00 00 00 
012EB4 00 00 00 00 
012EB8 00 00 00 00 
012EBC 00 00 00 00 
012EC0 00 00 00 00 
012EC4 00 00 00 00 
012EC8 00 00 00 00 
012ECC 00 00 00 00 
012ED0 00 00 00 00 
012ED4 00 00 00 00 
012ED8 00 00 00 00 
012EDC 00 00 00 00 
012EE0 00 00 00 00 
012EE4 00 00 00 00 
012EE8 00 00 00 00 
012EEC 00 00 00 00 
012EF0 00 00 00 00 
012EF4 00 00 00 00 
012EF8 00 00 00 00 
012EFC 00 00 00 00 
012F00 00 00 00 00 
012F04 00 00 00 00 
012F08 00 00 00 00 
012F0C 00 00 00 00 
012F10 00 00 00 00 
012F14 00 00 00 00 
012F18 00 00 00 00 
012F1C 00 00 00 00 
012F20 00 00 00 00 
012F24 00 00 00 00 
012F28 00 00 00 00 
012F2C 00 00 00 00 
012F30 00 00 00 00 
012F34 00 00 00 00 
012F38 00 00 00 00 
012F3C 00 00 00 00 
012F40 00 00 00 00 
012F44 00 00 00 00 
012F48 00 00 00 00 
012F4C 00 00 00 00 
012F50 00 00 00 00 
012F54 00 00 00 00 
012F58 00 00 00 00 
012F5C 00 00 00 00 
012F60 00 00 00 00 
012F64 00 00 00 00 
012F68 00 00 00 00 
012F6C 00 00 00 00 
012F70 00 00 00 00 
012F74 00 00 00 00 
012F78 00 00 00 00 
012F7C 00 00 00 00 
012F80 00 00 00 00 
012F84 00 00 00 00 
012F88 00 00 00 00 
012F8C 00 00 00 00 
012F90 00 00 00 00 
012F94 00 00 00 00 
012F98 00 00 00 00 
012F9C 00 00 00 00 
012FA0 00 00 00 00 
012FA4 00 00 00 00 
012FA8 00 00 00 00 
012FAC 00 00 00 00 
012FB0 00 00 00 00 
012FB4 00 00 00 00 
012FB8 00 00 00 00 
012FBC 00 00 00 00 
012FC0 00 00 00 00 
012FC4 00 00 00 00 
012FC8 00 00 00 00 
012FCC 00 00 00 00 
012FD0 00 00 00 00 
012FD4 00 00 00 00 
012FD8 00 00 00 00 
012FDC 00 00 00 00 
012FE0 00 00 00 00 
012FE4 00 00 00 00 
012FE8 00 00 00 00 
012FEC 00 00 00 00 
012FF0 00 00 00 00 
012FF4 00 00 00 00 
012FF8 00 00 00 00 
012FFC 00 00 00 00 
013000 00 00 00 00 
013004 00 00 00 00 
013008 00 00 00 00 
01300C 00 00 00 00 
013010 00 00 00 00 
013014 00 00 00 00 
013018 00 00 00 00 
01301C 00 00 00 00 
013020 00 00 00 00 
013024 00 00 00 00 
013028 00 00 00 00 
01302C 00 00 00 00 
013030 00 00 00 00 
013034 00 00 00 00 
013038 00 00 00 00 
01303C 00 00 00 00 
013040 00 00 00 00 
013044 00 00 00 00 
013048 00 00 00 00 
01304C 00 00 00 00 
013050 00 00 00 00 
013054 00 00 00 00 
013058 00 00 00 00 
01305C 00 00 00 00 
013060 00 00 00 00 
013064 00 00 00 00 
013068 00 00 00 00 
01306C 00 00 00 00 
013070 00 00 00 00 
013074 00 00 00 00 
013078 00 00 00 00 
01307C 00 00 00 00 
013080 00 00 00 00 
013084 00 00 00 00 
013088 00 00 00 00 
01308C 00 00 00 00 
013090 00 00 00 00 
013094 00 00 00 00 
013098 00 00 00 00 
01309C 00 00 00 00 
0130A0 00 00 00 00 
0130A4 00 00 00 00 
0130A8 00 00 00 00 
0130AC 00 00 00 00 
0130B0 00 00 00 00 
0130B4 00 00 00 00 
0130B8 00 00 00 00 
0130BC 00 00 00 00 
0130C0 00 00 00 00 
0130C4 00 00 00 00 
0130C8 00 00 00 00 
0130CC 00 00 00 00 
0130D0 00 00 00 00 
0130D4 00 00 00 00 
0130D8 00 00 00 00 
0130DC 00 00 00 00 
0130E0 00 00 00 00 
0130E4 00 00 00 00 
0130E8 00 00 00 00 
0130EC 00 00 00 00 
0130F0 00 00 00 00 
0130F4 00 00 00 00 
0130F8 00 00 00 00 
0130FC 00 00 00 00 
013100 00 00 00 00 
013104 00 00 00 00 
013108 00 00 00 00 
01310C 00 00 00 00 
013110 00 00 00 00 
013114 00 00 00 00 
013118 00 00 00 00 
01311C 00 00 00 00 
013120 00 00 00 00 
013124 00 00 00 00 
013128 00 00 00 00 
01312C 00 00 00 00 
013130 00 00 00 00 
013134 00 00 00 00 
013138 00 00 00 00 
01313C 00 00 00 00 
013140 00 00 00 00 
013144 00 00 00 00 
013148 00 00 00 00 
01314C 00 00 00 00 
013150 00 00 00 00 
013154 00 00 00 00 
013158 00 00 00 00 
01315C 00 00 00 00 
013160 00 00 00 00 
013164 00 00 00 00 
013168 00 00 00 00 
01316C 00 00 00 00 
013170 00 00 00 00 
013174 00 00 00 00 
013178 00 00 00 00 
01317C 00 00 00 00 
013180 00 00 00 00 
013184 00 00 00 00 
013188 00 00 00 00 
01318C 00 00 00 00 
013190 00 00 00 00 
013194 00 00 00 00 
013198 00 00 00 00 
01319C 00 00 00 00 
0131A0 00 00 00 00 
0131A4 00 00 00 00 
0131A8 00 00 00 00 
0131AC 00 00 00 00 
0131B0 00 00 00 00 
0131B4 00 00 00 00 
0131B8 00 00 00 00 
0131BC 00 00 00 00 
0131C0 00 00 00 00 
0131C4 00 00 00 00 
0131C8 00 00 00 00 
0131CC 00 00 00 00 
0131D0 00 00 00 00 
0131D4 00 00 00 00 
0131D8 00 00 00 00 
0131DC 00 00 00 00 
0131E0 00 00 00 00 
0131E4 00 00 00 00 
0131E8 00 00 00 00 
0131EC 00 00 00 00 
0131F0 00 00 00 00 
0131F4 00 00 00 00 
0131F8 00 00 00 00 
0131FC 00 00 00 00 
013200 00 00 00 00 
013204 00 00 00 00 
013208 00 00 00 00 
01320C 00 00 00 00 
013210 00 00 00 00 
013214 00 00 00 00 
013218 00 00 00 00 
01321C 00 00 00 00 
013220 00 00 00 00 
013224 00 00 00 00 
013228 00 00 00 00 
01322C 00 00 00 00 
013230 00 00 00 00 
013234 00 00 00 00 
013238 00 00 00 00 
01323C 00 00 00 00 
013240 00 00 00 00 
013244 00 00 00 00 
013248 00 00 00 00 
01324C 00 00 00 00 
013250 00 00 00 00 
013254 00 00 00 00 
013258 00 00 00 00 
01325C 00 00 00 00 
013260 00 00 00 00 
013264 00 00 00 00 
013268 00 00 00 00 
01326C 00 00 00 00 
013270 00 00 00 00 
013274 00 00 00 00 
013278 00 00 00 00 
01327C 00 00 00 00 
013280 00 00 00 00 
013284 00 00 00 00 
013288 00 00 00 00 
01328C 00 00 00 00 
013290 00 00 00 00 
013294 00 00 00 00 
013298 00 00 00 00 
01329C 00 00 00 00 
0132A0 00 00 00 00 
0132A4 00 00 00 00 
0132A8 00 00 00 00 
0132AC 00 00 00 00 
0132B0 00 00 00 00 
0132B4 00 00 00 00 
0132B8 00 00 00 00 
0132BC 00 00 00 00 
0132C0 00 00 00 00 
0132C4 00 00 00 00 
0132C8 00 00 00 00 
0132CC 00 00 00 00 
0132D0 00 00 00 00 
0132D4 00 00 00 00 
0132D8 00 00 00 00 
0132DC 00 00 00 00 
0132E0 00 00 00 00 
0132E4 00 00 00 00 
0132E8 00 00 00 00 
0132EC 00 00 00 00 
0132F0 00 00 00 00 
0132F4 00 00 00 00 
0132F8 00 00 00 00 
0132FC 00 00 00 00 
013300 00 00 00 00 
013304 00 00 00 00 
013308 00 00 00 00 
01330C 00 00 00 00 
013310 00 00 00 00 
013314 00 00 00 00 
013318 00 00 00 00 
01331C 00 00 00 00 
013320 00 00 00 00 
013324 00 00 00 00 
013328 00 00 00 00 
01332C 00 00 00 00 
013330 00 00 00 00 
013334 00 00 00 00 
013338 00 00 00 00 
01333C 00 00 00 00 
013340 00 00 00 00 
013344 00 00 00 00 
013348 00 00 00 00 
01334C 00 00 00 00 
013350 00 00 00 00 
013354 00 00 00 00 
013358 00 00 00 00 
01335C 00 00 00 00 
013360 00 00 00 00 
013364 00 00 00 00 
013368 00 00 00 00 
01336C 00 00 00 00 
013370 00 00 00 00 
013374 00 00 00 00 
013378 00 00 00 00 
01337C 00 00 00 00 
013380 00 00 00 00 
013384 00 00 00 00 
013388 00 00 00 00 
01338C 00 00 00 00 
013390 00 00 00 00 
013394 00 00 00 00 
013398 00 00 00 00 
01339C 00 00 00 00 
0133A0 00 00 00 00 
0133A4 00 00 00 00 
0133A8 00 00 00 00 
0133AC 00 00 00 00 
0133B0 00 00 00 00 
0133B4 00 00 00 00 
0133B8 00 00 00 00 
0133BC 00 00 00 00 
0133C0 00 00 00 00 
0133C4 00 00 00 00 
0133C8 00 00 00 00 
0133CC 00 00 00 00 
0133D0 00 00 00 00 
0133D4 00 00 00 00 
0133D8 00 00 00 00 
0133DC 00 00 00 00 
0133E0 00 00 00 00 
0133E4 00 00 00 00 
0133E8 00 00 00 00 
0133EC 00 00 00 00 
0133F0 00 00 00 00 
0133F4 00 00 00 00 
0133F8 00 00 00 00 
0133FC 00 00 00 00 
013400 00 00 00 00 
013404 00 00 00 00 
013408 00 00 00 00 
01340C 00 00 00 00 
013410 00 00 00 00 
013414 00 00 00 00 
013418 00 00 00 00 
01341C 00 00 00 00 
013420 00 00 00 00 
013424 00 00 00 00 
013428 00 00 00 00 
01342C 00 00 00 00 
013430 00 00 00 00 
013434 00 00 00 00 
013438 00 00 00 00 
01343C 00 00 00 00 
013440 00 00 00 00 
013444 00 00 00 00 
013448 00 00 00 00 
01344C 00 00 00 00 
013450 00 00 00 00 
013454 00 00 00 00 
013458 00 00 00 00 
01345C 00 00 00 00 
013460 00 00 00 00 
013464 00 00 00 00 
013468 00 00 00 00 
01346C 00 00 00 00 
013470 00 00 00 00 
013474 00 00 00 00 
013478 00 00 00 00 
01347C 00 00 00 00 
013480 00 00 00 00 
013484 00 00 00 00 
013488 00 00 00 00 
01348C 00 00 00 00 
013490 00 00 00 00 
013494 00 00 00 00 
013498 00 00 00 00 
01349C 00 00 00 00 
0134A0 00 00 00 00 
0134A4 00 00 00 00 
0134A8 00 00 00 00 
0134AC 00 00 00 00 
0134B0 00 00 00 00 
0134B4 00 00 00 00 
0134B8 00 00 00 00 
0134BC 00 00 00 00 
0134C0 00 00 00 00 
0134C4 00 00 00 00 
0134C8 00 00 00 00 
0134CC 00 00 00 00 
0134D0 00 00 00 00 
0134D4 00 00 00 00 
0134D8 00 00 00 00 
0134DC 00 00 00 00 
0134E0 00 00 00 00 
0134E4 00 00 00 00 
0134E8 00 00 00 00 
0134EC 00 00 00 00 
0134F0 00 00 00 00 
0134F4 00 00 00 00 
0134F8 00 00 00 00 
0134FC 00 00 00 00 
013500 00 00 00 00 
013504 00 00 00 00 
013508 00 00 00 00 
01350C 00 00 00 00 
013510 00 00 00 00 
013514 00 00 00 00 
013518 00 00 00 00 
01351C 00 00 00 00 
013520 00 00 00 00 
013524 00 00 00 00 
013528 00 00 00 00 
01352C 00 00 00 00 
013530 00 00 00 00 
013534 00 00 00 00 
013538 00 00 00 00 
01353C 00 00 00 00 
013540 00 00 00 00 
013544 00 00 00 00 
013548 00 00 00 00 
01354C 00 00 00 00 
013550 00 00 00 00 
013554 00 00 00 00 
013558 00 00 00 00 
01355C 00 00 00 00 
013560 00 00 00 00 
013564 00 00 00 00 
013568 00 00 00 00 
01356C 00 00 00 00 
013570 00 00 00 00 
013574 00 00 00 00 
013578 00 00 00 00 
01357C 00 00 00 00 
013580 00 00 00 00 
013584 00 00 00 00 
013588 00 00 00 00 
01358C 00 00 00 00 
013590 00 00 00 00 
013594 00 00 00 00 
013598 00 00 00 00 
01359C 00 00 00 00 
0135A0 00 00 00 00 
0135A4 00 00 00 00 
0135A8 00 00 00 00 
0135AC 00 00 00 00 
0135B0 00 00 00 00 
0135B4 00 00 00 00 
0135B8 00 00 00 00 
0135BC 00 00 00 00 
0135C0 00 00 00 00 
0135C4 00 00 00 00 
0135C8 00 00 00 00 
0135CC 00 00 00 00 
0135D0 00 00 00 00 
0135D4 00 00 00 00 
0135D8 00 00 00 00 
0135DC 00 00 00 00 
0135E0 00 00 00 00 
0135E4 00 00 00 00 
0135E8 00 00 00 00 
0135EC 00 00 00 00 
0135F0 00 00 00 00 
0135F4 00 00 00 00 
0135F8 00 00 00 00 
0135FC 00 00 00 00 
013600 00 00 00 00 
013604 00 00 00 00 
013608 00 00 00 00 
01360C 00 00 00 00 
013610 00 00 00 00 
013614 00 00 00 00 
013618 00 00 00 00 
01361C 00 00 00 00 
013620 00 00 00 00 
013624 00 00 00 00 
013628 00 00 00 00 
01362C 00 00 00 00 
013630 00 00 00 00 
013634 00 00 00 00 
013638 00 00 00 00 
01363C 00 00 00 00 
013640 00 00 00 00 
013644 00 00 00 00 
013648 00 00 00 00 
01364C 00 00 00 00 
013650 00 00 00 00 
013654 00 00 00 00 
013658 00 00 00 00 
01365C 00 00 00 00 
013660 00 00 00 00 
013664 00 00 00 00 
013668 00 00 00 00 
01366C 00 00 00 00 
013670 00 00 00 00 
013674 00 00 00 00 
013678 00 00 00 00 
01367C 00 00 00 00 
013680 00 00 00 00 
013684 00 00 00 00 
013688 00 00 00 00 
01368C 00 00 00 00 
013690 00 00 00 00 
013694 00 00 00 00 
013698 00 00 00 00 
01369C 00 00 00 00 
0136A0 00 00 00 00 
0136A4 00 00 00 00 
0136A8 00 00 00 00 
0136AC 00 00 00 00 
0136B0 00 00 00 00 
0136B4 00 00 00 00 
0136B8 00 00 00 00 
0136BC 00 00 00 00 
0136C0 00 00 00 00 
0136C4 00 00 00 00 
0136C8 00 00 00 00 
0136CC 00 00 00 00 
0136D0 00 00 00 00 
0136D4 00 00 00 00 
0136D8 00 00 00 00 
0136DC 00 00 00 00 
0136E0 00 00 00 00 
0136E4 00 00 00 00 
0136E8 00 00 00 00 
0136EC 00 00 00 00 
0136F0 00 00 00 00 
0136F4 00 00 00 00 
0136F8 00 00 00 00 
0136FC 00 00 00 00 
013700 00 00 00 00 
013704 00 00 00 00 
013708 00 00 00 00 
01370C 00 00 00 00 
013710 00 00 00 00 
013714 00 00 00 00 
013718 00 00 00 00 
01371C 00 00 00 00 
013720 00 00 00 00 
013724 00 00 00 00 
013728 00 00 00 00 
01372C 00 00 00 00 
013730 00 00 00 00 
013734 00 00 00 00 
013738 00 00 00 00 
01373C 00 00 00 00 
013740 00 00 00 00 
013744 00 00 00 00 
013748 00 00 00 00 
01374C 00 00 00 00 
013750 00 00 00 00 
013754 00 00 00 00 
013758 00 00 00 00 
01375C 00 00 00 00 
013760 00 00 00 00 
013764 00 00 00 00 
013768 00 00 00 00 
01376C 00 00 00 00 
013770 00 00 00 00 
013774 00 00 00 00 
013778 00 00 00 00 
01377C 00 00 00 00 
013780 00 00 00 00 
013784 00 00 00 00 
013788 00 00 00 00 
01378C 00 00 00 00 
013790 00 00 00 00 
013794 00 00 00 00 
013798 00 00 00 00 
01379C 00 00 00 00 
0137A0 00 00 00 00 
0137A4 00 00 00 00 
0137A8 00 00 00 00 
0137AC 00 00 00 00 
0137B0 00 00 00 00 
0137B4 00 00 00 00 
0137B8 00 00 00 00 
0137BC 00 00 00 00 
0137C0 00 00 00 00 
0137C4 00 00 00 00 
0137C8 00 00 00 00 
0137CC 00 00 00 00 
0137D0 00 00 00 00 
0137D4 00 00 00 00 
0137D8 00 00 00 00 
0137DC 00 00 00 00 
0137E0 00 00 00 00 
0137E4 00 00 00 00 
0137E8 00 00 00 00 
0137EC 00 00 00 00 
0137F0 00 00 00 00 
0137F4 00 00 00 00 
0137F8 00 00 00 00 
0137FC 00 00 00 00 
013800 00 00 00 00 
013804 00 00 00 00 
013808 00 00 00 00 
01380C 00 00 00 00 
013810 00 00 00 00 
013814 00 00 00 00 
013818 00 00 00 00 
01381C 00 00 00 00 
013820 00 00 00 00 
013824 00 00 00 00 
013828 00 00 00 00 
01382C 00 00 00 00 
013830 00 00 00 00 
013834 00 00 00 00 
013838 00 00 00 00 
01383C 00 00 00 00 
013840 00 00 00 00 
013844 00 00 00 00 
013848 00 00 00 00 
01384C 00 00 00 00 
013850 00 00 00 00 
013854 00 00 00 00 
013858 00 00 00 00 
01385C 00 00 00 00 
013860 00 00 00 00 
013864 00 00 00 00 
013868 00 00 00 00 
01386C 00 00 00 00 
013870 00 00 00 00 
013874 00 00 00 00 
013878 00 00 00 00 
01387C 00 00 00 00 
013880 00 00 00 00 
013884 00 00 00 00 
013888 00 00 00 00 
01388C 00 00 00 00 
013890 00 00 00 00 
013894 00 00 00 00 
013898 00 00 00 00 
01389C 00 00 00 00 
0138A0 00 00 00 00 
0138A4 00 00 00 00 
0138A8 00 00 00 00 
0138AC 00 00 00 00 
0138B0 00 00 00 00 
0138B4 00 00 00 00 
0138B8 00 00 00 00 
0138BC 00 00 00 00 
0138C0 00 00 00 00 
0138C4 00 00 00 00 
0138C8 00 00 00 00 
0138CC 00 00 00 00 
0138D0 00 00 00 00 
0138D4 00 00 00 00 
0138D8 00 00 00 00 
0138DC 00 00 00 00 
0138E0 00 00 00 00 
0138E4 00 00 00 00 
0138E8 00 00 00 00 
0138EC 00 00 00 00 
0138F0 00 00 00 00 
0138F4 00 00 00 00 
0138F8 00 00 00 00 
0138FC 00 00 00 00 
013900 00 00 00 00 
013904 00 00 00 00 
013908 00 00 00 00 
01390C 00 00 00 00 
013910 00 00 00 00 
013914 00 00 00 00 
013918 00 00 00 00 
01391C 00 00 00 00 
013920 00 00 00 00 
013924 00 00 00 00 
013928 00 00 00 00 
01392C 00 00 00 00 
013930 00 00 00 00 
013934 00 00 00 00 
013938 00 00 00 00 
01393C 00 00 00 00 
013940 00 00 00 00 
013944 00 00 00 00 
013948 00 00 00 00 
01394C 00 00 00 00 
013950 00 00 00 00 
013954 00 00 00 00 
013958 00 00 00 00 
01395C 00 00 00 00 
013960 00 00 00 00 
013964 00 00 00 00 
013968 00 00 00 00 
01396C 00 00 00 00 
013970 00 00 00 00 
013974 00 00 00 00 
013978 00 00 00 00 
01397C 00 00 00 00 
013980 00 00 00 00 
013984 00 00 00 00 
013988 00 00 00 00 
01398C 00 00 00 00 
013990 00 00 00 00 
013994 00 00 00 00 
013998 00 00 00 00 
01399C 00 00 00 00 
0139A0 00 00 00 00 
0139A4 00 00 00 00 
0139A8 00 00 00 00 
0139AC 00 00 00 00 
0139B0 00 00 00 00 
0139B4 00 00 00 00 
0139B8 00 00 00 00 
0139BC 00 00 00 00 
0139C0 00 00 00 00 
0139C4 00 00 00 00 
0139C8 00 00 00 00 
0139CC 00 00 00 00 
0139D0 00 00 00 00 
0139D4 00 00 00 00 
0139D8 00 00 00 00 
0139DC 00 00 00 00 
0139E0 00 00 00 00 
0139E4 00 00 00 00 
0139E8 00 00 00 00 
0139EC 00 00 00 00 
0139F0 00 00 00 00 
0139F4 00 00 00 00 
0139F8 00 00 00 00 
0139FC 00 00 00 00 
013A00 00 00 00 00 
013A04 00 00 00 00 
013A08 00 00 00 00 
013A0C 00 00 00 00 
013A10 00 00 00 00 
013A14 00 00 00 00 
013A18 00 00 00 00 
013A1C 00 00 00 00 
013A20 00 00 00 00 
013A24 00 00 00 00 
013A28 00 00 00 00 
013A2C 00 00 00 00 
013A30 00 00 00 00 
013A34 00 00 00 00 
013A38 00 00 00 00 
013A3C 00 00 00 00 
013A40 00 00 00 00 
013A44 00 00 00 00 
013A48 00 00 00 00 
013A4C 00 00 00 00 
013A50 00 00 00 00 
013A54 00 00 00 00 
013A58 00 00 00 00 
013A5C 00 00 00 00 
013A60 00 00 00 00 
013A64 00 00 00 00 
013A68 00 00 00 00 
013A6C 00 00 00 00 
013A70 00 00 00 00 
013A74 00 00 00 00 
013A78 00 00 00 00 
013A7C 00 00 00 00 
013A80 00 00 00 00 
013A84 00 00 00 00 
013A88 00 00 00 00 
013A8C 00 00 00 00 
013A90 00 00 00 00 
013A94 00 00 00 00 
013A98 00 00 00 00 
013A9C 00 00 00 00 
013AA0 00 00 00 00 
013AA4 00 00 00 00 
013AA8 00 00 00 00 
013AAC 00 00 00 00 
013AB0 00 00 00 00 
013AB4 00 00 00 00 
013AB8 00 00 00 00 
013ABC 00 00 00 00 
013AC0 00 00 00 00 
013AC4 00 00 00 00 
013AC8 00 00 00 00 
013ACC 00 00 00 00 
013AD0 00 00 00 00 
013AD4 00 00 00 00 
013AD8 00 00 00 00 
013ADC 00 00 00 00 
013AE0 00 00 00 00 
013AE4 00 00 00 00 
013AE8 00 00 00 00 
013AEC 00 00 00 00 
013AF0 00 00 00 00 
013AF4 00 00 00 00 
013AF8 00 00 00 00 
013AFC 00 00 00 00 
013B00 00 00 00 00 
013B04 00 00 00 00 
013B08 00 00 00 00 
013B0C 00 00 00 00 
013B10 00 00 00 00 
013B14 00 00 00 00 
013B18 00 00 00 00 
013B1C 00 00 00 00 
013B20 00 00 00 00 
013B24 00 00 00 00 
013B28 00 00 00 00 
013B2C 00 00 00 00 
013B30 00 00 00 00 
013B34 00 00 00 00 
013B38 00 00 00 00 
013B3C 00 00 00 00 
013B40 00 00 00 00 
013B44 00 00 00 00 
013B48 00 00 00 00 
013B4C 00 00 00 00 
013B50 00 00 00 00 
013B54 00 00 00 00 
013B58 00 00 00 00 
013B5C 00 00 00 00 
013B60 00 00 00 00 
013B64 00 00 00 00 
013B68 00 00 00 00 
013B6C 00 00 00 00 
013B70 00 00 00 00 
013B74 00 00 00 00 
013B78 00 00 00 00 
013B7C 00 00 00 00 
013B80 00 00 00 00 
013B84 00 00 00 00 
013B88 00 00 00 00 
013B8C 00 00 00 00 
013B90 00 00 00 00 
013B94 00 00 00 00 
013B98 00 00 00 00 
013B9C 00 00 00 00 
013BA0 00 00 00 00 
013BA4 00 00 00 00 
013BA8 00 00 00 00 
013BAC 00 00 00 00 
013BB0 00 00 00 00 
013BB4 00 00 00 00 
013BB8 00 00 00 00 
013BBC 00 00 00 00 
013BC0 00 00 00 00 
013BC4 00 00 00 00 
013BC8 00 00 00 00 
013BCC 00 00 00 00 
013BD0 00 00 00 00 
013BD4 00 00 00 00 
013BD8 00 00 00 00 
013BDC 00 00 00 00 
013BE0 00 00 00 00 
013BE4 00 00 00 00 
013BE8 00 00 00 00 
013BEC 00 00 00 00 
013BF0 00 00 00 00 
013BF4 00 00 00 00 
013BF8 00 00 00 00 
013BFC 00 00 00 00 
013C00 00 00 00 00 
013C04 00 00 00 00 
013C08 00 00 00 00 
013C0C 00 00 00 00 
013C10 00 00 00 00 
013C14 00 00 00 00 
013C18 00 00 00 00 
013C1C 00 00 00 00 
013C20 00 00 00 00 
013C24 00 00 00 00 
013C28 00 00 00 00 
013C2C 00 00 00 00 
013C30 00 00 00 00 
013C34 00 00 00 00 
013C38 00 00 00 00 
013C3C 00 00 00 00 
013C40 00 00 00 00 
013C44 00 00 00 00 
013C48 00 00 00 00 
013C4C 00 00 00 00 
013C50 00 00 00 00 
013C54 00 00 00 00 
013C58 00 00 00 00 
013C5C 00 00 00 00 
013C60 00 00 00 00 
013C64 00 00 00 00 
013C68 00 00 00 00 
013C6C 00 00 00 00 
013C70 00 00 00 00 
013C74 00 00 00 00 
013C78 00 00 00 00 
013C7C 00 00 00 00 
013C80 00 00 00 00 
013C84 00 00 00 00 
013C88 00 00 00 00 
013C8C 00 00 00 00 
013C90 00 00 00 00 
013C94 00 00 00 00 
013C98 00 00 00 00 
013C9C 00 00 00 00 
013CA0 00 00 00 00 
013CA4 00 00 00 00 
013CA8 00 00 00 00 
013CAC 00 00 00 00 
013CB0 00 00 00 00 
013CB4 00 00 00 00 
013CB8 00 00 00 00 
013CBC 00 00 00 00 
013CC0 00 00 00 00 
013CC4 00 00 00 00 
013CC8 00 00 00 00 
013CCC 00 00 00 00 
013CD0 00 00 00 00 
013CD4 00 00 00 00 
013CD8 00 00 00 00 
013CDC 00 00 00 00 
013CE0 00 00 00 00 
013CE4 00 00 00 00 
013CE8 00 00 00 00 
013CEC 00 00 00 00 
013CF0 00 00 00 00 
013CF4 00 00 00 00 
013CF8 00 00 00 00 
013CFC 00 00 00 00 
013D00 00 00 00 00 
013D04 00 00 00 00 
013D08 00 00 00 00 
013D0C 00 00 00 00 
013D10 00 00 00 00 
013D14 00 00 00 00 
013D18 00 00 00 00 
013D1C 00 00 00 00 
013D20 00 00 00 00 
013D24 00 00 00 00 
013D28 00 00 00 00 
013D2C 00 00 00 00 
013D30 00 00 00 00 
013D34 00 00 00 00 
013D38 00 00 00 00 
013D3C 00 00 00 00 
013D40 00 00 00 00 
013D44 00 00 00 00 
013D48 00 00 00 00 
013D4C 00 00 00 00 
013D50 00 00 00 00 
013D54 00 00 00 00 
013D58 00 00 00 00 
013D5C 00 00 00 00 
013D60 00 00 00 00 
013D64 00 00 00 00 
013D68 00 00 00 00 
013D6C 00 00 00 00 
013D70 00 00 00 00 
013D74 00 00 00 00 
013D78 00 00 00 00 
013D7C 00 00 00 00 
013D80 00 00 00 00 
013D84 00 00 00 00 
013D88 00 00 00 00 
013D8C 00 00 00 00 
013D90 00 00 00 00 
013D94 00 00 00 00 
013D98 00 00 00 00 
013D9C 00 00 00 00 
013DA0 00 00 00 00 
013DA4 00 00 00 00 
013DA8 00 00 00 00 
013DAC 00 00 00 00 
013DB0 00 00 00 00 
013DB4 00 00 00 00 
013DB8 00 00 00 00 
013DBC 00 00 00 00 
013DC0 00 00 00 00 
013DC4 00 00 00 00 
013DC8 00 00 00 00 
013DCC 00 00 00 00 
013DD0 00 00 00 00 
013DD4 00 00 00 00 
013DD8 00 00 00 00 
013DDC 00 00 00 00 
013DE0 00 00 00 00 
013DE4 00 00 00 00 
013DE8 00 00 00 00 
013DEC 00 00 00 00 
013DF0 00 00 00 00 
013DF4 00 00 00 00 
013DF8 00 00 00 00 
013DFC 00 00 00 00 
013E00 00 00 00 00 
013E04 00 00 00 00 
013E08 00 00 00 00 
013E0C 00 00 00 00 
013E10 00 00 00 00 
013E14 00 00 00 00 
013E18 00 00 00 00 
013E1C 00 00 00 00 
013E20 00 00 00 00 
013E24 00 00 00 00 
013E28 00 00 00 00 
013E2C 00 00 00 00 
013E30 00 00 00 00 
013E34 00 00 00 00 
013E38 00 00 00 00 
013E3C 00 00 00 00 
013E40 00 00 00 00 
013E44 00 00 00 00 
013E48 00 00 00 00 
013E4C 00 00 00 00 
013E50 00 00 00 00 
013E54 00 00 00 00 
013E58 00 00 00 00 
013E5C 00 00 00 00 
013E60 00 00 00 00 
013E64 00 00 00 00 
013E68 00 00 00 00 
013E6C 00 00 00 00 
013E70 00 00 00 00 
013E74 00 00 00 00 
013E78 00 00 00 00 
013E7C 00 00 00 00 
013E80 00 00 00 00 
013E84 00 00 00 00 
013E88 00 00 00 00 
013E8C 00 00 00 00 
013E90 00 00 00 00 
013E94 00 00 00 00 
013E98 00 00 00 00 
013E9C 00 00 00 00 
013EA0 00 00 00 00 
013EA4 00 00 00 00 
013EA8 00 00 00 00 
013EAC 00 00 00 00 
013EB0 00 00 00 00 
013EB4 00 00 00 00 
013EB8 00 00 00 00 
013EBC 00 00 00 00 
013EC0 00 00 00 00 
013EC4 00 00 00 00 
013EC8 00 00 00 00 
013ECC 00 00 00 00 
013ED0 00 00 00 00 
013ED4 00 00 00 00 
013ED8 00 00 00 00 
013EDC 00 00 00 00 
013EE0 00 00 00 00 
013EE4 00 00 00 00 
013EE8 00 00 00 00 
013EEC 00 00 00 00 
013EF0 00 00 00 00 
013EF4 00 00 00 00 
013EF8 00 00 00 00 
013EFC 00 00 00 00 
013F00 00 00 00 00 
013F04 00 00 00 00 
013F08 00 00 00 00 
013F0C 00 00 00 00 
013F10 00 00 00 00 
013F14 00 00 00 00 
013F18 00 00 00 00 
013F1C 00 00 00 00 
013F20 00 00 00 00 
013F24 00 00 00 00 
013F28 00 00 00 00 
013F2C 00 00 00 00 
013F30 00 00 00 00 
013F34 00 00 00 00 
013F38 00 00 00 00 
013F3C 00 00 00 00 
013F40 00 00 00 00 
013F44 00 00 00 00 
013F48 00 00 00 00 
013F4C 00 00 00 00 
013F50 00 00 00 00 
013F54 00 00 00 00 
013F58 00 00 00 00 
013F5C 00 00 00 00 
013F60 00 00 00 00 
013F64 00 00 00 00 
013F68 00 00 00 00 
013F6C 00 00 00 00 
013F70 00 00 00 00 
013F74 00 00 00 00 
013F78 00 00 00 00 
013F7C 00 00 00 00 
013F80 00 00 00 00 
013F84 00 00 00 00 
013F88 00 00 00 00 
013F8C 00 00 00 00 
013F90 00 00 00 00 
013F94 00 00 00 00 
013F98 00 00 00 00 
013F9C 00 00 00 00 
013FA0 00 00 00 00 
013FA4 00 00 00 00 
013FA8 00 00 00 00 
013FAC 00 00 00 00 
013FB0 00 00 00 00 
013FB4 00 00 00 00 
013FB8 00 00 00 00 
013FBC 00 00 00 00 
013FC0 00 00 00 00 
013FC4 00 00 00 00 
013FC8 00 00 00 00 
013FCC 00 00 00 00 
013FD0 00 00 00 00 
013FD4 00 00 00 00 
013FD8 00 00 00 00 
013FDC 00 00 00 00 
013FE0 00 00 00 00 
013FE4 00 00 00 00 
013FE8 00 00 00 00 
013FEC 00 00 00 00 
013FF0 00 00 00 00 
013FF4 00 00 00 00 
013FF8 00 00 00 00 
013FFC 00 00 00 00 
                		; Compress vector table by storing only the low order 16 bits of the
                		; vector. The high order bits are always the same.
                	syscall_vectors:
014000 1C 40       		dc		FMTKInitialize
014002 08 45       		dc		StartTask
014004 58 46       		dc		ExitTask
014006 C4 46       		dc   	KillTask
014008 65 48       		dc		SetTaskPriority
01400A 4C 4B       		dc		Sleep
01400C 84 4B       		dc		AllocMbx
01400E 68 4C       		dc		FreeMbx
014010 E8 4F       		dc		PostMsg
014012 00 50       		dc		SendMsg
014014 68 51       		dc		WaitMsg
014016 00 53       		dc		CheckMsg
                	
                	message "InitFMTK"
                	BranchToSelf:
014018 3A 00 00 00 	    bra     BranchToSelf
                	
                	FMTKInitialize:
                	InitFMTK:
                		; Initialize semaphores
01401C 7C C0 00 00 		sw		r0,freetcb_sema
014020 63 00 60 02 
014024 7C C0 00 00 		sw		r0,freembx_sema
014028 63 00 70 02 
01402C 7C C0 00 00 		sw		r0,freemsg_sema
014030 63 00 80 02 
014034 7C C0 00 00 		sw		r0,tcb_sema
014038 63 00 90 02 
01403C 7C C0 00 00 		sw		r0,readylist_sema
014040 63 00 A0 02 
014044 7C C0 00 00 		sw		r0,tolist_sema
014048 63 00 B0 02 
01404C 7C C0 00 00 		sw		r0,mbx_sema
014050 63 00 D0 02 
014054 7C C0 00 00 		sw		r0,msg_sema
014058 63 00 E0 02 
01405C 7C C0 00 00 		sw		r0,jcb_sema
014060 63 00 F0 02 
                	
014064 02 20 14 3E 		mfspr	r2,vbr
014068 7C 01 00 00 		ldi		r1,#reschedule
01406C 0A 10 48 A8 
014070 63 11 20 00 		sw		r1,16[r2]
014074 7C 01 00 00 		ldi		r1,#syscall_exception
014078 0A 10 90 A7 
01407C 63 11 40 00 		sw		r1,32[r2]
014080 7C 01 00 00 		ldi		r1,#FMTKTick
014084 0A 10 A8 AA 
014088 63 11 30 1C 		sw		r1,(448+3)<<3[r2]
01408C 7C C0 00 00 		sw		r0,UserTick
014090 63 00 00 00 
                	
014094 7C C0 00 00 		sw		r0,TimeoutList		; no entries in timeout list
014098 63 00 10 01 
01409C 7C C0 00 00 		sw		r0,QNdx0
0140A0 63 00 70 00 
0140A4 7C C0 00 00 		sw		r0,QNdx1
0140A8 63 00 80 00 
0140AC 7C C0 00 00 		sw		r0,QNdx2
0140B0 63 00 90 00 
0140B4 7C C0 00 00 		sw		r0,QNdx3
0140B8 63 00 A0 00 
0140BC 7C C0 00 00 		sw		r0,QNdx4
0140C0 63 00 B0 00 
0140C4 7C C0 00 00 		sw		r0,QNdx5
0140C8 63 00 C0 00 
0140CC 7C C0 00 00 		sw		r0,QNdx6
0140D0 63 00 D0 00 
0140D4 7C C0 00 00 		sw		r0,QNdx7
0140D8 63 00 E0 00 
                	
0140DC 7C C0 00 00 		sw		r0,missed_ticks
0140E0 63 00 70 01 
                	
                		; Initialize IO Focus List
                		;
0140E4 7C C0 00 00 		sw      r0,IOFocusTbl
0140E8 63 00 30 00 
0140EC 7C C0 00 00 		sw      r0,IOFocusTbl+8
0140F0 63 00 40 00 
0140F4 7C C0 00 00 		sw      r0,IOFocusTbl+16
0140F8 63 00 50 00 
0140FC 7C C0 00 00 		sw      r0,IOFocusTbl+32
014100 63 00 70 00 
                	
                		; zero out JCB's
                		; This will NULL out the I/O focus list pointers
014104 0A 10 B0 3F 		ldi     r1,#NR_JCB * JCB_Size / 8 - 8
014108 7C C4 00 00 		ldi     r2,#JCB_Array
01410C 0A 20 00 00 
                	.0001:
014110 6B 01 C2 00 		sw      r0,[r2+r1*8]
014114 95 10 02 00 		subui   r1,r1,#1
014118 BD 30 FC FF 		bge     r1,.0001
                	
                		; Setup default values in the JCB's
01411C 0A 30 00 00 		ldi		r3,#0
014120 0A 20 66 00 		ldi		r2,#NR_JCB
014124 7C C4 00 00 		ldi     r4,#JCB_Array
014128 0A 40 00 00 
                	ijcb1:
01412C 61 32 00 00 		sc		r3,JCB_Number[r4]
014130 60 02 E0 08 		sb		r0,JCB_esc[r4]
014134 0A 10 3E 00 		ldi     r1,#31
014138 60 12 14 08 		sb		r1,JCB_VideoRows[r4]
01413C 0A 10 A8 00 		ldi		r1,#84
014140 60 12 16 08 		sb		r1,JCB_VideoCols[r4]
014144 0A 10 02 00 		ldi		r1,#1				; turn on keyboard echo
014148 60 12 90 08 		sb		r1,JCB_KeybdEcho[r4]
01414C 60 12 1C 08 		sb		r1,JCB_CursorOn[r4]
014150 60 12 1E 08 		sb		r1,JCB_CursorFlash[r4]
014154 60 02 18 08 		sb		r0,JCB_CursorRow[r4]
014158 60 02 1A 08 		sb		r0,JCB_CursorCol[r4]
01415C 60 02 20 08 		sb		r0,JCB_CursorType[r4]
014160 FC 97 04 00 		ldi		r1,#%010010010_111111111_0000000000	; white on grey
014164 0A 10 00 F8 
014168 62 12 28 08 		sh		r1,JCB_NormAttr[r4]
01416C 62 12 30 08 		sh		r1,JCB_CurrAttr[r4]
014170 7C 00 00 00 		mulu	r5,r3,#16384		; 8192 words per screen
014174 97 51 00 80 
014178 7C D9 00 00 		addui   r5,r5,#SCREEN_Array
01417C 94 52 00 00 
014180 62 52 F0 07 		sh		r5,JCB_pVirtVid[r4]
014184 62 52 D0 07 		sh		r5,JCB_pVidMem[r4]
014188 BD 11 0E 00 		bne		r3,ijcb2
01418C 7C 32 02 00 		ldi		r1,#%001000110_010010010_0000000000	; grey on blue
014190 0A 10 00 90 
014194 62 12 28 08 		sh		r1,JCB_NormAttr[r4]
014198 62 12 30 08 		sh		r1,JCB_CurrAttr[r4]
01419C 44 50 00 00 		lh		r5,#TEXTSCR
0141A0 62 52 D0 07 		sh		r5,JCB_pVidMem[r4]
                	ijcb2:
0141A4 94 31 02 00 	    addui   r3,r3,#1
0141A8 14 42 00 0A 		addui	r4,r4,#JCB_Size
0141AC 86 21 66 00 		cmp     r2,r3,#NR_JCB
0141B0 3D 41 BE FF 		blt		r2,ijcb1
                	
                		; Initialize free message list
0141B4 FC 00 00 00 		ldi		r1,#NR_MSG
0141B8 0A 10 00 00 
0141BC 7C C0 00 00 		sw		r1,nMsgBlk
0141C0 63 10 60 01 
0141C4 7C C9 00 00 		ldi     r1,#MSG_Array
0141C8 0A 10 00 00 
0141CC 7C C0 00 00 		sw		r1,FreeMsg
0141D0 63 10 50 01 
0141D4 94 20 40 00 		addui   r2,r1,MSG_Size
                	st4:
0141D8 E3 20 00 00 		sw		r2,MSG_LINK[r1]
0141DC E3 00 10 00 		sw      r0,MSG_D1[r1]
0141E0 E3 00 20 00 		sw      r0,MSG_D2[r1]
0141E4 E3 00 30 00 		sw      r0,MSG_TYPE[r1]
0141E8 94 10 40 00 		addui	r1,r1,#MSG_Size
0141EC 14 21 40 00 		addui   r2,r2,#MSG_Size
0141F0 FC D8 00 00 		cmp     r3,r2,#MSG_ArrayEnd-MSG_Size
0141F4 06 31 C0 FF 
0141F8 BD 41 F0 FF 		blt     r3,st4
0141FC E3 00 00 00 		sw      r0,MSG_LINK[r1]
                	
                		; Initialize free mailbox list
                		; Note the first NR_TCB mailboxes are statically allocated to the tasks.
                		; They are effectively pre-allocated.
014200 0A 50 00 0E 		ldi		r5,#NR_MBX-NR_TCB
014204 7C C0 00 00 		sw		r5,nMailbox
014208 63 50 40 01 
                	
01420C 0A 10 00 02 	    ldi     r1,#NR_TCB
014210 97 20 C0 00 	    mulu    r2,r1,#MBX_Size
014214 7C C6 00 00 	    addui   r2,r2,#MBX_Array
014218 14 21 00 00 
01421C 7C C0 00 00 	    sw      r2,FreeMbxHandle
014220 63 20 30 01 
014224 02 31 00 1A 	    mov     r3,r2
014228 94 31 C0 00 	    addui   r3,r3,#MBX_Size
                	.imbxl1:
01422C 63 31 00 00 	    sw      r3,MBX_LINK[r2]
014230 14 21 C0 00 	    addui   r2,r2,#MBX_Size
014234 94 31 C0 00 	    addui   r3,r3,#MBX_Size
014238 95 52 02 00 	    subui   r5,r5,#1
01423C BD 22 F8 FF 	    bgt     r5,.imbxl1
                	
                		; Initialize the FreeJCB list
014240 7C C4 00 00 		ldi		r1,#JCB_Array+JCB_Size		; the next available JCB
014244 0A 10 00 0A 
014248 7C C0 00 00 		sw		r1,FreeJCB
01424C 63 10 F0 00 
014250 82 20 00 1A 		mov     r2,r1
014254 94 10 00 0A 		addui	r1,r1,#JCB_Size
014258 0A 30 64 00 		ldi		r3,#NR_JCB-1
                	st5:
01425C 63 11 40 08 		sw		r1,JCB_Next[r2]
014260 94 10 00 0A 		addui	r1,r1,#JCB_Size
014264 14 21 00 0A 		addui	r2,r2,#JCB_Size
014268 95 31 02 00 		subui   r3,r3,#1
01426C BD 11 F8 FF 		bne		r3,st5
014270 63 01 40 08 		sw      r0,JCB_Next[r2]
                	
                	    ; Initialize the free TCB list
                	    ; The first two TCB's are pre-allocated and so aren't part of the list
014274 7C C1 00 00 	    ldi     r2,#TCB_Array+2*TCB_Size
014278 0A 20 00 0C 
01427C 7C C0 00 00 	    sw      r2,FreeTCB
014280 63 20 00 01 
014284 63 01 40 04 	    sw      r0,TCB_PrevFree[r2]
                	.0001:
014288 14 31 00 06 	    addui   r3,r2,#TCB_Size
01428C 63 31 30 04 	    sw      r3,TCB_NextFree[r2]
014290 E3 21 40 04 	    sw      r2,TCB_PrevFree[r3]
014294 14 21 00 06 	    addui   r2,r2,#TCB_Size
014298 FC C3 00 00 	    cmpu    r4,r2,#TCB_ArrayEnd-TCB_Size
01429C 16 41 00 FA 
0142A0 3D 42 F4 FF 	    blt     r4,.0001
0142A4 63 01 30 04 	    sw      r0,TCB_NextFree[r2]
                	
0142A8 7C C1 00 00 	    ldi     r2,#TCB_Array
0142AC 0A 20 00 00 
0142B0 0A 40 00 00 	    ldi     r4,#0
                	.nextTCB:
0142B4 7C C4 00 00 	    ldi     r5,#JCB_Array
0142B8 0A 50 00 00 
0142BC 63 51 28 04 	    sw      r5,TCB_hJCB[r2]   ; owning JOB = monitor
0142C0 7C 01 00 00 	    ldi     r3,#BranchToSelf
0142C4 0A 30 30 80 
0142C8 63 31 00 03 	    sw      r3,TCB_IPC[r2]    ; set startup address
0142CC 17 32 00 20 	    mulu    r3,r4,#4096       ; initial stack size=4096
0142D0 7C F0 07 00 	    addui   r3,r3,#STACKS_Array+4088
0142D4 94 31 F0 1F 
0142D8 63 31 E0 01 	    sw      r3,TCB_r30[r2]    ; set the stack pointer to the default stack
0142DC 14 21 00 06 	    addui   r2,r2,#TCB_Size   ; move to next TCB 768B TCB size
0142E0 14 42 02 00 	    addui   r4,r4,#1
0142E4 16 12 00 02 	    cmpu    r1,r4,#NR_TCB
0142E8 BD 40 E6 FF 	    blt     r1,.nextTCB
                	
                		; Manually setup the BIOS task
0142EC 7C C1 00 00 		ldi     tr,#TCB_Array
0142F0 0A 80 01 00 
                	;	sw		tr,RunningTCB	; BIOS is task #0
0142F4 63 8C 01 04 		sw		tr,TCB_NextRdy[tr]	; manually build the ready list
0142F8 63 8C 11 04 		sw		tr,TCB_PrevRdy[tr]
0142FC 63 0C 50 04 		sw		r0,TCB_NextTo[tr]
014300 63 0C 60 04 		sw		r0,TCB_PrevTo[tr]
014304 7C C0 00 00 		sw		tr,QNdx3		; insert at priority 3
014308 63 80 A1 00 
                		; manually build the IO focus list
01430C 7C C4 00 00 		ldi		r1,#JCB_Array
014310 0A 10 00 00 
014314 7C C0 00 00 		sw	    r1,IOFocusNdx		; Job #0 (Monitor) has the focus
014318 63 10 20 00 
01431C E3 10 50 08 		sw		r1,JCB_iof_next[r1]
014320 E3 10 60 08 		sw		r1,JCB_iof_prev[r1]
014324 0A 10 02 00 		ldi		r1,#1
014328 7C C0 00 00 		sw		r1,IOFocusTbl		; set the job #0 request bit
01432C 63 10 30 00 
                	
014330 0A 10 06 00 		ldi		r1,#3
014334 61 1C 24 04 		sc		r1,TCB_Priority[tr]
014338 63 0C F0 04 		sw		r0,TCB_Timeout[tr]
01433C 0A 10 30 00 		ldi		r1,#TS_RUNNING|TS_READY
014340 60 1C 20 04 		sb		r1,TCB_Status[tr]
014344 7C F0 07 00 		ldi     r1,#STACKS_Array+$FF8   ; setup stack pointer top of memory
014348 0A 10 F0 1F 
01434C 63 1C F0 01 		sw		r1,TCB_r31[tr]
                	
014350 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	StartIdleTask:
014354 E7 EF 01 00 	    push    lr
014358 0A 10 0E 00 		ldi		r1,#7
01435C 0A 20 00 00 		ldi		r2,#0
014360 7C 01 00 00 		ldi		r3,#IdleTask
014364 0A 30 E0 86 
014368 39 34 00 00 		bsr		StartTask
01436C 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; IdleTask
                	;
                	; IdleTask is a low priority task that is always running. It runs when there
                	; is nothing else to run.
                	; This task check for tasks that are stuck in infinite loops and kills them.
                	;------------------------------------------------------------------------------
                	IdleTask:
                	it3:
014370 7C C1 00 00 	    ldi     r2,#TCB_Array
014374 0A 20 00 00 
                	it2:
                	;	inc		TEXTSCR+444		; increment IDLE active flag
014378 7C C1 00 00 		cmpu    r1,r2,#TCB_Array
01437C 16 11 00 00 
014380 BD 00 0E 00 		beq		r1,it1
014384 40 11 20 04 		lb		r1,TCB_Status[r2]
014388 86 10 40 00 		cmp		r1,r1,#TS_SLEEP
01438C BD 10 08 00 		bne		r1,it1
014390 02 11 00 1A 		mov     r1,r2
014394 38 0F 08 00 		sys		#4				; KillTask function
014398 03 00 00 00 		dh		3
                	it1:
01439C 14 21 00 06 	    addui   r2,r2,#TCB_Size
0143A0 FC C3 00 00 	    cmpu    r1,r2,#TCB_ArrayEnd-TCB_Size
0143A4 16 11 00 FA 
0143A8 BD 40 E8 FF 	    blt     r1,it2
0143AC BA F8 FF FF 	    bra     it3
0143B0 02 00 00 6E 		cli						; enable interrupts
                	;	wai						; wait for one to happen
0143B4 BA F8 FF FF 		bra		it2
                	
                	;------------------------------------------------------------------------------
                	; Parameters:
                	;	r1 = job name
                	;	r2 = start address
                	;------------------------------------------------------------------------------
                	
                	StartJob:
0143B8 E7 E0 01 00 		push    r1
                		
                		; Get a free JCB
                	sjob4:
0143BC 7C C0 00 00 	    lwar    r1,freejcb_sema
0143C0 5C 10 50 02 
0143C4 BD 10 FC FF 	    bne     r1,sjob4
0143C8 7C C0 00 00 	    swcr    tr,freejcb_sema
0143CC 6E 80 51 02 
0143D0 02 10 00 3E 	    mfspr   r1,cr0
0143D4 7C 00 00 10 	    and     r1,r1,#$1000000000
0143D8 8C 10 00 00 
0143DC BD 00 F0 FF 	    beq     r1,sjob4
                	
0143E0 7C C0 00 00 		lw		r6,FreeJCB
0143E4 46 60 F0 00 
0143E8 3D 03 24 00 		beq		r6,sjob1
0143EC 46 73 40 08 		lw		r7,JCB_Next[r6]
0143F0 7C C0 00 00 		sw		r7,FreeJCB
0143F4 63 70 F0 00 
0143F8 7C C0 00 00 		sw		r0,freejcb_sema
0143FC 63 00 50 02 
                	
014400 47 73 08 00 		lea		r7,JCB_Name[r6]		; r7 = address of name field
014404 82 93 00 1A 		mov		r9,r7				; save off buffer address
014408 0A 80 00 00 		ldi		r8,#0				; r8 = count of characters (0 to 31)
                	sjob3:
01440C C0 50 00 00 		lb	    r5,[r1]				; get a character
014410 BD 02 0E 00 		beq		r5,sjob2			; end of string ?
014414 E0 53 02 00 		sb		r5,1[r7]
014418 94 10 02 00 		addui   r1,r1,#1
01441C 94 73 02 00 		addui   r7,r7,#1
014420 14 84 02 00 		addui   r8,r8,#1
014424 16 54 3E 00 		cmpu	r5,r8,#31   		; max number of chars ?
014428 BD 42 F2 FF 		blt		r5,sjob3
                	sjob2:
01442C E0 84 00 00 		sb		r8,[r9]				; save name length
                	
                	sjob1:
014430 7C C0 00 00 		sw		r0,freejcb_sema
014434 63 00 50 02 
014438 57 1F 10 00 		pop     r1
01443C 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; Lock routines.
                	;------------------------------------------------------------------------------
                	
                	LockFreeMBX:
014440 E7 EF 01 00 	    push    lr
014444 E7 E0 01 00 	    push    r1
014448 7C C0 00 00 	    lea     r1,freembx_sema
01444C 47 10 70 02 
014450 B9 0F 00 00 	    bsr     LockSema
014454 57 1F 10 00 	    pop     r1
014458 3B FF 11 00 	    rts

                	LockFreeMSG:
01445C E7 EF 01 00 	    push    lr
014460 E7 E0 01 00 	    push    r1
014464 7C C0 00 00 	    lea     r1,freemsg_sema
014468 47 10 80 02 
01446C 39 0C 00 00 	    bsr     LockSema
014470 57 1F 10 00 	    pop     r1
014474 3B FF 11 00 	    rts

                	LockMBX:
014478 E7 EF 01 00 	    push    lr
01447C E7 E0 01 00 	    push    r1
014480 7C C0 00 00 	    lea     r1,mbx_sema
014484 47 10 D0 02 
014488 B9 08 00 00 	    bsr     LockSema
01448C 57 1F 10 00 	    pop     r1
014490 3B FF 11 00 	    rts

                	LockFreeTCB:
014494 E7 EF 01 00 	    push    lr
014498 E7 E0 01 00 	    push    r1
01449C 7C C0 00 00 	    lea     r1,freetcb_sema
0144A0 47 10 60 02 
0144A4 39 05 00 00 	    bsr     LockSema
0144A8 57 1F 10 00 	    pop     r1
0144AC 3B FF 11 00 	    rts

                	LockTCB:
0144B0 E7 EF 01 00 	    push    lr
0144B4 E7 E0 01 00 	    push    r1
0144B8 7C C0 00 00 	    lea     r1,tcb_sema
0144BC 47 10 90 02 
0144C0 B9 01 00 00 	    bsr     LockSema
0144C4 57 1F 10 00 	    pop     r1
0144C8 3B FF 11 00 	    rts

                	;------------------------------------------------------------------------------
                	; Lock the semaphore.
                	;
                	; While locking, a test is made to see if the task already owns the
                	; semaphore. This helps prevent problems in case of a software error in the
                	; OS. If an attempt is made to lock the semaphore twice (or more) by the same
                	; task, the OS would lock up waiting for the semaphore. Checking if it's
                	; already owned prevents this lockup.
                	;
                	; Parameters:
                	; r1 = address of semaphore to lock
                	;------------------------------------------------------------------------------
                	
                	LockSema:
0144CC 67 E1 01 00 	    push    r2
0144D0 E7 E1 01 00 	    push    r3
                	
                	    ; Interrupts should be already enabled or there would be no way for a locked
                	    ; semaphore to clear. Let's enable interrupts just in case.
0144D4 02 00 00 6E 	    cli
                	.0001:
0144D8 DC 30 00 00 	    lwar    r3,[r1]
0144DC 82 21 30 2C 	    cmpu    r2,r3,tr            ; does the task already own the lock ?
0144E0 3D 01 0E 00 	    beq     r2,.0002
0144E4 BD 11 FA FF 	    bne     r3,.0001            ; branch if not yet free
0144E8 EE 80 01 00 	    swcr    tr,[r1]             ; try and lock it
0144EC 02 30 00 3E 	    mfspr   r3,cr0
0144F0 7C 00 00 10 	    and     r3,r3,#$1000000000
0144F4 8C 31 00 00 
0144F8 BD 01 F0 FF 	    beq     r3,.0001            ; lock failed, go try again
                	.0002:
0144FC 57 3F 10 00 	    pop     r3
014500 57 2F 10 00 	    pop     r2
014504 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	; StartTask
                	;
                	; Startup a task. The task is automatically allocated a 1kW stack from the BIOS
                	; stacks area. 
                	;
                	; Parameters:
                	;	r1 = task priority
                	;	r2 = start flags
                	;	r3 = start address
                	;	r4 = start parameter
                	;	r5 = job handle
                	;------------------------------------------------------------------------------
                	
                	StartTask:
014508 E7 EF 01 00 	    push    lr
01450C E7 E0 01 00 	    push    r1
014510 67 E1 01 00 	    push    r2
014514 E7 E1 01 00 	    push    r3
014518 67 E2 01 00 	    push    r4
01451C E7 E2 01 00 	    push    r5
014520 67 E3 01 00 		push    r6
014524 E7 E3 01 00 		push    r7
014528 67 E4 01 00 		push    r8
01452C 82 60 00 1A 		mov		r6,r1				; r6 = task priority
014530 02 81 00 1A 		mov		r8,r2				; r8 = flag register value on startup
                		
                		; get a free TCB
                		;
014534 39 EC FF FF 	    bsr     LockFreeTCB
014538 7C C0 00 00 		lw		r1,FreeTCB			; get free tcb list pointer
01453C 46 10 00 01 
014540 BD 00 70 00 		beq		r1,stask1
014544 82 20 00 1A 		mov     r2,r1
014548 46 11 30 04 		lw		r1,TCB_NextFree[r2]
01454C 7C C0 00 00 		sw		r1,FreeTCB			; update the FreeTCB list pointer
014550 63 10 00 01 
014554 7C C0 00 00 		sw		r0,freetcb_sema
014558 63 00 60 02 
01455C 0A 10 A2 00 		ldi		r1,#81
014560 7C DC FF 00 		sc		r1,LEDS
014564 61 10 00 0C 
014568 02 11 00 1A 		mov     r1,r2				; r1 = TCB pointer
                	
                	;	sw		r1,TCB_mbx[r2]???
                		
                		; setup the stack for the task
                		; Zap the stack memory.
01456C 02 71 00 1A 		mov		r7,r2
014570 7C C1 00 00 		subui   r2,r2,#TCB_Array
014574 15 21 00 00 
014578 18 21 00 06 		divu    r2,r2,#TCB_Size     ; r2 = index number of TCB
01457C 02 21 18 70 		asl		r2,r2,#12			; 4kB stack per task
014580 7C F0 07 00 		addui	r8,r2,#STACKS_Array	; add in stack base
014584 14 81 00 00 
014588 02 24 00 1A 		mov     r2,r8
01458C 14 21 F0 1F 		addui   r2,r2,#4088
014590 E3 23 D0 04 		sw      r2,TCB_StackTop[r7]
014594 E3 23 F0 01 		sw      r2,TCB_r31[r7]
                		
                		; Fill the stack with the ExitTask address. This will cause a return
                		; to the ExitTask routine when the task finishes.
014598 E7 E0 01 00 		push    r1
01459C 67 E1 01 00 		push    r2
0145A0 E7 E1 01 00 		push    r3
0145A4 7C 01 00 00 		ldi		r1,#ExitTask		; r1 = fill value
0145A8 0A 10 B0 8C 
                	.stask6:
0145AC 63 11 00 00 		sw      r1,[r2]
0145B0 15 21 10 00 		subui   r2,r2,#8
0145B4 02 31 10 2C 		cmpu    r3,r2,r8
0145B8 BD 21 FA FF 		bgt     r3,.stask6
0145BC 57 3F 10 00 		pop     r3
0145C0 57 2F 10 00 		pop     r2
0145C4 57 1F 10 00 		pop     r1
                	
0145C8 39 DD FF FF 	    bsr     LockTCB
                	    	
0145CC E0 63 24 04 		sb		r6,TCB_Priority[r7]
0145D0 E0 03 20 04 		sb		r0,TCB_Status[r7]
0145D4 E3 03 F0 04 		sw		r0,TCB_Timeout[r7]
0145D8 E3 53 28 04 		sw		r5,TCB_hJCB[r7]		; save job handle
0145DC 0A 10 A4 00 		ldi		r1,#82
0145E0 7C DC FF 00 		sc		r1,LEDS
0145E4 61 10 00 0C 
0145E8 E3 03 C0 04 		sw		r0,TCB_MbxList[r7]
                	
                		; Insert the task into the ready list
0145EC 82 13 00 1A 		mov     r1,r7
0145F0 B9 56 00 00 		bsr		AddTaskToReadyList
0145F4 7C C0 00 00 		sw		r0,tcb_sema       ; unlock TCB semaphore
0145F8 63 00 90 02 
                	stask2:
0145FC 57 8F 10 00 		pop     r8
014600 57 7F 10 00 		pop     r7
014604 57 6F 10 00 		pop     r6
014608 57 5F 10 00 		pop     r5
01460C 57 4F 10 00 		pop     r4
014610 57 3F 10 00 		pop     r3
014614 57 2F 10 00 		pop     r2
014618 57 1F 10 00 		pop     r1
01461C 3B FF 11 00 		rts
stask1:
014620 7C C0 00 00 		sw		r0,freetcb_sema
014624 63 00 60 02 
014628 B9 59 02 00 		bsr		kernel_panic
01462C 4E 6F 20 6D 		db		"No more task control blocks available.",0
014630 6F 72 65 20 
014634 74 61 73 6B 
014638 20 63 6F 6E 
01463C 74 72 6F 6C 
014640 20 62 6C 6F 
014644 63 6B 73 20 
014648 61 76 61 69 
01464C 6C 61 62 6C 
014650 65 2E 00    
014653 00 3A F5 FF 		bra		stask2
014657 FF          
                	
                	;------------------------------------------------------------------------------
                	; ExitTask
                	;
                	; This routine is called when the task exits with an rts instruction. OR
                	; it may be invoked with a JMP ExitTask. In either case the task must be
                	; running so it can't be on the timeout list.
                	;------------------------------------------------------------------------------
                	message "ExitTask"
                	ExitTask:
                		; release any aquired resources
                		; - mailboxes
                		; - messages
                	;	hoff
014658 39 CB FF FF 	    bsr     LockTCB
01465C 02 1C 00 1A 	    mov     r1,tr
014660 B9 58 00 00 		bsr		RemoveTaskFromReadyList
014664 B9 81 00 00 		bsr		RemoveFromTimeoutList
014668 E3 00 20 04 		sw		r0,TCB_Status[r1]				; set task status to TS_NONE
01466C B9 95 02 00 		bsr		ReleaseIOFocus
                		; Free up all the mailboxes associated with the task.
                	xtsk7:
014670 E7 E0 01 00 		push    r1
014674 C6 10 C0 04 		lw		r1,TCB_MbxList[r1]
014678 BD 00 08 00 		beq		r1,xtsk6
01467C B9 BD 00 00 		bsr		FreeMbx
014680 57 1F 10 00 		pop     r1
014684 BA FD FF FF 		bra		xtsk7
                	xtsk6:
014688 57 1F 10 00 		pop     r1
01468C 0A 20 AC 00 		ldi		r2,#86
014690 7C DC FF 00 		sc		r2,LEDS
014694 61 20 00 0C 
014698 B9 BF FF FF 		bsr     LockFreeTCB
01469C 7C C0 00 00 		lw		r2,FreeTCB						; add the task control block to the free list
0146A0 46 20 00 01 
0146A4 E3 20 30 04 		sw		r2,TCB_NextFree[r1]
0146A8 7C C0 00 00 		sw		r1,FreeTCB
0146AC 63 10 00 01 
0146B0 7C C0 00 00 		sw		r0,freetcb_sema
0146B4 63 00 60 02 
0146B8 7C C0 00 00 		sw      r0,tcb_sema
0146BC 63 00 90 02 
                		; This loop will eventually be interrupted, the interrupt return will not
                		; return to here.
                	xtsk1:
0146C0 3A 00 00 00 		bra     xtsk1
                	
                	;------------------------------------------------------------------------------
                	; KillTask
                	;
                	; "Kills" a task, removing it from all system lists. If the task has the 
                	; IO focus, the IO focus is switched. Task #0 is immortal and cannot be
                	; killed. Task #1 is immortal and cannot be killed.
                	;
                	; Registers Affected: none
                	; Parameters:
                	;	r1 = task number
                	;------------------------------------------------------------------------------
                	;
                	KillTask:
0146C4 E7 EF 01 00 	    push    lr
0146C8 67 E1 01 00 		push    r2
0146CC 7C C1 00 00 		cmpu    r2,r1,#TCB_Array+TCB_Size  ; BIOS task and IDLE task are immortal
0146D0 96 20 00 06 
0146D4 3D 51 46 00 		ble		r2,kt1
0146D8 FC C3 00 00 		cmpu    r2,r1,#TCB_ArrayEnd-TCB_Size
0146DC 96 20 00 FA 
0146E0 3D 21 40 00 		bgt		r2,kt1
0146E4 82 20 00 1A 		mov     r2,r1
0146E8 C6 10 28 04 		lw		r1,TCB_hJCB[r1]
0146EC B9 81 02 00 		bsr		ForceReleaseIOFocus
0146F0 02 11 00 1A 		mov     r1,r2
0146F4 B9 B7 FF FF 		bsr     LockTCB
0146F8 7C 00 00 00 		jsr		RemoveTaskFromReadyList
0146FC 3C F0 93 A4 
014700 7C 00 00 00 		jsr		RemoveFromTimeoutList
014704 3C F0 39 A5 
014708 E0 00 20 04 		sb		r0,TCB_Status[r1]    		; set task status to TS_NONE
                	
                		; Free up all the mailboxes associated with the task.
                	kt7:
01470C E7 E0 01 00 		push    r1
014710 82 20 00 1A 		mov     r2,r1
014714 C6 10 C0 04 		lw		r1,TCB_MbxList[r1]
014718 BD 00 08 00 		beq		r1,kt6
01471C B9 AC 00 00 		bsr		FreeMbx2
014720 57 1F 10 00 		pop     r1
014724 3A FD FF FF 		bra		kt7
                	kt6:
014728 7C C0 00 00 	    sw      r0,tcb_sema
01472C 63 00 90 02 
014730 57 1F 10 00 	    pop     r1
014734 39 AC FF FF 	    bsr     LockFreeTCB
014738 7C C0 00 00 		lw		r2,FreeTCB					; add the task control block to the free list
01473C 46 20 00 01 
014740 E3 20 30 04 		sw		r2,TCB_NextFree[r1]
014744 7C C0 00 00 		sw		r1,FreeTCB
014748 63 10 00 01 
01474C 7C C0 00 00 		sw		r0,freetcb_sema
014750 63 00 60 02 
014754 82 20 30 0C 		cmp     r2,r1,tr                    ; keep running the current task as long as
014758 3D 11 04 00 		bne		r2,kt1						; the task didn't kill itself.
                	.self:
01475C 3A 00 00 00 		bra     .self
                	kt1:
014760 57 2F 10 00 		pop     r2
014764 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	
                	message "DumpTaskList"
                	DumpTaskList:
014768 E7 EF 01 00 	    push    lr
01476C E7 E0 01 00 		push    r1
014770 67 E1 01 00 		push    r2
014774 E7 E1 01 00 		push    r3
014778 67 E2 01 00 		push	r4
01477C 7C 01 00 00 		ldi		r1,#msgTaskList
014780 0A 10 68 90 
014784 39 FA F7 FF 		bsr		DisplayString
014788 0A 30 00 00 		ldi		r3,#0
                	.0001:
                	;    lwar    r4,tcb_sema
                	;    bne     r4,.0001
                	;    swcr    tr,tcb_sema
                	;    mfspr   r4,cr0
                	;    and     r4,r4,#$1000000000
                	;    beq     r4,.0001
                	dtl2:
01478C 7C C0 00 00 		lw		r1,QNdx0[r3]
014790 C6 11 70 00 
014794 82 40 00 1A 		mov		r4,r1
014798 3D 02 3A 00 		beq		r4,dtl1
                	dtl3:
01479C 0A 20 06 00 		ldi	    r2,#3
0147A0 82 11 06 72 		lsr     r1,r3,#3
0147A4 B9 0B F8 FF 		bsr		PRTNUM
0147A8 39 08 F8 FF 		bsr		DisplaySpace
0147AC 02 12 00 1A 		mov		r1,r4
0147B0 39 E7 F7 FF 		bsr		DisplayHalf
0147B4 B9 06 F8 FF 		bsr		DisplaySpace
0147B8 39 06 F8 FF 		bsr		DisplaySpace
0147BC 02 12 00 1A 		mov		r1,r4
0147C0 C0 10 20 04 		lb		r1,TCB_Status[r1]
0147C4 B9 E9 F7 FF 		bsr		DisplayByte
0147C8 39 04 F8 FF 		bsr		DisplaySpace
0147CC 0A 20 06 00 		ldi		r2,#3
0147D0 46 12 10 04 		lw		r1,TCB_PrevRdy[r4]
0147D4 B9 E2 F7 FF 		bsr		DisplayHalf
0147D8 39 02 F8 FF 		bsr		DisplaySpace
0147DC 0A 20 06 00 		ldi		r2,#3
0147E0 46 12 00 04 		lw		r1,TCB_NextRdy[r4]
0147E4 B9 E0 F7 FF 		bsr		DisplayHalf
0147E8 39 00 F8 FF 		bsr		DisplaySpace
0147EC 46 12 F0 04 		lw		r1,TCB_Timeout[r4]
0147F0 B9 DC F7 FF 		bsr		DisplayWord
0147F4 B9 F3 F7 FF 		bsr		CRLF
0147F8 46 42 00 04 		lw		r4,TCB_NextRdy[r4]
0147FC 7C C0 00 00 		lw      r1,QNdx0[r3]
014800 C6 11 70 00 
014804 02 12 02 0C 		cmp		r1,r4,r1
014808 BD 10 CA FF 		bne		r1,dtl3
                	dtl1:
01480C 94 31 10 00 		addui   r3,r3,#8
014810 86 41 80 00 		cmp     r4,r3,#64
014814 3D 42 BC FF 		blt		r4,dtl2
014818 7C C0 00 00 		sw		r0,tcb_sema       ; release semaphore
01481C 63 00 90 02 
014820 57 4F 10 00 		pop		r4
014824 57 3F 10 00 		pop     r3
014828 57 2F 10 00 		pop     r2
01482C 57 1F 10 00 		pop     r1
014830 3B FF 11 00 		rts

                	msgTaskList:
014834 0D 0A 50 72 		db	CR,LF,"Pri   Task   Stat    Prv     Nxt     Timeout",CR,LF,0
014838 69 20 20 20 
01483C 54 61 73 6B 
014840 20 20 20 53 
014844 74 61 74 20 
014848 20 20 20 50 
01484C 72 76 20 20 
014850 20 20 20 4E 
014854 78 74 20 20 
014858 20 20 20 54 
01485C 69 6D 65 6F 
014860 75 74 0D 0A 
014864 00          
                	
                	
                	;------------------------------------------------------------------------------
                	; r1 = task number
                	; r2 = new priority
                	;------------------------------------------------------------------------------
                	
                	SetTaskPriority:
014865 00 00 00 E7 	    push    lr
014869 EF 01 00    
01486C E7 E1 01 00 		push    r3
014870 39 88 FF FF 		bsr     LockTCB
014874 C0 30 20 04 		lb		r3,TCB_Status[r1]			    ; if the task is on the ready list
014878 8C 31 30 00 		and		r3,r3,#TS_READY|TS_RUNNING		; then remove it and re-add it.
01487C BD 01 0A 00 		beq		r3,.stp2						; Otherwise just go set the priority field
014880 B9 14 00 00 		bsr		RemoveTaskFromReadyList
014884 E0 30 24 04 		sb		r3,TCB_Priority[r1]
014888 B9 03 00 00 		bsr		AddTaskToReadyList
01488C 3A 01 00 00 		bra		.stp3
                	.stp2:
014890 E0 30 24 04 		sb		r3,TCB_Priority[r1]
                	.stp3:
014894 7C C0 00 00 		sw		r0,tcb_sema
014898 63 00 90 02 
01489C 57 3F 10 00 		pop     r3
0148A0 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; AddTaskToReadyList
                	;
                	; The ready list is a group of eight ready lists, one for each priority
                	; level. Each ready list is organized as a doubly linked list to allow fast
                	; insertions and removals. The list is organized as a ring (or bubble) with
                	; the last entry pointing back to the first. This allows a fast task switch
                	; to the next task. Which task is at the head of the list is maintained
                	; in the variable QNdx for the priority level.
                	;
                	; Registers Affected: none
                	; Parameters:
                	;	r1 = pointer to task control block
                	; Returns:
                	;	none
                	;------------------------------------------------------------------------------
                	message "AddToReadyList"
                	AddTaskToReadyList:
0148A4 67 E1 01 00 	    push    r2
0148A8 E7 E1 01 00 	    push    r3
0148AC 67 E2 01 00 	    push    r4
0148B0 0A 20 20 00 		ldi     r2,#TS_READY
0148B4 E0 20 20 04 		sb		r2,TCB_Status[r1]
0148B8 E3 00 00 04 		sw		r0,TCB_NextRdy[r1]
0148BC E3 00 10 04 		sw		r0,TCB_PrevRdy[r1]
0148C0 C0 30 24 04 		lb		r3,TCB_Priority[r1]
0148C4 86 41 10 00 		cmp		r4,r3,#8
0148C8 3D 42 04 00 		blt		r4,arl1
0148CC 0A 30 0E 00 		ldi		r3,#PRI_LOWEST
                	arl1:
0148D0 82 31 06 70 	    asl     r3,r3,#3
0148D4 7C C0 00 00 		lw		r2,QNdx0[r3]
0148D8 C6 21 70 00 
0148DC 3D 01 14 00 		beq		r2,arl5
0148E0 46 31 10 04 		lw		r3,TCB_PrevRdy[r2]
0148E4 E3 21 00 04 		sw		r2,TCB_NextRdy[r3]
0148E8 E3 30 10 04 		sw		r3,TCB_PrevRdy[r1]
0148EC 63 11 10 04 		sw		r1,TCB_PrevRdy[r2]
0148F0 E3 20 00 04 		sw		r2,TCB_NextRdy[r1]
0148F4 57 4F 10 00 		pop     r4
0148F8 57 3F 10 00 		pop     r3
0148FC 57 2F 10 00 		pop     r2
014900 37 FF 01 00 		rtl

                		; Here the ready list was empty, so add at head
                	arl5:
014904 7C C0 00 00 		sw		r1,QNdx0[r3]
014908 E3 11 70 00 
01490C E3 10 00 04 		sw		r1,TCB_NextRdy[r1]
014910 E3 10 10 04 		sw		r1,TCB_PrevRdy[r1]
014914 57 4F 10 00 		pop     r4
014918 57 3F 10 00 		pop     r3
01491C 57 2F 10 00 		pop     r2
014920 37 FF 01 00 		rtl
	
                	
                	;------------------------------------------------------------------------------
                	; RemoveTaskFromReadyList
                	;
                	; This subroutine removes a task from the ready list.
                	;
                	; Registers Affected: none
                	; Parameters:
                	;	r1 = pointer to task control block
                	; Returns:
                	;   r1 = pointer to task control block
                	;------------------------------------------------------------------------------
                	message "RemoveFromReadyList"
                	RemoveTaskFromReadyList:
014924 67 E1 01 00 	    push    r2
014928 E7 E1 01 00 	    push    r3
01492C 67 E2 01 00 		push	r4
014930 E7 E2 01 00 		push	r5
                	
014934 C0 30 20 04 		lb		r3,TCB_Status[r1]	; is the task on the ready list ?
014938 8C 41 30 00 		and		r4,r3,#TS_READY|TS_RUNNING
01493C 3D 02 2A 00 		beq		r4,rfr2
014940 8C 31 CE FF 		and		r3,r3,#~(TS_READY|TS_RUNNING)
	sb		r3,TCB_Status[r1]	; task status no longer running or ready
014944 E0 30 20 04 
014948 C6 40 00 04 		lw		r4,TCB_NextRdy[r1]	; Get previous and next fields.
01494C C6 50 10 04 		lw		r5,TCB_PrevRdy[r1]
014950 E3 42 00 04 		sw		r4,TCB_NextRdy[r5]
014954 63 52 10 04 		sw		r5,TCB_PrevRdy[r4]
014958 C0 30 24 04 		lb		r3,TCB_Priority[r1]
01495C 82 31 06 70 		asl     r3,r3,#3
014960 7C C0 00 00 		lw      r5,QNdx0[r3]
014964 C6 51 70 00 
014968 82 50 0A 0C 		cmp		r5,r1,r5			; Are we removing the QNdx task ?
01496C BD 12 12 00 		bne		r5,rfr2
014970 7C C0 00 00 		sw		r4,QNdx0[r3]
014974 E3 41 70 00 
                		; Now we test for the case where the task being removed was the only one
                		; on the ready list of that priority level. We can tell because the
                		; NxtRdy would point to the task itself.
014978 02 52 02 0C 		cmp		r5,r4,r1				
01497C BD 12 0A 00 		bne		r5,rfr2
014980 7C C0 00 00 		sw		r0,QNdx0[r3]        ; Make QNdx NULL
014984 E3 01 70 00 
014988 E3 00 00 04 		sw		r0,TCB_NextRdy[r1]
01498C E3 00 10 04 		sw		r0,TCB_PrevRdy[r1]
                	rfr2:
014990 57 5F 10 00 		pop		r5
014994 57 4F 10 00 		pop		r4
014998 57 3F 10 00 		pop     r3
01499C 57 2F 10 00 		pop     r2
0149A0 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; AddToTimeoutList
                	; AddToTimeoutList adds a task to the timeout list. The task is placed in the
                	; list depending on it's timeout value.
                	;
                	; Registers Affected: none
                	; Parameters:
                	;	r1 = task
                	;	r2 = timeout value
                	;------------------------------------------------------------------------------
                	message "AddToTimeoutList"
                	AddToTimeoutList:
0149A4 67 E1 01 00 		push    r2
0149A8 E7 E1 01 00 		push    r3
0149AC 67 E2 01 00 		push	r4
0149B0 E7 E2 01 00 		push	r5
                	
0149B4 0A 50 00 00 	    ldi     r5,#0
0149B8 E3 00 50 04 		sw		r0,TCB_NextTo[r1]   ; these fields should already be NULL
0149BC E3 00 60 04 		sw		r0,TCB_PrevTo[r1]
0149C0 7C C0 00 00 		lw		r4,TimeoutList		; are there any tasks on the timeout list ?
0149C4 46 40 10 01 
0149C8 3D 02 3A 00 		beq		r4,attl_add_at_head	; If not, update head of list
                	attl_check_next:
0149CC 46 32 F0 04 	    lw      r3,TCB_Timeout[r4]            
0149D0 02 21 06 2A 		subu	r2,r2,r3	        ; is this timeout > next
0149D4 3D 41 12 00 		blt		r2,attl_insert_before
0149D8 02 52 00 1A 		mov		r5,r4
0149DC 46 42 50 04 		lw		r4,TCB_NextTo[r4]
0149E0 3D 12 F6 FF 		bne		r4,attl_check_next
                	
                		; timeout of a greater value. So we add the task to the end of the list.
                	attl_add_at_end:
                		; Here we scanned until the end of the timeout list and didn't find a 
0149E4 E3 00 50 04 		sw		r0,TCB_NextTo[r1]		; 
0149E8 E3 12 50 04 		sw		r1,TCB_NextTo[r5]
0149EC E3 50 60 04 		sw		r5,TCB_PrevTo[r1]
0149F0 E3 20 F0 04 		sw		r2,TCB_Timeout[r1]
0149F4 BA 0B 00 00 		bra		attl_exit
                	
                	attl_insert_before:
0149F8 BD 02 0C 00 		beq		r5,attl_insert_before_head
0149FC E3 40 50 04 		sw		r4,TCB_NextTo[r1]	; next on list goes after this task
014A00 E3 50 60 04 		sw		r5,TCB_PrevTo[r1]	; set previous link
014A04 E3 12 50 04 		sw		r1,TCB_NextTo[r5]
014A08 63 12 60 04 		sw		r1,TCB_PrevTo[r4]
014A0C 3A 03 00 00 		bra		attl_adjust_timeout
                	
                		; Here there is no previous entry in the timeout list
                		; Add at start
                	attl_insert_before_head:
014A10 63 12 60 04 		sw		r1,TCB_PrevTo[r4]
014A14 E3 00 60 04 		sw		r0,TCB_PrevTo[r1]	;
014A18 E3 40 50 04 		sw		r4,TCB_NextTo[r1]
014A1C 7C C0 00 00 		sw		r1,TimeoutList			; update the head pointer
014A20 63 10 10 01 
                	attl_adjust_timeout:
014A24 02 21 06 28 		addu	r2,r2,r3	       ; get back timeout
014A28 E3 20 F0 04 		sw		r2,TCB_Timeout[r1]
014A2C 46 52 F0 04 		lw		r5,TCB_Timeout[r4]	; adjust the timeout of the next task
014A30 82 52 04 2A 		subu	r5,r5,r2
014A34 63 52 F0 04 		sw		r5,TCB_Timeout[r4]
014A38 3A 03 00 00 		bra		attl_exit
                	
                		; Here there were no tasks on the timeout list, so we add at the
                		; head of the list.
                	attl_add_at_head:
014A3C 7C C0 00 00 		sw		r1,TimeoutList		; set the head of the timeout list
014A40 63 10 10 01 
014A44 E3 20 F0 04 		sw		r2,TCB_Timeout[r1]
                		; flag no more entries in timeout list
014A48 E3 00 50 04 		sw		r0,TCB_NextTo[r1]	; no next entries
014A4C E3 00 60 04 		sw		r0,TCB_PrevTo[r1]	; and no prev entries
                	attl_exit:
014A50 C0 20 20 04 		lb		r2,TCB_Status[r1]	; set the task's status as timing out
014A54 0D 21 02 00 		or		r2,r2,#TS_TIMEOUT
014A58 E0 20 20 04 		sb		r2,TCB_Status[r1]
014A5C 57 5F 10 00 		pop		r5
014A60 57 4F 10 00 		pop		r4
014A64 57 3F 10 00 		pop     r3
014A68 57 2F 10 00 		pop     r2
014A6C 37 FF 01 00 		rtl
	
                	;------------------------------------------------------------------------------
                	; RemoveFromTimeoutList
                	;
                	; This routine is called when a task is killed. The task may need to be
                	; removed from the middle of the timeout list.
                	;
                	; On entry: the timeout list semaphore must be already set.
                	; Registers Affected: none
                	; Parameters:
                	;	 r1 = pointer to task control block
                	;------------------------------------------------------------------------------
                	
                	RemoveFromTimeoutList:
014A70 67 E1 01 00 		push    r2
014A74 E7 E1 01 00 		push    r3
014A78 67 E2 01 00 		push	r4
014A7C E7 E2 01 00 		push	r5
                	
014A80 C0 40 20 04 		lb		r4,TCB_Status[r1]		; Is the task even on the timeout list ?
014A84 0C 42 02 00 		and		r4,r4,#TS_TIMEOUT
014A88 3D 02 40 00 		beq		r4,rftl_not_on_list
014A8C 7C C0 00 00 		lw      r5,TimeoutList
014A90 46 50 10 01 
014A94 82 40 0A 0C 		cmp		r4,r1,r5         		; Are we removing the head of the list ?
014A98 3D 02 18 00 		beq		r4,rftl_remove_from_head
014A9C C6 40 60 04 		lw		r4,TCB_PrevTo[r1]		; adjust the links of the next and previous
014AA0 3D 02 26 00 		beq		r4,rftl_empty_list		; no previous link - list corrupt?
014AA4 C6 50 50 04 		lw		r5,TCB_NextTo[r1]		; tasks on the list to point around the task
014AA8 63 52 50 04 		sw		r5,TCB_NextTo[r4]
014AAC BD 02 20 00 		beq		r5,rftl_empty_list
014AB0 E3 42 60 04 		sw		r4,TCB_PrevTo[r5]
014AB4 C6 20 F0 04 		lw		r2,TCB_Timeout[r1]		; update the timeout of the next on list
014AB8 C6 32 F0 04 		lw      r3,TCB_Timeout[r5]
014ABC 02 21 06 08 		add		r2,r2,r3            	; with any remaining timeout in the task
014AC0 E3 22 F0 04 		sw		r2,TCB_Timeout[r5]		; removed from the list
014AC4 3A 05 00 00 		bra		rftl_empty_list
                	
                		; Update the head of the list.
                	rftl_remove_from_head:
014AC8 C6 50 50 04 		lw		r5,TCB_NextTo[r1]
014ACC 7C C0 00 00 		sw		r5,TimeoutList			; store next field into list head
014AD0 63 50 10 01 
014AD4 BD 02 0C 00 		beq		r5,rftl_empty_list
014AD8 C6 40 F0 04 		lw		r4,TCB_Timeout[r1]		; add any remaining timeout to the timeout
014ADC C6 32 F0 04 		lw      r3,TCB_Timeout[r5]
014AE0 02 42 06 08 		add		r4,r4,r3            	; of the next task on the list.
014AE4 E3 42 F0 04 		sw		r4,TCB_Timeout[r5]
014AE8 E3 02 60 04 		sw		r0,TCB_PrevTo[r5]       ; there is no previous item to the head
                		
                		; Here there is no previous or next items in the list, so the list
                		; will be empty once this task is removed from it.
                	rftl_empty_list:
014AEC 82 20 00 1A 		mov     r2,r1
014AF0 40 31 20 04 		lb		r3,TCB_Status[r2]	; clear timeout status (bit #0)
014AF4 8C 31 FC 01 		and     r3,r3,#$FE
014AF8 60 31 20 04 		sb      r3,TCB_Status[r2]
014AFC 63 01 50 04 		sw		r0,TCB_NextTo[r2]	; make sure the next and prev fields indicate	
014B00 63 01 60 04 		sw	    r0,TCB_PrevTo[r2]   ; the task is not on a list.
014B04 02 11 00 1A 		mov     r1,r2
                	rftl_not_on_list:
014B08 57 5F 10 00 		pop		r5
014B0C 57 4F 10 00 		pop		r4
014B10 57 3F 10 00 		pop     r3
014B14 57 2F 10 00 		pop     r2
                	rftl_not_on_list2:
014B18 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; PopTimeoutList
                	;
                	; This subroutine is called from within the timer ISR when the task's 
                	; timeout expires. It's always the head of the list that's being removed in
                	; the timer ISR so the removal from the timeout list is optimized. We know
                	; the timeout expired, so the amount of time to add to the next task is zero.
                	;
                	; Registers Affected: 
                	; Parameters:
                	;	r2: head of timeout list
                	; Returns:
                	;	r1 = task id of task popped from timeout list
                	;------------------------------------------------------------------------------
                	
                	PopTimeoutList:
014B1C 46 11 50 04 		lw		r1,TCB_NextTo[r2]
014B20 7C C0 00 00 		sw		r1,TimeoutList  ; store next field into list head
014B24 63 10 10 01 
014B28 BD 00 04 00 		beq		r1,ptl1
014B2C E3 00 60 04 		sw		r0,TCB_PrevTo[r1]; previous link = NULL
                	ptl1:
014B30 40 11 20 04 	    lb      r1,TCB_Status[r2]
014B34 8C 10 FC 01 	    and     r1,r1,#$FE       ; clear timeout status
014B38 60 11 20 04 	    sb      r1,TCB_Status[r2]
014B3C 63 01 50 04 		sw		r0,TCB_NextTo[r2]	; make sure the next and prev fields indicate
014B40 63 01 60 04 		sw		r0,TCB_PrevTo[r2]		; the task is not on a list.
014B44 02 11 00 1A 		mov     r1,r2
014B48 37 FF 01 00 	    rtl

                	;------------------------------------------------------------------------------
                	; Sleep
                	;
                	; Put the currently running task to sleep for a specified time.
                	;
                	; Registers Affected: none
                	; Parameters:
                	;	r1 = time duration in jiffies (1/60 second).
                	; Returns: none
                	;------------------------------------------------------------------------------
                	message "sleep"
                	
                	Sleep:
014B4C E7 EF 01 00 	    push    lr
014B50 E7 E0 01 00 	    push    r1
014B54 67 E1 01 00 	    push    r2
014B58 82 20 00 1A 		mov     r2,r1
014B5C B9 2A FF FF 		bsr     LockTCB
014B60 02 1C 00 1A 		mov		r1,tr
014B64 39 B8 FF FF 		bsr		RemoveTaskFromReadyList
014B68 B9 C7 FF FF 		bsr		AddToTimeoutList	; The scheduler will be returning to this
014B6C 7C C0 00 00 		sw		r0,tcb_sema
014B70 63 00 90 02 
014B74 38 0F 04 80 		int		#2				; task eventually, once the timeout expires,
014B78 57 2F 10 00 		pop     r2
014B7C 57 1F 10 00 		pop     r1
014B80 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; Allocate a mailbox
                	; Parameters:
                	;	r1 = pointer to place to store handle
                	; Returns:
                	;	r1 = E_Ok	means mailbox allocated properly
                	;	r1 = E_Arg	means a NULL pointer was passed in r1
                	;	r1 = E_NoMoreMbx	means no more mailboxes were available
                	;	zf is set if everything is ok, otherwise zf is clear
                	;------------------------------------------------------------------------------
                	;
                	AllocMbx:
014B84 BD 00 60 00 		beq		r1,ambx_bad_ptr
014B88 E7 EF 01 00 		push    lr
014B8C 67 E1 01 00 		push    r2
014B90 E7 E1 01 00 		push    r3
014B94 67 E2 01 00 		push	r4
                		ld		r4,r1			; r4 = pointer to returned handle
014B98 39 15 FF FF 		bsr     LockFreeMBX
014B9C 7C C0 00 00 		lw		r1,FreeMbxHandle			; Get mailbox off of free mailbox list
014BA0 46 10 30 01 
014BA4 63 12 00 00 		sw		r1,[r4]			; store off the mailbox number
014BA8 BD 00 52 00 		beq		r1,ambx_no_mbxs
014BAC C6 20 00 00 		lw		r2,MBX_LINK[r1]		; and update the head of the list
014BB0 7C C0 00 00 		sw		r2,FreeMbxHandle
014BB4 63 20 30 01 
014BB8 7C C0 00 00 		dec		nMailbox		; decrement number of available mailboxes
014BBC 64 F0 41 01 
014BC0 7C C0 00 00 		sw		r0,freembx_sema
014BC4 63 00 70 02 
014BC8 39 1D FF FF 		bsr     LockTCB
014BCC 02 3C 00 1A 		mov		r3,tr           ; Add the mailbox to the list of mailboxes
014BD0 46 2C C0 04 		lw		r2,TCB_MbxList[tr]	; managed by the task.
014BD4 E3 20 00 00 		sw		r2,MBX_LINK[r1]
014BD8 63 1C C0 04 		sw		r1,TCB_MbxList[tr]
014BDC 82 20 00 1A 		mov     r2,r1
014BE0 46 1C 28 04 		lw		r1,TCB_hJCB[tr]
014BE4 7C C0 00 00 		sw		r0,tcb_sema
014BE8 63 00 90 02 
                	
014BEC B9 11 FF FF 		bsr     LockMBX
014BF0 63 81 A1 00 		sw		tr,MBX_OWNER[r2]
014BF4 63 01 10 00 		sw		r0,MBX_TQ_HEAD[r2] ; initialize the head and tail of the queues
014BF8 63 01 30 00 		sw		r0,MBX_TQ_TAIL[r2]
014BFC 63 01 40 00 		sw		r0,MBX_MQ_HEAD[r2]
014C00 63 01 50 00 		sw		r0,MBX_MQ_TAIL[r2]
014C04 63 01 60 00 		sw		r0,MBX_TQ_COUNT[r2]	; initialize counts to zero
014C08 63 01 80 00 		sw		r0,MBX_MQ_COUNT[r2]
014C0C 63 01 90 00 		sw		r0,MBX_MQ_MISSED[r2]
014C10 0A 10 10 00 		ldi		r1,#8				; set the max queue size
014C14 63 11 70 00 		sw		r1,MBX_MQ_SIZE[r2]	; and
014C18 7C 00 00 00 		ldi		r1,#MQS_NEWEST		; queueing strategy
014C1C 7C 00 00 00 
014C20 0A 10 B6 06 
014C24 63 11 B0 00 		sw		r1,MBX_MQ_STRATEGY[r2]
014C28 7C C0 00 00 		sw		r0,mbx_sema
014C2C 63 00 D0 02 
014C30 57 4F 10 00 		pop		r4
014C34 57 3F 10 00 		pop     r3
014C38 57 2F 10 00 		pop     r2
014C3C 0A 10 00 00 		ldi		r1,#E_Ok
014C40 3B FF 11 00 		rts
ambx_bad_ptr:
014C44 0A 10 02 00 		ldi		r1,#E_Arg
014C48 37 FF 01 00 		rtl
ambx_no_mbxs:
014C4C 7C C0 00 00 		sw		r0,freembx_sema
014C50 63 00 70 02 
014C54 57 4F 10 00 		pop		r4
014C58 57 3F 10 00 		pop     r3
014C5C 57 2F 10 00 		pop     r2
014C60 0A 10 80 00 		ldi		r1,#E_NoMoreMbx
014C64 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; Free up a mailbox.
                	;	This function frees a mailbox from the currently running task. It may be
                	; called by ExitTask().
                	;
                	; Parameters:
                	;	r1 = mailbox handle
                	;------------------------------------------------------------------------------
                	
                	FreeMbx:
014C68 E7 EF 01 00 	    push    lr
014C6C 67 E1 01 00 		push    r2
014C70 02 2C 00 1A 		mov     r2,tr
014C74 B9 01 00 00 		bsr		FreeMbx2
014C78 57 2F 10 00 		pop     r2
014C7C 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; Free up a mailbox.
                	;	This function dequeues any messages from the mailbox and adds the messages
                	; back to the free message pool. The function also dequeues any threads from
                	; the mailbox.
                	;	Called from KillTask() and FreeMbx().
                	;
                	; Parameters:
                	;	r1 = mailbox handle
                	;	r2 = task handle
                	; Returns:
                	;	r1 = E_Ok	if everything ok
                	;	r1 = E_Arg	if a bad handle is passed
                	;------------------------------------------------------------------------------
                	
                	FreeMbx2:
014C80 E7 EF 01 00 	    push    lr
014C84 67 E1 01 00 		push    r2
014C88 E7 E1 01 00 		push    r3
014C8C 67 E2 01 00 		push    r4
014C90 39 FD FE FF 		bsr     LockMBX
                	
                		; Dequeue messages from mailbox and add them back to the free message list.
                	fmbx5:
014C94 E7 E0 01 00 		push    r1
014C98 39 43 00 00 		bsr		DequeueMsgFromMbx
014C9C BD 00 1A 00 		beq		r1,fmbx3
014CA0 B9 F7 FE FF 		bsr     LockFreeMSG
014CA4 67 E1 01 00 		push    r2
014CA8 7C C0 00 00 		lw		r2,FreeMsg
014CAC 46 20 50 01 
014CB0 E3 20 00 00 		sw		r2,MSG_LINK[r1]
014CB4 7C C0 00 00 		sw		r1,FreeMsg
014CB8 63 10 50 01 
014CBC 7C C0 00 00 		sw		r0,freemsg_sema
014CC0 63 00 80 02 
014CC4 57 2F 10 00 		pop     r2
014CC8 57 1F 10 00 		pop     r1
014CCC 3A F9 FF FF 		bra		fmbx5
                	fmbx3:
014CD0 57 1F 10 00 		pop     r1
                	
                		; Dequeue threads from mailbox.
                	fmbx6:
014CD4 E7 E0 01 00 		push    r1
014CD8 B9 55 00 00 		bsr		DequeueThreadFromMbx2
014CDC BD 00 06 00 		beq		r1,fmbx7
014CE0 57 1F 10 00 		pop     r1
014CE4 3A FE FF FF 		bra		fmbx6
                	fmbx7:
014CE8 57 1F 10 00 		pop     r1
                	
                		; Remove mailbox from TCB list
014CEC 46 31 C0 04 		lw		r3,TCB_MbxList[r2]
014CF0 67 E1 01 00 		push    r2
014CF4 0A 20 FE FF 		ldi		r2,#-1
                	fmbx10:
014CF8 82 40 06 0C 		cmp		r4,r1,r3
014CFC 3D 02 0C 00 		beq		r4,fmbx9
014D00 82 21 00 1A 		mov     r2,r3
014D04 C6 31 00 00 		lw		r3,MBX_LINK[r3]
014D08 BD 11 F8 FF 		bne		r3,fmbx10
                		; ?The mailbox was not in the list managed by the task.
014D0C 57 2F 10 00 		pop     r2
014D10 BA 08 00 00 		bra		fmbx2
                	fmbx9:
014D14 3D 01 0A 00 		beq		r2,fmbx11
014D18 C6 31 00 00 		lw		r3,MBX_LINK[r3]
014D1C 63 31 00 00 		sw		r3,MBX_LINK[r2]
014D20 57 2F 10 00 		pop     r2
014D24 3A 02 00 00 		bra		fmbx12
                	fmbx11:
                		; No prior mailbox in list, update head
014D28 C6 30 00 00 		lw		r3,MBX_LINK[r1]
014D2C 57 2F 10 00 		pop     r2
014D30 63 31 C0 04 		sw		r3,TCB_MbxList[r2]
                	
                	fmbx12:
                		; Add mailbox back to mailbox pool
014D34 B9 E1 FE FF 		bsr     LockFreeMBX
014D38 7C C0 00 00 		lw		r2,FreeMbxHandle
014D3C 46 20 30 01 
014D40 E3 20 00 00 		sw		r2,MBX_LINK[r1]
014D44 7C C0 00 00 		sw		r1,FreeMbxHandle
014D48 63 10 30 01 
014D4C 7C C0 00 00 		sw		r0,freembx_sema
014D50 63 00 70 02 
                	fmbx2:
014D54 7C C0 00 00 		sw		r0,mbx_sema
014D58 63 00 D0 02 
014D5C 57 4F 10 00 		pop     r4
014D60 57 3F 10 00 		pop     r3
014D64 57 2F 10 00 		pop     r2
014D68 0A 10 00 00 		ldi		r1,#E_Ok
014D6C 3B FF 11 00 		rts
fmbx1:
014D70 0A 10 02 00 		ldi		r1,#E_Arg
014D74 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; Queue a message at a mailbox.
                	; On entry the mailbox semaphore is already activated.
                	;
                	; Parameters:
                	;	r1 = message
                	;	r2 = mailbox
                	;------------------------------------------------------------------------------
                	
                	QueueMsgAtMbx:
014D78 BD 00 52 00 		beq		r1,qmam_bad_msg
014D7C E7 EF 01 00 		push    lr
014D80 E7 E0 01 00 		push    r1
014D84 67 E1 01 00 		push    r2
014D88 E7 E1 01 00 		push    r3
014D8C 67 E2 01 00 		push	r4
014D90 46 41 B0 00 		lw		r4,MBX_MQ_STRATEGY[r2]
014D94 7C 00 00 00 		cmp		r3,r4,#MQS_UNLIMITED
014D98 7C 00 00 00 
014D9C 06 32 D4 06 
014DA0 BD 01 26 00 		beq		r3,qmam_unlimited
014DA4 7C 00 00 00 		cmp		r3,r4,#MQS_NEWEST
014DA8 7C 00 00 00 
014DAC 06 32 B6 06 
014DB0 BD 01 38 00 		beq		r3,qmam_newest
014DB4 7C 00 00 00 		cmp		r3,r4,#MQS_OLDEST
014DB8 7C 00 00 00 
014DBC 06 32 DA 06 
014DC0 BD 01 6E 00 		beq		r3,qmam_oldest
014DC4 39 66 01 00 		bsr		kernel_panic
014DC8 49 6C 6C 65 		db		"Illegal message queue strategy",0
014DCC 67 61 6C 20 
014DD0 6D 65 73 73 
014DD4 61 67 65 20 
014DD8 71 75 65 75 
014DDC 65 20 73 74 
014DE0 72 61 74 65 
014DE4 67 79 00    
014DE7 00 BA 0E 00 		bra		qmam8
014DEB 00          
                		; Here we assumed "unlimited" message storage. Just add the new message at
                		; the tail of the queue.
                	qmam_unlimited:
014DEC 46 31 50 00 		lw		r3,MBX_MQ_TAIL[r2]
014DF0 BD 01 06 00 		beq		r3,qmam_add_at_head
014DF4 E3 11 00 00 		sw		r1,MSG_LINK[r3]
014DF8 3A 01 00 00 		bra		qmam2
                	qmam_add_at_head:
014DFC 63 11 40 00 		sw		r1,MBX_MQ_HEAD[r2]
                	qmam2:
014E00 63 11 50 00 		sw		r1,MBX_MQ_TAIL[r2]
                	qmam6:
014E04 64 11 80 00 		inc		MBX_MQ_COUNT[r2]		; increase the queued message count
	sw		r0,MSG_LINK[r1]
014E08 57 4F 10 00 		pop		r4
014E0C 57 3F 10 00 		pop     r3
014E10 57 2F 10 00 		pop     r2
014E14 57 1F 10 00 		pop     r1
014E18 3B FF 11 00 		rts
qmam_bad_msg:
014E1C 37 FF 01 00 		rtl
	; Here we are queueing a limited number of messages. As new messages are
                		; added at the tail of the queue, messages drop off the head of the queue.
                	qmam_newest:
014E20 46 31 50 00 		lw		r3,MBX_MQ_TAIL[r2]
014E24 BD 01 06 00 		beq		r3,qmam3
014E28 E3 11 00 00 		sw		r1,MSG_LINK[r3]
014E2C 3A 01 00 00 		bra		qmam4
                	qmam3:
014E30 63 11 40 00 		sw		r1,MBX_MQ_HEAD[r2]
                	qmam4:
014E34 63 11 50 00 		sw		r1,MBX_MQ_TAIL[r2]
014E38 46 31 80 00 		lw		r3,MBX_MQ_COUNT[r2]
014E3C 94 31 02 00 		addui   r3,r3,#1
014E40 46 41 70 00 		lw      r4,MBX_MQ_SIZE[r2]
014E44 82 31 08 2C 		cmpu    r3,r3,r4
014E48 BD 51 DE FF 		ble		r3,qmam6
014E4C E3 00 00 00 		sw		r0,MSG_LINK[r1]
                		; Remove the oldest message which is the one at the head of the mailbox queue.
                		; Add the message back to the pool of free messages.
014E50 46 11 40 00 		lw		r1,MBX_MQ_HEAD[r2]
014E54 C6 30 00 00 		lw		r3,MSG_LINK[r1]		; move next in queue
014E58 63 31 40 00 		sw		r3,MBX_MQ_HEAD[r2]	; to head of list
                	qmam8:
014E5C 64 11 90 00 		inc		MBX_MQ_MISSED[r2]
qmam1:
014E60 B9 BF FE FF 	    bsr     LockFreeMSG
014E64 7C C0 00 00 		lw		r3,FreeMsg				; put old message back into free message list
014E68 46 30 50 01 
014E6C E3 30 00 00 		sw		r3,MSG_LINK[r1]
014E70 7C C0 00 00 		sw		r1,FreeMsg
014E74 63 10 50 01 
014E78 7C C0 00 00 		inc		nMsgBlk
014E7C 64 10 60 01 
014E80 7C C0 00 00 		sw		r0,freemsg_sema
014E84 63 00 80 02 
                		;GoReschedule
014E88 57 4F 10 00 		pop		r4
014E8C 57 3F 10 00 		pop     r3
014E90 57 2F 10 00 		pop     r2
014E94 57 1F 10 00 		pop     r1
014E98 3B FF 11 00 		rts
	; Here we are buffering the oldest messages. So if there are too many messages
                		; in the queue already, then the queue doesn't change and the new message is
                		; lost.
                	qmam_oldest:
014E9C 46 31 80 00 		lw		r3,MBX_MQ_COUNT[r2]		; Check if the queue is full
014EA0 46 41 70 00 		lw      r4,MBX_MQ_SIZE[r2]
014EA4 82 31 08 2C 		cmpu	r3,r3,r4
014EA8 BD 31 DA FF 		bge		r3,qmam8			; If the queue is full, then lose the current message
014EAC 3A E8 FF FF 		bra		qmam_unlimited		; Otherwise add message to queue
                	
                	;------------------------------------------------------------------------------
                	; Dequeue a message from a mailbox.
                	;
                	; Returns
                	;	r1 = message pointer (NULL if there are no messages)
                	;------------------------------------------------------------------------------
                	
                	DequeueMsgFromMbx:
014EB0 67 E1 01 00 	    push    r2
014EB4 E7 E1 01 00 	    push    r3
014EB8 82 20 00 1A 		mov     r2,r1				; x = mailbox index
014EBC 46 11 80 00 		lw		r1,MBX_MQ_COUNT[r2]		; are there any messages available ?
014EC0 BD 00 1A 00 		beq		r1,dmfm3
014EC4 95 10 02 00 		subui   r1,r1,#1
014EC8 63 11 80 00 		sw		r1,MBX_MQ_COUNT[r2]		; update the message count
014ECC 46 11 40 00 		lw		r1,MBX_MQ_HEAD[r2]		; Get the head of the list, this should not be NULL
014ED0 BD 00 12 00 		beq		r1,dmfm3			; since the message count > 0
014ED4 C6 30 00 00 		lw		r3,MSG_LINK[r1]		; get the link to the next message
014ED8 63 31 40 00 		sw		r3,MBX_MQ_HEAD[r2]		; update the head of the list
014EDC BD 11 04 00 		bne		r3,dmfm2			; if there was no more messages then update the
014EE0 63 31 50 00 		sw		r3,MBX_MQ_TAIL[r2]	; tail of the list as well.
                	dmfm2:
014EE4 E3 10 00 00 		sw		r1,MSG_LINK[r1]		; point the link to the message itself to indicate it's dequeued
                	dmfm1:
014EE8 57 3F 10 00 	    pop     r3
014EEC 57 2F 10 00 	    pop     r2
014EF0 3B FF 11 00 		rts
dmfm3:
014EF4 57 3F 10 00 	    pop     r3
014EF8 57 2F 10 00 	    pop     r2
014EFC 0A 10 00 00 		ldi		r1,#0
014F00 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; Parameters:
                	;	r1 = mailbox handle
                	; Returns:
                	;	r1 = E_arg		means pointer is invalid
                	;	r1 = E_NoThread	means no thread was queued at the mailbox
                	;	r2 = thead handle
                	;------------------------------------------------------------------------------
                	
                	DequeueThreadFromMbx:
014F04 67 E2 01 00 		push	r4
014F08 C6 40 10 00 		lw		r4,MBX_TQ_HEAD[r1]
014F0C 3D 12 0A 00 		bne		r4,dtfm2
014F10 57 4F 10 00 		pop		r4
014F14 0A 20 00 00 		ldi		r2,#0
014F18 0A 10 0C 00 		ldi		r1,#E_NoThread
014F1C 37 FF 01 00 		rtl
dtfm2:
014F20 E7 E2 01 00 		push	r5
014F24 E4 F0 61 00 		dec		MBX_TQ_COUNT[r1]
	mov		r2,r4
014F28 46 42 70 04 		lw		r4,TCB_mbq_next[r4]
014F2C E3 40 10 00 		sw		r4,MBX_TQ_HEAD[r1]
014F30 3D 02 06 00 		beq		r4,dtfm3
014F34 63 02 80 04 			sw		r0,TCB_mbq_prev[r4]
014F38 3A 01 00 00 			bra		dtfm4
                	dtfm3:
014F3C E3 00 30 00 			sw		r0,MBX_TQ_TAIL[r1]
                	dtfm4:
014F40 02 51 00 1A 		mov		r5,r2
014F44 C0 12 20 04 		lb		r1,TCB_Status[r5]
014F48 8C 10 02 00 		and		r1,r1,#TS_TIMEOUT
014F4C BD 00 0C 00 		beq		r1,dtfm5
014F50 82 12 00 1A 		mov		r1,r5
014F54 E7 EF 01 00 		push    lr
014F58 7C 00 00 00 		jsr		RemoveFromTimeoutList
014F5C 3C F0 39 A5 
014F60 57 FF 11 00 		pop     lr
                	dtfm5:
014F64 E3 02 70 04 		sw		r0,TCB_mbq_next[r5]
014F68 E3 02 80 04 		sw		r0,TCB_mbq_prev[r5]
014F6C E3 02 B0 04 		sw		r0,TCB_hWaitMbx[r5]
014F70 E0 02 20 04 		sb		r0,TCB_Status[r5]		; set task status = TS_NONE
014F74 57 5F 10 00 		pop		r5
014F78 57 4F 10 00 		pop		r4
014F7C 0A 10 00 00 		ldi		r1,#E_Ok
014F80 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	;	This function is called from FreeMbx(). It dequeues threads from the
                	; mailbox without removing the thread from the timeout list. The thread will
                	; then timeout waiting for a message that can never be delivered.
                	;
                	; Parameters:
                	;	r1 = mailbox handle
                	; Returns:
                	;	r1 = E_arg		means pointer is invalid
                	;	r1 = E_NoThread	means no thread was queued at the mailbox
                	;	r2 = thead handle
                	;------------------------------------------------------------------------------
                	
                	DequeueThreadFromMbx2:
014F84 67 E2 01 00 		push	r4
014F88 C6 40 10 00 		lw		r4,MBX_TQ_HEAD[r1]
014F8C 3D 12 0A 00 		bne		r4,dtfm2a
014F90 57 4F 10 00 		pop		r4
014F94 0A 20 00 00 		ldi		r2,#0
014F98 0A 10 0C 00 		ldi		r1,#E_NoThread
014F9C 37 FF 01 00 		rtl
dtfm2a:
014FA0 E7 E2 01 00 		push	r5
014FA4 E4 F0 61 00 		dec		MBX_TQ_COUNT[r1]
	mov		r2,r4
014FA8 46 42 70 04 		lw		r4,TCB_mbq_next[r4]
014FAC E3 40 10 00 		sw		r4,MBX_TQ_HEAD[r1]
014FB0 3D 02 06 00 		beq		r4,dtfm3a
014FB4 63 02 80 04 			sw		r0,TCB_mbq_prev[r4]
014FB8 3A 01 00 00 			bra		dtfm4a
                	dtfm3a:
014FBC E3 00 30 00 			sw		r0,MBX_TQ_TAIL[r1]
                	dtfm4a:
014FC0 63 01 70 04 		sw	    r0,TCB_mbq_next[r2]
014FC4 63 01 80 04 		sw		r0,TCB_mbq_prev[r2]
014FC8 63 01 B0 04 		sw		r0,TCB_hWaitMbx[r2]
                	;	sei
014FCC 40 11 20 04 	    lb      r1,TCB_Status[r2]
014FD0 8C 10 FA FF 	    and     r1,r1,#~TS_WAITMSG
014FD4 60 11 20 04 	    sb      r1,TCB_Status[r2]
                	;	cli
014FD8 57 5F 10 00 		pop		r5
014FDC 57 4F 10 00 		pop		r4
014FE0 0A 10 00 00 		ldi		r1,#E_Ok
014FE4 37 FF 01 00 		rtl

                	;------------------------------------------------------------------------------
                	; PostMsg and SendMsg are the same operation except that PostMsg doesn't
                	; invoke rescheduling while SendMsg does. So they both call the same
                	; SendMsgPrim primitive routine. This two wrapper functions for convenience.
                	;------------------------------------------------------------------------------
                	
                	PostMsg:
014FE8 E7 EF 01 00 	    push    lr
014FEC 67 E2 01 00 		push	r4
014FF0 0A 40 00 00 		ldi		r4,#0			; Don't invoke scheduler
014FF4 39 05 00 00 		bsr		SendMsgPrim
014FF8 57 4F 10 00 		pop		r4
014FFC 3B FF 11 00 		rts

                	SendMsg:
015000 E7 EF 01 00 	    push    lr
015004 67 E2 01 00 		push	r4
015008 0A 40 02 00 		ldi		r4,#1			; Do invoke scheduler
01500C 7C 00 00 00 		jsr		SendMsgPrim
015010 3C F0 0F A8 
015014 57 4F 10 00 		pop		r4
015018 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; SendMsgPrim
                	; Send a message to a mailbox
                	;
                	; Parameters
                	;	r1 = handle to mailbox
                	;	r2 = message D1
                	;	r3 = message D2
                	;	r4 = scheduler flag		1=invoke,0=don't invoke
                	;
                	; Returns
                	;	r1=E_Ok			everything is ok
                	;	r1=E_BadMbx		for a bad mailbox number
                	;	r1=E_NotAlloc	for a mailbox that isn't allocated
                	;	r1=E_NoMsg		if there are no more message blocks available
                	;------------------------------------------------------------------------------
                	message "SendMsgPrim"
                	SendMsgPrim:
01501C E7 EF 01 00 	    push    lr
015020 E7 E2 01 00 		push	r5
015024 67 E3 01 00 		push	r6
015028 E7 E3 01 00 		push	r7
                	
01502C B9 89 FE FF 	    bsr     LockMBX
015030 C6 70 A0 00 		lw		r7,MBX_OWNER[r1]
015034 BD 03 7A 00 		beq		r7,smsg2				; error: no owner
015038 E7 E0 01 00 		push    r1
01503C 67 E1 01 00 		push    r2
015040 B9 D8 FF FF 		bsr		DequeueThreadFromMbx	; r1=mbx
015044 02 61 00 1A 		mov		r6,r2					; r6 = thread
015048 57 2F 10 00 		pop     r2
01504C 57 1F 10 00 		pop     r1
015050 3D 13 2C 00 		bne		r6,smsg3
                			; Here there was no thread waiting at the mailbox, so a message needs to
                			; be allocated
                	smp2:
015054 39 81 FE FF 	        bsr     LockFreeMSG
015058 7C C0 00 00 			lw		r7,FreeMsg
01505C 46 70 50 01 
015060 BD 03 72 00 			beq		r7,smsg4		; no more messages available
015064 C6 53 00 00 			lw		r5,MSG_LINK[r7]
015068 7C C0 00 00 			sw		r5,FreeMsg
01506C 63 50 50 01 
015070 7C C0 00 00 			dec		nMsgBlk		; decrement the number of available messages
015074 64 F0 61 01 
015078 7C C0 00 00 			sw		r0,freemsg_sema
01507C 63 00 80 02 
015080 E3 23 10 00 			sw		r2,MSG_D1[r7]
015084 E3 33 20 00 			sw		r3,MSG_D2[r7]
015088 E7 E0 01 00 			push    r1
01508C 67 E1 01 00 			push    r2
015090 82 20 00 1A 			mov     r2,r1			; r2 = mailbox
015094 82 13 00 1A 			mov		r1,r7			; r1 = message
015098 39 9C FF FF 			bsr		QueueMsgAtMbx
01509C 57 2F 10 00 			pop     r2
0150A0 57 1F 10 00 			pop     r1
0150A4 3D 03 30 00 			beq		r6,smsg5    ; check if there is a thread waiting for a message
                	smsg3:
0150A8 63 23 90 04 		sw		r2,TCB_MSG_D1[r6]
0150AC 63 33 A0 04 		sw		r3,TCB_MSG_D2[r6]
                	smsg7:
0150B0 39 80 FE FF 	    bsr     LockTCB
0150B4 40 53 20 04 		lb		r5,TCB_Status[r6]
0150B8 8C 52 02 00 		and		r5,r5,#TS_TIMEOUT
0150BC BD 02 06 00 		beq		r5,smsg8
0150C0 02 13 00 1A 		mov		r1,r6
0150C4 B9 35 FF FF 		bsr		RemoveFromTimeoutList
                	smsg8:
0150C8 40 13 20 04 	    lb      r1,TCB_Status[r6]
0150CC 8C 10 FA FF 	    and     r1,r1,#~TS_WAITMSG
0150D0 60 13 20 04 	    sb      r1,TCB_Status[r6]
0150D4 7C C0 00 00 		sw		r0,tcb_sema
0150D8 63 00 90 02 
0150DC 02 13 00 1A 		mov		r1,r6
0150E0 39 7A FE FF 		bsr     LockTCB
0150E4 39 F8 FE FF 		bsr		AddTaskToReadyList
0150E8 7C C0 00 00 		sw		r0,tcb_sema
0150EC 63 00 90 02 
0150F0 3D 02 0A 00 		beq		r4,smsg5
0150F4 7C C0 00 00 		sw		r0,mbx_sema
0150F8 63 00 D0 02 
0150FC 38 0F 04 80 		int		#2
                		;GoReschedule
015100 BA 01 00 00 		bra		smsg9
                	smsg5:
015104 7C C0 00 00 		sw		r0,mbx_sema
015108 63 00 D0 02 
                	smsg9:
01510C 57 7F 10 00 		pop		r7
015110 57 6F 10 00 		pop		r6
015114 57 5F 10 00 		pop		r5
015118 0A 10 00 00 		ldi		r1,#E_Ok
01511C 3B FF 11 00 		rts
smsg1:
015120 0A 10 08 00 		ldi		r1,#E_BadMbx
015124 37 FF 01 00 		rtl
smsg2:
015128 7C C0 00 00 		sw		r0,mbx_sema
01512C 63 00 D0 02 
015130 57 7F 10 00 		pop		r7
015134 57 6F 10 00 		pop		r6
015138 57 5F 10 00 		pop		r5
01513C 0A 10 12 00 		ldi		r1,#E_NotAlloc
015140 3B FF 11 00 		rts
smsg4:
015144 7C C0 00 00 		sw		r0,freemsg_sema
015148 63 00 80 02 
01514C 7C C0 00 00 		sw		r0,mbx_sema
015150 63 00 D0 02 
015154 57 7F 10 00 		pop		r7
015158 57 6F 10 00 		pop		r6
01515C 57 5F 10 00 		pop		r5
015160 0A 10 16 00 		ldi		r1,#E_NoMsg
015164 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; WaitMsg
                	; Wait at a mailbox for a message to arrive. This subroutine will block the
                	; task until a message is available or the task times out on the timeout
                	; list.
                	;
                	; Parameters
                	;	r1=mailbox
                	;	r2=timeout
                	; Returns:
                	;	r1=E_Ok			if everything is ok
                	;	r1=E_BadMbx		for a bad mailbox number
                	;	r1=E_NotAlloc	for a mailbox that isn't allocated
                	;	r2=message D1
                	;	r3=message D2
                	;------------------------------------------------------------------------------
                	message "WaitMsg"
                	WaitMsg:
                	;	cmp		r3,r1,#NR_MBX			; check the mailbox number to make sure
                	;	bge		r3,wmsg1				; that it's sensible
015168 E7 EF 01 00 		push    lr
01516C 67 E2 01 00 		push	r4
015170 E7 E2 01 00 		push	r5
015174 67 E3 01 00 		push	r6
015178 E7 E3 01 00 		push	r7
01517C 82 60 00 1A 		mov		r6,r1
                	wmsg11:
015180 39 5F FE FF 	    bsr     LockMBX
015184 C6 50 A0 00 		lw		r5,MBX_OWNER[r1]
015188 7C 00 00 00 		cmp		r3,r5,#MAX_TASKNO
01518C 7C 00 00 00 
015190 86 32 16 07 
015194 BD 21 9E 00 		bgt		r3,wmsg2				; error: no owner
015198 39 A3 FF FF 		bsr		DequeueMsgFromMbx
01519C BD 10 5E 00 		bne		r1,wmsg3
                	
                		; Here there was no message available, remove the task from
                		; the ready list, and optionally add it to the timeout list.
                		; Queue the task at the mailbox.
                	wmsg12:
0151A0 39 62 FE FF 	    bsr     LockTCB
0151A4 02 1C 00 1A 		mov		r1,tr				; remove the task from the ready list
0151A8 B9 EF FE FF 		bsr		RemoveTaskFromReadyList
0151AC 7C C0 00 00 		sw		r0,tcb_sema
0151B0 63 00 90 02 
                	wmsg13:
0151B4 B9 5F FE FF 	    bsr     LockTCB
0151B8 C0 70 20 04 		lb		r7,TCB_Status[r1]
0151BC 8D 73 04 00 		or		r7,r7,#TS_WAITMSG			; set task status to waiting
0151C0 E0 70 20 04 		sb		r7,TCB_Status[r1]
0151C4 E3 60 B0 04 		sw		r6,TCB_hWaitMbx[r1]			; set which mailbox is waited for
0151C8 E3 00 70 04 		sw		r0,TCB_mbq_next[r1]			; adding at tail, so there is no next
0151CC 46 73 10 00 		lw		r7,MBX_TQ_HEAD[r6]			; is there a task que setup at the mailbox ?
0151D0 BD 03 36 00 		beq		r7,wmsg6
0151D4 46 73 30 00 		lw		r7,MBX_TQ_TAIL[r6]
0151D8 E3 70 80 04 		sw		r7,TCB_mbq_prev[r1]
0151DC E3 13 70 04 		sw		r1,TCB_mbq_next[r7]
0151E0 63 13 30 00 		sw		r1,MBX_TQ_TAIL[r6]
0151E4 64 13 60 00 		inc		MBX_TQ_COUNT[r6]			; increment number of tasks queued
	
                	
                	wmsg7:
0151E8 7C C0 00 00 		sw		r0,tcb_sema
0151EC 63 00 90 02 
0151F0 7C C0 00 00 		sw		r0,mbx_sema
0151F4 63 00 D0 02 
0151F8 3D 01 0C 00 		beq		r2,wmsg10                   ; check for a timeout
                	wmsg14:
0151FC B9 56 FE FF 	    bsr     LockTCB
015200 B9 F4 FE FF 		bsr		AddToTimeoutList
015204 7C C0 00 00 		sw		r0,tcb_sema
015208 63 00 90 02 
01520C 38 0F 04 80 		int		#2	;	GoReschedule			; invoke the scheduler
                	wmsg10:
                		; At this point either a message was sent to the task, or the task
                		; timed out. If a message is still not available then the task must
                		; have timed out. Return a timeout error.
                		; Note that SendMsg will directly set the message D1, D2 data
                		; without queing a message at the mailbox (if there is a task
                		; waiting already). So we cannot just try dequeing a message again.
015210 C6 20 90 04 		lw		r2,TCB_MSG_D1[r1]
015214 C6 30 A0 04 		lw		r3,TCB_MSG_D2[r1]
015218 C0 40 20 04 		lb		r4,TCB_Status[r1]
01521C 0C 42 04 00 		and		r4,r4,#TS_WAITMSG	; Is the task still waiting for a message ?
015220 3D 02 48 00 		beq		r4,wmsg8			; If not, go return OK status
015224 57 7F 10 00 		pop		r7				; Otherwise return timeout error
015228 57 6F 10 00 		pop		r6
01522C 57 5F 10 00 		pop		r5
015230 57 4F 10 00 		pop		r4
015234 0A 10 20 00 		ldi		r1,#E_Timeout
015238 3B FF 11 00 		rts
	
                		; Here there were no prior tasks queued at the mailbox
                	wmsg6:
01523C E3 00 80 04 		sw		r0,TCB_mbq_prev[r1]		; no previous tasks
015240 E3 00 70 04 		sw		r0,TCB_mbq_next[r1]
015244 63 13 10 00 		sw		r1,MBX_TQ_HEAD[r6]		; set both head and tail indexes
015248 63 13 30 00 		sw		r1,MBX_TQ_TAIL[r6]
01524C 0A 70 02 00 		ldi		r7,#1
015250 63 73 60 00 		sw		r7,MBX_TQ_COUNT[r6]		; one task queued
015254 BA F2 FF FF 		bra		wmsg7					; check for a timeout value
                		
                	wmsg3:
015258 7C C0 00 00 		sw		r0,mbx_sema
01525C 63 00 D0 02 
015260 C6 20 10 00 		lw		r2,MSG_D1[r1]
015264 C6 30 20 00 		lw		r3,MSG_D2[r1]
                		; Add the newly dequeued message to the free messsage list
                	wmsg5:
015268 7C C0 00 00 		lwar    r6,freemsg_sema
01526C 5C 60 80 02 
015270 3D 13 FC FF 		bne     r6,wmsg5
015274 7C C0 00 00 		swcr    tr,freemsg_sema
015278 6E 80 81 02 
01527C 02 60 00 3E 		mfspr   r6,cr0
015280 7C 00 00 10 		and     r6,r6,#$1000000000
015284 0C 63 00 00 
015288 3D 03 F0 FF 		beq     r6,wmsg5
01528C 7C C0 00 00 		lw		r7,FreeMsg
015290 46 70 50 01 
015294 E3 70 00 00 		sw		r7,MSG_LINK[r1]
015298 7C C0 00 00 		sw		r1,FreeMsg
01529C 63 10 50 01 
0152A0 7C C0 00 00 		inc		nMsgBlk
0152A4 64 10 60 01 
0152A8 7C C0 00 00 		sw		r0,freemsg_sema
0152AC 63 00 80 02 
                	wmsg8:
0152B0 57 7F 10 00 		pop		r7
0152B4 57 6F 10 00 		pop		r6
0152B8 57 5F 10 00 		pop		r5
0152BC 57 4F 10 00 		pop		r4
0152C0 0A 10 00 00 		ldi		r1,#E_Ok
0152C4 3B FF 11 00 		rts
wmsg1:
0152C8 0A 10 08 00 		ldi		r1,#E_BadMbx
0152CC 37 FF 01 00 		rtl
wmsg2:
0152D0 7C C0 00 00 		sw		r0,mbx_sema
0152D4 63 00 D0 02 
0152D8 57 7F 10 00 		pop		r7
0152DC 57 6F 10 00 		pop		r6
0152E0 57 5F 10 00 		pop		r5
0152E4 57 4F 10 00 		pop		r4
0152E8 0A 10 12 00 		ldi		r1,#E_NotAlloc
0152EC 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; Check for a message at a mailbox. Does not block. This function is a
                	; convenience wrapper for CheckMsg().
                	;
                	; Parameters
                	;	r1=mailbox handle
                	; Returns:
                	;	r1=E_Ok			if everything is ok
                	;	r1=E_NoMsg		if no message is available
                	;	r1=E_BadMbx		for a bad mailbox number
                	;	r1=E_NotAlloc	for a mailbox that isn't allocated
                	;	r2=message D1
                	;	r3=message D2
                	;------------------------------------------------------------------------------
                	
                	PeekMsg:
0152F0 E7 EF 01 00 	    push    lr
0152F4 0A 20 00 00 		ldi		r2,#0		; don't remove from queue
0152F8 39 01 00 00 		bsr		CheckMsg
0152FC 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; CheckMsg
                	; Check for a message at a mailbox. Does not block.
                	;
                	; Parameters
                	;	r1=mailbox handle
                	;	r2=remove from queue if present
                	; Returns:
                	;	r1=E_Ok			if everything is ok
                	;	r1=E_NoMsg		if no message is available
                	;	r1=E_BadMbx		for a bad mailbox number
                	;	r1=E_NotAlloc	for a mailbox that isn't allocated
                	;	r2=message D1
                	;	r3=message D2
                	;------------------------------------------------------------------------------
                	message "CheckMsg"
                	CheckMsg:
015300 E7 EF 01 00 	    push    lr
015304 67 E3 01 00 	    push    r6
                	;	cmp		r3,r1,#NR_MBX			; check the mailbox number to make sure
                	;	bge		r3,cmsg1				; that it's sensible
015308 67 E2 01 00 		push	r4
01530C E7 E2 01 00 		push	r5
                	
015310 39 2D FE FF 	    bsr     LockMBX
                	
015314 C6 50 A0 00 		lw		r5,MBX_OWNER[r1]
015318 BD 02 3C 00 		beq		r5,cmsg2				; error: no owner
01531C 3D 01 06 00 		beq		r2,cmsg3                ; are we to dequeue the message ?
015320 39 72 FF FF 		bsr		DequeueMsgFromMbx
015324 3A 01 00 00 		bra		cmsg4
                	cmsg3:
015328 C6 10 40 00 		lw		r1,MBX_MQ_HEAD[r1]		; peek the message at the head of the messages queue
                	cmsg4:
01532C BD 00 40 00 		beq		r1,cmsg5
015330 02 41 00 1A 		mov     r4,r2
015334 C6 20 10 00 		lw		r2,MSG_D1[r1]
015338 C6 30 20 00 		lw		r3,MSG_D2[r1]
01533C 3D 02 16 00 		beq		r4,cmsg8
                	cmsg10:
015340 B9 23 FE FF 	    bsr     LockFreeMSG
015344 7C C0 00 00 		lw		r5,FreeMsg
015348 46 50 50 01 
01534C E3 50 00 00 		sw		r5,MSG_LINK[r1]
015350 7C C0 00 00 		sw		r1,FreeMsg
015354 63 10 50 01 
015358 7C C0 00 00 		inc		nMsgBlk
01535C 64 10 60 01 
015360 7C C0 00 00 		sw		r0,freemsg_sema
015364 63 00 80 02 
                	cmsg8:
015368 7C C0 00 00 		sw		r0,mbx_sema
01536C 63 00 D0 02 
015370 57 5F 10 00 		pop		r5
015374 57 4F 10 00 		pop		r4
015378 57 6F 10 00 		pop     r6
01537C 0A 10 00 00 		ldi		r1,#E_Ok
015380 3B FF 11 00 		rts
cmsg1:
015384 0A 10 08 00 		ldi		r1,#E_BadMbx
015388 57 6F 10 00 		pop     r6
01538C 3B FF 11 00 		rts
cmsg2:
015390 7C C0 00 00 		sw		r0,mbx_sema            ; unlock semaphore
015394 63 00 D0 02 
015398 57 5F 10 00 		pop		r5
01539C 57 4F 10 00 		pop		r4
0153A0 57 6F 10 00 		pop     r6
0153A4 0A 10 12 00 		ldi		r1,#E_NotAlloc
0153A8 3B FF 11 00 		rts
cmsg5:
0153AC 7C C0 00 00 		sw		r0,mbx_sema            ; unlock semaphore
0153B0 63 00 D0 02 
0153B4 57 5F 10 00 		pop		r5
0153B8 57 4F 10 00 		pop		r4
0153BC 57 6F 10 00 		pop     r6
0153C0 0A 10 16 00 		ldi		r1,#E_NoMsg
0153C4 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; System Call Exception
                	;
                	;------------------------------------------------------------------------------
                	;
                	syscall_exception:
0153C8 02 E0 01 6C 	    cpuid   sp,r0,#0
0153CC 3D 0F 08 00 	    beq     sp,.0001
0153D0 7C 02 00 00 	    ldi     sp,#CPU1_SYS_STACK
0153D4 0A E0 01 20 
0153D8 BA 01 00 00 	    bra     .0002
                	.0001:
0153DC 7C 00 00 00 	    ldi     sp,#CPU0_SYS_STACK
0153E0 0A E0 01 A0 
                	.0002:
0153E4 67 E3 01 00 		push	r6					; save off some working registers
0153E8 E7 E3 01 00 		push	r7
0153EC 02 60 12 3E 		mfspr   r6,epc              ; get return address into r6
0153F0 44 73 08 00 		lh	    r7,4[r6]			; get static call number parameter into r7
0153F4 14 63 10 00 		addui   r6,r6,#8			; update return address
0153F8 02 03 12 3C 		mtspr   epc,r6
0153FC 7C 01 00 00 		lcu     r6,syscall_vectors[r7]       ; load the vector into r6
015400 C3 63 00 80 
015404 7C 01 00 00 		or      r6,r6,#syscall_exception & 0xFFFFFFFFFFFF0000
015408 0D 63 00 00 
01540C E7 EF 01 00 		push    lr
015410 3C F3 01 00 		jsr		[r6]				; do the system function
015414 57 FF 11 00 		pop     lr
015418 57 7F 10 00 		pop		r7
01541C 57 6F 10 00 		pop		r6
015420 02 E0 3D 6E 		rte
                	
                	;------------------------------------------------------------------------------
                	; Reschedule tasks to run without affecting the timeout list timing.
                	;------------------------------------------------------------------------------
                	
                	reschedule:
015424 02 E0 01 6C 	    cpuid   sp,r0,#0
015428 3D 0F 08 00 	    beq     sp,.0001
01542C 7C 02 00 00 	    ldi     sp,#CPU1_IRQ_STACK
015430 0A E0 01 10 
015434 BA 01 00 00 	    bra     .0003
                	.0001:
015438 FC 00 00 00 	    ldi     sp,#IRQ_STACK
01543C 0A E0 01 00 
                	.0003:
015440 E7 E0 01 00 	    push    r1
015444 67 E1 01 00 		push    r2
015448 7C C0 00 00 		lwar    r1,tcb_sema
01544C 5C 10 90 02 
015450 BD 10 10 00 		bne     r1,.0004
015454 7C C0 00 00 		swcr    tr,tcb_sema
015458 6E 80 91 02 
01545C 02 10 00 3E 		mfspr   r1,cr0
015460 7C 00 00 10 		and     r1,r1,#$1000000000
015464 8C 10 00 00 
015468 BD 10 0E 00 		bne     r1,.0005
01546C BA 01 00 00 		bra     .0006
                	.0004:
015470 7C C0 00 00 	    swcr    r1,tcb_sema
015474 6E 10 90 02 
                	.0006:
015478 57 2F 10 00 		pop     r2
01547C 57 1F 10 00 		pop     r1
015480 02 E0 3F 6E 		rti
                	.0005:
015484 57 2F 10 00 	    pop     r2
015488 57 1F 10 00 	    pop     r1
01548C 63 1C 10 00 	    sw      r1,TCB_r1[tr]
015490 63 2C 20 00 	    sw      r2,TCB_r2[tr]
015494 63 3C 30 00 	    sw      r3,TCB_r3[tr]
015498 63 4C 40 00 	    sw      r4,TCB_r4[tr]
01549C 63 5C 50 00 	    sw      r5,TCB_r5[tr]
0154A0 63 6C 60 00 	    sw      r6,TCB_r6[tr]
0154A4 63 7C 70 00 	    sw      r7,TCB_r7[tr]
0154A8 63 8C 80 00 	    sw      r8,TCB_r8[tr]
0154AC 63 9C 90 00 	    sw      r9,TCB_r9[tr]
0154B0 63 AC A0 00 	    sw      r10,TCB_r10[tr]
0154B4 63 BC B0 00 	    sw      r11,TCB_r11[tr]
0154B8 63 CC C0 00 	    sw      r12,TCB_r12[tr]
0154BC 63 DC D0 00 	    sw      r13,TCB_r13[tr]
0154C0 63 EC E0 00 	    sw      r14,TCB_r14[tr]
0154C4 63 FC F0 00 	    sw      r15,TCB_r15[tr]
0154C8 63 0C 01 01 	    sw      r16,TCB_r16[tr]
0154CC 63 1C 11 01 	    sw      r17,TCB_r17[tr]
0154D0 63 2C 21 01 	    sw      r18,TCB_r18[tr]
0154D4 63 3C 31 01 	    sw      r19,TCB_r19[tr]
0154D8 63 4C 41 01 	    sw      r20,TCB_r20[tr]
0154DC 63 5C 51 01 	    sw      r21,TCB_r21[tr]
0154E0 63 6C 61 01 	    sw      r22,TCB_r22[tr]
0154E4 63 7C 71 01 	    sw      r23,TCB_r23[tr]
0154E8 63 8C 81 01 	    sw      r24,TCB_r24[tr]
0154EC 63 9C 91 01 	    sw      r25,TCB_r25[tr]
0154F0 63 AC A1 01 	    sw      r26,TCB_r26[tr]
0154F4 63 BC B1 01 	    sw      r27,TCB_r27[tr]
0154F8 63 CC C1 01 	    sw      r28,TCB_r28[tr]
0154FC 63 DC D1 01 	    sw      r29,TCB_r29[tr]
015500 02 10 1E 3E 	    mfspr   r1,isp
015504 63 1C E0 01 	    sw      r1,TCB_r30[tr]
015508 63 FC F1 01 	    sw      r31,TCB_r31[tr]
01550C 02 10 10 3E 	    mfspr   r1,ipc
015510 63 1C 00 03 	    sw      r1,TCB_IPC[tr]
015514 02 10 0E 3E 	    mfspr   r1,dpc
015518 63 1C 10 03 	    sw      r1,TCB_DPC[tr]
01551C 02 10 12 3E 	    mfspr   r1,epc
015520 63 1C 20 03 	    sw      r1,TCB_EPC[tr]
                	resched1:
015524 40 1C 20 04 	    lb      r1,TCB_Status[tr]  ; clear RUNNING status (bit #3)
015528 8C 10 EE FF 	    and     r1,r1,#~TS_RUNNING
01552C 60 1C 20 04 	    sb      r1,TCB_Status[tr]
015530 7C 00 00 00 		jmp		SelectTaskToRun
015534 3C 00 7C AB 
                	
                	strStartQue:
015538 00 00 00 01 		db		0,0,0,1,0,0,0,2,0,1,0,3,0,0,0,4,0,1,0,5,0,0,0,6,0,1,0,7
01553C 00 00 00 02 
015540 00 01 00 03 
015544 00 00 00 04 
015548 00 01 00 05 
01554C 00 00 00 06 
015550 00 01 00 07 
                	;	db		0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
                	
                	;------------------------------------------------------------------------------
                	; 60 Hz interrupt
                	; - takes care of "flashing" the cursor
                	; - decrements timeouts for tasks on timeout list
                	; - switching tasks
                	;------------------------------------------------------------------------------
                	
                	FMTKTick:
015554 02 E0 01 6C 	    cpuid   sp,r0,#0
015558 3D 0F 0C 00 	    beq     sp,.0001
01555C 02 E0 3F 6E 	    rti
015560 7C 02 00 00 	    ldi     sp,#CPU1_IRQ_STACK
015564 0A E0 01 10 
015568 E7 E0 01 00 	    push    r1
01556C BA 04 00 00 	    bra     .0003
                	.0001:
015570 FC 00 00 00 	    ldi     sp,#IRQ_STACK
015574 0A E0 01 00 
015578 E7 E0 01 00 		push    r1
01557C 0A 10 06 00 		ldi		r1,#3				; reset the edge sense circuit
015580 7C DC FF 00 		sh		r1,PIC_RSTE
015584 62 10 A8 1F 
015588 7C C0 00 00 		inc		IRQFlag
01558C 64 10 10 00 
                	.0003:
                		; Try and aquire the ready list and tcb. If unsuccessful it means there is
                		; a system function in the process of updating the list. All we can do is
                		; return to the system function and let it complete whatever it was doing.
                		; As if we don't return to the system function we will be deadlocked.
                		; The tick will be deferred; however if the system function was busy updating
                		; the ready list, in all likelyhood it's about to call the reschedule
                		; interrupt.
015590 67 E1 01 00 		push    r2
015594 7C C0 00 00 		lwar    r1,tcb_sema
015598 5C 10 90 02 
01559C BD 10 0E 00 		bne     r1,.0006
0155A0 7C C0 00 00 		swcr    tr,tcb_sema
0155A4 6E 80 91 02 
0155A8 02 10 00 3E 		mfspr   r1,cr0
0155AC 7C 00 00 10 		and     r1,r1,#$1000000000
0155B0 8C 10 00 00 
0155B4 BD 10 0C 00 		bne     r1,.0005
                	.0006:
0155B8 7C C0 00 00 		inc		missed_ticks
0155BC 64 10 70 01 
0155C0 57 2F 10 00 		pop     r2
0155C4 57 1F 10 00 		pop     r1
0155C8 02 E0 3F 6E 		rti
                	.0005:
0155CC 57 2F 10 00 	    pop     r2
0155D0 57 1F 10 00 	    pop     r1
                	p100Hz11:
0155D4 63 1C 10 00 	    sw      r1,TCB_r1[tr]
0155D8 63 2C 20 00 	    sw      r2,TCB_r2[tr]
0155DC 63 3C 30 00 	    sw      r3,TCB_r3[tr]
0155E0 63 4C 40 00 	    sw      r4,TCB_r4[tr]
0155E4 63 5C 50 00 	    sw      r5,TCB_r5[tr]
0155E8 63 6C 60 00 	    sw      r6,TCB_r6[tr]
0155EC 63 7C 70 00 	    sw      r7,TCB_r7[tr]
0155F0 63 8C 80 00 	    sw      r8,TCB_r8[tr]
0155F4 63 9C 90 00 	    sw      r9,TCB_r9[tr]
0155F8 63 AC A0 00 	    sw      r10,TCB_r10[tr]
0155FC 63 BC B0 00 	    sw      r11,TCB_r11[tr]
015600 63 CC C0 00 	    sw      r12,TCB_r12[tr]
015604 63 DC D0 00 	    sw      r13,TCB_r13[tr]
015608 63 EC E0 00 	    sw      r14,TCB_r14[tr]
01560C 63 FC F0 00 	    sw      r15,TCB_r15[tr]
015610 63 0C 01 01 	    sw      r16,TCB_r16[tr]
015614 63 1C 11 01 	    sw      r17,TCB_r17[tr]
015618 63 2C 21 01 	    sw      r18,TCB_r18[tr]
01561C 63 3C 31 01 	    sw      r19,TCB_r19[tr]
015620 63 4C 41 01 	    sw      r20,TCB_r20[tr]
015624 63 5C 51 01 	    sw      r21,TCB_r21[tr]
015628 63 6C 61 01 	    sw      r22,TCB_r22[tr]
01562C 63 7C 71 01 	    sw      r23,TCB_r23[tr]
015630 63 8C 81 01 	    sw      r24,TCB_r24[tr]
015634 63 9C 91 01 	    sw      r25,TCB_r25[tr]
015638 63 AC A1 01 	    sw      r26,TCB_r26[tr]
01563C 63 BC B1 01 	    sw      r27,TCB_r27[tr]
015640 63 CC C1 01 	    sw      r28,TCB_r28[tr]
015644 63 DC D1 01 	    sw      r29,TCB_r29[tr]
015648 02 10 1E 3E 	    mfspr   r1,isp
01564C 63 1C E0 01 	    sw      r1,TCB_r30[tr]
015650 63 FC F1 01 	    sw      r31,TCB_r31[tr]
015654 02 10 10 3E 	    mfspr   r1,ipc
015658 63 1C 00 03 	    sw      r1,TCB_IPC[tr]
01565C 02 10 0E 3E 	    mfspr   r1,dpc
015660 63 1C 10 03 	    sw      r1,TCB_DPC[tr]
015664 02 10 12 3E 	    mfspr   r1,epc
015668 63 1C 20 03 	    sw      r1,TCB_EPC[tr]
01566C 0A 10 C0 00 		ldi		r1,#96
015670 7C DC FF 00 		sc		r1,LEDS
015674 61 10 00 0C 
015678 7C C0 00 00 		lw		r1,UserTick
01567C 46 10 00 00 
015680 BD 00 08 00 		beq		r1,p100Hz4
015684 E7 EF 01 00 		push    lr
015688 BC F0 01 00 		jsr		[r1]
01568C 57 FF 11 00 		pop     lr
                	p100Hz4:
015690 40 1C 20 04 	    lb      r1,TCB_Status[tr]
015694 8C 10 EE FF 	    and     r1,r1,#~TS_RUNNING
015698 60 1C 20 04 	    sb      r1,TCB_Status[tr]
01569C 0A 10 C2 00 		ldi		r1,#97
0156A0 7C DC FF 00 		sc		r1,LEDS
0156A4 61 10 00 0C 
                	
                		; Check the timeout list to see if there are items ready to be removed from
                		; the list. Also decrement the timeout of the item at the head of the list.
                	p100Hz15:
0156A8 7C C0 00 00 		lw		r2,TimeoutList
0156AC 46 20 10 01 
0156B0 3D 01 1E 00 		beq		r2,p100Hz12				; are there any entries in the timeout list ?
0156B4 46 11 F0 04 		lw		r1,TCB_Timeout[r2]
0156B8 BD 10 0C 00 		bne		r1,p100Hz14				; has this entry timed out ?
0156BC E7 EF 01 00 		push    lr
0156C0 B9 8B FE FF 		bsr     PopTimeoutList
0156C4 39 3C FE FF 		bsr		AddTaskToReadyList
0156C8 57 FF 11 00 		pop     lr
0156CC BA FB FF FF 		bra		p100Hz15				; go back and see if there's another task to be removed
                										; there could be a string of tasks to make ready.
                	p100Hz14:
0156D0 95 10 02 00 		subui   r1,r1,#1				; decrement the entry's timeout
0156D4 7C C0 00 00 		lw      r3,missed_ticks
0156D8 46 30 70 01 
0156DC 82 10 06 2A 		subu	r1,r1,r3        		; account for any missed ticks
0156E0 7C C0 00 00 		sw		r0,missed_ticks
0156E4 63 00 70 01 
0156E8 63 11 F0 04 		sw		r1,TCB_Timeout[r2]
                		
                	p100Hz12:
                		; Falls through into selecting a task to run
                	tck3:
0156EC 0A 10 C4 00 		ldi		r1,#98
0156F0 7C DC FF 00 		sc		r1,LEDS
0156F4 61 10 00 0C 
                	
                	;------------------------------------------------------------------------------
                	; Search the ready queues for a ready task.
                	; The search is occasionally started at a lower priority queue in order
                	; to prevent starvation of lower priority tasks. This is managed by 
                	; using a tick count as an index to a string containing the start que.
                	;------------------------------------------------------------------------------
                	;
                	SelectTaskToRun:
0156F8 0A 60 10 00 		ldi		r6,#8			; number of queues to search
0156FC 7C C0 00 00 		lw		r3,IRQFlag		; use the IRQFlag as a buffer index
015700 46 30 10 00 
                	;	lsr		r3,r3,#1		; the LSB is always the same
015704 8C 31 3E 00 		and		r3,r3,#$1F		; counts from 0 to 31
015708 7C 01 00 00 		lb	    r3,strStartQue[r3]	; get the queue to start search at
01570C C0 31 70 AA 
015710 8C 31 0E 00 		and     r3,r3,#7
                	sttr2:
015714 82 41 06 70 	    asl     r4,r3,#3
015718 7C C0 00 00 		lw		r1,QNdx0[r4]
01571C 46 12 70 00 
015720 BD 00 B0 00 		beq		r1,sttr1
015724 C6 10 00 04 		lw		r1,TCB_NextRdy[r1]		; Advance the queue index
015728 8C 70 FE 01 		and     r7,r1,#$FF
01572C BD 13 D4 00 		bne     r7,sttr_badtask
015730 7C C1 00 00 		cmpu    r7,r1,#TCB_Array
015734 96 70 00 00 
015738 BD 43 CE 00 		blt     r7,sttr_badtask
01573C FC C3 00 00 		cmpu    r7,r1,#TCB_ArrayEnd-TCB_Size
015740 96 70 00 FA 
015744 BD 23 C8 00 		bgt     r7,sttr_badtask
015748 7C C0 00 00 		sw		r1,QNdx0[r4]
01574C 63 12 70 00 
015750 02 70 00 6C 		cpuid   r7,r0,#0
015754 BD 03 08 00 		beq     r7,sttr5
015758 C2 80 00 05 		lc      r8,TCB_Affinity[r1]
01575C 82 73 10 0C 		cmp     r7,r7,r8
015760 BD 13 90 00 		bne     r7,sttr1
                	sttr5:
                		; This is the only place the RunningTCB is set (except for initialization).
015764 82 80 01 1A 		mov     tr,r1
015768 3F 00 00 00 		nop
01576C 3F 00 00 00 		nop
015770 40 1C 20 04 		lb      r1,TCB_Status[tr]
015774 8D 10 10 00 		or      r1,r1,#TS_RUNNING    ; flag the task as the running task
015778 60 1C 20 04 		sb      r1,TCB_Status[tr]
01577C 0A 10 C6 00 		ldi		r1,#99
015780 7C DC FF 00 		sc		r1,LEDS
015784 61 10 00 0C 
015788 7C C0 00 00 		lw		r1,iof_switch		
01578C 46 10 F0 01 
015790 BD 00 22 00 		beq		r1,sttr6				
015794 7C C0 00 00 		lwar	r1,iof_sema		; just ignore the request to switch
015798 5C 10 C0 02 
01579C BD 10 6C 00 		bne		r1,sttr7		; I/O focus if the semaphore can't be aquired
0157A0 7C C0 00 00 		swcr    tr,iof_sema
0157A4 6E 80 C1 02 
0157A8 02 10 00 3E 		mfspr   r1,cr0
0157AC 7C 00 00 10 		and     r1,r1,#$1000000000
0157B0 8C 10 00 00 
0157B4 BD 00 10 00 		beq     r1,sttr6
0157B8 7C C0 00 00 		sw		r0,iof_switch
0157BC 63 00 F0 01 
0157C0 E7 EF 01 00 		push    lr
0157C4 39 3D 00 00 		bsr		SwitchIOFocus
0157C8 57 FF 11 00 		pop     lr
0157CC 7C C0 00 00 		sw		r0,iof_sema
0157D0 63 00 C0 02 
                	sttr6:
0157D4 46 1C 20 03 	    lw      r1,TCB_EPC[tr]
0157D8 82 00 12 3C 	    mtspr   epc,r1
0157DC 46 1C 10 03 	    lw      r1,TCB_DPC[tr]
0157E0 82 00 0E 3C 	    mtspr   dpc,r1
0157E4 46 1C 00 03 	    lw      r1,TCB_IPC[tr]
0157E8 82 00 10 3C 	    mtspr   ipc,r1
0157EC 46 FC F1 01 	    lw      r31,TCB_r31[tr]
0157F0 46 1C E0 01 	    lw      r1,TCB_r30[tr]
0157F4 82 00 1E 3C 	    mtspr   isp,r1
0157F8 46 DC D1 01 	    lw      r29,TCB_r29[tr]
0157FC 46 CC C1 01 	    lw      r28,TCB_r28[tr]
015800 46 BC B1 01 	    lw      r27,TCB_r27[tr]
015804 46 AC A1 01 	    lw      r26,TCB_r26[tr]
015808 46 9C 91 01 	    lw      r25,TCB_r25[tr]
                	;   lw      r24,TCB_r24[tr]    ; r24 is the task register - no need to load
01580C 46 7C 71 01 	    lw      r23,TCB_r23[tr]
015810 46 6C 61 01 	    lw      r22,TCB_r22[tr]
015814 46 5C 51 01 	    lw      r21,TCB_r21[tr]
015818 46 4C 41 01 	    lw      r20,TCB_r20[tr]
01581C 46 3C 31 01 	    lw      r19,TCB_r19[tr]
015820 46 2C 21 01 	    lw      r18,TCB_r18[tr]
015824 46 1C 11 01 	    lw      r17,TCB_r17[tr]
015828 46 0C 01 01 	    lw      r16,TCB_r16[tr]
01582C 46 FC F0 00 	    lw      r15,TCB_r15[tr]
015830 46 EC E0 00 	    lw      r14,TCB_r14[tr]
015834 46 DC D0 00 	    lw      r13,TCB_r13[tr]
015838 46 CC C0 00 	    lw      r12,TCB_r12[tr]
01583C 46 BC B0 00 	    lw      r11,TCB_r11[tr]
015840 46 AC A0 00 	    lw      r10,TCB_r10[tr]
015844 46 9C 90 00 	    lw      r9,TCB_r9[tr]
015848 46 8C 80 00 	    lw      r8,TCB_r8[tr]
01584C 46 7C 70 00 	    lw      r7,TCB_r7[tr]
015850 46 6C 60 00 	    lw      r6,TCB_r6[tr]
015854 46 5C 50 00 	    lw      r5,TCB_r5[tr]
015858 46 4C 40 00 	    lw      r4,TCB_r4[tr]
01585C 46 3C 30 00 	    lw      r3,TCB_r3[tr]
015860 46 2C 20 00 	    lw      r2,TCB_r2[tr]
015864 46 1C 10 00 	    lw      r1,TCB_r1[tr]
015868 7C C0 00 00 		sw		r0,tcb_sema
01586C 63 00 90 02 
015870 02 E0 3F 6E 		rti
                	sttr7:
015874 7C C0 00 00 	    swcr    r1,iof_sema
015878 6E 10 C0 02 
01587C 3A EB FF FF 	    bra     sttr6
                	
                		; Set index to check the next ready list for a task to run
                	sttr1:
015880 94 31 02 00 		addui   r3,r3,#1
015884 8C 31 0E 00 		and     r3,r3,#7
015888 15 63 02 00 		subui   r6,r6,#1
01588C 3D 33 44 FF 		bge		r6,sttr2
                	
                		; Here there were no tasks ready
                		; This should not be able to happen, so hang the machine (in a lower
                		; power mode).
                	sttr3:
015890 0A 20 BC 00 		ldi     r2,#94
015894 7C DC FF 00 		sc		r2,LEDS
015898 61 20 00 0C 
01589C E7 EF 01 00 		push    lr
0158A0 B9 0A 00 00 		bsr		kernel_panic
0158A4 4E 6F 20 74 		db		"No tasks in ready queue.",0
0158A8 61 73 6B 73 
0158AC 20 69 6E 20 
0158B0 72 65 61 64 
0158B4 79 20 71 75 
0158B8 65 75 65 2E 
0158BC 00          
0158BD 00 00 00 39 		bsr     DumpTaskList
0158C1 D5 FD FF    
0158C4 57 FF 11 00 		pop     lr
                		; Might as well power down the clock and wait for a reset or
                		; NMI. In the case of an NMI the kernel is reinitialized without
                		; doing the boot reset.
0158C8 02 00 04 6E 		stp								
0158CC 7C 00 00 00 		jmp		FMTKInitialize
0158D0 3C 00 0E A0 
                	
                	sttr_badtask:
0158D4 39 04 00 00 	    bsr     kernel_panic
0158D8 42 61 64 20 	    db      "Bad task on ready list.",0
0158DC 74 61 73 6B 
0158E0 20 6F 6E 20 
0158E4 72 65 61 64 
0158E8 79 20 6C 69 
0158EC 73 74 2E 00 
0158F0 3A F2 FF FF 	    bra     sttr1
                	
                	;------------------------------------------------------------------------------
                	; kernal_panic:
                	;	All this does right now is display the panic message on the screen.
                	; Parameters:
                	;	inline: string
                	;------------------------------------------------------------------------------
                	;
                	kernel_panic:
0158F4 E7 E0 01 00 	    push    r1
                	kpan2:
0158F8 C1 1F 00 00 		lbu	    r1,[lr]		; get a byte from the code space
0158FC BD 00 0C 00 		beq		r1,kpan1		; is it end of string ?
015900 94 FF 03 00 		addui	lr,lr,#1	; increment pointer
015904 E7 EF 01 00 		push    lr
015908 39 04 F7 FF 		bsr		OutChar
01590C 57 FF 11 00 		pop     lr
015910 3A FD FF FF 		bra		kpan2
                	kpan1:
015914 E7 EF 01 00 	    push    lr   		; must update the return address !
015918 39 CF F5 FF 		bsr		CRLF
01591C 57 FF 11 00 		pop     lr
015920 57 1F 10 00 		pop     r1
015924 94 FF 07 00 		addui   lr,lr,#3    ; round the link register to the next instruction address
015928 8C FF F9 FF 		and     lr,lr,#-4
01592C 37 FF 01 00 		rtl

                	
                	; ============================================================================
                	; iofocus.s
                	;        __
                	;   \\__/ o\    (C) 2014, 2015  Robert Finch, Stratford
                	;    \  __ /    All rights reserved.
                	;     \/_//     robfinch<remove>@finitron.ca
                	;       ||
                	;  
                	;
                	; This source file is free software: you can redistribute it and/or modify 
                	; it under the terms of the GNU Lesser General Public License as published 
                	; by the Free Software Foundation, either version 3 of the License, or     
                	; (at your option) any later version.                                      
                	;                                                                          
                	; This source file is distributed in the hope that it will be useful,      
                	; but WITHOUT ANY WARRANTY; without even the implied warranty of           
                	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
                	; GNU General Public License for more details.                             
                	;                                                                          
                	; You should have received a copy of the GNU General Public License        
                	; along with this program.  If not, see <http://www.gnu.org/licenses/>.    
                	;
                	; iofocus.s
                	; ============================================================================
                	
                	LockIOF:
015930 E7 EF 01 00 	    push    lr
015934 E7 E0 01 00 	    push    r1
015938 7C C0 00 00 	    ldi     r1,#iof_sema
01593C 0A 10 C0 02 
015940 B9 71 FD FF 	    bsr     LockSema
015944 57 1F 10 00 	    pop     r1
015948 3B FF 11 00 	    rts
    
                	;------------------------------------------------------------------------------
                	; ForceIOFocus
                	;
                	; Force the IO focus to a specific job.
                	;------------------------------------------------------------------------------
                	;
                	ForceIOFocus:
01594C E7 EF 01 00 	    push    lr
015950 E7 E0 01 00 		push    r1
015954 67 E1 01 00 	    push    r2
015958 E7 E1 01 00 	    push    r3 
01595C B9 FA FF FF 	    bsr     LockIOF
015960 7C C0 00 00 		lw		r3,IOFocusNdx
015964 46 30 20 00 
015968 82 20 06 0C 		cmp		r2,r1,r3
01596C 3D 01 14 00 		beq		r2,fif1
015970 82 20 00 1A 		mov     r2,r1
015974 B9 5A 00 00 		bsr		CopyScreenToVirtualScreen
015978 C6 11 F0 07 		lw		r1,JCB_pVirtVid[r3]
01597C E3 11 D0 07 		sw		r1,JCB_pVidMem[r3]
015980 7C C0 00 00 		sw		r2,IOFocusNdx
015984 63 20 20 00 
015988 0A 10 00 00 		ldi		r1,#TEXTSCR
01598C 63 11 D0 07 		sw		r1,JCB_pVidMem[r2]
015990 B9 48 00 00 		bsr		CopyVirtualScreenToScreen
                	fif1:
015994 7C C0 00 00 		sw		r0,iof_sema
015998 63 00 C0 02 
01599C 57 3F 10 00 		pop     r3
0159A0 57 2F 10 00 		pop     r2
0159A4 57 1F 10 00 		pop     r1
0159A8 3B FF 11 00 		rts
	
                	;------------------------------------------------------------------------------
                	; SwitchIOFocus
                	;
                	; Switches the IO focus to the next task requesting the I/O focus. This
                	; routine may be called when a task releases the I/O focus as well as when
                	; the user presses ALT-TAB on the keyboard.
                	; On Entry: the io focus semaphore is set already.
                	;------------------------------------------------------------------------------
                	;
                	SwitchIOFocus:
0159AC E7 EF 01 00 	    push    lr
0159B0 E7 E0 01 00 	    push    r1
0159B4 67 E1 01 00 	    push    r2
0159B8 E7 E1 01 00 	    push    r3
                	
                		; First check if it's even possible to switch the focus to another
                		; task. The I/O focus list could be empty or there may be only a
                		; single task in the list. In either case it's not possible to
                		; switch.
0159BC B9 EE FF FF 		bsr     LockIOF
0159C0 7C C0 00 00 		lw		r3,IOFocusNdx		; Get the job at the head of the list.
0159C4 46 30 20 00 
0159C8 BD 01 16 00 		beq	    r3,siof3			; Is the list empty ?
0159CC C6 21 50 08 		lw		r2,JCB_iof_next[r3]	; Get the next job on the list.
0159D0 3D 01 12 00 		beq		r2,siof3			; Nothing to switch to
                	
                		; Copy the current task's screen to it's virtual screen buffer.
0159D4 B9 4E 00 00 		bsr		CopyScreenToVirtualScreen
0159D8 C6 11 F0 07 		lw		r1,JCB_pVirtVid[r3]
0159DC E3 11 D0 07 		sw		r1,JCB_pVidMem[r3]
                	
0159E0 7C C0 00 00 		sw		r2,IOFocusNdx		; Make task the new head of list.
0159E4 63 20 20 00 
0159E8 0A 10 00 00 		ldi		r1,#TEXTSCR
0159EC 63 11 D0 07 		sw		r1,JCB_pVidMem[r2]
                	
                		; Copy the virtual screen of the task recieving the I/O focus to the
                		; text screen.
0159F0 B9 3C 00 00 		bsr		CopyVirtualScreenToScreen
                	siof3:
0159F4 7C C0 00 00 	    sw      r0,iof_sema
0159F8 63 00 C0 02 
0159FC 57 3F 10 00 		pop     r3
015A00 57 2F 10 00 		pop     r2
015A04 57 1F 10 00 		pop     r1
015A08 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	; The I/O focus list is an array indicating which jobs are requesting the
                	; I/O focus. The I/O focus is user controlled by pressing ALT-TAB on the
                	; keyboard.
                	;------------------------------------------------------------------------------
                	
                	RequestIOFocus:
015A0C E7 EF 01 00 	    push    lr
015A10 E7 E0 01 00 	    push    r1
015A14 67 E1 01 00 	    push    r2
015A18 E7 E1 01 00 	    push    r3
015A1C 67 E2 01 00 		push	r4
015A20 E7 E2 01 00 		push    r5
                	;	DisTmrKbd
015A24 46 2C 28 04 		lw	    r2,TCB_hJCB[tr]
015A28 02 11 00 1A 		mov     r1,r2
015A2C 7C C4 00 00 		subui   r1,r1,#JCB_Array
015A30 95 10 00 00 
015A34 98 10 00 0A 		divu    r1,r1,#JCB_Size
015A38 82 30 0C 72 		lsr     r3,r1,#6           ; r3 = word index into IO focus table
015A3C B9 DE FF FF 		bsr     LockIOF
015A40 7C C0 00 00 		lw      r4,IOFocusTbl[r3]  ; r4 = word from IO focus table
015A44 C6 41 30 00 
015A48 8C 30 7E 00 		and     r3,r1,#$3F         ; r3 = bit number in word
015A4C 82 50 06 62 		lsr     r5,r1,r3           ; extract bit into r5
015A50 8C 52 02 00 		and     r5,r5,#1           ; mask off extra bits
015A54 BD 12 2E 00 		bne     r5,riof1           ; is the job already in the IO focus list ?
015A58 7C C0 00 00 		lw		r1,IOFocusNdx	   ; Is the focus list empty ?
015A5C 46 10 20 00 
015A60 BD 00 38 00 		beq		r1,riof2
015A64 C6 30 60 08 		lw		r3,JCB_iof_prev[r1]
015A68 BD 01 3E 00 		beq		r3,riof4
015A6C E3 20 60 08 		sw		r2,JCB_iof_prev[r1]
015A70 63 11 50 08 		sw		r1,JCB_iof_next[r2]
015A74 63 31 60 08 		sw		r3,JCB_iof_prev[r2]
015A78 E3 21 50 08 		sw		r2,JCB_iof_next[r3]
                	riof3:
015A7C 02 11 00 1A 	    mov     r1,r2
015A80 7C C4 00 00 		subui   r1,r1,#JCB_Array
015A84 95 10 00 00 
015A88 98 10 00 0A 		divu    r1,r1,#JCB_Size    ; r1 = index into JCB array
015A8C 82 30 0C 72 		lsr     r3,r1,#6           ; r3 = word index into IO focus table
015A90 7C C0 00 00 		lw      r4,IOFocusTbl[r3]  ; r4 = word from IO focus table
015A94 C6 41 30 00 
015A98 8C 20 7E 00 		and     r2,r1,#$3F         ; r2 = bit number in word
015A9C 0A 50 02 00 		ldi     r5,#1              ; r5 = 1 bit to insert
015AA0 82 52 04 60 		asl     r5,r5,r2           ; r5 shifted into place
015AA4 82 52 08 1A 		or      r5,r5,r4           ; insert bit
015AA8 7C C0 00 00 		sw      r5,IOFocusTbl[r3]  ; store word back to IO focus table
015AAC E3 51 30 00 
                	riof1:
                	;	EnTmrKbd4
015AB0 7C C0 00 00 	    sw      r0,iof_sema
015AB4 63 00 C0 02 
015AB8 57 5F 10 00 	    pop     r5
015ABC 57 4F 10 00 		pop		r4
015AC0 57 3F 10 00 		pop     r3
015AC4 57 2F 10 00 		pop     r2
015AC8 57 1F 10 00 		pop     r1
015ACC 37 FF 01 00 		rtl

                		; Here, the IO focus list was empty. So expand it.
                		; Make sure pointers are NULL
                	riof2:
015AD0 7C C0 00 00 		sw		r2,IOFocusNdx
015AD4 63 20 20 00 
015AD8 63 01 50 08 		sw		r0,JCB_iof_next[r2]
015ADC 63 01 60 08 		sw		r0,JCB_iof_prev[r2]
015AE0 BA F3 FF FF 		bra		riof3
                	
                		; Here there was only a single entry in the list.
                		; Setup pointers appropriately.
                	riof4:
015AE4 63 11 50 08 		sw		r1,JCB_iof_next[r2]
015AE8 63 11 60 08 		sw		r1,JCB_iof_prev[r2]
015AEC E3 20 50 08 		sw		r2,JCB_iof_next[r1]
015AF0 E3 20 60 08 		st		r2,JCB_iof_prev[r1]
015AF4 3A F1 FF FF 		bra		riof3
                	
                	;------------------------------------------------------------------------------
                	; Releasing the I/O focus causes the focus to switch if the running job
                	; had the I/O focus.
                	; ForceReleaseIOFocus forces the release of the IO focus for a job
                	; different than the one currently running.
                	;------------------------------------------------------------------------------
                	
                	ForceReleaseIOFocus:
015AF8 E7 EF 01 00 	    push    lr
015AFC E7 E0 01 00 		push    r1
015B00 67 E1 01 00 		push    r2
015B04 E7 E1 01 00 		push    r3
015B08 67 E2 01 00 		push	r4
015B0C E7 E2 01 00 		push    r5
015B10 02 11 00 1A 		mov     r1,r2
                	;	DisTmrKbd
015B14 3A 04 00 00 		bra		rliof4  ; wedge into ReleaseIOFocus
                	
                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	message "ReleaseIOFocus"	
                	ReleaseIOFocus:
015B18 E7 EF 01 00 	    push    lr
015B1C E7 E0 01 00 		push    r1
015B20 67 E1 01 00 		push    r2
015B24 E7 E1 01 00 		push    r3
015B28 67 E2 01 00 		push	r4
015B2C E7 E2 01 00 		push    r5
                	;	DisTmrKbd
015B30 46 2C 28 04 		lw	    r2,TCB_hJCB[tr]
                	rliof4:
015B34 02 11 00 1A 		mov     r1,r2
015B38 7C C4 00 00 		subui   r1,r1,#JCB_Array
015B3C 95 10 00 00 
015B40 98 10 00 0A 		divu    r1,r1,#JCB_Size
015B44 82 30 0C 72 		lsr     r3,r1,#6           ; r3 = word index into IO focus table
015B48 39 BD FF FF 		bsr     LockIOF
015B4C 7C C0 00 00 		lw      r4,IOFocusTbl[r3]  ; r4 = word from IO focus table
015B50 C6 41 30 00 
015B54 8C 30 7E 00 		and     r3,r1,#$3F         ; r3 = bit number in word
015B58 82 50 06 62 		lsr     r5,r1,r3           ; extract bit into r5
015B5C 8C 52 02 00 		and     r5,r5,#1           ; mask off extra bits
015B60 BD 02 2A 00 		beq		r5,rliof3          ; nothing to do (not in table)
015B64 02 42 06 66 		ror     r4,r4,r3
015B68 0C 42 FC FF 		and     r4,r4,#-2          ; mask off LSB
015B6C 02 42 06 64 		rol     r4,r4,r3           ; back in position
015B70 7C C0 00 00 		sw		r4,IOFocusTbl
015B74 63 40 30 00 
015B78 7C C0 00 00 		lw      r5,IOFocusNdx	; Does the running job have the I/O focus ?
015B7C 46 50 20 00 
015B80 02 51 0A 0C 		cmp		r5,r2,r5
015B84 BD 12 04 00 		bne		r5,rliof1
015B88 B9 C4 FF FF 		bsr		SwitchIOFocus	; If so, then switch the focus.
                	rliof1:
015B8C 46 11 50 08 		lw		r1,JCB_iof_next[r2]	; get next and previous fields.
015B90 BD 00 0A 00 		beq		r1,rliof5			; Is list emptying ?
015B94 46 31 60 08 		lw		r3,JCB_iof_prev[r2]
015B98 E3 11 50 08 		sw		r1,JCB_iof_next[r3]	; prev->next = current->next
015B9C E3 30 60 08 		sw	    r3,JCB_iof_prev[r1]	; next->prev = current->prev
015BA0 BA 01 00 00 		bra		rliof2
                	rliof5:
015BA4 7C C0 00 00 		sw		r0,IOFocusNdx		; emptied.
015BA8 63 00 20 00 
                	rliof2:
015BAC 63 01 50 08 		sw		r0,JCB_iof_next[r2]	; Update the next and prev fields to indicate
015BB0 63 01 60 08 		sw		r0,JCB_iof_prev[r2]	; the job is no longer on the list.
                	rliof3:
                	;	EnTmrKbd
015BB4 7C C0 00 00 	    sw      r0,iof_sema
015BB8 63 00 C0 02 
015BBC 57 5F 10 00 	    pop     r5
015BC0 57 4F 10 00 		pop		r4
015BC4 57 3F 10 00 		pop     r3
015BC8 57 2F 10 00 		pop     r2
015BCC 57 1F 10 00 		pop     r1
015BD0 3B FF 11 00 		rts

                	;------------------------------------------------------------------------------
                	;------------------------------------------------------------------------------
                	message "CopyVirtualScreenToScreen"
                	CopyVirtualScreenToScreen
015BD4 E7 E0 01 00 	    push    r1
015BD8 67 E1 01 00 	    push    r2
015BDC E7 E1 01 00 	    push    r3
015BE0 67 E2 01 00 		push	r4
015BE4 7C C0 00 00 		lw		r2,IOFocusNdx		; compute virtual screen location
015BE8 46 20 20 00 
015BEC 3D 01 10 00 		beq		r2,cvss3
                		; copy screen chars
015BF0 0A 10 FE 1F 		ldi		r1,#4095			; number of words to copy-1
015BF4 46 21 F0 07 		lw		r2,JCB_pVirtVid[r2]
015BF8 0A 30 00 00 		ldi		r3,#TEXTSCR
                	.0001:
015BFC 4C 41 82 00 		lh      r4,[r2+r1*4]       ; from virtual
015C00 EA 41 82 00 		sh      r4,[r3+r1*4]       ; to screen
015C04 95 10 02 00 		subui   r1,r1,#1
015C08 BD 30 FA FF 		bge     r1,.0001
                	cvss3:
                		; reset the cursor position in the text controller
015C0C 7C C0 00 00 		lw		r3,IOFocusNdx
015C10 46 30 20 00 
015C14 C0 21 18 08 		lb		r2,JCB_CursorRow[r3]
015C18 7C DA FF 00 		ldi		r1,(TEXTREG+TEXT_COLS)|$FFD00000
015C1C 0A 10 00 00 
015C20 02 21 02 2E 		mulu	r2,r2,r1
015C24 C0 41 1A 08 		lb      r4,JCB_CursorCol[r3]
015C28 02 21 08 08 		add		r2,r2,r4
015C2C 7C DA FF 00 		sc		r2,(TEXTREG+TEXT_CURPOS)|$FFD00000
015C30 61 20 58 00 
015C34 57 4F 10 00 		pop		r4
015C38 57 3F 10 00 		pop     r3
015C3C 57 2F 10 00 		pop     r2
015C40 57 1F 10 00 		pop     r1
015C44 37 FF 01 00 		rtl
message "CopyScreenToVirtualScreen"
                	CopyScreenToVirtualScreen
015C48 E7 E0 01 00 	    push    r1
015C4C 67 E1 01 00 	    push    r2
015C50 E7 E1 01 00 	    push    r3
015C54 67 E2 01 00 		push	r4
015C58 0A 10 FE 1F 		ldi		r1,#4095
015C5C 0A 20 00 00 		ldi		r2,#TEXTSCR
015C60 7C C0 00 00 		lw		r3,IOFocusNdx
015C64 46 30 20 00 
015C68 BD 01 0C 00 		beq		r3,csvs3
015C6C C6 31 F0 07 		lw		r3,JCB_pVirtVid[r3]
                	.0001:
015C70 4C 41 82 00 		lh      r4,[r2+r1*4]
015C74 EA 41 82 00 		sh      r4,[r3+r1*4]
015C78 95 10 02 00 		subui   r1,r1,#1
015C7C BD 30 FA FF 		bge     r1,.0001
                	csvs3:
015C80 57 4F 10 00 		pop		r4
015C84 57 3F 10 00 		pop     r3
015C88 57 2F 10 00 		pop     r2
015C8C 57 1F 10 00 		pop     r1
015C90 37 FF 01 00 		rtl

                	
                	         
015C94 3F 00 00 00 	    nop
015C98 3F 00 00 00 	    nop
                	
                	
                		rodata
                		align	16                	
                		align	8                	
                		extern	RTCC_BUF
                		extern	Milliseconds
                		extern	Milliseconds
1012 symbols
  Symbol Name                              seg     address
  API_AREA                                    bss  000430
  API_head                                    bss  00037e
  API_sema                                    bss  000388
  API_tail                                    bss  000380
  AddTaskToReadyList                         code  0148a4
  AddToTimeoutList                           code  0149a4
  AllocMbx                                   code  014b84
  AsciiToHexNybble                           code  011440
  AsciiToHexNybble.gthx3                     code  0114a0
  AsciiToHexNybble.gthx5                     code  011460
  AsciiToHexNybble.gthx6                     code  011480
  AsciiToScreen                              code  010614
  AsciiToScreen.00001                        code  010634
  BIOSCall                                   code  01088c
  BIOSCall.0002                              code  0108ac
  BIOSCall.0003                              code  8000000000000111
  BIOSCall.0005                              code  0108c0
  BIOSCall.0006                              code  0108d8
  BIOS_DONE                                 const  000001
  BIOS_FREE                                 const  000000
  BIOS_FuncTable                             code  010004
  BIOS_INSERVICE                            const  000002
  BIOS_arg1                                 const  000008
  BIOS_arg2                                 const  000010
  BIOS_arg3                                 const  000018
  BIOS_arg4                                 const  000020
  BIOS_arg5                                 const  000028
  BIOS_op                                   const  000000
  BIOS_resp                                 const  000030
  BIOS_sema                                   bss  000390
  BIOS_stat                                 const  000038
  BITMAP_SCREEN1                            const  400000
  BITMAP_SCREEN2                            const  800000
  BMP_CLUT                                  const  0c5800
  BSI_BootSig                               const  000026
  BSI_DriveNum                              const  000024
  BSI_FATS                                  const  000010
  BSI_FileSysType                           const  000036
  BSI_Heads                                 const  00001a
  BSI_HiddenSecs                            const  00001c
  BSI_HugeSecs                              const  00001e
  BSI_JMP                                   const  000000
  BSI_Media                                 const  000015
  BSI_OEMName                               const  000003
  BSI_ResSectors                            const  00000e
  BSI_RootDirEnts                           const  000011
  BSI_Rsvd1                                 const  000025
  BSI_SecPerCluster                         const  00000d
  BSI_SecPerFAT                             const  000016
  BSI_SecPerTrack                           const  000018
  BSI_Sectors                               const  000013
  BSI_VolID                                 const  000027
  BSI_VolLabel                              const  00002b
  BSI_bps                                   const  00000b
  BYTE_SECTOR_BUF                           const  03a000
  BlankLine                                  code  010e78
  BlankLine.0001                             code  010eb4
  BranchToSelf                               code  014018
  BranchToSelf2                              code  0107e4
  CPU0_BIOS_STACK                           const  006800
  CPU0_SYS_STACK                            const  005000
  CPU1_BIOS_STACK                           const  021800
  CPU1_IRQ_STACK                            const  020800
  CPU1_SYS_STACK                            const  021000
  CPUIdleTick                                 bss  0003a8
  CR                                        const  00000d
  CRLF                                       code  010790
  CRLF1                                      code  010794
  CTRLC                                     const  000003
  CTRLCCheck                                 code  0113a0
  CTRLCCheck.0001                            code  0113c8
  CTRLH                                     const  000008
  CTRLI                                     const  000009
  CTRLJ                                     const  00000a
  CTRLK                                     const  00000b
  CTRLM                                     const  00000d
  CTRLS                                     const  000013
  CTRLX                                     const  000018
  CalcScreenLoc                              code  010ba4
  CharsInRxBuf                               code  01040c
  CheckKeys                                  code  01138c
  CheckMsg                                   code  015300
  CheckScrollLock                            code  0113d0
  CheckScrollLock.0001                       code  0113f0
  CheckScrollLock.0002                       code  0113dc
  ClearBmpScreen                             code  8000000000000091
  ClearScreen                                code  010674
  ClearScreen.cs1                            code  0106b4
  CopyScreenToVirtualScreen                  code  015c48
  CopyScreenToVirtualScreen.0001             code  015c70
  CopyVirtualScreenToScreen                  code  015bd4
  CopyVirtualScreenToScreen.0001             code  015bfc
  CursorCol                                   bss  000139
  CursorOff                                  code  010658
  CursorOn                                   code  01065c
  CursorRow                                   bss  000138
  DBG_STACK                                 const  007000
  DequeueMsgFromMbx                          code  014eb0
  DequeueThreadFromMbx                       code  014f04
  DequeueThreadFromMbx2                      code  014f84
  DispCharQ                                  code  0107b0
  DispStartMsg                               code  0107c4
  DisplayByte                                code  010710
  DisplayChar                                code  010bf0
  DisplayChar.dcx12                          code  010d08
  DisplayChar.dcx4                           code  010c78
  DisplayChar.dcx5                           code  010d3c
  DisplayChar.dcx7                           code  010cb0
  DisplayChar.doBackspace                    code  010d20
  DisplayChar.doCursorDown                   code  010ce0
  DisplayChar.doCursorHome                   code  010cf8
  DisplayChar.doCursorLeft                   code  010ccc
  DisplayChar.doCursorRight                  code  010c9c
  DisplayChar.doCursorUp                     code  010cb8
  DisplayChar.doDelete                       code  010d10
  DisplayChar.doLinefeed                     code  010d70
  DisplayChar.docr                           code  010c90
  DisplayCharHex                             code  0106fc
  DisplayErr                                 code  0114ac
  DisplayHalf                                code  0106e8
  DisplayMemBytes                            code  0112cc
  DisplayMemBytes.001                        code  011300
  DisplayMemBytes.002                        code  011338
  DisplayMemBytes.003                        code  011358
  DisplayMemBytes.004                        code  01134c
  DisplayNybble                              code  010724
  DisplayNybble.0001                         code  010744
  DisplaySpace                               code  0107e8
  DisplayString                              code  010754
  DisplayString.dm1                          code  010778
  DisplayString.dm2                          code  010764
  DisplayStringCRLF                          code  010784
  DisplayWord                                code  0106d4
  Dummy1                                      bss  00013a
  DumpTaskList                               code  014768
  DumpTaskList.0001                          code  01478c
  E_Arg                                     const  000001
  E_BadAlarm                                const  000011
  E_BadBlockNum                             const  000025
  E_BadDevNum                               const  000020
  E_BadDevOp                                const  000022
  E_BadFuncno                               const  000001
  E_BadMbx                                  const  000004
  E_DCBInUse                                const  000019
  E_NoDev                                   const  000021
  E_NoMem                                   const  00000c
  E_NoMoreAlarmBlks                         const  000044
  E_NoMoreMbx                               const  000040
  E_NoMoreMsgBlks                           const  000041
  E_NoMoreTCBs                              const  000045
  E_NoMsg                                   const  00000b
  E_NoThread                                const  000006
  E_NotAlloc                                const  000009
  E_NotOwner                                const  000012
  E_Ok                                      const  000000
  E_QueFull                                 const  000005
  E_QueStrategy                             const  000013
  E_ReadError                               const  000023
  E_Timeout                                 const  000010
  E_TooManyBlocks                           const  000026
  E_WriteError                              const  000024
  EndStaticAllocations                        bss  03f400
  EndStaticAllocations.bss                    bss  03f408
  ExitTask                                   code  014658
  FMTKInitialize                             code  01401c
  FMTKTick                                   code  015554
  FMTKTick.0001                              code  015570
  FMTKTick.0003                              code  015590
  FMTKTick.0005                              code  0155cc
  FMTKTick.0006                              code  0155b8
  ForceIOFocus                               code  01594c
  ForceReleaseIOFocus                        code  015af8
  FreeJCB                                     bss  c00078
  FreeMbx                                    code  014c68
  FreeMbx2                                   code  014c80
  FreeMbxHandle                               bss  c00098
  FreeMsg                                     bss  c000a8
  FreeTCB                                     bss  c00080
  GetCurrAttr                                code  010b54
  GetHexNumber                               code  011400
  GetHexNumber.gthxn1                        code  011430
  GetHexNumber.gthxn2                        code  011414
  GetRandomNumber                            code  011580
  GetRange                                   code  011038
  GetScreenLocation                          code  010b48
  GetSystemTime                              code  010b3c
  GetTwoParams                               code  01101c
  HomeCursor                                 code  010660
  I2C_CMD                                   const  000004
  I2C_CONTROL                               const  000002
  I2C_ERR                                    code  011ea0
  I2C_INIT                                   code  011dd0
  I2C_MASTER                                const  ffdc0e00
  I2C_PRESCALE_HI                           const  000001
  I2C_PRESCALE_LO                           const  000000
  I2C_READ                                   code  011e04
  I2C_RX                                    const  000003
  I2C_STAT                                  const  000004
  I2C_TX                                    const  000003
  I2C_WAIT_TC                                code  011f30
  I2C_WAIT_TC.0001                           code  011f30
  I2C_WRITE                                  code  011eb0
  IBPT_ISR                                   code  012384
  IBPT_ISR.0001                              code  012388
  IOFocusNdx                                  bss  c00010
  IOFocusTbl                                  bss  c00018
  IRQFlag                                     bss  c00008
  IRQ_STACK                                 const  008000
  IdleTask                                   code  014370
  IncCursorPos                               code  010d78
  IncCursorRow                               code  010da4
  InitFMTK                                   code  01401c
  InitFMTK.0001                              code  014110
  InitPIC                                    code  010258
  InitUart                                   code  010274
  InputVec                                    bss  000118
  JCB_Array                                 const  c40000
  JCB_ArrayEnd                              const  c50000
  JCB_CmdLine                               const  000280
  JCB_CurrAttr                              const  000418
  JCB_CursorCol                             const  00040d
  JCB_CursorFlash                           const  00040f
  JCB_CursorOn                              const  00040e
  JCB_CursorRow                             const  00040c
  JCB_CursorType                            const  000410
  JCB_ExitError                             const  0003e0
  JCB_ExitRF                                const  000180
  JCB_KeybdAck                              const  00044a
  JCB_KeybdBad                              const  000449
  JCB_KeybdBuffer                           const  000450
  JCB_KeybdEcho                             const  000448
  JCB_KeybdHead                             const  000438
  JCB_KeybdLocks                            const  00044c
  JCB_KeybdTail                             const  000440
  JCB_LogSize                               const  00000a
  JCB_MemGroup0                             const  000024
  JCB_MemGroup1                             const  000026
  JCB_MemGroup2                             const  000028
  JCB_MemGroup3                             const  00002a
  JCB_MemGroup4                             const  00002c
  JCB_MemGroup5                             const  00002e
  JCB_Name                                  const  000004
  JCB_Next                                  const  000420
  JCB_NormAttr                              const  000414
  JCB_Number                                const  000000
  JCB_Path                                  const  000080
  JCB_ScrlCnt                               const  00041c
  JCB_Size                                  const  000500
  JCB_SysIn                                 const  000380
  JCB_SysOut                                const  0003b0
  JCB_UserName                              const  000060
  JCB_VideoCols                             const  00040b
  JCB_VideoMode                             const  000408
  JCB_VideoRows                             const  00040a
  JCB_esc                                   const  000470
  JCB_fVidPause                             const  00041e
  JCB_iof_next                              const  000428
  JCB_iof_prev                              const  000430
  JCB_nCode                                 const  000038
  JCB_nData                                 const  000048
  JCB_nStack                                const  000058
  JCB_pCode                                 const  000030
  JCB_pData                                 const  000040
  JCB_pStack                                const  000050
  JCB_pVidMem                               const  0003e8
  JCB_pVidMemAttr                           const  0003f0
  JCB_pVirtVid                              const  0003f8
  JCB_pVirtVidAttr                          const  000400
  KEYBD                                     const  ffdc0000
  KEYBDCLR                                  const  ffdc0004
  KEYBD_DELAY                               const  0003e8
  KeyState1                                   bss  000140
  KeyState2                                   bss  000141
  KeybdBad                                    bss  00013d
  KeybdEcho                                   bss  00013c
  KeybdGetChar                               code  0117e4
  KeybdGetChar.0001                          code  011818
  KeybdGetChar.0003                          code  0117f0
  KeybdGetChar.0004                          code  011940
  KeybdGetChar.0005                          code  0119c4
  KeybdGetChar.0006                          code  011814
  KeybdGetChar.0007                          code  0118d8
  KeybdGetChar.0008                          code  0118ec
  KeybdGetChar.0009                          code  0118c0
  KeybdGetChar.0010                          code  0118a4
  KeybdGetChar.0011                          code  011970
  KeybdGetChar.0012                          code  0119a0
  KeybdGetChar.0013                          code  011880
  KeybdGetChar.doAlt                         code  011950
  KeybdGetChar.doCapsLock                    code  0119e8
  KeybdGetChar.doCtrl                        code  011924
  KeybdGetChar.doExtend                      code  011914
  KeybdGetChar.doKeyup                       code  011908
  KeybdGetChar.doNumLock                     code  0119d4
  KeybdGetChar.doScrollLock                  code  0119fc
  KeybdGetChar.doShift                       code  0119a8
  KeybdGetChar.doTab                         code  011980
  KeybdGetCharDirect                         code  011600
  KeybdGetCharDirect.0001                    code  011608
  KeybdGetCharDirect.gk1                     code  01164c
  KeybdGetCharDirect.gk2                     code  011648
  KeybdGetCharDirectNB                       code  01158c
  KeybdGetCharDirectNB.0001                  code  0115ec
  KeybdGetCharDirectNB.0002                  code  0115e0
  KeybdGetCharDirectNB.0003                  code  0115dc
  KeybdGetCharNoWait                         code  0117d4
  KeybdGetCharWait                           code  0117dc
  KeybdGetScancode                           code  011730
  KeybdGetStatus                             code  011724
  KeybdIRQ                                   code  0107d8
  KeybdInit                                  code  011671
  KeybdInit.0001                             code  01167c
  KeybdInit.0002                             code  01168c
  KeybdInit.0004                             code  01170c
  KeybdInit.config                           code  0116c8
  KeybdInit.keybdErr                         code  0116f8
  KeybdInit.tryAgain                         code  0116f0
  KeybdLEDs                                   bss  000143
  KeybdLocks                                  bss  00013e
  KeybdRecvByte                              code  011744
  KeybdRecvByte.0003                         code  011750
  KeybdRecvByte.0004                         code  011774
  KeybdSendByte                              code  011a94
  KeybdSetLEDStatus                          code  011a10
  KeybdSetLEDStatus.0001                     code  011a84
  KeybdSetLEDStatus.0002                     code  011a34
  KeybdSetLEDStatus.0003                     code  011a48
  KeybdSetLEDStatus.0004                     code  011a5c
  KeybdWaitFlag                               bss  000142
  KeybdWaitTx                                code  011784
  KeybdWaitTx.0001                           code  011794
  KeybdWaitTx.0002                           code  0117c0
  KillTask                                   code  0146c4
  LEDS                                      const  ffdc0600
  LF                                        const  00000a
  LoadFromSerial                             code  012248
  LoadFromSerial.0001                        code  01225c
  LockFreeMBX                                code  014440
  LockFreeMSG                                code  01445c
  LockFreeTCB                                code  014494
  LockIOF                                    code  015930
  LockMBX                                    code  014478
  LockSema                                   code  0144cc
  LockSema.0001                              code  0144d8
  LockSema.0002                              code  0144fc
  LockTCB                                    code  0144b0
  MAX_BIOS_CALL                             const  000064
  MAX_TASKNO                                 code  800000000000038b
  MBX_Array                                 const  c60000
  MBX_ArrayEnd                              const  c90000
  MBX_LINK                                  const  000000
  MBX_MQ_COUNT                              const  000040
  MBX_MQ_HEAD                               const  000020
  MBX_MQ_MISSED                             const  000048
  MBX_MQ_SIZE                               const  000038
  MBX_MQ_STRATEGY                           const  000058
  MBX_MQ_TAIL                               const  000028
  MBX_OWNER                                 const  000050
  MBX_Size                                  const  000060
  MBX_TQ_COUNT                              const  000030
  MBX_TQ_HEAD                               const  000008
  MBX_TQ_TAIL                               const  000018
  MEM_END                                   const  8000000
  MON_STACK                                 const  006000
  MON_r1                                      bss  000010
  MON_r10                                     bss  000058
  MON_r11                                     bss  000060
  MON_r12                                     bss  000068
  MON_r13                                     bss  000070
  MON_r14                                     bss  000078
  MON_r15                                     bss  000080
  MON_r16                                     bss  000088
  MON_r17                                     bss  000090
  MON_r18                                     bss  000098
  MON_r19                                     bss  0000a0
  MON_r2                                      bss  000018
  MON_r20                                     bss  0000a8
  MON_r21                                     bss  0000b0
  MON_r22                                     bss  0000b8
  MON_r23                                     bss  0000c0
  MON_r24                                     bss  0000c8
  MON_r25                                     bss  0000d0
  MON_r26                                     bss  0000d8
  MON_r27                                     bss  0000e0
  MON_r28                                     bss  0000e8
  MON_r29                                     bss  0000f0
  MON_r3                                      bss  000020
  MON_r30                                     bss  0000f8
  MON_r31                                     bss  000100
  MON_r4                                      bss  000028
  MON_r5                                      bss  000030
  MON_r6                                      bss  000038
  MON_r7                                      bss  000040
  MON_r8                                      bss  000048
  MON_r9                                      bss  000050
  MQS_NEWEST                                 code  800000000000035b
  MQS_OLDEST                                 code  800000000000036d
  MQS_UNLIMITED                              code  800000000000036a
  MQ_NEWEST                                 const  000002
  MQ_OLDEST                                 const  000001
  MQ_UNLIMITED                              const  000000
  MRTest                                     code  8000000000000160
  MSG_Array                                 const  c90000
  MSG_ArrayEnd                              const  d90000
  MSG_D1                                    const  000008
  MSG_D2                                    const  000010
  MSG_LINK                                  const  000000
  MSG_Size                                  const  000020
  MSG_TYPE                                  const  000018
  MT_GETCHAR                                const  ffffffffffffffef
  MT_IRQ                                    const  fffffffffffffff0
  MT_SEMA                                   const  ffffffffffffffff
  MicroDelay                                 code  012218
  MicroDelay.0001                            code  012224
  Milliseconds                                bss  000108
  MonGetch                                   code  010fe0
  Monitor                                    code  010ef6
  NR_JCB                                    const  000033
  NR_MBX                                    const  000800
  NR_MSG                                    const  008000
  NR_PTBL                                   const  000020
  NR_TCB                                    const  000100
  NUMWKA                                      bss  000144
  NormAttr                                    bss  000130
  OutCRLF                                    code  010790
  OutChar                                    code  011128
  OutputVec                                   bss  000110
  PIC                                       const  ffdc0fc0
  PIC_ES                                    const  ffdc0fd0
  PIC_IE                                    const  ffdc0fc4
  PIC_RSTE                                  const  ffdc0fd4
  PN1                                        code  01082c
  PN2                                        code  01082c
  PN3                                        code  01084c
  PN4                                        code  010858
  PN5                                        code  010864
  PN6                                        code  010848
  PNRET                                      code  010878
  PRI_HIGH                                  const  000001
  PRI_HIGHEST                               const  000000
  PRI_LOW                                   const  000005
  PRI_LOWEST                                const  000007
  PRI_NORMAL                                const  000003
  PROG_LOAD_AREA                            const  03b000
  PRTNUM                                     code  010800
  PeekMsg                                    code  0152f0
  PopTimeoutList                             code  014b1c
  PostMsg                                    code  014fe8
  QNdx0                                       bss  c00038
  QNdx1                                       bss  c00040
  QNdx2                                       bss  c00048
  QNdx3                                       bss  c00050
  QNdx4                                       bss  c00058
  QNdx5                                       bss  c00060
  QNdx6                                       bss  c00068
  QNdx7                                       bss  c00070
  QueueMsgAtMbx                              code  014d78
  RANDOM_NUM                                const  ffdc0c00
  ROOTDIR_BUF                                 bss  03b000
  RTCCOscOn                                  code  011f90
  RTCCReadbuf                                code  011f40
  RTCCReadbuf.0001                           code  011f4c
  RTCCWritebuf                               code  011f68
  RTCCWritebuf.0001                          code  011f74
  RTCC_BUF                                    bss  0003d0
  RW_READ_SD_BLOCK                          const  000002
  RW_WRITE_SD_BLOCK                         const  000003
  ReleaseIOFocus                             code  015b18
  RemoveFromTimeoutList                      code  014a70
  RemoveTaskFromReadyList                    code  014924
  RequestIOFocus                             code  015a0c
  RunningTCB                                  bss  c00090
  SCREEN_Array                              const  d90000
  SCREEN_ArrayEnd                           const  e90000
  SC_ALT                                    const  000011
  SC_CAPSLOCK                               const  000058
  SC_CTRL                                   const  000014
  SC_DEL                                    const  000071
  SC_EXTEND                                 const  0000e0
  SC_KEYUP                                  const  0000f0
  SC_LCTRL                                  const  000058
  SC_LSHIFT                                 const  000012
  SC_NUMLOCK                                const  000077
  SC_RSHIFT                                 const  000059
  SC_SCROLLLOCK                             const  00007e
  SC_TAB                                    const  00000d
  SDDiskSize                                 code  8000000000000097
  SDInit                                     code  8000000000000093
  SDReadBoot                                 code  8000000000000176
  SDReadMultiple                             code  8000000000000094
  SDReadPart                                 code  8000000000000096
  SDWriteMultiple                            code  8000000000000095
  SD_2_0                                     code  8000000000000201
  SD_CMD8                                    code  012000
  SD_CMD8.0001                               code  012070
  SD_CMD8.0002                               code  012078
  SD_CMD8.0003                               code  0120d4
  SD_CMD8.0004                               code  012088
  SD_CMD8.respOk                             code  012118
  SD_INIT                                    code  011fb4
  SD_MASTER                                 const  ffdc0b00
  SD_WAIT_RESP                               code  012130
  SD_WAIT_RESP.0001                          code  012144
  SD_WAIT_RESP.0002                          code  012170
  SECTOR_BUF                                  bss  03a000
  SPIMASTER                                 const  ffdc0500
  SPI_DIRECT_ACCESS_DATA_REG                const  000018
  SPI_INIT_NO_ERROR                         const  000000
  SPI_INIT_SD                               const  000001
  SPI_MASTER_CONTROL_REG                    const  000004
  SPI_MASTER_VERSION_REG                    const  000000
  SPI_READ_NO_ERROR                         const  000000
  SPI_RESP_BYTE1                            const  0000c0
  SPI_RESP_BYTE2                            const  0000c4
  SPI_RESP_BYTE3                            const  0000c8
  SPI_RESP_BYTE4                            const  0000cc
  SPI_RX_FIFO_CTRL_REG                      const  000050
  SPI_RX_FIFO_DATA_COUNT_LSB                const  00004c
  SPI_RX_FIFO_DATA_COUNT_MSB                const  000048
  SPI_RX_FIFO_DATA_REG                      const  000040
  SPI_SD_SECT_15_8_REG                      const  000020
  SPI_SD_SECT_23_16_REG                     const  000024
  SPI_SD_SECT_31_24_REG                     const  000028
  SPI_SD_SECT_7_0_REG                       const  00001c
  SPI_TRANS_BUSY                            const  000001
  SPI_TRANS_CTRL_REG                        const  00000c
  SPI_TRANS_ERROR_REG                       const  000014
  SPI_TRANS_START                           const  000001
  SPI_TRANS_STATUS_REG                      const  000010
  SPI_TRANS_TYPE_REG                        const  000008
  SPI_TX_FIFO_CTRL_REG                      const  000090
  SPI_TX_FIFO_DATA_REG                      const  000080
  SPI_WRITE_NO_ERROR                        const  000000
  SSM_ISR                                    code  012380
  STACKS_Array                              const  7f00000
  STACKS_ArrayEnd                           const  8000000
  ScreenToAscii                              code  01063c
  ScreenToAscii.stasc1                       code  010650
  ScrollUp                                   code  010df4
  ScrollUp.0001                              code  010e38
  SelectTaskToRun                            code  0156f8
  SelectTaskToRun2                           code  010af8
  SelectTaskToRun2.0001                      code  010b28
  SendMsg                                    code  015000
  SendMsgPrim                                code  01501c
  SerialCheckForCharDirect                   code  0102fc
  SerialGetChar                              code  010430
  SerialGetCharDirect                        code  0102e0
  SerialIRQ                                  code  0104f4
  SerialPutChar                              code  01030c
  SerialStartMsg                             code  010160
  ServiceRequestIRQ                          code  80000000000000b9
  SetTaskPriority                            code  014865
  SetTaskPriority.stp2                       code  014890
  SetTaskPriority.stp3                       code  014894
  SetupIntVectors                            code  01018c
  SetupMemtags                               code  0121d4
  Sleep                                      code  014b4c
  StartCPU1Addr                               bss  0003a0
  StartCPU1Flag                               bss  000398
  StartIdleTask                              code  014354
  StartJob                                   code  0143b8
  StartTask                                  code  014508
  StartTask.stask6                           code  0145ac
  SwitchIOFocus                              code  0159ac
  TAB                                       const  000009
  TCB_Affinity                              const  000280
  TCB_Array                                 const  c10000
  TCB_ArrayEnd                              const  c40000
  TCB_BASE                                  const  c00000
  TCB_BackLink                              const  000000
  TCB_DPC                                   const  000188
  TCB_EPC                                   const  000190
  TCB_IPC                                   const  000180
  TCB_MSG_D1                                const  000248
  TCB_MSG_D2                                const  000250
  TCB_MbxList                               const  000260
  TCB_NextFree                              const  000218
  TCB_NextRdy                               const  000200
  TCB_NextTo                                const  000228
  TCB_PrevFree                              const  000220
  TCB_PrevRdy                               const  000208
  TCB_PrevTo                                const  000230
  TCB_Priority                              const  000212
  TCB_SP0Save                               const  000100
  TCB_SP10Save                              const  000150
  TCB_SP11Save                              const  000158
  TCB_SP12Save                              const  000160
  TCB_SP13Save                              const  000168
  TCB_SP14Save                              const  000170
  TCB_SP15Save                              const  000178
  TCB_SP1Save                               const  000108
  TCB_SP2Save                               const  000110
  TCB_SP3Save                               const  000118
  TCB_SP4Save                               const  000120
  TCB_SP5Save                               const  000128
  TCB_SP6Save                               const  000130
  TCB_SP7Save                               const  000138
  TCB_SP8Save                               const  000140
  TCB_SP9Save                               const  000148
  TCB_Size                                  const  000300
  TCB_StackTop                              const  000268
  TCB_Status                                const  000210
  TCB_TOP                                   const  1c00000
  TCB_Timeout                               const  000278
  TCB_errno                                 const  000270
  TCB_hJCB                                  const  000214
  TCB_hWaitMbx                              const  000258
  TCB_mbq_next                              const  000238
  TCB_mbq_prev                              const  000240
  TCB_r1                                    const  000008
  TCB_r10                                   const  000050
  TCB_r11                                   const  000058
  TCB_r12                                   const  000060
  TCB_r13                                   const  000068
  TCB_r14                                   const  000070
  TCB_r15                                   const  000078
  TCB_r16                                   const  000080
  TCB_r17                                   const  000088
  TCB_r18                                   const  000090
  TCB_r19                                   const  000098
  TCB_r2                                    const  000010
  TCB_r20                                   const  0000a0
  TCB_r21                                   const  0000a8
  TCB_r22                                   const  0000b0
  TCB_r23                                   const  0000b8
  TCB_r24                                   const  0000c0
  TCB_r25                                   const  0000c8
  TCB_r26                                   const  0000d0
  TCB_r27                                   const  0000d8
  TCB_r28                                   const  0000e0
  TCB_r29                                   const  0000e8
  TCB_r3                                    const  000018
  TCB_r30                                   const  0000f0
  TCB_r31                                   const  0000f8
  TCB_r4                                    const  000020
  TCB_r5                                    const  000028
  TCB_r6                                    const  000030
  TCB_r7                                    const  000038
  TCB_r8                                    const  000040
  TCB_r9                                    const  000048
  TCBs                                        bss  00a000
  TEXTREG                                   const  0a0000
  TEXTSCR                                   const  000000
  TEXT_COLS                                 const  000000
  TEXT_CURCTL                               const  000020
  TEXT_CURPOS                               const  00002c
  TEXT_ROWS                                 const  000004
  TSSBaseAddress                              bss  00a000
  TS_NONE                                   const  000000
  TS_PREEMPT                                const  000004
  TS_READY                                  const  000010
  TS_READY_BIT                              const  000004
  TS_RUNNING                                const  000008
  TS_RUNNING_BIT                            const  000003
  TS_SLEEP                                  const  000020
  TS_TIMEOUT                                const  000001
  TS_TIMEOUT_BIT                            const  000000
  TS_WAITMSG                                const  000002
  TS_WAITMSG_BIT                            const  000001
  TXTCOLS                                   const  000054
  TXTROWS                                   const  00001f
  TempTCB                                     bss  008000
  Tick1024Rout                               code  010ac8
  Tick1024Rout.0001                          code  010ad4
  TickRout                                   code  010920
  TickRout.SaveContext                       code  010930
  TickRout.acknowledgeInterrupt              code  010a54
  TickVec                                     bss  000128
  Ticks                                       bss  000008
  TimeoutList                                 bss  c00088
  ToJul                                      code  012564
  UART                                      const  ffdc0a00
  UART_CM0                                  const  000008
  UART_CM1                                  const  000009
  UART_CM2                                  const  00000a
  UART_CM3                                  const  00000b
  UART_CTRL                                 const  000007
  UART_FF                                   const  000005
  UART_IE                                   const  000004
  UART_IS                                   const  000003
  UART_LS                                   const  000001
  UART_MC                                   const  000006
  UART_MS                                   const  000002
  UART_RX                                   const  000000
  UART_SPR                                  const  00000f
  UART_TX                                   const  000000
  Uart_foff                                   bss  000176
  Uart_fon                                    bss  000178
  Uart_ms                                     bss  00016c
  Uart_rxdtr                                  bss  000174
  Uart_rxfifo                                 bss  00017d
  Uart_rxflow                                 bss  000172
  Uart_rxhead                                 bss  00016e
  Uart_rxrts                                  bss  000173
  Uart_rxtail                                 bss  000170
  Uart_rxxon                                  bss  000175
  Uart_txdtr                                  bss  00017b
  Uart_txrts                                  bss  00017a
  Uart_txxon                                  bss  00017c
  Uart_txxonoff                               bss  00016d
  UpdateCursorPos                            code  010b5c
  UserTick                                    bss  c00000
  UserTickRout                               code  010a98
  VAR_Area                                  const  c00000
  Wait10ms                                   code  011aa0
  Wait10ms.0001                              code  011aac
  Wait10ms.0002                              code  011ac4
  WaitMsg                                    code  015168
  XOFF                                      const  000013
  XON                                       const  000011
  ambx_bad_ptr                               code  014c44
  ambx_no_mbxs                               code  014c4c
  arl1                                       code  0148d0
  arl5                                       code  014904
  attl_add_at_end                            code  0149e4
  attl_add_at_head                           code  014a3c
  attl_adjust_timeout                        code  014a24
  attl_check_next                            code  0149cc
  attl_exit                                  code  014a50
  attl_insert_before                         code  0149f8
  attl_insert_before_head                    code  014a10
  berr_rout                                  code  01231f
  brkpt1                                     code  0121dc
  brkpt1.0001                                code  0121f8
  cirxb1                                     code  01042c
  clockmsg_d1                                 bss  c00100
  clockmsg_d2                                 bss  c00108
  cmsg1                                      code  015384
  cmsg10                                     code  015340
  cmsg2                                      code  015390
  cmsg3                                      code  015328
  cmsg4                                      code  01532c
  cmsg5                                      code  0153ac
  cmsg8                                      code  015368
  csvs3                                      code  015c80
  cvss3                                      code  015c0c
  disk_size                                   bss  000168
  dmfm1                                      code  014ee8
  dmfm2                                      code  014ee4
  dmfm3                                      code  014ef4
  doCLS                                      code  011572
  doCS                                       code  800000000000015d
  doDate                                     code  011238
  doDate.0001                                code  011278
  doDay                                      code  0112b0
  doDumpTL                                   code  011078
  doDumpmem                                  code  011058
  doDumpmem.001                              code  011064
  doFillmem                                  code  011080
  doFillmem.0001                             code  0110dc
  doFillmem.0002                             code  0110c4
  doFillmem.0003                             code  0110e4
  doFillmem.0004                             code  011094
  doJump                                     code  01112c
  doRand                                     code  8000000000000162
  doSDBoot                                   code  011104
  drf_rout                                   code  012290
  drf_rout.0001                              code  0122a8
  dtfm2                                      code  014f20
  dtfm2a                                     code  014fa0
  dtfm3                                      code  014f3c
  dtfm3a                                     code  014fbc
  dtfm4                                      code  014f40
  dtfm4a                                     code  014fc0
  dtfm5                                      code  014f64
  dtl1                                       code  01480c
  dtl2                                       code  01478c
  dtl3                                       code  01479c
  dwf_rout                                   code  0122ac
  dwf_rout.0001                              code  0122c4
  eval                                       code  8000000000000163
  exf_rout                                   code  012274
  exf_rout.0001                              code  01228c
  fif1                                       code  015994
  fmbx1                                      code  014d70
  fmbx10                                     code  014cf8
  fmbx11                                     code  014d28
  fmbx12                                     code  014d34
  fmbx2                                      code  014d54
  fmbx3                                      code  014cd0
  fmbx5                                      code  014c94
  fmbx6                                      code  014cd4
  fmbx7                                      code  014ce8
  fmbx9                                      code  014d14
  freejcb_sema                                bss  c00128
  freembx_sema                                bss  c00138
  freemsg_sema                                bss  c00140
  freetcb_sema                                bss  c00130
  get_datetime                               code  012390
  hangprg                                    code  0121c4
  icc1                                       code  010dd4
  icr1                                       code  010db4
  ignBlanks                                  code  010ffc
  ignBlanks1                                 code  011004
  ijcb1                                      code  01412c
  ijcb2                                      code  0141a4
  iof_sema                                    bss  c00160
  iof_switch                                  bss  c000f8
  it1                                        code  01439c
  it2                                        code  014378
  it3                                        code  014370
  jcb_sema                                    bss  c00178
  jmp_vector                                  bss  000120
  kbdi5                                      code  011658
  kernel_panic                               code  0158f4
  keybdControlCodes                          code  011cd0
  keybdExtendedCodes                         code  011d50
  keybdInIRQ                                  bss  c000f0
  keybdIsSetup                                bss  c000e0
  keybdLock                                   bss  c000e8
  keybd_char                                  bss  c000d8
  keybd_mbx                                   bss  c000d0
  keybdmsg_d1                                 bss  c000c0
  keybdmsg_d2                                 bss  c000c8
  kpan1                                      code  015914
  kpan2                                      code  0158f8
  kt1                                        code  014760
  kt6                                        code  014728
  kt6.self                                   code  01475c
  kt7                                        code  01470c
  ld                                         code  014b98
  loadBootFile                               code  8000000000000177
  mbx_sema                                    bss  c00168
  missed_ticks                                bss  c000b8
  mmu_acc_save                                bss  c00120
  mon1                                       code  010f14
  mon1.Prompt1                               code  010f50
  mon1.Prompt2                               code  010f6c
  mon1.Prompt3                               code  010f38
  mon1.PromptLn                              code  010f2c
  mon1.doHelp                                code  010fd0
  msgBadKeybd                                code  011658
  msgBusErr                                  code  01230a
  msgEA                                      code  01231a
  msgErr                                     code  0114bc
  msgHelp                                    code  0114c4
  msgMonitorStarted                          code  011561
  msgPriv                                    code  0122f3
  msgStart                                   code  010ed9
  msgTaskList                                code  014834
  msgUninit                                  code  0122fe
  msg_sema                                    bss  c00170
  msgdrf                                     code  0122e9
  msgdwf                                     code  0122ee
  msgexf                                     code  0122e4
  nMailbox                                    bss  c000a0
  nMsgBlk                                     bss  c000b0
  p100Hz11                                   code  0155d4
  p100Hz12                                   code  0156ec
  p100Hz14                                   code  0156d0
  p100Hz15                                   code  0156a8
  p100Hz4                                    code  015690
  pSpriteController                          code  0126f4
  priv_rout                                  code  0122c8
  priv_rout.0001                             code  0122e0
  ptl1                                       code  014b30
  qmam2                                      code  014e00
  qmam3                                      code  014e30
  qmam4                                      code  014e34
  qmam6                                      code  014e04
  qmam8                                      code  014e5c
  qmam_add_at_head                           code  014dfc
  qmam_bad_msg                               code  014e1c
  qmam_newest                                code  014e20
  qmam_oldest                                code  014e9c
  qmam_unlimited                             code  014dec
  r1                                         code  014b98
  r11                                        code  010900
  r11.0003                                   code  010918
  r11.0004                                   code  010904
  r2                                         code  011eac
  r3                                         code  011eac
  r4                                         code  014b98
  r5                                         code  011eac
  readylist_sema                              bss  c00150
  resched1                                   code  015524
  reschedule                                 code  015424
  reschedule.0001                            code  015438
  reschedule.0003                            code  015440
  reschedule.0004                            code  015470
  reschedule.0005                            code  015484
  reschedule.0006                            code  015478
  rfr2                                       code  014990
  rftl_empty_list                            code  014aec
  rftl_not_on_list                           code  014b08
  rftl_not_on_list2                          code  014b18
  rftl_remove_from_head                      code  014ac8
  riof1                                      code  015ab0
  riof2                                      code  015ad0
  riof3                                      code  015a7c
  riof4                                      code  015ae4
  rliof1                                     code  015b8c
  rliof2                                     code  015bac
  rliof3                                     code  015bb4
  rliof4                                     code  015b34
  rliof5                                     code  015ba4
  rxfull                                    const  000001
  set_time_serial                            code  012638
  set_time_serial_10                         code  012504
  set_time_serial_12                         code  01253c
  set_time_serial_14                         code  01253c
  set_time_serial_17                         code  01262c
  set_time_serial_19                         code  0126e8
  set_time_serial_2                          code  012418
  set_time_serial_20                         code  0126d4
  set_time_serial_4                          code  012450
  set_time_serial_6                          code  012488
  set_time_serial_8                          code  0124cc
  sgc1                                       code  0102e0
  sgcfifo1                                   code  0104dc
  sgcfifo2                                   code  0104c8
  sgcfifo3                                   code  0104a0
  sgcfifo4                                   code  0104b4
  sgcfifo5                                   code  0104c8
  shiftedScanCodes                           code  011bd0
  siof3                                      code  0159f4
  sirq1                                      code  010538
  sjob1                                      code  014430
  sjob2                                      code  01442c
  sjob3                                      code  01440c
  sjob4                                      code  0143bc
  smp2                                       code  015054
  smsg1                                      code  015120
  smsg2                                      code  015128
  smsg3                                      code  0150a8
  smsg4                                      code  015144
  smsg5                                      code  015104
  smsg7                                      code  0150b0
  smsg8                                      code  0150c8
  smsg9                                      code  01510c
  smsirq                                     code  01054c
  spcabort                                   code  0103f4
  spcb1                                      code  01036c
  spcb2                                      code  0103a4
  spcb3                                      code  010344
  spcb4                                      code  01037c
  spcb5                                      code  0103c0
  spcb6                                      code  0103ac
  spcb7                                      code  0103f0
  spcb8                                      code  0103c8
  sprite_demo                                code  0126fc
  sprite_demo_10                             code  01279c
  sprite_demo_11                             code  012814
  sprite_demo_12                             code  01280c
  sprite_demo_13                             code  012814
  sprite_demo_14                             code  0128e8
  sprite_demo_15                             code  012820
  sprite_demo_16                             code  0128d8
  sprite_demo_17                             code  0128d0
  sprite_demo_18                             code  0128e8
  sprite_demo_4                              code  012734
  sprite_demo_5                              code  01276c
  sprite_demo_6                              code  012764
  sprite_demo_7                              code  012770
  sprite_demo_8                              code  012798
  sprite_demo_9                              code  012790
  sprites                                     bss  03f000
  srxirq                                     code  01055c
  srxirq1                                    code  01055c
  srxirq2                                    code  01057c
  srxirq3                                    code  01058c
  srxirq5                                    code  0105a4
  srxirq6                                    code  0105ec
  srxirq7                                    code  010600
  srxirq8                                    code  010610
  st4                                        code  0141d8
  st4.imbxl1                                 code  01422c
  st5                                        code  01425c
  st5.0001                                   code  014288
  st5.nextTCB                                code  0142b4
  start                                      code  010080
  start.0001                                 code  0100c8
  start.0002                                 code  0100b0
  start.0003                                 code  010094
  startSector                                 bss  000164
  stask1                                     code  014620
  stask2                                     code  0145fc
  strStartQue                                code  015538
  sttr1                                      code  015880
  sttr2                                      code  015714
  sttr3                                      code  015890
  sttr5                                      code  015764
  sttr6                                      code  0157d4
  sttr7                                      code  015874
  sttr_badtask                               code  0158d4
  stxirq                                     code  010558
  syscall_exception                          code  0153c8
  syscall_exception.0001                     code  0153dc
  syscall_exception.0002                     code  0153e4
  syscall_vectors                            code  014000
  tcb_sema                                    bss  c00148
  tcbsema_d1                                  bss  c00110
  tcbsema_d2                                  bss  c00118
  tck3                                       code  0156ec
  tolist_sema                                 bss  c00158
  unshiftedScanCodes                         code  011ad0
  wmsg1                                      code  0152c8
  wmsg10                                     code  015210
  wmsg11                                     code  015180
  wmsg12                                     code  0151a0
  wmsg13                                     code  0151b4
  wmsg14                                     code  0151fc
  wmsg2                                      code  0152d0
  wmsg3                                      code  015258
  wmsg5                                      code  015268
  wmsg6                                      code  01523c
  wmsg7                                      code  0151e8
  wmsg8                                      code  0152b0
  xtsk1                                      code  0146c0
  xtsk6                                      code  014688
  xtsk7                                      code  014670
