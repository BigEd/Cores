     1	
     2	
     3	
     4	
     5	
     6	
     7	// message types
     8	
     9	enum {
    10	     E_Ok = 0,
    11	     E_BadTCBHandle,
    12	     E_BadPriority,
    13	     E_BadCallno,
    14	     E_Arg,
    15	     E_BadMbx,
    16	     E_QueFull,
    17	     E_NoThread,
    18	     E_NotAlloc,
    19	     E_NoMsg,
    20	     E_Timeout,
    21	     E_BadAlarm,
    22	     E_NotOwner,
    23	     E_QueStrategy,
    24	     E_DCBInUse,
    25	     //; Device driver errors
    26	     E_BadDevNum =	0x20,
    27	     E_NoDev,
    28	     E_BadDevOp,
    29	     E_ReadError,
    30	     E_WriteError,
    31	     E_BadBlockNum,
    32	     E_TooManyBlocks,
    33	
    34	     // resource errors
    35	     E_NoMoreMbx =	0x40,
    36	     E_NoMoreMsgBlks,
    37	     E_NoMoreAlarmBlks,
    38	     E_NoMoreTCBs,
    39	     E_NoMem
    40	};
    41	
    42	
    43	typedef unsigned int uint;
    44	typedef __int16 hTCB;
    45	typedef __int8 hJCB;
    46	typedef __int16 hMBX;
    47	typedef __int16 hMSG;
    48	
    49	typedef struct tagMSG align(32) {
    50		unsigned __int16 link;
    51		unsigned __int16 retadr;    // return address
    52		unsigned __int16 tgtadr;    // target address
    53		unsigned __int16 type;
    54		unsigned int d1;            // payload data 1
    55		unsigned int d2;            // payload data 2
    56		unsigned int d3;            // payload data 3
    57	} MSG;
    58	
    59	typedef struct _tagJCB align(2048)
    60	{
    61	    struct _tagJCB *iof_next;
    62	    struct _tagJCB *iof_prev;
    63	    char UserName[32];
    64	    char path[256];
    65	    char exitRunFile[256];
    66	    char commandLine[256];
    67	    unsigned __int32 *pVidMem;
    68	    unsigned __int32 *pVirtVidMem;
    69	    unsigned __int16 VideoRows;
    70	    unsigned __int16 VideoCols;
    71	    unsigned __int16 CursorRow;
    72	    unsigned __int16 CursorCol;
    73	    unsigned __int32 NormAttr;
    74	    __int8 KeyState1;
    75	    __int8 KeyState2;
    76	    __int8 KeybdWaitFlag;
    77	    __int8 KeybdHead;
    78	    __int8 KeybdTail;
    79	    unsigned __int16 KeybdBuffer[16];
    80	    hJCB number;
    81	} JCB;
    82	
    83	struct tagMBX;
    84	
    85	typedef struct _tagTCB align(1024) {
    86	    // exception storage area
    87		int regs[32];
    88		int isp;
    89		int dsp;
    90		int esp;
    91		int ipc;
    92		int dpc;
    93		int epc;
    94		int cr0;
    95		// interrupt storage
    96		int iregs[32];
    97		int iisp;
    98		int idsp;
    99		int iesp;
   100		int iipc;
   101		int idpc;
   102		int iepc;
   103		int icr0;
   104		hTCB next;
   105		hTCB prev;
   106		hTCB mbq_next;
   107		hTCB mbq_prev;
   108		int *sys_stack;
   109		int *bios_stack;
   110		int *stack;
   111		__int64 timeout;
   112		MSG msg;
   113		hMBX hMailboxes[4]; // handles of mailboxes owned by task
   114		hMBX hWaitMbx;      // handle of mailbox task is waiting at
   115		hTCB number;
   116		__int8 priority;
   117		__int8 status;
   118		__int8 affinity;
   119		hJCB hJob;
   120		__int64 startTick;
   121		__int64 endTick;
   122		__int64 ticks;
   123	} TCB;
   124	
   125	typedef struct tagMBX align(64) {
   126	    hMBX link;
   127		hJCB owner;		// hJcb of owner
   128		hTCB tq_head;
   129		hTCB tq_tail;
   130		hMSG mq_head;
   131		hMSG mq_tail;
   132		char mq_strategy;
   133		byte resv[2];
   134		uint tq_count;
   135		uint mq_size;
   136		uint mq_count;
   137		uint mq_missed;
   138	} MBX;
   139	
   140	typedef struct tagALARM {
   141		struct tagALARM *next;
   142		struct tagALARM *prev;
   143		MBX *mbx;
   144		MSG *msg;
   145		uint BaseTimeout;
   146		uint timeout;
   147		uint repeat;
   148		byte resv[8];		// padding to 64 bytes
   149	} ALARM;
   150	
   151	
   152	extern int irq_stack[];
   153	extern int FMTK_Inited;
   154	extern JCB jcbs[];
   155	extern TCB tcbs[];
   156	extern hTCB readyQ[];
   157	extern hTCB freeTCB;
   158	extern int sysstack[];
   159	extern int stacks[][];
   160	extern int sys_stacks[][];
   161	extern int bios_stacks[][];
   162	extern int fmtk_irq_stack[];
   163	extern int fmtk_sys_stack[];
   164	extern MBX mailbox[];
   165	extern MSG message[];
   166	extern int nMsgBlk;
   167	extern int nMailbox;
   168	extern hMSG freeMSG;
   169	extern hMBX freeMBX;
   170	extern JCB *IOFocusNdx;
   171	extern int IOFocusTbl[];
   172	extern int iof_switch;
   173	extern int BIOS1_sema;
   174	extern int iof_sema;
   175	extern int sys_sema;
   176	extern int BIOS_RespMbx;
   177	extern char hasUltraHighPriorityTasks;
   178	extern int missed_ticks;
   179	extern short int video_bufs[][];
   180	extern hTCB TimeoutList;
   181	
   182	
   183	// ============================================================================
   184	//        __
   185	//   \\__/ o\    (C) 2012-2015  Robert Finch, Stratford
   186	//    \  __ /    All rights reserved.
   187	//     \/_//     robfinch<remove>@finitron.ca
   188	//       ||
   189	//
   190	// TCB.c
   191	// Task Control Block related functions.
   192	//
   193	// This source file is free software: you can redistribute it and/or modify 
   194	// it under the terms of the GNU Lesser General Public License as published 
   195	// by the Free Software Foundation, either version 3 of the License, or     
   196	// (at your option) any later version.                                      
   197	//                                                                          
   198	// This source file is distributed in the hope that it will be useful,      
   199	// but WITHOUT ANY WARRANTY; without even the implied warranty of           
   200	// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
   201	// GNU General Public License for more details.                             
   202	//                                                                          
   203	// You should have received a copy of the GNU General Public License        
   204	// along with this program.  If not, see <http://www.gnu.org/licenses/>.    
   205	//                                                                          
   206	// ============================================================================
   207	//
   208	// JCB functions
   209	JCB *GetJCBPtr();                   // get the JCB pointer of the running task
   210	
   211	// TCB functions
   212	TCB *GetRunningTCBPtr();
   213	hTCB GetRunningTCB();
   214	pascal void SetRunningTCB(hTCB ht);
   215	pascal int chkTCB(TCB *p);
   216	pascal int InsertIntoReadyList(hTCB ht);
   217	pascal int RemoveFromReadyList(hTCB ht);
   218	pascal int InsertIntoTimeoutList(hTCB ht, int to);
   219	pascal int RemoveFromTimeoutList(hTCB ht);
   220	void DumpTaskList();
   221	
   222	pascal void SetBound48(TCB *ps, TCB *pe, int algn);
   223	pascal void SetBound49(JCB *ps, JCB *pe, int algn);
   224	pascal void SetBound50(MBX *ps, MBX *pe, int algn);
   225	pascal void SetBound51(MSG *ps, MSG *pe, int algn);
   226	
   227	void set_vector(unsigned int, unsigned int);
   228	int getCPU();
   229	int GetVecno();          // get the last interrupt vector number
   230	void outb(unsigned int, int);
   231	void outc(unsigned int, int);
   232	void outh(unsigned int, int);
   233	void outw(unsigned int, int);
   234	pascal int LockSemaphore(int *sema, int retries);
   235	pascal void UnlockSemaphore(int *sema);
   236	
   237	// The following causes a privilege violation if called from user mode
   238	
   239	
   240	/*
   241	SC_DEL		EQU		$71		; extend
   242	SC_LCTRL	EQU		$58
   243	*/
   244	
   245	extern byte keybdExtendedCodes[];
   246	extern byte keybdControlCodes[];
   247	extern byte shiftedScanCodes[];
   248	extern byte unshiftedScanCodes[];
   249	//
   250	// KeyState2_
   251	// 876543210
   252	// ||||||||+ = shift
   253	// |||||||+- = alt
   254	// ||||||+-- = control
   255	// |||||+--- = numlock
   256	// ||||+---- = capslock
   257	// |||+----- = scrolllock
   258	// ||+------ =
   259	// |+------- = 
   260	// +-------- = extended
   261	//
   262	
   263	unsigned int keybd_irq_stack[512];
   264	
   265	void KeybdIRQ()
   266	{
   267	    __int8 sc;
   268	    __int8 kh, kt;
   269	    JCB *jcb;
   270	
   271	     prolog asm {
   272	         lea   sp,keybd_irq_stack_+4088
   273	         sw    r1,8+312[tr]
   274	         sw    r2,16+312[tr]
   275	         sw    r3,24+312[tr]
   276	         sw    r4,32+312[tr]
   277	         sw    r5,40+312[tr]
   278	         sw    r6,48+312[tr]
   279	         sw    r7,56+312[tr]
   280	         sw    r8,64+312[tr]
   281	         sw    r9,72+312[tr]
   282	         sw    r10,80+312[tr]
   283	         sw    r11,88+312[tr]
   284	         sw    r12,96+312[tr]
   285	         sw    r13,104+312[tr]
   286	         sw    r14,112+312[tr]
   287	         sw    r15,120+312[tr]
   288	         sw    r16,128+312[tr]
   289	         sw    r17,136+312[tr]
   290	         sw    r18,144+312[tr]
   291	         sw    r19,152+312[tr]
   292	         sw    r20,160+312[tr]
   293	         sw    r21,168+312[tr]
   294	         sw    r22,176+312[tr]
   295	         sw    r23,184+312[tr]
   296	         sw    r24,192+312[tr]
   297	         sw    r25,200+312[tr]
   298	         sw    r26,208+312[tr]
   299	         sw    r27,216+312[tr]
   300	         sw    r28,224+312[tr]
   301	         sw    r29,232+312[tr]
   302	         sw    r30,240+312[tr]
   303	         sw    r31,248+312[tr]
   304	         mfspr r1,cr0
   305	         sw    r1,304[tr]
   306	     }
   307	     if (KeybdGetStatus() < 0) {       // Is there actually a scancode available
   308	         sc = KeybdGetScancode();
   309	         jcb = IOFocusNdx;             // Are there any jobs with focus ?     
   310	         if (jcb) {
   311	          	 if (LockSemaphore(&sys_sema,10000)) {
   312	                 KeybdClearRcv();              // clear recieve register
   313	                 kh = jcb->KeybdHead;
   314	                 kt = jcb->KeybdTail;
   315	                 kh++;
   316	                 kh &= 15;
   317	                 if (kh <> kt) {
   318	                     jcb->KeybdHead = kh;   
   319	                     jcb->KeybdBuffer[kh] = sc;
   320	                 }
   321	                 UnlockSemaphore(&sys_sema);
   322	             }
   323	             if ((jcb->KeyState2 & 2) && sc == 0x0D)    // ALT + TAB ?
   324	                 iof_switch++;       
   325	         }
   326	     }
   327	     // Restore the processor registers and return using an RTI.
   328	     epilog asm {
   329	         lw    r1,304[tr]
   330	         mtspr cr0,r1
   331	         lw    r1,8+312[tr]
   332	         lw    r2,16+312[tr]
   333	         lw    r3,24+312[tr]
   334	         lw    r4,32+312[tr]
   335	         lw    r5,40+312[tr]
   336	         lw    r6,48+312[tr]
   337	         lw    r7,56+312[tr]
   338	         lw    r8,64+312[tr]
   339	         lw    r9,72+312[tr]
   340	         lw    r10,80+312[tr]
   341	         lw    r11,88+312[tr]
   342	         lw    r12,96+312[tr]
   343	         lw    r13,104+312[tr]
   344	         lw    r14,112+312[tr]
   345	         lw    r15,120+312[tr]
   346	         lw    r16,128+312[tr]
   347	         lw    r17,136+312[tr]
   348	         lw    r18,144+312[tr]
   349	         lw    r19,152+312[tr]
   350	         lw    r20,160+312[tr]
   351	         lw    r21,168+312[tr]
   352	         lw    r22,176+312[tr]
   353	         lw    r23,184+312[tr]
   354	         lw    r25,200+312[tr]
   355	         lw    r26,208+312[tr]
   356	         lw    r27,216+312[tr]
   357	         lw    r28,224+312[tr]
   358	         lw    r29,232+312[tr]
   359	         lw    r31,248+312[tr]
   360	         rti
   361	     }
   362	}
   363	
   364	
   365	// Return -1 if there is a scancode available in the buffer.
   366	


*** local symbol table ***

sc_        =ffffffff    -    Auto        Byte
kh_        =fffffffe    -    Auto        Byte
kt_        =fffffffd    -    Auto        Byte
jcb_       =fffffff0    -    Auto        Pointer to struct _tagJCB_ 



   367	int KeybdGetBufferStatus()
   368	{
   369	    JCB *j;
   370	    __int8 kh, kt;
   371	
   372	    j = GetJCBPtr();
   373	    if (LockSemaphore(&sys_sema,-1)) {
   374	        kh = j->KeybdHead;
   375	        kt = j->KeybdTail;
   376	        UnlockSemaphore(&sys_sema);
   377	    }
   378	    if (kh<>kt)
   379	        return -1;
   380	    return 0;
   381	            
   382	}
   383	


*** local symbol table ***

j_         =fffffff8    -    Auto        Pointer to struct _tagJCB_ 
kh_        =fffffff7    -    Auto        Byte
kt_        =fffffff6    -    Auto        Byte



   384	int KeybdGetBufferedScancode()
   385	{
   386	    JCB *j;
   387	    __int8 kh, kt;
   388	    __int8 sc;
   389	
   390	    j = GetJCBPtr();
   391	    if (LockSemaphore(&sys_sema,-1)) {
   392	        kh = j->KeybdHead;
   393	        kt = j->KeybdTail;
   394	        if (kh <> kt) {
   395	            sc = j->KeybdBuffer[kt];
   396	            kt++;
   397	            kt &= 15;
   398	            j->KeybdTail = kt;
   399	        }
   400	        else sc = 0;
   401	        UnlockSemaphore(&sys_sema);
   402	    }
   403	    return sc;
   404	}
   405	


*** local symbol table ***

j_         =fffffff8    -    Auto        Pointer to struct _tagJCB_ 
kh_        =fffffff7    -    Auto        Byte
kt_        =fffffff6    -    Auto        Byte
sc_        =fffffff5    -    Auto        Byte



   406	private char KeybdGetBufferedChar()
   407	{
   408	    JCB *j;
   409	    __int8 sc;
   410	    char ch;
   411	
   412	    j = GetJCBPtr();
   413	    forever {
   414	        while (KeybdGetBufferStatus() >= 0) {
   415	            if (j->KeybdWaitFlag==0)
   416	                return -1;
   417	        }
   418	        sc = KeybdGetBufferedScancode();
   419	        switch(sc) {
   420	        case 0xF0:
   421	            j->KeyState1 = -1;
   422	            break;
   423	        case 0xE0:
   424	            j->KeyState2 |= 0x80;
   425	            break;
   426	        case 0x14:
   427	            if (j->KeyState1 >= 0)
   428	                j->KeyState2 |= 4;
   429	            else
   430	                j->KeyState2 &= ~4;
   431	            j->KeyState1 = 0;
   432	            break;
   433	        case 0x59:
   434	            if (j->KeyState1 >= 0)
   435	                j->KeyState2 |= 1;
   436	            else
   437	                j->KeyState2 &= ~1;
   438	            j->KeyState1 = 0;
   439	            break;
   440	        case 0x77:
   441	            j->KeyState2 ^= 16;
   442	            //KeybdSetLEDStatus();
   443	            break;
   444	        case 0x58:
   445	            j->KeyState2 ^= 32;
   446	            //KeybdSetLEDStatus();
   447	            break;
   448	        case 0x7E:
   449	            j->KeyState2 ^= 64;
   450	            //KeybdSetLEDStatus();
   451	            break;
   452	        case 0x11:
   453	            if (j->KeyState1 >= 0)
   454	                j->KeyState2 |= 2;
   455	            else
   456	                j->KeyState2 &= ~2;
   457	            j->KeyState1 = 0;
   458	            break;
   459	        default:
   460	            if (sc == 0x0D && (j->KeyState2 & 2) && j->KeyState1==0) {
   461	                iof_switch++;
   462	                break;
   463	            }
   464	            else {
   465	                 if (j->KeyState1) {
   466	                     j->KeyState1 = 0;
   467	                     break;
   468	                 }
   469	                 else {
   470	                      if (j->KeyState2 & 0x80) { // Extended code ?
   471	                          ch = keybdExtendedCodes[sc];
   472	                          j->KeyState1 = 0;
   473	                          j->KeyState2 &= 0x7F;
   474	                          return ch;
   475	                      }
   476	                      else if (j->KeyState2 & 0x04) { // control ?
   477	                          ch = keybdControlCodes[sc];
   478	                          j->KeyState2 &= 0xFB;
   479	                          return ch;
   480	                      }
   481	                      else if (j->KeyState2 & 0x01) { // shifted ?
   482	                          ch = shiftedScanCodes[sc];
   483	                          j->KeyState2 &= 0xFE;
   484	                          return ch;
   485	                      }
   486	                      else {
   487	                          ch = unshiftedScanCodes[sc];
   488	                          return ch;
   489	                      }
   490	                 }
   491	            }
   492	        }
   493	    }
   494	}
   495	


*** local symbol table ***

j_         =fffffff8    -    Auto        Pointer to struct _tagJCB_ 
sc_        =fffffff7    -    Auto        Byte
ch_        =fffffff4    -    Auto        Char



   496	char KeybdGetBufferedCharWait() {
   497	    JCB *j;
   498	    j = GetJCBPtr();
   499	    j->KeybdWaitFlag = 1;
   500	    return KeybdGetBufferedChar();     
   501	}
   502	


*** local symbol table ***

j_         =fffffff8    -    Auto        Pointer to struct _tagJCB_ 



   503	char KeybdGetBufferedCharNoWait() {
   504	    JCB *j;
   505	    j = GetJCBPtr();
   506	    j->KeybdWaitFlag = 0;
   507	    return KeybdGetBufferedChar();     
   508	}
   509	


*** local symbol table ***

j_         =fffffff8    -    Auto        Pointer to struct _tagJCB_ 




 *** global scope typedef symbol table ***

jcbs_      =000000    -    External    Array of struct _tagJCB_ 
E_NoMoreMsgBlks_ =000041    -    Constant    Long
tcbs_      =000000    -    External    Array of struct _tagTCB_ 
nMsgBlk_   =000000    -    External    Long
KeybdGetBufferedChar_ =000018    -    Static      Function returning Char
E_NoThread_ =000007    -    Constant    Long
E_WriteError_ =000024    -    Constant    Long
IOFocusTbl_ =000000    -    External    Array of Long
outb_      =001480    -    Global      Function returning 
outc_      =001480    -    Global      Function returning 
E_Arg_     =000004    -    Constant    Long
E_NotAlloc_ =000008    -    Constant    Long
uint_      =000000    1   
outh_      =001480    -    Global      Function returning 
irq_stack_ =000000    -    External    Array of Long
IOFocusNdx_ =000000    -    External    Pointer to struct _tagJCB_ 
DumpTaskList_ =001480    -    External    Function returning 
E_BadBlockNum_ =000025    -    Constant    Long
E_TooManyBlocks_ =000026    -    Constant    Long
JCB_       =000800    1   struct _tagJCB_ 
outw_      =001480    -    Global      Function returning 
E_BadTCBHandle_ =000001    -    Constant    Long
E_BadMbx_  =000005    -    Constant    Long
fmtk_irq_stack_ =000000    -    External    Array of Long
TCB_       =001000    1   struct _tagTCB_ 
GetRunningTCB_ =001480    -    External    Function returning Char
KeybdIRQ_  =002480    -    Global      Function returning 
keybdControlCodes_ =000000    -    External    Array of Byte
E_NotOwner_ =00000c    -    Constant    Long
fmtk_sys_stack_ =000000    -    External    Array of Long
message_   =000000    -    External    Array of struct tagMSG_ 
SetRunningTCB_ =001480    -    Global      Function returning 
MSG_       =000020    1   struct tagMSG_ 
MBX_       =001400    1   struct tagMBX_ 
mailbox_   =000000    -    External    Array of struct tagMBX_ 
KeybdGetBufferStatus_ =002480    -    Global      Function returning Long
FMTK_Inited_ =000000    -    External    Long
E_BadDevNum_ =000020    -    Constant    Long
KeybdClearRcv_ =000000    -    External    Function returning Long
missed_ticks_ =000000    -    External    Long
KeybdGetBufferedCharNoWait_ =002480    -    Global      Function returning Char
E_BadCallno_ =000003    -    Constant    Long
E_BadPriority_ =000002    -    Constant    Long
chkTCB_    =001480    -    Global      Function returning Long
GetRunningTCBPtr_ =001480    -    External    Function returning Pointer to struct _tagTCB_ 
UnlockSemaphore_ =001480    -    Global      Function returning 
E_NoMoreMbx_ =000040    -    Constant    Long
GetVecno_  =001480    -    External    Function returning Long
E_QueStrategy_ =00000d    -    Constant    Long
GetJCBPtr_ =001480    -    External    Function returning Pointer to struct _tagJCB_ 
video_bufs_ =000000    -    External    Array of Array of Short
getCPU_    =001480    -    External    Function returning Long
E_ReadError_ =000023    -    Constant    Long
hasUltraHighPriorityTasks_ =000000    -    External    Char
LockSemaphore_ =001480    -    Global      Function returning Long
keybdExtendedCodes_ =000000    -    External    Array of Byte
iof_switch_ =000000    -    External    Long
keybd_irq_stack_ =001480    -    Global      Array of 
KeybdGetScancode_ =000000    -    External    Function returning Long
hJCB_      =00000a    1   Byte
nMailbox_  =000000    -    External    Long
unshiftedScanCodes_ =000000    -    External    Array of Byte
set_vector_ =001480    -    Global      Function returning 
E_NoMoreTCBs_ =000043    -    Constant    Long
hTCB_      =000008    1   Char
iof_sema_  =000000    -    External    Long
KeybdGetBufferedCharWait_ =002480    -    Global      Function returning Char
sys_stacks_ =000000    -    External    Array of Array of Long
BIOS_RespMbx_ =000000    -    External    Long
hMBX_      =00000c    1   Char
hMSG_      =00000e    1   Char
E_DCBInUse_ =00000e    -    Constant    Long
KeybdGetBufferedScancode_ =002480    -    Global      Function returning Long
shiftedScanCodes_ =000000    -    External    Array of Byte
E_Ok_      =000000    -    Constant    Long
E_QueFull_ =000006    -    Constant    Long
BIOS1_sema_ =000000    -    External    Long
sys_sema_  =000000    -    External    Long
readyQ_    =000000    -    External    Array of Char
E_NoMoreAlarmBlks_ =000042    -    Constant    Long
ALARM_     =001440    1   struct tagALARM_ 
sysstack_  =000000    -    External    Array of Long
freeTCB_   =000000    -    External    Char
E_NoDev_   =000021    -    Constant    Long
E_NoMem_   =000044    -    Constant    Long
TimeoutList_ =000000    -    External    Char
RemoveFromTimeoutList_ =001480    -    Global      Function returning Long
E_NoMsg_   =000009    -    Constant    Long
E_BadDevOp_ =000022    -    Constant    Long
stacks_    =000000    -    External    Array of Array of Long
freeMSG_   =000000    -    External    Char
freeMBX_   =000000    -    External    Char
SetBound50_ =001480    -    Global      Function returning 
SetBound51_ =001480    -    Global      Function returning 
E_Timeout_ =00000a    -    Constant    Long
SetBound48_ =001480    -    Global      Function returning 
SetBound49_ =001480    -    Global      Function returning 
InsertIntoTimeoutList_ =001480    -    Global      Function returning Long
RemoveFromReadyList_ =001480    -    Global      Function returning Long
KeybdGetStatus_ =000000    -    External    Function returning Long
bios_stacks_ =000000    -    External    Array of Array of Long
E_BadAlarm_ =00000b    -    Constant    Long
InsertIntoReadyList_ =001480    -    Global      Function returning Long

 *** structures and unions ***

tagMSG_    =000000    -    Type        struct tagMSG_ 
    link_      =000000    -    Member      
    retadr_    =000002    -    Member      
    tgtadr_    =000004    -    Member      
    type_      =000006    -    Member      
    d1_        =000008    -    Member      
    d2_        =000010    -    Member      
    d3_        =000018    -    Member      
_tagJCB_   =000000    -    Type        struct _tagJCB_ 
    iof_next_  =000000    -    Member      Pointer to struct _tagJCB_ 
    iof_prev_  =000008    -    Member      Pointer to struct _tagJCB_ 
    UserName_  =000010    -    Member      Array of Char
    path_      =000050    -    Member      Array of Char
    exitRunFile_ =000250    -    Member      Array of Char
    commandLine_ =000450    -    Member      Array of Char
    pVidMem_   =000650    -    Member      Pointer to 
    pVirtVidMem_ =000658    -    Member      Pointer to 
    VideoRows_ =000660    -    Member      
    VideoCols_ =000662    -    Member      
    CursorRow_ =000664    -    Member      
    CursorCol_ =000666    -    Member      
    NormAttr_  =000668    -    Member      
    KeyState1_ =00066c    -    Member      Byte
    KeyState2_ =00066d    -    Member      Byte
    KeybdWaitFlag_ =00066e    -    Member      Byte
    KeybdHead_ =00066f    -    Member      Byte
    KeybdTail_ =000670    -    Member      Byte
    KeybdBuffer_ =000672    -    Member      Array of 
    number_    =000692    -    Member      Byte
tagMBX_    =000000    -    Type        struct tagMBX_ 
    link_      =000000    -    Member      Char
    owner_     =000002    -    Member      Byte
    tq_head_   =000004    -    Member      Char
    tq_tail_   =000006    -    Member      Char
    mq_head_   =000008    -    Member      Char
    mq_tail_   =00000a    -    Member      Char
    mq_strategy_ =00000c    -    Member      Char
    resv_      =00000e    -    Member      Array of Byte
    tq_count_  =000010    -    Member      
    mq_size_   =000018    -    Member      
    mq_count_  =000020    -    Member      
    mq_missed_ =000028    -    Member      
_tagTCB_   =000000    -    Type        struct _tagTCB_ 
    regs_      =000000    -    Member      Array of Long
    isp_       =000100    -    Member      Long
    dsp_       =000108    -    Member      Long
    esp_       =000110    -    Member      Long
    ipc_       =000118    -    Member      Long
    dpc_       =000120    -    Member      Long
    epc_       =000128    -    Member      Long
    cr0_       =000130    -    Member      Long
    iregs_     =000138    -    Member      Array of Long
    iisp_      =000238    -    Member      Long
    idsp_      =000240    -    Member      Long
    iesp_      =000248    -    Member      Long
    iipc_      =000250    -    Member      Long
    idpc_      =000258    -    Member      Long
    iepc_      =000260    -    Member      Long
    icr0_      =000268    -    Member      Long
    next_      =000270    -    Member      Char
    prev_      =000272    -    Member      Char
    mbq_next_  =000274    -    Member      Char
    mbq_prev_  =000276    -    Member      Char
    sys_stack_ =000278    -    Member      Pointer to Long
    bios_stack_ =000280    -    Member      Pointer to Long
    stack_     =000288    -    Member      Pointer to Long
    timeout_   =000290    -    Member      Long
    msg_       =0002a0    -    Member      struct tagMSG_ 
    hMailboxes_ =0002c0    -    Member      Array of Char
    hWaitMbx_  =0002c8    -    Member      Char
    number_    =0002ca    -    Member      Char
    priority_  =0002cc    -    Member      Byte
    status_    =0002cd    -    Member      Byte
    affinity_  =0002ce    -    Member      Byte
    hJob_      =0002cf    -    Member      Byte
    startTick_ =0002d0    -    Member      Long
    endTick_   =0002d8    -    Member      Long
    ticks_     =0002e0    -    Member      Long
tagALARM_  =000000    -    Type        struct tagALARM_ 
    next_      =000000    -    Member      Pointer to struct tagALARM_ 
    prev_      =000008    -    Member      Pointer to struct tagALARM_ 
    mbx_       =000010    -    Member      Pointer to struct tagMBX_ 
    msg_       =000018    -    Member      Pointer to struct tagMSG_ 
    BaseTimeout_ =000020    -    Member      
    timeout_   =000028    -    Member      
    repeat_    =000030    -    Member      
    resv_      =000038    -    Member      Array of Byte
