     1	// ============================================================================
     2	//        __
     3	//   \\__/ o\    (C) 2012-2015  Robert Finch, Stratford
     4	//    \  __ /    All rights reserved.
     5	//     \/_//     robfinch<remove>@finitron.ca
     6	//       ||
     7	//
     8	// TCB.c
     9	// Task Control Block related functions.
    10	//
    11	// This source file is free software: you can redistribute it and/or modify 
    12	// it under the terms of the GNU Lesser General Public License as published 
    13	// by the Free Software Foundation, either version 3 of the License, or     
    14	// (at your option) any later version.                                      
    15	//                                                                          
    16	// This source file is distributed in the hope that it will be useful,      
    17	// but WITHOUT ANY WARRANTY; without even the implied warranty of           
    18	// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
    19	// GNU General Public License for more details.                             
    20	//                                                                          
    21	// You should have received a copy of the GNU General Public License        
    22	// along with this program.  If not, see <http://www.gnu.org/licenses/>.    
    23	//                                                                          
    24	// ============================================================================
    25	//
    26	
    27	
    28	
    29	
    30	
    31	
    32	// message types
    33	
    34	enum {
    35	     E_Ok = 0,
    36	     E_BadTCBHandle,
    37	     E_BadPriority,
    38	     E_BadCallno,
    39	     E_Arg,
    40	     E_BadMbx,
    41	     E_QueFull,
    42	     E_NoThread,
    43	     E_NotAlloc,
    44	     E_NoMsg,
    45	     E_Timeout,
    46	     E_BadAlarm,
    47	     E_NotOwner,
    48	     E_QueStrategy,
    49	     E_DCBInUse,
    50	     //; Device driver errors
    51	     E_BadDevNum =	0x20,
    52	     E_NoDev,
    53	     E_BadDevOp,
    54	     E_ReadError,
    55	     E_WriteError,
    56	     E_BadBlockNum,
    57	     E_TooManyBlocks,
    58	
    59	     // resource errors
    60	     E_NoMoreMbx =	0x40,
    61	     E_NoMoreMsgBlks,
    62	     E_NoMoreAlarmBlks,
    63	     E_NoMoreTCBs,
    64	     E_NoMem
    65	};
    66	
    67	
    68	typedef unsigned int uint;
    69	typedef __int16 hTCB;
    70	typedef __int8 hJCB;
    71	typedef __int16 hMBX;
    72	typedef __int16 hMSG;
    73	
    74	typedef struct tagMSG align(32) {
    75		unsigned __int16 link;
    76		unsigned __int16 retadr;    // return address
    77		unsigned __int16 tgtadr;    // target address
    78		unsigned __int16 type;
    79		unsigned int d1;            // payload data 1
    80		unsigned int d2;            // payload data 2
    81		unsigned int d3;            // payload data 3
    82	} MSG;
    83	
    84	typedef struct _tagJCB align(2048)
    85	{
    86	    struct _tagJCB *iof_next;
    87	    struct _tagJCB *iof_prev;
    88	    char UserName[32];
    89	    char path[256];
    90	    char exitRunFile[256];
    91	    char commandLine[256];
    92	    unsigned __int32 *pVidMem;
    93	    unsigned __int32 *pVirtVidMem;
    94	    unsigned __int16 VideoRows;
    95	    unsigned __int16 VideoCols;
    96	    unsigned __int16 CursorRow;
    97	    unsigned __int16 CursorCol;
    98	    unsigned __int32 NormAttr;
    99	    __int8 KeyState1;
   100	    __int8 KeyState2;
   101	    __int8 KeybdWaitFlag;
   102	    __int8 KeybdHead;
   103	    __int8 KeybdTail;
   104	    unsigned __int16 KeybdBuffer[16];
   105	    hJCB number;
   106	} JCB;
   107	
   108	struct tagMBX;
   109	
   110	typedef struct _tagTCB align(1024) {
   111	    // exception storage area
   112		int regs[32];
   113		int isp;
   114		int dsp;
   115		int esp;
   116		int ipc;
   117		int dpc;
   118		int epc;
   119		int cr0;
   120		// interrupt storage
   121		int iregs[32];
   122		int iisp;
   123		int idsp;
   124		int iesp;
   125		int iipc;
   126		int idpc;
   127		int iepc;
   128		int icr0;
   129		hTCB next;
   130		hTCB prev;
   131		hTCB mbq_next;
   132		hTCB mbq_prev;
   133		int *sys_stack;
   134		int *bios_stack;
   135		int *stack;
   136		__int64 timeout;
   137		MSG msg;
   138		hMBX hMailboxes[4]; // handles of mailboxes owned by task
   139		hMBX hWaitMbx;      // handle of mailbox task is waiting at
   140		hTCB number;
   141		__int8 priority;
   142		__int8 status;
   143		__int8 affinity;
   144		hJCB hJob;
   145		__int64 startTick;
   146		__int64 endTick;
   147		__int64 ticks;
   148	} TCB;
   149	
   150	typedef struct tagMBX align(64) {
   151	    hMBX link;
   152		hJCB owner;		// hJcb of owner
   153		hTCB tq_head;
   154		hTCB tq_tail;
   155		hMSG mq_head;
   156		hMSG mq_tail;
   157		char mq_strategy;
   158		byte resv[2];
   159		uint tq_count;
   160		uint mq_size;
   161		uint mq_count;
   162		uint mq_missed;
   163	} MBX;
   164	
   165	typedef struct tagALARM {
   166		struct tagALARM *next;
   167		struct tagALARM *prev;
   168		MBX *mbx;
   169		MSG *msg;
   170		uint BaseTimeout;
   171		uint timeout;
   172		uint repeat;
   173		byte resv[8];		// padding to 64 bytes
   174	} ALARM;
   175	
   176	
   177	// ============================================================================
   178	//        __
   179	//   \\__/ o\    (C) 2012-2015  Robert Finch, Stratford
   180	//    \  __ /    All rights reserved.
   181	//     \/_//     robfinch<remove>@finitron.ca
   182	//       ||
   183	//
   184	// TCB.c
   185	// Task Control Block related functions.
   186	//
   187	// This source file is free software: you can redistribute it and/or modify 
   188	// it under the terms of the GNU Lesser General Public License as published 
   189	// by the Free Software Foundation, either version 3 of the License, or     
   190	// (at your option) any later version.                                      
   191	//                                                                          
   192	// This source file is distributed in the hope that it will be useful,      
   193	// but WITHOUT ANY WARRANTY; without even the implied warranty of           
   194	// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
   195	// GNU General Public License for more details.                             
   196	//                                                                          
   197	// You should have received a copy of the GNU General Public License        
   198	// along with this program.  If not, see <http://www.gnu.org/licenses/>.    
   199	//                                                                          
   200	// ============================================================================
   201	//
   202	// JCB functions
   203	JCB *GetJCBPtr();                   // get the JCB pointer of the running task
   204	
   205	// TCB functions
   206	TCB *GetRunningTCBPtr();
   207	hTCB GetRunningTCB();
   208	pascal void SetRunningTCB(hTCB ht);
   209	pascal int chkTCB(TCB *p);
   210	pascal int InsertIntoReadyList(hTCB ht);
   211	pascal int RemoveFromReadyList(hTCB ht);
   212	pascal int InsertIntoTimeoutList(hTCB ht, int to);
   213	pascal int RemoveFromTimeoutList(hTCB ht);
   214	void DumpTaskList();
   215	
   216	pascal void SetBound48(TCB *ps, TCB *pe, int algn);
   217	pascal void SetBound49(JCB *ps, JCB *pe, int algn);
   218	pascal void SetBound50(MBX *ps, MBX *pe, int algn);
   219	pascal void SetBound51(MSG *ps, MSG *pe, int algn);
   220	
   221	void set_vector(unsigned int, unsigned int);
   222	int getCPU();
   223	int GetVecno();          // get the last interrupt vector number
   224	void outb(unsigned int, int);
   225	void outc(unsigned int, int);
   226	void outh(unsigned int, int);
   227	void outw(unsigned int, int);
   228	pascal int LockSemaphore(int *sema, int retries);
   229	pascal void UnlockSemaphore(int *sema);
   230	
   231	// The following causes a privilege violation if called from user mode
   232	
   233	
   234	extern char hasUltraHighPriorityTasks;
   235	
   236	TCB tcbs[256];
   237	hTCB freeTCB;
   238	hTCB TimeoutList;
   239	hTCB readyQ[8];
   240	
   241	pascal int chkTCB(TCB *p)
   242	{
   243	    asm {
   244	        lw    r1,24[bp]
   245	        chk   r1,r1,b48
   246	    }
   247	}
   248	


*** local symbol table ***

p_         =000018    -    Auto        Pointer to struct _tagTCB_ 



   249	naked TCB *GetRunningTCBPtr()
   250	{
   251	    asm {
   252	        mov   r1,tr
   253	        rtl
   254	    }
   255	}
   256	


*** local symbol table ***




   257	naked hTCB GetRunningTCB()
   258	{
   259	    asm {
   260	        subui  r1,tr,#tcbs_
   261	        lsri   r1,r1,#10
   262	        rtl
   263	    }
   264	}
   265	


*** local symbol table ***




   266	pascal void SetRunningTCB(hTCB ht)
   267	{
   268	     asm {
   269	         lw      tr,24[bp]
   270	         asli    tr,tr,#10
   271	         addui   tr,tr,#tcbs_
   272	     }
   273	}
   274	
   275	// ----------------------------------------------------------------------------
   276	// ----------------------------------------------------------------------------
   277	


*** local symbol table ***

ht_        =000018    -    Auto        Char



   278	pascal int InsertIntoReadyList(hTCB ht)
   279	{
   280	    hTCB hq;
   281	    TCB *p, *q;
   282	
   283	    __check(ht >=0 && ht < 256);
   284	    p = &tcbs[ht];
   285		if (p->priority > 077 || p->priority < 000)
   286			return E_BadPriority;
   287		if (p->priority < 003)
   288		   hasUltraHighPriorityTasks |= (1 << p->priority);
   289		p->status = 16;
   290		hq = readyQ[p->priority>>3];
   291		// Ready list empty ?
   292		if (hq<0) {
   293			p->next = ht;
   294			p->prev = ht;
   295			readyQ[p->priority>>3] = ht;
   296			return E_Ok;
   297		}
   298		// Insert at tail of list
   299		q = &tcbs[hq];
   300		p->next = hq;
   301		p->prev = q->prev;
   302		tcbs[q->prev].next = ht;
   303		q->prev = ht;
   304		return E_Ok;
   305	}
   306	
   307	// ----------------------------------------------------------------------------
   308	// ----------------------------------------------------------------------------
   309	


*** local symbol table ***

ht_        =000018    -    Auto        Char
hq_        =fffffffe    -    Auto        Char
p_         =fffffff0    -    Auto        Pointer to struct _tagTCB_ 
q_         =ffffffe8    -    Auto        Pointer to struct _tagTCB_ 



   310	pascal int RemoveFromReadyList(hTCB ht)
   311	{
   312	    TCB *t;
   313	
   314	    __check(ht >=0 && ht < 256);
   315	    t = &tcbs[ht];
   316		if (t->priority > 077 || t->priority < 000)
   317			return E_BadPriority;
   318	    if (ht==readyQ[t->priority>>3])
   319	       readyQ[t->priority>>3] = t->next;
   320	    if (ht==readyQ[t->priority>>3])
   321	       readyQ[t->priority>>3] = -1;
   322	    tcbs[t->next].prev = t->prev;
   323	    tcbs[t->prev].next = t->next;
   324	    t->next = -1;
   325	    t->prev = -1;
   326	    t->status = 0;
   327	    return E_Ok;
   328	}
   329	
   330	
   331	// ----------------------------------------------------------------------------
   332	// ----------------------------------------------------------------------------
   333	


*** local symbol table ***

ht_        =000018    -    Auto        Char
t_         =fffffff8    -    Auto        Pointer to struct _tagTCB_ 



   334	pascal int InsertIntoTimeoutList(hTCB ht, int to)
   335	{
   336	    TCB *p, *q, *t;
   337	
   338	    __check(ht >=0 && ht < 256);
   339	    t = &tcbs[ht];
   340	    if (TimeoutList<0) {
   341	        t->timeout = to;
   342	        TimeoutList = ht;
   343	        t->next = -1;
   344	        t->prev = -1;
   345	        return E_Ok;
   346	    }
   347	    q = (void *)0;
   348	    p = &tcbs[TimeoutList];
   349	    while (to > p->timeout) {
   350	        to -= p->timeout;
   351	        q = p;
   352	        p = &tcbs[p->next];
   353	    }
   354	    t->next = p - tcbs;
   355	    t->prev = q - tcbs;
   356	    if (p) {
   357	        p->timeout -= to;
   358	        p->prev = ht;
   359	    }
   360	    if (q)
   361	        q->next = ht;
   362	    else
   363	        TimeoutList = ht;
   364	    t->status |= 1;
   365	    return E_Ok;


*** local symbol table ***

ht_        =000018    -    Auto        Char
to_        =000020    -    Auto        Long
p_         =fffffff8    -    Auto        Pointer to struct _tagTCB_ 
q_         =fffffff0    -    Auto        Pointer to struct _tagTCB_ 
t_         =ffffffe8    -    Auto        Pointer to struct _tagTCB_ 



   366	};
   367	
   368	// ----------------------------------------------------------------------------
   369	// ----------------------------------------------------------------------------
   370	
   371	pascal int RemoveFromTimeoutList(hTCB ht)
   372	{
   373	    TCB *t;
   374	    
   375	    __check(ht >=0 && ht < 256);
   376	    t = &tcbs[ht];
   377	    if (t->next) {
   378	       tcbs[t->next].prev = t->prev;
   379	       tcbs[t->next].timeout += t->timeout;
   380	    }
   381	    if (t->prev >= 0)
   382	       tcbs[t->prev].next = t->next;
   383	    t->status = 0;
   384	    t->next = -1;
   385	    t->prev = -1;
   386	}
   387	
   388	// ----------------------------------------------------------------------------
   389	// Pop the top entry from the timeout list.
   390	// ----------------------------------------------------------------------------
   391	


*** local symbol table ***

ht_        =000018    -    Auto        Char
t_         =fffffff8    -    Auto        Pointer to struct _tagTCB_ 



   392	hTCB PopTimeoutList()
   393	{
   394	    TCB *p;
   395	    hTCB h;
   396	
   397	    h = TimeoutList;
   398	    if (TimeoutList >= 0 && TimeoutList < 256) {
   399	        TimeoutList = tcbs[TimeoutList].next;
   400	        if (TimeoutList >= 0 && TimeoutList < 256)
   401	            tcbs[TimeoutList].prev = -1;
   402	    }
   403	    return h;
   404	}
   405	
   406	// ----------------------------------------------------------------------------
   407	// ----------------------------------------------------------------------------
   408	


*** local symbol table ***

p_         =fffffff8    -    Auto        Pointer to struct _tagTCB_ 
h_         =fffffff6    -    Auto        Char



   409	void DumpTaskList()
   410	{
   411	     TCB *p, *q;
   412	     int n;
   413	     int kk;
   414	     hTCB h, j;
   415	
   416	     printf("CPU Pri Stat Task Prev Next Timeout\r\n");
   417	     for (n = 0; n < 8; n++) {
   418	         h = readyQ[n];
   419	         if (h >= 0 && h < 256) {
   420	             q = &tcbs[h];
   421	             p = q;
   422	             kk = 0;
   423	             do {
   424	//                 if (!chkTCB(p)) {
   425	//                     printf("Bad TCB (%X)\r\n", p);
   426	//                     break;
   427	//                 }
   428	                   j = p - tcbs;
   429	                 printf("%3d %3d  %02X  %04X %04X %04X %08X %08X\r\n", p->affinity, p->priority, p->status, (int)j, p->prev, p->ne   430	xt, p->timeout, p->ticks);
   431	                 if (p->next < 0 || p->next >= 256)
   432	                     break;
   433	                 p = &tcbs[p->next];
   434	                 if (getcharNoWait()==3)
   435	                    goto j1;
   436	                 kk = kk + 1;
   437	             } while (p != q && kk < 10);
   438	         }
   439	     }
   440	j1:  ;
   441	}
   442	
   443	


*** local symbol table ***

j1_        =000032    -    Label
p_         =fffffff8    -    Auto        Pointer to struct _tagTCB_ 
q_         =fffffff0    -    Auto        Pointer to struct _tagTCB_ 
n_         =ffffffe8    -    Auto        Long
kk_        =ffffffe0    -    Auto        Long
h_         =ffffffde    -    Auto        Char
j_         =ffffffdc    -    Auto        Char




 *** global scope typedef symbol table ***

E_NoMoreMsgBlks_ =000041    -    Constant    Long
tcbs_      =001800    -    Global      Array of struct _tagTCB_ 
PopTimeoutList_ =041814    -    Global      Function returning Char
E_NoThread_ =000007    -    Constant    Long
E_WriteError_ =000024    -    Constant    Long
outb_      =001480    -    Global      Function returning 
outc_      =001480    -    Global      Function returning 
E_Arg_     =000004    -    Constant    Long
E_NotAlloc_ =000008    -    Constant    Long
uint_      =000000    1   
outh_      =001480    -    Global      Function returning 
DumpTaskList_ =041814    -    Global      Function returning 
E_BadBlockNum_ =000025    -    Constant    Long
E_TooManyBlocks_ =000026    -    Constant    Long
JCB_       =000800    1   struct _tagJCB_ 
outw_      =001480    -    Global      Function returning 
E_BadTCBHandle_ =000001    -    Constant    Long
E_BadMbx_  =000005    -    Constant    Long
TCB_       =001000    1   struct _tagTCB_ 
GetRunningTCB_ =041814    -    Global      Function returning Char
E_NotOwner_ =00000c    -    Constant    Long
SetRunningTCB_ =001480    -    Global      Function returning 
MSG_       =000020    1   struct tagMSG_ 
MBX_       =001400    1   struct tagMBX_ 
E_BadDevNum_ =000020    -    Constant    Long
E_BadCallno_ =000003    -    Constant    Long
E_BadPriority_ =000002    -    Constant    Long
chkTCB_    =001480    -    Global      Function returning Long
GetRunningTCBPtr_ =041814    -    Global      Function returning Pointer to struct _tagTCB_ 
UnlockSemaphore_ =001480    -    Global      Function returning 
E_NoMoreMbx_ =000040    -    Constant    Long
GetVecno_  =001480    -    External    Function returning Long
E_QueStrategy_ =00000d    -    Constant    Long
GetJCBPtr_ =001480    -    External    Function returning Pointer to struct _tagJCB_ 
getCPU_    =001480    -    External    Function returning Long
E_ReadError_ =000023    -    Constant    Long
hasUltraHighPriorityTasks_ =000000    -    External    Char
LockSemaphore_ =001480    -    Global      Function returning Long
getcharNoWait_ =000000    -    External    Function returning Long
hJCB_      =00000a    1   Byte
set_vector_ =001480    -    Global      Function returning 
E_NoMoreTCBs_ =000043    -    Constant    Long
hTCB_      =000008    1   Char
hMBX_      =00000c    1   Char
hMSG_      =00000e    1   Char
E_DCBInUse_ =00000e    -    Constant    Long
E_Ok_      =000000    -    Constant    Long
E_QueFull_ =000006    -    Constant    Long
readyQ_    =041804    -    Global      Array of Char
E_NoMoreAlarmBlks_ =000042    -    Constant    Long
ALARM_     =001440    1   struct tagALARM_ 
freeTCB_   =041800    -    Global      Char
E_NoDev_   =000021    -    Constant    Long
E_NoMem_   =000044    -    Constant    Long
TimeoutList_ =041802    -    Global      Char
RemoveFromTimeoutList_ =001480    -    Global      Function returning Long
E_NoMsg_   =000009    -    Constant    Long
E_BadDevOp_ =000022    -    Constant    Long
SetBound50_ =001480    -    Global      Function returning 
SetBound51_ =001480    -    Global      Function returning 
E_Timeout_ =00000a    -    Constant    Long
SetBound48_ =001480    -    Global      Function returning 
SetBound49_ =001480    -    Global      Function returning 
InsertIntoTimeoutList_ =001480    -    Global      Function returning Long
RemoveFromReadyList_ =001480    -    Global      Function returning Long
printf_    =000000    -    External    Function returning Long
E_BadAlarm_ =00000b    -    Constant    Long
InsertIntoReadyList_ =001480    -    Global      Function returning Long

 *** structures and unions ***

tagMSG_    =000000    -    Type        struct tagMSG_ 
    link_      =000000    -    Member      
    retadr_    =000002    -    Member      
    tgtadr_    =000004    -    Member      
    type_      =000006    -    Member      
    d1_        =000008    -    Member      
    d2_        =000010    -    Member      
    d3_        =000018    -    Member      
_tagJCB_   =000000    -    Type        struct _tagJCB_ 
    iof_next_  =000000    -    Member      Pointer to struct _tagJCB_ 
    iof_prev_  =000008    -    Member      Pointer to struct _tagJCB_ 
    UserName_  =000010    -    Member      Array of Char
    path_      =000050    -    Member      Array of Char
    exitRunFile_ =000250    -    Member      Array of Char
    commandLine_ =000450    -    Member      Array of Char
    pVidMem_   =000650    -    Member      Pointer to 
    pVirtVidMem_ =000658    -    Member      Pointer to 
    VideoRows_ =000660    -    Member      
    VideoCols_ =000662    -    Member      
    CursorRow_ =000664    -    Member      
    CursorCol_ =000666    -    Member      
    NormAttr_  =000668    -    Member      
    KeyState1_ =00066c    -    Member      Byte
    KeyState2_ =00066d    -    Member      Byte
    KeybdWaitFlag_ =00066e    -    Member      Byte
    KeybdHead_ =00066f    -    Member      Byte
    KeybdTail_ =000670    -    Member      Byte
    KeybdBuffer_ =000672    -    Member      Array of 
    number_    =000692    -    Member      Byte
tagMBX_    =000000    -    Type        struct tagMBX_ 
    link_      =000000    -    Member      Char
    owner_     =000002    -    Member      Byte
    tq_head_   =000004    -    Member      Char
    tq_tail_   =000006    -    Member      Char
    mq_head_   =000008    -    Member      Char
    mq_tail_   =00000a    -    Member      Char
    mq_strategy_ =00000c    -    Member      Char
    resv_      =00000e    -    Member      Array of Byte
    tq_count_  =000010    -    Member      
    mq_size_   =000018    -    Member      
    mq_count_  =000020    -    Member      
    mq_missed_ =000028    -    Member      
_tagTCB_   =000000    -    Type        struct _tagTCB_ 
    regs_      =000000    -    Member      Array of Long
    isp_       =000100    -    Member      Long
    dsp_       =000108    -    Member      Long
    esp_       =000110    -    Member      Long
    ipc_       =000118    -    Member      Long
    dpc_       =000120    -    Member      Long
    epc_       =000128    -    Member      Long
    cr0_       =000130    -    Member      Long
    iregs_     =000138    -    Member      Array of Long
    iisp_      =000238    -    Member      Long
    idsp_      =000240    -    Member      Long
    iesp_      =000248    -    Member      Long
    iipc_      =000250    -    Member      Long
    idpc_      =000258    -    Member      Long
    iepc_      =000260    -    Member      Long
    icr0_      =000268    -    Member      Long
    next_      =000270    -    Member      Char
    prev_      =000272    -    Member      Char
    mbq_next_  =000274    -    Member      Char
    mbq_prev_  =000276    -    Member      Char
    sys_stack_ =000278    -    Member      Pointer to Long
    bios_stack_ =000280    -    Member      Pointer to Long
    stack_     =000288    -    Member      Pointer to Long
    timeout_   =000290    -    Member      Long
    msg_       =0002a0    -    Member      struct tagMSG_ 
    hMailboxes_ =0002c0    -    Member      Array of Char
    hWaitMbx_  =0002c8    -    Member      Char
    number_    =0002ca    -    Member      Char
    priority_  =0002cc    -    Member      Byte
    status_    =0002cd    -    Member      Byte
    affinity_  =0002ce    -    Member      Byte
    hJob_      =0002cf    -    Member      Byte
    startTick_ =0002d0    -    Member      Long
    endTick_   =0002d8    -    Member      Long
    ticks_     =0002e0    -    Member      Long
tagALARM_  =000000    -    Type        struct tagALARM_ 
    next_      =000000    -    Member      Pointer to struct tagALARM_ 
    prev_      =000008    -    Member      Pointer to struct tagALARM_ 
    mbx_       =000010    -    Member      Pointer to struct tagMBX_ 
    msg_       =000018    -    Member      Pointer to struct tagMSG_ 
    BaseTimeout_ =000020    -    Member      
    timeout_   =000028    -    Member      
    repeat_    =000030    -    Member      
    resv_      =000038    -    Member      Array of Byte
