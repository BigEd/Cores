     1	// ============================================================================
     2	//        __
     3	//   \\__/ o\    (C) 2012-2015  Robert Finch, Stratford
     4	//    \  __ /    All rights reserved.
     5	//     \/_//     robfinch<remove>@finitron.ca
     6	//       ||
     7	//
     8	//
     9	// This source file is free software: you can redistribute it and/or modify 
    10	// it under the terms of the GNU Lesser General Public License as published 
    11	// by the Free Software Foundation, either version 3 of the License, or     
    12	// (at your option) any later version.                                      
    13	//                                                                          
    14	// This source file is distributed in the hope that it will be useful,      
    15	// but WITHOUT ANY WARRANTY; without even the implied warranty of           
    16	// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
    17	// GNU General Public License for more details.                             
    18	//                                                                          
    19	// You should have received a copy of the GNU General Public License        
    20	// along with this program.  If not, see <http://www.gnu.org/licenses/>.    
    21	//                                                                          
    22	// ============================================================================
    23	//
    24	
    25	
    26	
    27	
    28	
    29	
    30	// message types
    31	
    32	enum {
    33	     E_Ok = 0,
    34	     E_BadTCBHandle,
    35	     E_BadPriority,
    36	     E_BadCallno,
    37	     E_Arg,
    38	     E_BadMbx,
    39	     E_QueFull,
    40	     E_NoThread,
    41	     E_NotAlloc,
    42	     E_NoMsg,
    43	     E_Timeout,
    44	     E_BadAlarm,
    45	     E_NotOwner,
    46	     E_QueStrategy,
    47	     E_DCBInUse,
    48	     //; Device driver errors
    49	     E_BadDevNum =	0x20,
    50	     E_NoDev,
    51	     E_BadDevOp,
    52	     E_ReadError,
    53	     E_WriteError,
    54	     E_BadBlockNum,
    55	     E_TooManyBlocks,
    56	
    57	     // resource errors
    58	     E_NoMoreMbx =	0x40,
    59	     E_NoMoreMsgBlks,
    60	     E_NoMoreAlarmBlks,
    61	     E_NoMoreTCBs,
    62	     E_NoMem,
    63	     E_TooManyTasks
    64	};
    65	
    66	
    67	typedef unsigned int uint;
    68	typedef __int16 hTCB;
    69	typedef __int8 hJCB;
    70	typedef __int16 hMBX;
    71	typedef __int16 hMSG;
    72	
    73	typedef struct tagMSG align(32) {
    74		unsigned __int16 link;
    75		unsigned __int16 retadr;    // return address
    76		unsigned __int16 tgtadr;    // target address
    77		unsigned __int16 type;
    78		unsigned int d1;            // payload data 1
    79		unsigned int d2;            // payload data 2
    80		unsigned int d3;            // payload data 3
    81	} MSG;
    82	
    83	typedef struct _tagJCB align(2048)
    84	{
    85	    struct _tagJCB *iof_next;
    86	    struct _tagJCB *iof_prev;
    87	    char UserName[32];
    88	    char path[256];
    89	    char exitRunFile[256];
    90	    char commandLine[256];
    91	    unsigned __int32 *pVidMem;
    92	    unsigned __int32 *pVirtVidMem;
    93	    unsigned __int16 VideoRows;
    94	    unsigned __int16 VideoCols;
    95	    unsigned __int16 CursorRow;
    96	    unsigned __int16 CursorCol;
    97	    unsigned __int32 NormAttr;
    98	    __int8 KeyState1;
    99	    __int8 KeyState2;
   100	    __int8 KeybdWaitFlag;
   101	    __int8 KeybdHead;
   102	    __int8 KeybdTail;
   103	    unsigned __int8 KeybdBuffer[32];
   104	    hJCB number;
   105	    hTCB tasks[8];
   106	    hJCB next;
   107	} JCB;
   108	
   109	struct tagMBX;
   110	
   111	typedef struct _tagTCB align(1024) {
   112	    // exception storage area
   113		int regs[32];
   114		int isp;
   115		int dsp;
   116		int esp;
   117		int ipc;
   118		int dpc;
   119		int epc;
   120		int cr0;
   121		// interrupt storage
   122		int iregs[32];
   123		int iisp;
   124		int idsp;
   125		int iesp;
   126		int iipc;
   127		int idpc;
   128		int iepc;
   129		int icr0;
   130		hTCB next;
   131		hTCB prev;
   132		hTCB mbq_next;
   133		hTCB mbq_prev;
   134		int *sys_stack;
   135		int *bios_stack;
   136		int *stack;
   137		__int64 timeout;
   138		MSG msg;
   139		hMBX hMailboxes[4]; // handles of mailboxes owned by task
   140		hMBX hWaitMbx;      // handle of mailbox task is waiting at
   141		hTCB number;
   142		__int8 priority;
   143		__int8 status;
   144		__int8 affinity;
   145		hJCB hJob;
   146		__int64 startTick;
   147		__int64 endTick;
   148		__int64 ticks;
   149		int exception;
   150	} TCB;
   151	
   152	typedef struct tagMBX align(64) {
   153	    hMBX link;
   154		hJCB owner;		// hJcb of owner
   155		hTCB tq_head;
   156		hTCB tq_tail;
   157		hMSG mq_head;
   158		hMSG mq_tail;
   159		char mq_strategy;
   160		byte resv[2];
   161		uint tq_count;
   162		uint mq_size;
   163		uint mq_count;
   164		uint mq_missed;
   165	} MBX;
   166	
   167	typedef struct tagALARM {
   168		struct tagALARM *next;
   169		struct tagALARM *prev;
   170		MBX *mbx;
   171		MSG *msg;
   172		uint BaseTimeout;
   173		uint timeout;
   174		uint repeat;
   175		byte resv[8];		// padding to 64 bytes
   176	} ALARM;
   177	
   178	
   179	// ============================================================================
   180	//        __
   181	//   \\__/ o\    (C) 2012-2015  Robert Finch, Stratford
   182	//    \  __ /    All rights reserved.
   183	//     \/_//     robfinch<remove>@finitron.ca
   184	//       ||
   185	//
   186	// TCB.c
   187	// Task Control Block related functions.
   188	//
   189	// This source file is free software: you can redistribute it and/or modify 
   190	// it under the terms of the GNU Lesser General Public License as published 
   191	// by the Free Software Foundation, either version 3 of the License, or     
   192	// (at your option) any later version.                                      
   193	//                                                                          
   194	// This source file is distributed in the hope that it will be useful,      
   195	// but WITHOUT ANY WARRANTY; without even the implied warranty of           
   196	// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            
   197	// GNU General Public License for more details.                             
   198	//                                                                          
   199	// You should have received a copy of the GNU General Public License        
   200	// along with this program.  If not, see <http://www.gnu.org/licenses/>.    
   201	//                                                                          
   202	// ============================================================================
   203	//
   204	// JCB functions
   205	JCB *GetJCBPtr();                   // get the JCB pointer of the running task
   206	
   207	// TCB functions
   208	TCB *GetRunningTCBPtr();
   209	hTCB GetRunningTCB();
   210	pascal void SetRunningTCB(hTCB ht);
   211	pascal int chkTCB(TCB *p);
   212	pascal int InsertIntoReadyList(hTCB ht);
   213	pascal int RemoveFromReadyList(hTCB ht);
   214	pascal int InsertIntoTimeoutList(hTCB ht, int to);
   215	pascal int RemoveFromTimeoutList(hTCB ht);
   216	void DumpTaskList();
   217	
   218	pascal void SetBound48(TCB *ps, TCB *pe, int algn);
   219	pascal void SetBound49(JCB *ps, JCB *pe, int algn);
   220	pascal void SetBound50(MBX *ps, MBX *pe, int algn);
   221	pascal void SetBound51(MSG *ps, MSG *pe, int algn);
   222	
   223	pascal void set_vector(unsigned int, unsigned int);
   224	int getCPU();
   225	int GetVecno();          // get the last interrupt vector number
   226	void outb(unsigned int, int);
   227	void outc(unsigned int, int);
   228	void outh(unsigned int, int);
   229	void outw(unsigned int, int);
   230	pascal int LockSemaphore(int *sema, int retries);
   231	pascal void UnlockSemaphore(int *sema);
   232	
   233	// The following causes a privilege violation if called from user mode
   234	
   235	
   236	extern int irq_stack[];
   237	extern int FMTK_Inited;
   238	extern JCB jcbs[];
   239	extern TCB tcbs[];
   240	extern hTCB readyQ[];
   241	extern hTCB freeTCB;
   242	extern int sysstack[];
   243	extern int stacks[][];
   244	extern int sys_stacks[][];
   245	extern int bios_stacks[][];
   246	extern int fmtk_irq_stack[];
   247	extern int fmtk_sys_stack[];
   248	extern MBX mailbox[];
   249	extern MSG message[];
   250	extern int nMsgBlk;
   251	extern int nMailbox;
   252	extern hMSG freeMSG;
   253	extern hMBX freeMBX;
   254	extern JCB *IOFocusNdx;
   255	extern int IOFocusTbl[];
   256	extern int iof_switch;
   257	extern int BIOS1_sema;
   258	extern int iof_sema;
   259	extern int sys_sema;
   260	extern int kbd_sema;
   261	extern int BIOS_RespMbx;
   262	extern char hasUltraHighPriorityTasks;
   263	extern int missed_ticks;
   264	extern short int video_bufs[][];
   265	extern hTCB TimeoutList;
   266	
   267	
   268	extern int shell();
   269	
   270	int irq_stack[512];
   271	int sp_tmp;
   272	int FMTK_Inited;
   273	JCB jcbs[51];
   274	extern TCB tcbs[256];
   275	extern hTCB readyQ[8];
   276	int sysstack[1024];
   277	int stacks[256][1024];
   278	int sys_stacks[256][512];
   279	int bios_stacks[256][512];
   280	int fmtk_irq_stack[512];
   281	int fmtk_sys_stack[512];
   282	MBX mailbox[1024];
   283	MSG message[16384];
   284	int nMsgBlk;
   285	int nMailbox;
   286	hJCB freeJCB;
   287	hMSG freeMSG;
   288	hMBX freeMBX;
   289	JCB *IOFocusNdx;
   290	int IOFocusTbl[4];
   291	int iof_switch;
   292	int BIOS1_sema;
   293	int iof_sema;
   294	int sys_sema;
   295	int BIOS_RespMbx;
   296	char hasUltraHighPriorityTasks;
   297	int missed_ticks;
   298	
   299	short int video_bufs[51][4096];
   300	extern hTCB TimeoutList;
   301	
   302	// This table needed in case we want to call the OS routines directly.
   303	// It is also used by the system call interrupt as a vector table.
   304	
   305	naked void FMTK_BrTbl()
   306	{
   307	      asm {
   308	          bra  FMTKInitialize_
   309	          bra  FMTK_StartTask_
   310	          bra  FMTK_ExitTask_
   311	          bra  FMTK_KillTask_
   312	          bra  FMTK_SetTaskPriority_
   313	          bra  FMTK_Sleep_
   314	          bra  FMTK_AllocMbx_
   315	          bra  FMTK_FreeMbx_
   316	          bra  FMTK_PostMsg_
   317	          bra  FMTK_SendMsg_
   318	          bra  FMTK_WaitMsg_
   319	          bra  FMTK_CheckMsg_
   320	      }
   321	}
   322	


*** local symbol table ***




   323	naked int GetVecno()
   324	{
   325	    asm {
   326	        mfspr  r1,12
   327	        rtl
   328	    }
   329	}
   330	


*** local symbol table ***




   331	naked void DisplayIRQLive()
   332	{
   333	     asm {
   334	         lh       r1,$FFD00000+220
   335	         addui    r1,r1,#1
   336	         sh       r1,$FFD00000+220
   337	         rtl
   338	     }
   339	}
   340	


*** local symbol table ***




   341	JCB *GetJCBPtr()
   342	{
   343	    return &jcbs[tcbs[GetRunningTCB()].hJob];
   344	}
   345	
   346	
   347	// ----------------------------------------------------------------------------
   348	// Select a task to run.
   349	// ----------------------------------------------------------------------------
   350	


*** local symbol table ***




   351	private __int8 startQ[32] = { 0, 0, 0, 1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 1, 0, 4, 0, 0, 0, 5, 0, 0, 0, 6, 0, 1, 0, 7, 0, 0, 0, 0 };
   352	private __int8 startQNdx;
   353	
   354	private hTCB SelectTaskToRun()
   355	{
   356		int nn,kk;
   357		TCB *p, *q;
   358		int qToCheck;
   359	    hTCB h;
   360	 
   361		startQNdx++;
   362		startQNdx &= 31;
   363		qToCheck = startQ[startQNdx];
   364		qToCheck &= 7;
   365		for (nn = 0; nn < 8; nn++) {
   366			h = readyQ[qToCheck];
   367			if (h >= 0 && h < 256) {
   368	    		p = &tcbs[h];
   369	            kk = 0;
   370	            // Can run the head of a lower Q level if it's not the running
   371	            // task, otherwise look to the next task.
   372	            if (h != GetRunningTCB())
   373	           		q = p;
   374	    		else
   375	           		q = &tcbs[p->next];
   376	            do {  
   377	                if (!(q->status & 8)) {
   378	                    if (q->affinity == getCPU()) {
   379	        			   readyQ[qToCheck] = q - tcbs;
   380	        			   return q - tcbs;
   381	                    }
   382	                }
   383	                q = &tcbs[q->next];
   384	                kk = kk + 1;
   385	            } while (q != p && kk < 256);
   386	        }
   387			qToCheck++;
   388			qToCheck &= 7;
   389		}
   390		return GetRunningTCB();
   391		panic("No entries in ready queue.");
   392	}
   393	
   394	// ----------------------------------------------------------------------------
   395	// There isn't any 'C' code in the SystemCall() function. If there were it
   396	// would have to be arranged like the TimerIRQ() or RescheduleIRQ() functions.
   397	// ----------------------------------------------------------------------------
   398	


*** local symbol table ***

nn_        =fffffff8    -    Auto        Long
kk_        =fffffff0    -    Auto        Long
p_         =ffffffe8    -    Auto        Pointer to struct _tagTCB_ 
q_         =ffffffe0    -    Auto        Pointer to struct _tagTCB_ 
qToCheck_  =ffffffd8    -    Auto        Long
h_         =ffffffd6    -    Auto        Char



   399	naked FMTK_SystemCall()
   400	{
   401	    asm {
   402	         lea   sp,sys_stacks_[tr]
   403	         sw    r1,8[tr]
   404	         sw    r2,16[tr]
   405	         sw    r3,24[tr]
   406	         sw    r4,32[tr]
   407	         sw    r5,40[tr]
   408	         sw    r6,48[tr]
   409	         sw    r7,56[tr]
   410	         sw    r8,64[tr]
   411	         sw    r9,72[tr]
   412	         sw    r10,80[tr]
   413	         sw    r11,88[tr]
   414	         sw    r12,96[tr]
   415	         sw    r13,104[tr]
   416	         sw    r14,112[tr]
   417	         sw    r15,120[tr]
   418	         sw    r16,128[tr]
   419	         sw    r17,136[tr]
   420	         sw    r18,144[tr]
   421	         sw    r19,152[tr]
   422	         sw    r20,160[tr]
   423	         sw    r21,168[tr]
   424	         sw    r22,176[tr]
   425	         sw    r23,184[tr]
   426	         sw    r24,192[tr]
   427	         sw    r25,200[tr]
   428	         sw    r26,208[tr]
   429	         sw    r27,216[tr]
   430	         sw    r28,224[tr]
   431	         sw    r29,232[tr]
   432	         sw    r30,240[tr]
   433	         sw    r31,248[tr]
   434	         mfspr r1,isp
   435	         sw    r1,256[tr]
   436	         mfspr r1,dsp
   437	         sw    r1,264[tr]
   438	         mfspr r1,esp
   439	         sw    r1,272[tr]
   440	         mfspr r1,ipc
   441	         sw    r1,280[tr]
   442	         mfspr r1,dpc
   443	         sw    r1,288[tr]
   444	         mfspr r1,epc
   445	         sw    r1,296[tr]
   446	         mfspr r1,cr0
   447	         sw    r1,304[tr]
   448	
   449	    	 mfspr r6,epc           ; get return address into r6
   450	    	 and   r7,r6,#-4        ; clear LSB's
   451	    	 lh	   r7,4[r7]			; get static call number parameter into r7
   452	    	 addui r6,r6,#8		    ; update return address
   453	    	 sw    r6,296[tr]
   454	    	 cmpu  r6,r7,#20
   455	    	 bgt   r6,.bad_callno
   456	    	 asl   r7,r7,#2
   457	    	 lw    r1,8[tr]         ; get back r1, we trashed it above
   458	    	 push  r5
   459	    	 push  r4
   460	    	 push  r3
   461	    	 push  r2
   462	    	 push  r1
   463	    	 jsr   FMTK_BrTbl_[r7]	; do the system function
   464	    	 addui sp,sp,#40
   465	    	 sw    r1,8[tr]
   466	.0001:
   467	         lw    r1,256[tr]
   468	         mtspr isp,r1
   469	         lw    r1,264[tr]
   470	         mtspr dsp,r1
   471	         lw    r1,272[tr]
   472	         mtspr esp,r1
   473	         lw    r1,280[tr]
   474	         mtspr ipc,r1
   475	         lw    r1,288[tr]
   476	         mtspr dpc,r1
   477	         lw    r1,296[tr]
   478	         mtspr epc,r1
   479	         lw    r1,304[tr]
   480	         mtspr cr0,r1
   481	         lw    r1,8[tr]
   482	         lw    r2,16[tr]
   483	         lw    r3,24[tr]
   484	         lw    r4,32[tr]
   485	         lw    r5,40[tr]
   486	         lw    r6,48[tr]
   487	         lw    r7,56[tr]
   488	         lw    r8,64[tr]
   489	         lw    r9,72[tr]
   490	         lw    r10,80[tr]
   491	         lw    r11,88[tr]
   492	         lw    r12,96[tr]
   493	         lw    r13,104[tr]
   494	         lw    r14,112[tr]
   495	         lw    r15,120[tr]
   496	         lw    r16,128[tr]
   497	         lw    r17,136[tr]
   498	         lw    r18,144[tr]
   499	         lw    r19,152[tr]
   500	         lw    r20,160[tr]
   501	         lw    r21,168[tr]
   502	         lw    r22,176[tr]
   503	         lw    r23,184[tr]
   504	         lw    r25,200[tr]
   505	         lw    r26,208[tr]
   506	         lw    r27,216[tr]
   507	         lw    r28,224[tr]
   508	         lw    r29,232[tr]
   509	         lw    r31,248[tr]
   510	         rte
   511	.bad_callno:
   512	         ldi   r1,#E_BadFuncno
   513	         sw    r1,8[tr]
   514	         bra   .0001   
   515	    }
   516	}
   517	
   518	// ----------------------------------------------------------------------------
   519	// If timer interrupts are enabled during a priority #0 task, this routine
   520	// only updates the missed ticks and remains in the same task. No timeouts
   521	// are updated and no task switches will occur. The timer tick routine
   522	// basically has a fixed latency when priority #0 is present.
   523	// ----------------------------------------------------------------------------
   524	


*** local symbol table ***




   525	void FMTK_SchedulerIRQ()
   526	{
   527	     TCB *t;
   528	
   529	     prolog asm {
   530	         lea   sp,fmtk_irq_stack_+4088
   531	         sw    r1,8+312[tr]
   532	         sw    r2,16+312[tr]
   533	         sw    r3,24+312[tr]
   534	         sw    r4,32+312[tr]
   535	         sw    r5,40+312[tr]
   536	         sw    r6,48+312[tr]
   537	         sw    r7,56+312[tr]
   538	         sw    r8,64+312[tr]
   539	         sw    r9,72+312[tr]
   540	         sw    r10,80+312[tr]
   541	         sw    r11,88+312[tr]
   542	         sw    r12,96+312[tr]
   543	         sw    r13,104+312[tr]
   544	         sw    r14,112+312[tr]
   545	         sw    r15,120+312[tr]
   546	         sw    r16,128+312[tr]
   547	         sw    r17,136+312[tr]
   548	         sw    r18,144+312[tr]
   549	         sw    r19,152+312[tr]
   550	         sw    r20,160+312[tr]
   551	         sw    r21,168+312[tr]
   552	         sw    r22,176+312[tr]
   553	         sw    r23,184+312[tr]
   554	         sw    r24,192+312[tr]
   555	         sw    r25,200+312[tr]
   556	         sw    r26,208+312[tr]
   557	         sw    r27,216+312[tr]
   558	         sw    r28,224+312[tr]
   559	         sw    r29,232+312[tr]
   560	         sw    r30,240+312[tr]
   561	         sw    r31,248+312[tr]
   562	         mfspr r1,isp
   563	         sw    r1,256+312[tr]
   564	         mfspr r1,dsp
   565	         sw    r1,264+312[tr]
   566	         mfspr r1,esp
   567	         sw    r1,272+312[tr]
   568	         mfspr r1,ipc
   569	         sw    r1,280+312[tr]
   570	         mfspr r1,dpc
   571	         sw    r1,288+312[tr]
   572	         mfspr r1,epc
   573	         sw    r1,296+312[tr]
   574	         mfspr r1,cr0
   575	         sw    r1,304+312[tr]
   576	         mfspr r1,tick
   577	         sw    r1,$2D8[tr]
   578	     }
   579	     switch(GetVecno()) {
   580	     // Timer tick interrupt
   581	     case 451:
   582	          asm {
   583	             ldi   r1,#3				; reset the edge sense circuit
   584	             sh	   r1,PIC_RSTE
   585	         }
   586	         if (getCPU()==0) DisplayIRQLive();
   587	         if (ILockSemaphore(&sys_sema,10)) {
   588	             t = GetRunningTCBPtr();
   589	             t->ticks = t->ticks + (t->endTick - t->startTick);
   590	             if (t->priority != 000) {
   591	                 t->status = 4;
   592	                 while (TimeoutList >= 0 && TimeoutList < 256) {
   593	                     if (tcbs[TimeoutList].timeout<=0)
   594	                         InsertIntoReadyList(PopTimeoutList());
   595	                     else {
   596	                          tcbs[TimeoutList].timeout = tcbs[TimeoutList].timeout - missed_ticks - 1;
   597	                          missed_ticks = 0;
   598	                          break;
   599	                     }
   600	                 }
   601	                 if (t->priority > 002)
   602	                    SetRunningTCB(SelectTaskToRun());
   603	                 GetRunningTCBPtr()->status = 8;
   604	             }
   605	             else
   606	                 missed_ticks++;
   607	             UnlockSemaphore(&sys_sema);
   608	         }
   609	         else {
   610	             missed_ticks++;
   611	         }
   612	         break;
   613	     // Explicit rescheduling request.
   614	     case 2:
   615	         t = GetRunningTCBPtr();
   616	         t->ticks = t->ticks + (t->endTick - t->startTick);
   617	         t->status = 4;
   618	         t->iipc = t->iipc + 4;  // advance the return address
   619	         SetRunningTCB(SelectTaskToRun());
   620	         GetRunningTCBPtr()->status = 8;
   621	         break;
   622	     default:  ;
   623	     }
   624	     // If an exception was flagged (eg CTRL-C) return to the catch handler
   625	     // not the interrupted code.
   626	     t = GetRunningTCBPtr();
   627	     if (t->exception) {
   628	         t->iregs[31] = t->iregs[28];   // set link register to catch handler
   629	         t->iipc = t->iregs[28];        // and the PC register
   630	         t->iregs[1] = t->exception;    // r1 = exception value
   631	         t->exception = 0;
   632	         t->iregs[2] = 24;              // r2 = exception type
   633	     }
   634	     // Restore the processor registers and return using an RTI.
   635	     epilog asm {
   636	RestoreContext:
   637	         mfspr r1,tick
   638	         sw    r1,$2d0[tr]
   639	         lw    r1,256+312[tr]
   640	         mtspr isp,r1
   641	         lw    r1,264+312[tr]
   642	         mtspr dsp,r1
   643	         lw    r1,272+312[tr]
   644	         mtspr esp,r1
   645	         lw    r1,280+312[tr]
   646	         mtspr ipc,r1
   647	         lw    r1,288+312[tr]
   648	         mtspr dpc,r1
   649	         lw    r1,296+312[tr]
   650	         mtspr epc,r1
   651	         lw    r1,304+312[tr]
   652	         mtspr cr0,r1
   653	         lw    r1,8+312[tr]
   654	         lw    r2,16+312[tr]
   655	         lw    r3,24+312[tr]
   656	         lw    r4,32+312[tr]
   657	         lw    r5,40+312[tr]
   658	         lw    r6,48+312[tr]
   659	         lw    r7,56+312[tr]
   660	         lw    r8,64+312[tr]
   661	         lw    r9,72+312[tr]
   662	         lw    r10,80+312[tr]
   663	         lw    r11,88+312[tr]
   664	         lw    r12,96+312[tr]
   665	         lw    r13,104+312[tr]
   666	         lw    r14,112+312[tr]
   667	         lw    r15,120+312[tr]
   668	         lw    r16,128+312[tr]
   669	         lw    r17,136+312[tr]
   670	         lw    r18,144+312[tr]
   671	         lw    r19,152+312[tr]
   672	         lw    r20,160+312[tr]
   673	         lw    r21,168+312[tr]
   674	         lw    r22,176+312[tr]
   675	         lw    r23,184+312[tr]
   676	         lw    r25,200+312[tr]
   677	         lw    r26,208+312[tr]
   678	         lw    r27,216+312[tr]
   679	         lw    r28,224+312[tr]
   680	         lw    r29,232+312[tr]
   681	         lw    r31,248+312[tr]
   682	         rti
   683	     }
   684	}
   685	


*** local symbol table ***

t_         =fffffff8    -    Auto        Pointer to struct _tagTCB_ 



   686	void panic(char *msg)
   687	{
   688	     putstr(msg);
   689	j1:  goto j1;
   690	}
   691	
   692	// ----------------------------------------------------------------------------
   693	// ----------------------------------------------------------------------------
   694	


*** local symbol table ***

msg_       =000018    -    Auto        Pointer to Char
j1_        =000039    -    Label



   695	void IdleTask()
   696	{
   697	     int ii;
   698	     __int32 *screen = (__int32 *)0xFFD00000;
   699	
   700	//     try {
   701	j1:  ;
   702	         forever {
   703	             try {
   704	                 ii++;
   705	                 if (getCPU()==0)
   706	                     screen[57] = ii;
   707	             }
   708	             catch(static __exception ex=0) {
   709	                 if (ex&0xFFFFFFFFL==515) {
   710	                     printf("IdleTask: CTRL-C pressed.\r\n");
   711	                 }
   712	                 else
   713	                     throw ex;
   714	             }
   715	         }
   716	/*
   717	     }
   718	     catch (static __exception ex1=0) {
   719	         printf("IdleTask: exception %d.\r\n", ex1);
   720	         goto j1;
   721	     }
   722	*/


*** local symbol table ***

j1_        =00003d    -    Label
ii_        =fffffff8    -    Auto        Long
screen_    =fffffff0    -    Auto        Pointer to Short



   723	}
   724	
   725	// ----------------------------------------------------------------------------
   726	// ----------------------------------------------------------------------------
   727	
   728	int FMTK_KillTask(int taskno)
   729	{
   730	    hTCB ht;
   731	    int nn;
   732	    JCB *j;
   733	
   734	    asm { mfspr r1,ivno };
   735	    ht = taskno;
   736	    if (LockSemaphore(&sys_sema,-1)) {
   737	        RemoveFromReadyList(ht);
   738	        RemoveFromTimeoutList(ht);
   739	        for (nn = 0; nn < 4; nn++)
   740	            if (tcbs[ht].hMailboxes[nn] >= 0 && tcbs[ht].hMailboxes[nn] < 1024) {
   741	                FMTK_FreeMbx(tcbs[ht].hMailboxes[nn]);
   742	                tcbs[ht].hMailboxes[nn] = -1;
   743	            }
   744	        // remove task from job's task list
   745	        j = &jcbs[tcbs[ht].hJob];
   746	        for (nn = 0; nn < 8; nn++) {
   747	            if (j->tasks[nn]==ht)
   748	                j->tasks[nn] = -1;
   749	        }
   750	        // If the job no longer has any tasks associated with it, it is 
   751	        // finished.
   752	        for (nn = 0; nn < 8; nn++)
   753	            if (j->tasks[nn]!=-1)
   754	                break;
   755	        if (nn == 8) {
   756	            j->next = freeJCB;
   757	            freeJCB = j - jcbs;
   758	        }
   759	        UnlockSemaphore(&sys_sema);
   760	    }
   761	}
   762	
   763	
   764	// ----------------------------------------------------------------------------
   765	// ----------------------------------------------------------------------------
   766	


*** local symbol table ***

taskno_    =000018    -    Auto        Long
ht_        =fffffffe    -    Auto        Char
nn_        =fffffff0    -    Auto        Long
j_         =ffffffe8    -    Auto        Pointer to struct _tagJCB_ 



   767	int FMTK_ExitTask()
   768	{
   769	    asm { mfspr r1,ivno };
   770	    KillTask(GetRunningTCB());
   771	    asm { int #2 }     // reschedule
   772	j1: goto j1;
   773	}
   774	
   775	
   776	// ----------------------------------------------------------------------------
   777	// ----------------------------------------------------------------------------
   778	


*** local symbol table ***

j1_        =000064    -    Label



   779	int FMTK_StartTask(int priority, int affinity, int adr, int parm, hJCB job)
   780	{
   781	    hTCB ht;
   782	    TCB *t;
   783	    int nn;
   784	
   785	    asm { mfspr r1,ivno };
   786	    if (LockSemaphore(&sys_sema,-1)) {
   787	        ht = freeTCB;
   788	        freeTCB = tcbs[ht].next;
   789	        UnlockSemaphore(&sys_sema);
   790	    }
   791	    t = &tcbs[ht];
   792	    t->affinity = affinity;
   793	    t->priority = priority;
   794	    t->hJob = job;
   795	    // Insert into the job's list of tasks.
   796	    for (nn = 0; nn < 8; nn++) {
   797	        if (jcbs[job].tasks[nn]<0) {
   798	            jcbs[job].tasks[nn] = ht;
   799	            break;
   800	        }
   801	    }
   802	    if (nn == 8) {
   803	        if (LockSemaphore(&sys_sema,-1)) {
   804	            tcbs[ht].next = freeTCB;
   805	            freeTCB = ht;
   806	            UnlockSemaphore(&sys_sema);
   807	        }
   808	        return E_TooManyTasks;
   809	    }
   810	    t->iregs[1] = parm;
   811	    t->iregs[28] = FMTK_ExitTask;
   812	    t->iregs[31] = FMTK_ExitTask;
   813	    t->iisp = t->stack + 1023;
   814	    t->iipc = adr|1;   // stay in kernel mode for now
   815	    t->icr0 = 0x140000000L;
   816	    t->startTick = 0;
   817	    t->endTick = 0;
   818	    t->ticks = 0;
   819	    t->exception = 0;
   820	    if (LockSemaphore(&sys_sema,-1)) {
   821	        InsertIntoReadyList(ht); }
   822	        UnlockSemaphore(&sys_sema);
   823	    }


*** local symbol table ***

priority_  =000018    -    Auto        Long
affinity_  =000020    -    Auto        Long
adr_       =000028    -    Auto        Long
parm_      =000030    -    Auto        Long
job_       =000038    -    Auto        Byte
ht_        =fffffffe    -    Auto        Char
t_         =fffffff0    -    Auto        Pointer to struct _tagTCB_ 
nn_        =ffffffe8    -    Auto        Long



   824	    return E_Ok;
   825	}
   826	
   827	// ----------------------------------------------------------------------------
   828	// ----------------------------------------------------------------------------
   829	
   830	int FMTK_Sleep(int timeout)
   831	{
   832	    hTCB ht;
   833	    
   834	    asm { mfspr r1,ivno };
   835	    if (LockSemaphore(&sys_sema,-1)) {
   836	        ht = GetRunningTCB();
   837	        RemoveFromReadyList(ht);
   838	        InsertIntoTimeoutList(ht, timeout);
   839	        UnlockSemaphore(&sys_sema);
   840	    }
   841	    asm { int #2 }      // reschedule
   842	    return E_Ok;
   843	}
   844	
   845	// ----------------------------------------------------------------------------
   846	// ----------------------------------------------------------------------------
   847	


*** local symbol table ***

timeout_   =000018    -    Auto        Long
ht_        =fffffffe    -    Auto        Char



   848	int FMTK_SetTaskPriority(hTCB ht, int priority)
   849	{
   850	    TCB *t;
   851	
   852	    asm { mfspr r1,ivno };
   853	    if (priority > 077 || priority < 000)
   854	       return E_Arg;
   855	    if (LockSemaphore(&sys_sema,-1)) {
   856	        t = &tcbs[ht];
   857	        if (t->status & (8 | 16)) {
   858	            RemoveFromReadyList(ht);
   859	            t->priority = priority;
   860	            InsertIntoReadyList(ht);
   861	        }
   862	        else
   863	            t->priority = priority;
   864	        UnlockSemaphore(&sys_sema);
   865	    }
   866	    return E_Ok;
   867	}
   868	
   869	// ----------------------------------------------------------------------------
   870	// ----------------------------------------------------------------------------
   871	


*** local symbol table ***

ht_        =000018    -    Auto        Char
priority_  =000020    -    Auto        Long
t_         =fffffff8    -    Auto        Pointer to struct _tagTCB_ 



   872	void FMTKInitialize()
   873	{
   874		int nn,jj;
   875	
   876	    asm { mfspr r1,ivno };
   877	//    firstcall
   878	    {
   879	        asm {
   880	            ldi   r1,#20
   881	            sc    r1,LEDS
   882	        }
   883	        hasUltraHighPriorityTasks = 0;
   884	        missed_ticks = 0;
   885	
   886	        IOFocusTbl[0] = 0;
   887	        IOFocusNdx = (void *)0;
   888	        iof_switch = 0;
   889	
   890	        UnlockSemaphore(&sys_sema);
   891	        UnlockSemaphore(&iof_sema);
   892	        UnlockSemaphore(&kbd_sema);
   893	
   894	        for (nn = 0; nn < 16384; nn++) {
   895	            message[nn].link = nn+1;
   896	        }
   897	        message[16384-1].link = -1;
   898	        freeMSG = 0;
   899	
   900	        asm {
   901	            ldi   r1,#30
   902	            sc    r1,LEDS
   903	        }
   904	
   905	        for (nn = 0; nn < 51; nn++) {
   906	            jcbs[nn].number = nn;
   907	            for (jj = 0; jj < 8; jj++)
   908	                jcbs[nn].tasks[jj] = -1;
   909	            if (nn == 0 ) {
   910	                jcbs[nn].pVidMem = 0xFFD00000;
   911	                jcbs[nn].pVirtVidMem = video_bufs[nn];
   912	                jcbs[nn].NormAttr = 0x0026B800;
   913	                RequestIOFocus(&jcbs[0]);
   914	           }
   915	            else {
   916	                 jcbs[nn].pVidMem = video_bufs[nn];
   917	                 jcbs[nn].pVirtVidMem = video_bufs[nn];
   918	                 jcbs[nn].NormAttr = 0x0026B800;
   919	            }
   920	            jcbs[nn].VideoRows = 31;
   921	            jcbs[nn].VideoCols = 84;
   922	            jcbs[nn].CursorRow = 0;
   923	            jcbs[nn].CursorCol = 0;
   924	            jcbs[nn].KeybdHead = 0;
   925	            jcbs[nn].KeybdTail = 0;
   926	            jcbs[nn].KeyState1 = 0;
   927	            jcbs[nn].KeyState2 = 0;
   928	        }
   929	
   930	        asm {
   931	            ldi   r1,#40
   932	            sc    r1,LEDS
   933	        }
   934	
   935	    	for (nn = 0; nn < 8; nn++)
   936	    		readyQ[nn] = -1;
   937	    	for (nn = 0; nn < 256; nn++) {
   938	            tcbs[nn].number = nn;
   939	    		tcbs[nn].next = nn+1;
   940	    		tcbs[nn].prev = -1;
   941	    		tcbs[nn].status = 0;
   942	    		tcbs[nn].priority = 070;
   943	    		tcbs[nn].affinity = 0;
   944	    		tcbs[nn].sys_stack = &sys_stacks[nn] + 511;
   945	    		tcbs[nn].bios_stack = &bios_stacks[nn] + 511;
   946	    		tcbs[nn].stack = &stacks[nn] + 1023;
   947	    		tcbs[nn].hJob = 0;
   948	    		tcbs[nn].timeout = 0;
   949	    		tcbs[nn].hMailboxes[0] = -1;
   950	    		tcbs[nn].hMailboxes[1] = -1;
   951	    		tcbs[nn].hMailboxes[2] = -1;
   952	    		tcbs[nn].hMailboxes[3] = -1;
   953	    		if (nn<2) {
   954	                tcbs[nn].affinity = nn;
   955	                tcbs[nn].priority = 030;
   956	            }
   957	            tcbs[nn].exception = 0;
   958	    	}
   959	    	tcbs[256-1].next = -1;
   960	    	freeTCB = 2;
   961	        asm {
   962	            ldi   r1,#42
   963	            sc    r1,LEDS
   964	        }
   965	    	InsertIntoReadyList(0);
   966	    	InsertIntoReadyList(1);
   967	    	tcbs[0].status = 8;
   968	    	tcbs[1].status = 8;
   969	        asm {
   970	            ldi   r1,#44
   971	            sc    r1,LEDS
   972	        }
   973	    	SetRunningTCB(0);
   974	    	TimeoutList = -1;
   975	    	set_vector(4,FMTK_SystemCall);
   976	    	set_vector(2,FMTK_SchedulerIRQ);
   977	    	set_vector(451,FMTK_SchedulerIRQ);
   978	    	FMTK_StartTask(030, 0, shell, 0, 0);
   979	        FMTK_StartTask(077, 0, IdleTask, 0, 0);
   980	        FMTK_StartTask(077, 1, IdleTask, 0, 0);
   981	    	FMTK_Inited = 0x12345678;
   982	        asm {
   983	            ldi   r1,#50
   984	            sc    r1,LEDS
   985	        }
   986	    }
   987	}
   988	


*** local symbol table ***

nn_        =fffffff8    -    Auto        Long
jj_        =fffffff0    -    Auto        Long




 *** global scope typedef symbol table ***

jcbs_      =000000    -    External    Array of struct _tagJCB_ 
E_NoMoreMsgBlks_ =000041    -    Constant    Long
startQNdx_ =00000d    -    Static      Byte
tcbs_      =000000    -    External    Array of struct _tagTCB_ 
nMsgBlk_   =000000    -    External    Long
FMTK_KillTask_ =57c0a2    -    Global      Function returning Long
PopTimeoutList_ =000000    -    External    Function returning Long
putstr_    =000000    -    External    Function returning Long
FMTK_SetTaskPriority_ =57c0b0    -    Global      Function returning Long
E_NoThread_ =000007    -    Constant    Long
E_WriteError_ =000024    -    Constant    Long
outb_      =001480    -    Global      Function returning 
IOFocusTbl_ =000000    -    External    Array of Long
outc_      =001480    -    Global      Function returning 
E_Arg_     =000004    -    Constant    Long
FMTK_ExitTask_ =57c0a2    -    Global      Function returning Long
E_NotAlloc_ =000008    -    Constant    Long
uint_      =000000    1   
outh_      =001480    -    Global      Function returning 
irq_stack_ =000000    -    External    Array of Long
IOFocusNdx_ =000000    -    External    Pointer to struct _tagJCB_ 
DumpTaskList_ =001480    -    External    Function returning 
E_BadBlockNum_ =000025    -    Constant    Long
E_TooManyBlocks_ =000026    -    Constant    Long
JCB_       =000800    1   struct _tagJCB_ 
outw_      =001480    -    Global      Function returning 
E_BadTCBHandle_ =000001    -    Constant    Long
E_BadMbx_  =000005    -    Constant    Long
fmtk_irq_stack_ =000000    -    External    Array of Long
TCB_       =001000    1   struct _tagTCB_ 
GetRunningTCB_ =001480    -    External    Function returning Char
E_NotOwner_ =00000c    -    Constant    Long
fmtk_sys_stack_ =000000    -    External    Array of Long
message_   =000000    -    External    Array of struct tagMSG_ 
SetRunningTCB_ =001480    -    Global      Function returning 
MSG_       =000020    1   struct tagMSG_ 
MBX_       =001400    1   struct tagMBX_ 
SelectTaskToRun_ =00000e    -    Static      Function returning Char
mailbox_   =000000    -    External    Array of struct tagMBX_ 
FMTK_Inited_ =000000    -    External    Long
E_BadDevNum_ =000020    -    Constant    Long
missed_ticks_ =000000    -    External    Long
E_BadCallno_ =000003    -    Constant    Long
panic_     =57c09a    -    Global      Function returning 
E_BadPriority_ =000002    -    Constant    Long
chkTCB_    =001480    -    Global      Function returning Long
GetRunningTCBPtr_ =001480    -    External    Function returning Pointer to struct _tagTCB_ 
UnlockSemaphore_ =001480    -    Global      Function returning 
IdleTask_  =57c09a    -    Global      Function returning 
shell_     =000000    -    External    Function returning Long
E_NoMoreMbx_ =000040    -    Constant    Long
GetVecno_  =57c078    -    Global      Function returning Long
FMTK_SchedulerIRQ_ =57c09a    -    Global      Function returning 
KillTask_  =000000    -    External    Function returning Long
E_QueStrategy_ =00000d    -    Constant    Long
GetJCBPtr_ =57c078    -    Global      Function returning Pointer to struct _tagJCB_ 
video_bufs_ =000000    -    External    Array of Array of Short
getCPU_    =001480    -    External    Function returning Long
E_ReadError_ =000023    -    Constant    Long
hasUltraHighPriorityTasks_ =000000    -    External    Char
LockSemaphore_ =001480    -    Global      Function returning Long
iof_switch_ =000000    -    External    Long
FMTK_StartTask_ =57c0a2    -    Global      Function returning Long
kbd_sema_  =000000    -    External    Long
hJCB_      =00000a    1   Byte
nMailbox_  =000000    -    External    Long
FMTK_FreeMbx_ =000000    -    External    Function returning Long
set_vector_ =001480    -    Global      Function returning 
E_NoMoreTCBs_ =000043    -    Constant    Long
hTCB_      =000008    1   Char
iof_sema_  =000000    -    External    Long
FMTKInitialize_ =57c0b0    -    Global      Function returning 
sys_stacks_ =000000    -    External    Array of Array of Long
BIOS_RespMbx_ =000000    -    External    Long
hMBX_      =00000c    1   Char
hMSG_      =00000e    1   Char
E_DCBInUse_ =00000e    -    Constant    Long
DisplayIRQLive_ =57c078    -    Global      Function returning 
E_Ok_      =000000    -    Constant    Long
E_QueFull_ =000006    -    Constant    Long
BIOS1_sema_ =000000    -    External    Long
sys_sema_  =000000    -    External    Long
readyQ_    =000000    -    External    Array of Char
FMTK_BrTbl_ =57c078    -    Global      Function returning 
E_NoMoreAlarmBlks_ =000042    -    Constant    Long
ALARM_     =001440    1   struct tagALARM_ 
E_TooManyTasks_ =000045    -    Constant    Long
freeJCB_   =4b0010    -    Global      Byte
sysstack_  =000000    -    External    Array of Long
ILockSemaphore_ =000000    -    External    Function returning Long
freeTCB_   =000000    -    External    Char
startQ_    =00000c    -    Static      Array of Byte
E_NoDev_   =000021    -    Constant    Long
E_NoMem_   =000044    -    Constant    Long
RequestIOFocus_ =000000    -    External    Function returning Long
TimeoutList_ =000000    -    External    Char
RemoveFromTimeoutList_ =001480    -    Global      Function returning Long
E_NoMsg_   =000009    -    Constant    Long
E_BadDevOp_ =000022    -    Constant    Long
SetBound50_ =001480    -    Global      Function returning 
stacks_    =000000    -    External    Array of Array of Long
freeMSG_   =000000    -    External    Char
freeMBX_   =000000    -    External    Char
SetBound51_ =001480    -    Global      Function returning 
FMTK_Sleep_ =57c0b0    -    Global      Function returning Long
E_Timeout_ =00000a    -    Constant    Long
SetBound48_ =001480    -    Global      Function returning 
SetBound49_ =001480    -    Global      Function returning 
InsertIntoTimeoutList_ =001480    -    Global      Function returning Long
FMTK_SystemCall_ =57c09a    -    Global      Function returning Long
RemoveFromReadyList_ =001480    -    Global      Function returning Long
sp_tmp_    =002480    -    Global      Long
printf_    =000000    -    External    Function returning Long
bios_stacks_ =000000    -    External    Array of Array of Long
E_BadAlarm_ =00000b    -    Constant    Long
InsertIntoReadyList_ =001480    -    Global      Function returning Long

 *** structures and unions ***

tagMSG_    =000000    -    Type        struct tagMSG_ 
    link_      =000000    -    Member      
    retadr_    =000002    -    Member      
    tgtadr_    =000004    -    Member      
    type_      =000006    -    Member      
    d1_        =000008    -    Member      
    d2_        =000010    -    Member      
    d3_        =000018    -    Member      
_tagJCB_   =000000    -    Type        struct _tagJCB_ 
    iof_next_  =000000    -    Member      Pointer to struct _tagJCB_ 
    iof_prev_  =000008    -    Member      Pointer to struct _tagJCB_ 
    UserName_  =000010    -    Member      Array of Char
    path_      =000050    -    Member      Array of Char
    exitRunFile_ =000250    -    Member      Array of Char
    commandLine_ =000450    -    Member      Array of Char
    pVidMem_   =000650    -    Member      Pointer to 
    pVirtVidMem_ =000658    -    Member      Pointer to 
    VideoRows_ =000660    -    Member      
    VideoCols_ =000662    -    Member      
    CursorRow_ =000664    -    Member      
    CursorCol_ =000666    -    Member      
    NormAttr_  =000668    -    Member      
    KeyState1_ =00066c    -    Member      Byte
    KeyState2_ =00066d    -    Member      Byte
    KeybdWaitFlag_ =00066e    -    Member      Byte
    KeybdHead_ =00066f    -    Member      Byte
    KeybdTail_ =000670    -    Member      Byte
    KeybdBuffer_ =000671    -    Member      Array of Unsigned Byte
    number_    =000691    -    Member      Byte
    tasks_     =000692    -    Member      Array of Char
    next_      =0006a2    -    Member      Byte
tagMBX_    =000000    -    Type        struct tagMBX_ 
    link_      =000000    -    Member      Char
    owner_     =000002    -    Member      Byte
    tq_head_   =000004    -    Member      Char
    tq_tail_   =000006    -    Member      Char
    mq_head_   =000008    -    Member      Char
    mq_tail_   =00000a    -    Member      Char
    mq_strategy_ =00000c    -    Member      Char
    resv_      =00000e    -    Member      Array of Byte
    tq_count_  =000010    -    Member      
    mq_size_   =000018    -    Member      
    mq_count_  =000020    -    Member      
    mq_missed_ =000028    -    Member      
_tagTCB_   =000000    -    Type        struct _tagTCB_ 
    regs_      =000000    -    Member      Array of Long
    isp_       =000100    -    Member      Long
    dsp_       =000108    -    Member      Long
    esp_       =000110    -    Member      Long
    ipc_       =000118    -    Member      Long
    dpc_       =000120    -    Member      Long
    epc_       =000128    -    Member      Long
    cr0_       =000130    -    Member      Long
    iregs_     =000138    -    Member      Array of Long
    iisp_      =000238    -    Member      Long
    idsp_      =000240    -    Member      Long
    iesp_      =000248    -    Member      Long
    iipc_      =000250    -    Member      Long
    idpc_      =000258    -    Member      Long
    iepc_      =000260    -    Member      Long
    icr0_      =000268    -    Member      Long
    next_      =000270    -    Member      Char
    prev_      =000272    -    Member      Char
    mbq_next_  =000274    -    Member      Char
    mbq_prev_  =000276    -    Member      Char
    sys_stack_ =000278    -    Member      Pointer to Long
    bios_stack_ =000280    -    Member      Pointer to Long
    stack_     =000288    -    Member      Pointer to Long
    timeout_   =000290    -    Member      Long
    msg_       =0002a0    -    Member      struct tagMSG_ 
    hMailboxes_ =0002c0    -    Member      Array of Char
    hWaitMbx_  =0002c8    -    Member      Char
    number_    =0002ca    -    Member      Char
    priority_  =0002cc    -    Member      Byte
    status_    =0002cd    -    Member      Byte
    affinity_  =0002ce    -    Member      Byte
    hJob_      =0002cf    -    Member      Byte
    startTick_ =0002d0    -    Member      Long
    endTick_   =0002d8    -    Member      Long
    ticks_     =0002e0    -    Member      Long
    exception_ =0002e8    -    Member      Long
tagALARM_  =000000    -    Type        struct tagALARM_ 
    next_      =000000    -    Member      Pointer to struct tagALARM_ 
    prev_      =000008    -    Member      Pointer to struct tagALARM_ 
    mbx_       =000010    -    Member      Pointer to struct tagMBX_ 
    msg_       =000018    -    Member      Pointer to struct tagMSG_ 
    BaseTimeout_ =000020    -    Member      
    timeout_   =000028    -    Member      
    repeat_    =000030    -    Member      
    resv_      =000038    -    Member      Array of Byte
