     1	#define TEXTSCR	0xFFD00000
     2	
     3	#define ST_DESTROYED	0
     4	#define ST_HAPPY		1
     5	
     6	#define MV_DOWN		0
     7	#define MV_LEFT		1
     8	#define MV_RIGHT	2
     9	
    10	int *screen;
    11	int moveDir;
    12	
    13	typedef struct _tagInvader
    14	{
    15		int status;
    16		int type;
    17		int x;
    18		int y;
    19		int maxX;
    20		int minX;
    21	} Invader;
    22	
    23	int LeftColInv,RightColInv;
    24	
    25	Invader Invaders[5][8];
    26	
    27	void DrawInvader(unsigned int row, unsigned int col)
    28	{
    29		Invader *i;
    30		unsigned int *base;
    31	
    32		i = &Invaders[row][col];
    33		if (i->status == ST_DESTROYED)
    34			return;
    35		base = &screen[i->y * 56 + i->x];
    36	
    37		switch (i->type)
    38		{
    39		case 1:
    40			// Above
    41			base[0] = 32;
    42			base[1] = 32;
    43			base[2] = 32;
    44			base[3] = 32;
    45			base[4] = 32;
    46			// top
    47			base[56] = 32;
    48			base[57] = 233;
    49			base[58] = 242;
    50			base[59] = 223;
    51			base[60] = 32;
    52			// bottom
    53			base[112] = 32;
    54			if (i->x & 1) {
    55				base[113] = 24;
    56				base[115] = 24;
    57			}
    58			else {
    59				base[113] = 22;
    60				base[115] = 22;
    61			}
    62			base[114] = 32;
    63			break;
    64		}
    65	}
    66	


*** local symbol table ***

row        =000002    -    Auto        Long
col        =000003    -    Auto        Long
i          =ffffffff    -    Auto        Pointer to struct _tagInvader 
base       =fffffffe    -    Auto        Pointer to Long



    67	void main ()
    68	{
    69		int i, j;
    70		Invader *pi;
    71	
    72		InitializeForScreen();
    73		while (IsColumnDestroyed(LeftColInv)) {
    74			LeftColInv++;
    75			if (LeftColInv > RightColInv) {
    76				return;
    77			}
    78			for (i = 0; i < 5; i++) {
    79				for (j = 0; j < 8; j++)  {
    80					Invaders[i][j].minX -= 4;
    81				}
    82			}
    83		}
    84		while (IsColumnDestroyed(RightColInv)) {
    85			RightColInv--;
    86			if (LeftColInv > RightColInv) {
    87				return;
    88			}
    89			for (i = 0; i < 5; i++) {
    90				for (j = 0; j < 8; j++)  {
    91					Invaders[i][j].maxX += 4;
    92				}
    93			}
    94		}
    95		for (i = 0; i < 5; i++) {
    96			for (j = 0; j < 8; j++) {
    97				DrawInvader(i,j);
    98			}
    99		}
   100		pi = &Invaders[0][0];
   101		if (moveDir==MV_LEFT) {
   102			if (!MoveLeft(pi))
   103				moveDir = MV_DOWN;
   104		}
   105		if (moveDir==MV_RIGHT) {
   106			if (!MoveRight(pi)) {
   107				moveDir = MV_DOWN;
   108			}
   109		}
   110		for (i = 0; i < 5; i++) {
   111			for (j = 0; j < 8; j++) {
   112				pi = &Invaders[i][j];
   113				switch(moveDir) {
   114				case MV_LEFT:	MoveLeft(pi); break;
   115				case MV_RIGHT:	MoveRight(pi); break;
   116				case MV_DOWN:	MoveDown(pi); break;
   117				}
   118			}
   119		}
   120	}
   121	


*** local symbol table ***

i          =ffffffff    -    Auto        Long
j          =fffffffe    -    Auto        Long
pi         =fffffffd    -    Auto        Pointer to struct _tagInvader 



   122	void InitializeForScreen()
   123	{
   124		unsigned int i,j;
   125	
   126		screen = (unsigned int *)TEXTSCR;
   127		for (i = 0; i < 5; i++)
   128			for (j = 0; j < 8; j++) {
   129				switch(i) {
   130				case 0:		Invaders[i][j].type = 1;
   131				case 1,2:	Invaders[i][j].type = 2;
   132				case 3,4:	Invaders[i][j].type = 3;
   133				}
   134				Invaders[i][j].status = ST_HAPPY;
   135				Invaders[i][j].x = j * 4 + 12;
   136				Invaders[i][j].y = i * 3 + 1;
   137				Invaders[i][j].maxX = j * 4 + 24;
   138				Invaders[i][j].minX = j * 4;
   139			}
   140		LeftColInv = 0;
   141		RightColInv = 4;
   142	}
   143	


*** local symbol table ***

i          =ffffffff    -    Auto        Long
j          =fffffffe    -    Auto        Long



   144	int IsColumnDestroyed(int col)
   145	{
   146		if ((Invaders[0][col].status==ST_DESTROYED) && 
   147			(Invaders[1][col].status==ST_DESTROYED) && 
   148			(Invaders[2][col].status==ST_DESTROYED) && 
   149			(Invaders[3][col].status==ST_DESTROYED) && 
   150			(Invaders[4][col].status==ST_DESTROYED))
   151			return 1;
   152		return 0;
   153	}
   154	


*** local symbol table ***

col        =000002    -    Auto        Long



   155	int MoveLeft(Invader *i)
   156	{
   157		if (i->x > i->minX) {
   158			i->x--;
   159			return 1;
   160		}
   161		return 0;
   162	}
   163	


*** local symbol table ***

i          =000002    -    Auto        Pointer to struct _tagInvader 



   164	int MoveRight(Invader *i)
   165	{
   166		if (i->x < i->maxX) {
   167			i->x++;
   168			return 1;
   169		}
   170		return 0;
   171	}
   172	


*** local symbol table ***

i          =000002    -    Auto        Pointer to struct _tagInvader 



   173	int MoveDown(Invader *i)
   174	{
   175		if (i->y < 31) {
   176			i->y++;
   177			return 1;
   178		}
   179		return 0;
   180	}
   181	


*** local symbol table ***

i          =000002    -    Auto        Pointer to struct _tagInvader 




 *** global scope typedef symbol table ***

MoveLeft   =000000    -    Global      Function returning Long
MoveDown   =000000    -    Global      Function returning Long
Invaders   =00000a    -    Global      Array of Array of struct _tagInvader 
RightColInv =000009    -    Global      Long
DrawInvader =0000fa    -    Global      Function returning 
screen     =000000    -    Global      Pointer to Long
MoveRight  =000000    -    Global      Function returning Long
InitializeForScreen =000000    -    Global      Function returning 
main       =0000fa    -    Global      Function returning 
Invader    =000002    1   struct _tagInvader 
moveDir    =000001    -    Global      Long
LeftColInv =000008    -    Global      Long
IsColumnDestroyed =000000    -    Global      Function returning Long

 *** structures and unions ***

_tagInvader =000000    -    Type        struct _tagInvader 
    status     =000000    -    Member      Long
    type       =000001    -    Member      Long
    x          =000002    -    Member      Long
    y          =000003    -    Member      Long
    maxX       =000004    -    Member      Long
    minX       =000005    -    Member      Long
